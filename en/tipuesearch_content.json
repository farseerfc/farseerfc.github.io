{"pages":[{"title":"About","text":"About This Blog I will use 3 languages, namely Chinese(zh), Japanese(jp) and English(en) to write this blog whenever it make sense. Chinese has both traditional(zh) simplified(zhs) version, and I will always write as the traditional version first and then translate it into simplified version by using OpenCC automatically. Currently My Name is YANG Jiachen(楊嘉晨) born in June 1989 I am currently pursuing PhD degree in Graduate School of Information Science and Technology, Osaka University ( http://sdl.ist.osaka-u.ac.jp/ ) I graduated from School of Software, Shanghai Jiao Tong University. F0703701 ( http://se.sjtu.edu.cn/ ) Contact You can contact me by： Mobile phone（softbank）: 080-3853-2770 Email of mobile phone: jc-yang@softbank.ne.jp Or you can find me on Internet： Skype: farseerfc GMail: farseerfc@gmail.com twitter: http://twitter.com/farseerfc Github: https://github.com/farseerfc weibo(微博): http://weibo.com/farseerfc facebook: http://www.facebook.com/farseerfc telegram: http://telegram.me/farseerfc tox: https://toxme.se/u/farseerfc pgp: 4B1D E545 A801 D454 9BFD 3FEF 90CB 3D62 C13D 4796 Current Avatar This avatar is 十六夜 ( いざよい Izayoi ) 咲夜 ( さくや Sakuya ) ， drawn by HUG and published here pixiv id=41143207 . Izayoi is a character from Touhou Project, and she is my favorite character in many released games of Touhou Project, including 妖々夢 ( Perfect Cherry Blossom ) , 永夜抄 ( Imperishable Night ) , 緋想天 ( Scarlet Weather Rhapsody ) , 非想天則 ( Hisōtensoku ) .","tags":"pages","url":"//farseerfc.me/en/pages/about.html"},{"title":"PacVis: visualize pacman local database","text":"PacVis Motivation for PacVis I must admit that I love Arch Linux, largely because Arch Linux made me feel like I really own the whole system. In my Arch Linux system, I know clearly every package I have installed and why I installed it. I can find which package brings in a give file. A Debian/Fedora/openSUSE user with enough experience may achieve this with their favorite package manager too, but they must overcome a much higher complexity with their distro's fine-grinding packaging strategy. Usually they have 3 to 10 times more packages than Arch Linux on a similar setup. And with regard to packaging system, they must work with much more details than Arch's simple PKGBUILD based packaging. Every user who successfully installed Arch Linux should have learned that, after the initial installation, you will only get a minimum setup. The most important step in the installation guide on ArchWiki is a command pactrap /​mnt base , which will use /​mnt as the filesystem root and call pacman -S base inside that root to install the whole base group. And that's basically all you will get after the install. The initial system has nearly nothing. Everything you need will be installed afterwards, manually by using pacman . It is nothing unnecessary, only for your own need. But after using the system for a long time, there are unavoidably some packages inside the system which are installed and used for awhile and abandoned. They are like the old furnitures inside your house, taking space and covered by dusts. We have pacman -Qtd to help you find all orphan packages, namely those installed as dependency for other packages once but not needed for now , but for manually installed packages, we have no good tool but manually checking them one by one. So I was looking for a tool to help me understand the relations in my system. In particular, I want a tool to help me do these things: Find packages that I installed manually but not needed now Find those large and space-consuming packages Understand the relationships between packages Android System Architecture About the last thing \"relations between packages\", I once saw the diagram of macOS Architecture and Android System Architecture, and I was impressed by the layered hierarchy in these diagrams. I was wondering since then, is it possible to draw a similar layered architecture diagram for modern Linux desktop ? Or will a Linux desktop be much different ? I can find out hierarchy diagrams for Linux kernel or Xorg graphic stack on Wikipedia or other sites, but I don't know such diagrams for the whole distribution. And further I thought, can I draw such diagram from the dependency relationships between packages automatically ? Predecessors of PacVis Before working on PacVis, I have tried several similar tools. Some of them meet some of my needs, but they all lack certain features that I considered important. These tools became the prototype of PacVis, as they enlightened me of how PacVis should be. pactree pactree started as an individual project , but now it is part of pacman . From its manpage we can see that the output of pactree is a dependency tree starting from a given package. By appending --graph parameter, pactree can also output a diagram in dot format, then we can render this diagram using dot command: pactree pacvis-git -d3 --graph | dot -Tpng >pacvis-pactree.png $ pactree pacvis-git -d3 pacvis-git ├─python-tornado │ └─python │ ├─expat │ ├─bzip2 │ ├─gdbm │ ├─openssl │ ├─libffi │ └─zlib ├─pyalpm │ ├─python │ └─pacman │ ├─bash │ ├─glibc │ ├─libarchive │ ├─curl │ ├─gpgme │ ├─pacman-mirrorlist │ └─archlinux-keyring └─python-setuptools └─python-packaging ├─python-pyparsing └─python-six $ pactree pacvis-git -d3 --graph | dot -Tpng >pacvis-pactree.png From the rendered diagram we can see that, because some packages may share common dependencies, the whole diagram is no longer a tree in graph theory . During the initial prototyping of PacVis, I tried to parse the output of pactree and pacman using bash/python scripts, to draw a single diagram for the whole system. However the rendered picture is so large that it takes hours for dot to layout them, and the result is barely viewable in an image viewer or a browser. I need to say that there will be no PacVis if there is no pactree. Even the pyalpm library that I used in PacVis is a python binding for alpm, which is born during the rewrite of pactree in C language. pacgraph The output of pacgraph pacgraph is developped by a Arch Linux Trusted User keenerd . It is written in Python, as is PacVis. Comparing with pactree, pacgraph is definitely more suitable for my needs. It will draw a diagram for all the packages in the system, using a clever layout algorithm that surpass the performance of dot's layout. The output of pacgraph is an artistic diagram with different font size of package names showing their disk usage. By viewing pacgraph's output, we can determine the overall system structure, e.g. whether the system is a desktop system or a server. We can easily find large packages and consider remove them. There's more. pacgraph provided an interactive GUI called pacgraph-tk, written clearly in tk. You can zoom in to see details or zoom out to see the whole graph in GUI, and you can highlight one package to see its relations to others. And pacgraph support to render the dependencies of a selected group of packages, not all, like pactree does. But pacgraph does not meet all my needs. I want a diagram to show the architecture of the system, but pacgraph don't differ \"the packages that this package depend on\" and \"the packages that depends on this package\". In other words, pacgraph draws a undirected graph , but I want a directed graph , that reflects the layered hierarchy of dependency relationship . So here is PacVis PacVis on startup With these predecessors, I started working on PacVis. The development takes me 2 month, and largely break into 2 stages. In the first stage I wrote basic logics and a prototype of the UI. In the second stage I applied the templates from https://getmdl.io/ . Now finally it is usable for others. So several days ago I made a PKGBUILD for pacvis on AUR: pacvis-git . Now it's fairly easy to run pacvis locally on a Arch Linux system. You can use any aurhelper you familiar with, or build it directly from AUR: ~$ git clone aur@aur.archlinux.org:pacvis-git.git ~$ cd pacvis-git ~/pacvis-git$ makepkg -si ~/pacvis-git$ pacvis Start PacVis at http://localhost:8888/ Following the instruction, open http://localhost:8888/ in a browser then you can see PacVis's result of your own system. As a demonstration you can also visit PacVis on my Arch Linux server : https://pacvis.farseerfc.me/ . It is showing a minimal server setup, that might load and layout faster than a normal desktop system. PacVis on Windows msys2 As a side note, pacvis only depends on pyalpm and tornado, so there should be no problem running it on other pacman-based systems, including msys2 on Windows (altough building a msys2 python-tornado may take some non-trival effort). The legend and usage of PacVis PacVis resembles the UI of a map app such as Google Maps. You can use wheel of mouse to zoom and drag to move, or pinch gestures on a touch screen. There is a side panel on the right top corner and you can hide it when you don't need it. There are some zoom buttons on the right bottom corner. The dependencies of pacvis-git package The whole diagram is made up of small circles and arrows in between circles. A circle represent a package, while an arrow represents a dependency relationship. If you zoom into details, you can see text under the circles showing their package names. Hover on packages will also give you infos about the package. You can select a package, and in the side panel there will be more detailed infomation about that package. The above picture is showing the dependencies of pacvis-git package itself. It dependes on pyalpm, python-tornado and python-setuptools, while pyalpm is in-turn depend on pacman. A package in purple means it is installed manually, while a package in orange means it is installed as a dependency for other packages. The color of arrows usually follow their origin package's color. Note that most arrows in the diagram are pointing bottom-up, this is because PacVis will do a topology sort based on the dependencies of packages. From the topology sort, PacVis assigned a topology level to each package, e.g. pacvis-git has a topo-level of 39, its dependency pyalpm has a topo-level of 38, and pacman is sat on the topo-level 37. Layering packages with their topo-level is the main difference of PacVis with pacgraph. Besides manually zoom-in to look around, you can also use PacVis's search box to locate a particular package by its name. And when you select a package, the related package names will be shown in the Dep and Req-By tabs in the sidebar. These package names are made as buttons so you can click them to browse the whole dependency graph. Let me describe some arguments related to the implementation: Max Level This will limit the max topo-level that PacVis renders. When there are too many packages, the layout algorithm will take a lot of time. Limiting this is very useful during debug of PacVis. Max Required-By This will limit the max required-by-relationship that PacVis renders. If you play around in PacVis, you will soon find that most packages in the system directly depends on glibc or gcc-libs. Rendering these well-known dependency may result in a lot of long arrows, that reduce the readability of the whole diagram. You can limit this to a lower number so that PacVis will not render these well-known dependencies. Some facts you can learn from PacVis A normal KDE desktop Full image（17M） You may find many facts by playing around in PacVis. An example will be the aforementioned \"most packages depends on glibc\". Besides that, I will give some more examples below. Dependency hierachy The packages in the system is clearly divided into several layers: glibc, etc. C runtime Bash/Perl/Python etc. script languages coreutils/gcc/binutils etc. core binary utilities pacman/systemd etc. large system utilities gtk{2,3}/qt{4,5} etc. GUI toolkit chromium etc. GUI Applications Plasma/Gnome etc. Desktop environments This largely meet my overall understanding, but some details are interesting to me. For example, zsh dependes on gdbm which in-turn depends on bash, which means that you can not get rid of bash even if you only use zsh. For another example, python package (which is python3 in Arch Linux) and python2 and pypy sit roughly on the same topo-level in the diagram. zsh indirectly depends on bash because of gdbm However there are some facts beyond common knowledge, e.g. qt5-base < qt4 < gtk2 < gtk3 with regard to topo-level. Qt5 was split into several packages therefore it is understandable that qt5-base is lower than qt4. The fact that gtk is more high level than qt may beyond most expectations (including mine). Circular dependencies There are some packages that have circular dependencies in between. An example will be freetype2 and harfbuzz. freetype2 is a library for font rendering, and harfbuzz is a library to deal with OpenType font shapes. They depend on each other. Another example is kio and kinit of KDE. kio provides VFS-like and FUSE-like resource abstraction for KDE applications, while kinit is in charge of initializing KDE desktop environment. Circular dependency between freetype2 and harfbuzz Because of these circular dependencies, PacVis cannot simply apply topology sort directly. Before that, PacVis will firstly find all circles in the dependency graph to break these circles. It renders the relationship that will cause a circle as red arrows in the diagram. Some packages don't have dependency relationship man-pages and licenses don't have dependencies There are some packages that don't depend on others, and don't depended by others. They are isolated in the whole diagram, e.g. man-pages and licenses. These packages sit on the most top level of the diagram, with a topo-level of 0. PacVis will render them as blue squares specially. Linux (the kernel) is unimportant, if we only look at dependencies All userspace program depend on glibc, which calls the kernel using well-defined syscalls. As a result, if we only look at userspace dependencies, glibc and other GNU components are the center of the GNU/Linux distribution, while Linux the kernel is just located in a random place deeply blew the dependency graph. On my demo server the Linux package is even located on the most bottom level because it depends on mkinitcpio which in-turn depend on many components in the system. pacman -Qtd cannot find orphan packages with circle dependency msys2 packages with circle dependency I saw an archipelago of packages from mingw repo when testing PacVis on msys2. To my surprise, they don't connected to any manually installed packages, something strange as I routinely run pacman -Qtd and remove the results on all my systems. After zoomed in I found that they contained a circle dependency which indicated pacman -Qtd cannot find these orphan packages, not like a GC algorithm. The future of PacVis Currently PacVis is what I planned to make, with some features added during the development. Some of these added features are related to the poor performance of the layout algorithm (e.g. limiting the max level). In the future I planned to add more features: More reasonable behavior for optdeps. Currently PacVis draw optdeps but do not consider it during the topology sort. More reasonable dependency resolution . Sometimes the dependency is not written directly as package names, instead they appear in provides array in the metadata. Currently PacVis resolve all dependencies using alpm directly, which will lose these information. Currently PacVis did not consider the repository (core/extra/community) and package group that a package belongs to. In the future PacVis may consider these infomation to render a clearer hierarchy. Currently PacVis cannot show only part of the packages. In the future we may provide the ability to draw only a part of all the installed packages like pactree/pacgraph does. If you want some features in PacVis, please leave me an issue .","tags":"tech","url":"//farseerfc.me/en/pacvis.html"},{"title":"Jumping KDE5 Plasma Activities Button","text":"I found this when using activities under KDE5 today. One can drag the activities button out of the edge of the screen, then it will jump back and forth at the edge. Here is a video: Youtube Youku Of course you can drag it back, so it is not a serious problem. It is just so cute that I had to note this. By comparison, the jumping window in Gnome3 is far worse than this: Youtube Youku BTW, I saw another cute translation error of mute screen in KDE5: KDE5のミュート画面の中国語翻訳、「静音」のはずだが「镜音」になっている。Vocaloidファンのネタだか、単なる入力ミスだか分からない。 pic.twitter.com/ipyHjXMscR — Jiachen YANG (@farseerfc) 2014 12月 8日","tags":"tech","url":"//farseerfc.me/en/jumping-kde5-plasma-activities-button.html"},{"title":"Will You Marry Me?","text":"After rendering Above is a image, the playable version is below: * Use WASD←→ to move，need WebGL support","tags":"life","url":"//farseerfc.me/en/marry-me.html"},{"title":"MSR 2012 @ ICSE","text":"Mining Software Repository 2012 @ ICSE I participated MSR of this year. We came to University of Zurich early in the morning. The registration got something wrong when it seems that Swisses cannot tell the difference among Asians so that name cards of 3 Chinese with family name of Yang are misplaced. And also the organization field of Hotta was \"Japan, Japan\", as if he represented the Japan. MSR(MicroSoft Research) talk @ MSR(Mining Software Repositories) The first talk was the keynote given by Mrs Zhang from MSR(MicroSoft Research @ Asia), so it turned out to be MSR gave keynote of MSR. The talk was about Software Analysis and their clone detection tool called XIAO. XIAO was a clone detector developed by MSRA which can be used as a plugin for Microsoft Visual Studio. XIAO has two part, or system state: the statics state analysis all the clones which didn't consider the running time, while the dynamic state need real time response. The thing I need to develop for Samsung is something like dynamic mode. I wanted to know more about the internal details about XIAO but the talk was finished there. Towards Improving BTS with Game Mechanisms The contents of this talk is very much like this blog: http://www.joelonsoftware.com/items/2008/09/15.html The talk discussed whether the same game mechanism can be applied to the things like issue tracking or similar. From my point of view, it is useless to use game mechanism in this situation. The reason that stackoverflow can success lies on that they just captured the use of fade system in opensource community, as all hackers like to be approved as great hacker, as what is happening in Wikipedia. Whether the same theory can be applied in issue tracking systems inside a internal company is questionable. Although MSDN has basic the same structure as Wikipedia, the content of MSDN and Wikipedia have different involvement of users. So I myself didn't approve this research. GHTorrent They slide of this talk can be found from here: http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524 Data exporter for github. Main part of data of Github, namely the hosted code, are already exposed as git repos, and wiki of repos are stored in git repo. So the aim of this project is to expose other data such as issues, code comments, etc. The project access github api and fetch the needed data as distributed system in order to overcome the limitations of the github api. The project will provide download history as torrents. The json data from github api is stored as bson in MongoDB and the parsed data is stored in MySQL with schema. From my point of view, it will be better if the format of data can be uniformed and all data are stored in the git repo as wiki pages. As the history stored in git repo is more nature, and using git blame to trace author of code comments should also be more useful. Of course it is harder to read and write the raw data of git as we need more understanding of the internal format of git. Maybe only people from github can do this. Topic Mining I can not understand the two parameters, DE, AIC, used in this research, study this later. The experiment target of this research are Firefox, Mylyn and Eclipse. They are trying to analysis the identifiers and comments from source codes in software repos and find the relationship between topics and bugs, like what kind of topics are more likely to contain buggy codes. The result of this research is not so clear. Such as it said that the core functions of Firefox have more bug reports, but it said no reason about this. Maybe this only means that the core features are well tested, rather than that the core features are more buggy. But the slides showed by author are pretty and easy to understand. The evolution of software The keynote talk of the second day. It is about how should we combine the social media with software development. Maybe this is the reason why Github succeeded. In the talk she told about accessing tags, uBlogs, blogs etc. directly from Integrated Development Environments, or should we need cloud IDE such as Cloud9. Do Faster Releases Improve Software Quality? Used Firefox as example. The conclusion is that faster releases will lead to more bugs and more frequent crash, but bugs are get fixed more quickly and user will switch to new released more quickly. Security vs Performance Bugs in Firefox Performance bugs are regression, blocks release. Some of my thoughts Separation of commits based on Semantic analysis The user of some tools (such as git) are not following the design purposes of these tools which brings some difficulty to MSR. For example git has a prefect branch system, so it is desired for users of git to commit per topic. Commit per topic means that user send a commit for a single implementation of a feature or a bug fix, etc. If it is difficult to contain all modifications in a commit, then it should be in a separate branch and merged into master branch. But actually user tends to send very large commits, that contains many logical features, and they can not predict to open a new branch until a few commits. Maybe this is not the fault of the user of tools, this is the tools that are not smart enough. We should separate the commits according to the semantic topics inside a commit. About the slide systems used today The study with title Incorporating Version Histories in Information Retrieval Based Bug Localization used the slides made by beamer. It contains many equations, used many overlays are iterations, with few figures, is a typical beamer slide. It also used mindmap very well. There are at least 3 slides that are made by beamer today. The study with title Towards Improving Bug Tracking Systems with Game Mechanisms presented with prezi. It have many pictures and many transitions. But because of it is made by prezi, there are no headers and footers so no page numbers and section titles etc. This is not so convenient in such a official occasions because people need to refer to the page number in question session. There are at lease 6 presents used Apple Keynote. It is really difficult to tell the difference between slides made by PowerPoint and Keynote. 2 of them used the default theme of keynote. The rest are using PowerPoint. Mrs Zhang from Microsoft used PowerPoint but her slides looks like beamer very much such as the usage of footer and header and overlays. If these are made by PowerPoint that will involve many manually operations. It is worth to mention that the slides of a study with title Green Mining: A Methodology of Relating Software Change to Power Consumption are all badly drawn hand paintings. The effect of these slide are well received, they are green and clean and cute. You can refer to the following animation for the effect but it is not exactly the same version with what we saw : http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv Microsoft is MEANING It is not a news. But Microsoft is the sponsor of Mining Challenge, and the prize of this challenge will be Xbox and Kinect and the topic of this year is: Mining Android Bug I see what you are doing there Microsoft ......","tags":"life","url":"//farseerfc.me/en/msr2012.html"},{"title":"PyRuby","text":"Today I saw a package called PyRuby in Github. The readme says: PyRuby - Some Ruby for your Python! PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful. Usage All you have to do is import the ruby module: import ruby From now on you should be able to write Ruby code within a regular Python module. An example: 1.upto(10) { |n| puts n } Even PyPI has listed this as a package. In the beginning I thought this was again a Ruby implementation by PyPy project. Or at least it use some magic trick to write ruby code directly in Python. Then I browse into the source code of it. It contains only one file: ruby.py # -*- coding: utf-8 -*- print ( \"\"\" `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:` .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms. `:ohmdys+//::/::--::::////:-.```......`````.://:-` `/dNs. .+hNds:`-:-:///::------::///++///:--....--::///::-`.///. `oMm/ /hNmo.` `` `....``````````` ...------:::-:/+/-.:/:` /NMs oMd/` `::::--.---://+` //` `````-:::::+/-`::.` :NM+ yN` -+.` `/` o. ``::.-:. `` :NN: :Nm - ./ : `.-://///:-. `-` `` :NN- /NM/ .-:::-.` `/ `:sdmdhyMMMMMMNNmy/` :mNo` :hMd: /dmddddNNmdy+-. `smmy/-```hMMMMMMMhydm/ `-.`` `...:mMm+. -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+- dMN-`-+hmmmmdhhhhdddmMN-`-/o: .-::::/oydms- oNMo:+/::. ``...--:/+ohNMNhs- :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms. .MMo:/`o:.:+sso+:-` sM+ ./-` /mNh+-....-/ymNNdo::--/shd+` -`:mm: /MM-o ./ ohhsooohNmy::sh. `yM/ `:oyyyyyyhys+:.` hy `/Nh` : -NN. -MM// -: `` y: odddhh+ -omNh- `--.` `` ```` .:ohMMs. +Ms / yMo hMoo .+. :Mh ```` `/hNd/.` ohdddy::...`..` `-/sdmdyo+NMNh+- :Mh / sMs .mmh:..:. :NMm `-/dMNM+ ./+++/:`.hM:`.````.` `-/shmNmh+-` /Mmooso.hM/ .: `mM/ .mNs://: .NMNMs- -:-.`/+-sms. ` `shyyyhy`sNd` `.:+sdmmmdMM-. .oNM+ :m/ `s``yMh -mMo . sMNdMNNh+-. .ydyoyy` ``+o::+shdddhs+:-.:MM.`.-+hNMMh- `.`-/::dNs` -NM- mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.` `/mMMdmmddNMm+` ..-/hNh- sMy NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs `..:+ymMMMMd+--yNh. `+hNh: -Mm NMMM/yMh -NM-`..--:NMo:--.`+My :MNoydmNMMNmhdMh` -dNs` `yMd: `MN mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/ yMy` MN yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-. `yMMNs. /My `MN :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM- ./hNNy- /Nd` -Mh dMydMmsNMNdNNMMmmmNMMMdddhys+yMo`` /Nm: `:yNNdo. .sNd. +Ms .mMsMN::NN:.:MN: `.+NM. +Mo +Mm+ymNdo- .omm+` yM: .hNMd+:sMN. oMm. oMo +Mh ```.:+shMNmy+-``.-:-..-//-`:yNmo` mM. :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/` .Mm `` .-:/+osyyhhddddddddddhhyysoo+/:-. `./+//--+oo/--+ymmy/. :Mh .: `+:` `.------------` ```-////:/++/:../ydNdo:` +Ms `/` :+o+:-``` ``..-::///++///:-.`-+ydNdo:` oMs :/:.`` `..---.``` ````````..-:/:::---.` `-ohmmh+:` /Mh .://///:::-----.-----.......` `-+hmmy+- sMy` ``````-+ydmy+- /mNs-` `./ohmNMNNNmy+- /yNmho/:.``````````.-:/+syhdNmdyso+/-.` `:+ydmNMNNNNNNNNNmdhys+/:.` ``.....` LOL U MAD? \"\"\" ) import sys sys . exit ( 1 ) Yes, indead. The idea of using Ruby in Python is totally mad.","tags":"tech","url":"//farseerfc.me/en/mix-ruby.html"},{"title":"Discuss C++ Template Downcast","text":"This is a discuss in C board in bbs.sjtu.edu.cn, about type down-cast in C++ template. Original Discuss http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html The problem Today I read a book about we can do cast-down in template, so I write this to test: template < bool _Test , class _Type = void > struct enable_if { }; template < class _Type > struct enable_if < true , _Type > { typedef _Type type ; }; class A { }; class B : A { }; template < typename T > struct traits { static int const value = false ; }; template <> struct traits < A > { static int const value = true ; }; template < typename T > void f ( T , typename enable_if < traits < T >:: value >:: type * = 0 ) { } template <> void f < A > ( A , enable_if < traits < A >:: value >:: type * ) { } template < typename T > class BB {}; template < typename T > class DD : public BB < T > {}; template < typename T > void ff ( BB < T > ) {}; int main ( int argc , char * argv []) { A a ; B b ; DD < long > dd ; //f(b); ff ( dd ); } It is strange when f it don't allow my specified f<A>` . But in ff it allowed ff<BB<long>>` . Tested under VC10 and GCC3.4 My answer to the problem Let's think ourself as compiler to see what happened there. Define mark # : A#B is the instantiated result when we put B into the parameter T of A<T> . First we discuss ff DD < long > dd ; After this sentense, the compiler saw the instantiation of DD<long> , so it instantiate DD#long , and also BB#long . ff ( dd ); This sentense required the compiler to calculate set of overloading functions. Step 1 we need to infer T of ff<T> from argument DD#long -> BB<T> . Based on the inference rule: Argument with type :code:`class_template_name<T>` can be use to infer :code:`T``. So compiler inferred T as long . Here if it is not BB but CC which is complete un-related, we can also infer, as long as CC is a template like CC<T> . Step 2 Template Specialization Resolution. There is only one template here so we matched ff<T> . Step 3 Template Instantiation After inferred long -> T , compiler instantiated ff#long . Set of available overloading functions : {ff#long} Then overloading resolution found the only match ff#long` , checked its real parameter DD#long can be down-cast to formal parameter BB#long . Then we discuss f f ( b ); Calculate set of overloading functions. Step 1 infer all template parameters for template f . According to inference rule: Parameter with type T can be used to infer T 。 So B -> T is inferred. Step 2 Template Specialization Resolution. Here B is not A so we can not apply specialization of f<A> , remaining f<T> as the only alternative. Step 3 Template Instantiation. When we put B into f<T> to instantiate as f#B , we need to instantiate traits#B` . There is no specialization for B so we use template traits<T> , traits#B::value=false , so enable_if#false didn't contains a type , an error occurred. The only template is mismatch, available overloading functions is empty set. So we got an error.","tags":"tech","url":"//farseerfc.me/en/discuss-cpp-template-downcast.html"},{"title":"Give a try to Pelican","text":"It seems in one night all geeks have their own Github User Page and Octopress Blog. Like everyone posted in their blogs, Static Blog is indeed more convenient than traditional Blog systems such as WordPress. I have been wanting my own Octopress since then. But it seems that Octopress isn't for me At first I was confused by Setup Steps of Octopress . What is this RVM thing? And what is that rbenv thing? It seems the high pace of Ruby community has beyond my imagination to a degree that they need a version manager to ensure the compatibility of different versions of Ruby. Althrough the same compatibility issue also troubles Python community [1] , but at least Python don't need a version manager (yet) to control this mass [2] . Real problem for me is that I haven't yet a Linux box that I can play around freely. (I really want one ... ) Both RVM and rbenv needs to run on Unix/Linux/MacOSX. One can not be a geek if he use Windows ? (Maybe it's true...) Remaining problem is the battle between Ruby and Python campaign. I haven't tried Markdown , and I rather like ReST . It seems that both sides depend on Pygments as code block highlighter so Rubyists need Python environment anyway. I simply don't want to depend on any Ruby component. It is better when it is in pure Python, no C extensions so that I can debug into it and make minor modifications. So I started searching for Static Blog Engine in Python on Github. The author of the great framework Flask , mitsuhiko , wrote a rstblog , but it's not well developed. Hyde seems to be complete enough, but it use MarkDown as its default markup language, and the design of its homepage is too fashion to be used as blog. Finally I found Pelican . [1] Such as the difference between Python 2.x and 3.x , and also difference in C-API of implementations of PyPy , CPython , Stackless , Cython . [2] Yes, we have easy_install and pip , but all these are package manager, running in a perticular Python implementation. Python implementation itself don't need a manager. Version issue of Python largely have been solved by lightweight converters such as 2to3.py and 3to2.py , you don't need to store multiple implementations of Python in your disk for different packages. Yes you can use virtualenv if you need to preserve stablility but this is another story. Let it be Pelican For my own use, Pelican offers me some advantages over Octopress : Implemented in pure Python . This means that I can use different implementation of Python other than CPython easily. I use PyPy myself. Translation of multi-languages. The original author of Pelican is a France. This is unnecessory for most people, but I will post my blog mainly in three languages: English, Japanese and Chinese. ReST . So that I can use the @auto-rst feature of Leo . And also I don't need to switch between my blog and documentation of my projects. But it seems that Pelican was less contributed than Octopress . Some minor issues remains in latest version: Support of pelican-import from WordPress for Chinese and Japanese articles are buggy. Datetime format, timezone, and locale support for multi-language blogs are not so natural. I will work on this in these days There are not so many templates compared to Octopress . And less plugins . I hope more people from Python community can contribute to this excellent project, then all these issues will be fixed soon. My settings To install Pelican is simple: $ pip install pelican Write posts in ReST , with rst extensions, and put them in pages folder. (Re)Build all pages is simply: $ pelican -s settings.py Push to Github: $ git commit -am \"Commit message\" $ git push And following is my settings.py : # -*- coding: utf-8 -*- TIMEZONE = 'Asia/Tokyo' DATE_FORMATS = { 'en' :( 'usa' , ' %a , %d %b %Y' ), 'zh' :( 'chs' , '%Y-%m- %d , %a ' ), 'jp' :( 'jpn' , '%Y/%m/ %d ( %a )' ), } # windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx LOCALE = [ 'usa' , 'chs' , 'jpn' , # windows 'en_US' , 'zh_CN' , 'ja_JP' ] # Unix/Linux DEFAULT_LANG = 'zh' SITENAME = 'Farseerfc Blog' AUTHOR = 'Jiachen Yang' DISQUS_SITENAME = 'farseerfcgithub' GITHUB_URL = 'https://github.com/farseerfc' SITEURL = 'http://farseerfc.github.com' TAG_FEED = 'feeds/ %s .atom.xml' SOCIAL = (( 'twitter' , 'http://twitter.com/farseerfc' ), ( 'github' , 'https://github.com/farseerfc' ), ( 'facebook' , 'http://www.facebook.com/farseerfc' ), ( 'weibo' , 'http://weibo.com/farseerfc' ), ( 'renren' , 'http://www.renren.com/farseer' ), ) TWITTER_USERNAME = 'farseerfc' THEME = 'notmyidea' CSS_FILE = \"wide.css\" DEFAULT_CATEGORY = 'Others' OUTPUT_PATH = '.' PATH = 'posts'","tags":"tech","url":"//farseerfc.me/en/try-pelican.html"},{"title":"\"…if we do this work … \" --Bill Gates","text":"Imported from renren \"…if we do this work … and the result is that Linux works great …\" --Bill Gates From: Bill Gates '-- Sent: Sunday, January 24, 1999 8:41 AM Jeff Westorinon; Ben Fathi ; TO: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder Subject: ACPI extensions One thing I find myself wondering about is whether we shouldn't try and make the \"ACPI\" extensions somehow Windows specific. It seems unfortunate if we do this work and get our partners to do the work and the result is that Linux works great without having to do the work . Maybe there is no way to avoid this problem but it does bother me. Maybe we could define the APIs so that they work well with NT and not the others even if they are open. Or maybe we could patent something relaled to this. From: http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf If this is the reason that Xen 4.0 is still not fully support ACPI 3.0, then f*ck you Bill Gates!","tags":"import","url":"//farseerfc.me/en/if-we-do-this-work.html"},{"title":"Write a program to keep CPU usage as sin funcion","text":"Imported from: renren . It is said that this is a problem from interview of Microsoft. Write a program, which makes the CPU usage curve in Windows Task Manager shows a Sin function. The program below is written in java: public class sincpu { private static final int cycle = 1024 , tick = 256 ; public static void main ( String [] args ) throws InterruptedException { for ( int i = 0 ;; i ++ ){ work ( calcNextSleep ( i % cycle )); sleep ( tick - calcNextSleep ( i % cycle )); } } private static long calcNextSleep ( long i ){ return ( int )( Math . sin (( double ) i * 2 * Math . PI / cycle ) * tick + tick ) / 2 ; } private static void sleep ( long sleepTime ) throws InterruptedException { if ( sleepTime < 2 ) Thread . yield (); else Thread . sleep ( sleepTime ); } private static void work ( long period ) { long start = System . currentTimeMillis (); for (;;){ Math . sin ( 1 ); if ( System . currentTimeMillis () - start >= period ) break ; } } } Be careful you need to turn off other cores if you have multi-core CPU.","tags":"import","url":"//farseerfc.me/en/sine-cpu.html"},{"title":"EVA-Komm,susser Tod","text":"Imported from renren I know, I know I''ve let you down I''ve been a fool to myself I thought that I could live for no one else But now through all the hurt and pain It''s time for me to respect The ones you love mean more than anything So with sadness in my heart Feel the best thing I could do It''s end it all And leave forever What''s done is done it feel so bad What once was happy now is sad I''ll never love again My world is ending I wish that I could turn back time Cause now the guilt is all mine Can''t live without the trust from those you love I know we can''t forget the past You can''t forget love and pride Because that it''s killing me inside It all returns to nothing It all comes tumbling down tumbling down tumbling down It all returns to nothing I just keep letting me down letting me down letting me down In my heart of hearts I know I could never love again I''ve lost everything everything Everything that matters to me matters in this world I wish that I could turn back time Cause now the guilt is all mine Can''t live without the trust from those you love I know we can''t forget the past You can''t forget love and pride Because that it''s killing me inside It all returns to nothing It just keeps tumbling down tumbling down tumbling down It all returns to nothing I just keep letting me down letting me down letting me down Up up up up up Tumbling down tumbling down tumbling down Up up up up up Letting me down letting me down letting me down Up up up up up Tumbling down tumbling down tumbling down Up up up up up Letting me down letting me down letting me down","tags":"import","url":"//farseerfc.me/en/EVA-Komm-susser-Tod.html"},{"title":"PacVis: 可視化 pacman 本地數據庫","text":"PacVis 我爲什麼要做 PacVis 我喜歡 Arch Linux ，大概是因爲唯有 Arch Linux 能給我對整個系統「瞭如指掌」的感覺。 在 Arch Linux 裏我能清楚地知道我安裝的每一個包，能知道系統裏任何一個文件是來自哪個包， 以及我爲什麼要裝它。或許對 Debian/Fedora/openSUSE 足夠熟悉了之後也能做到這兩點， 不過他們的細緻打包的結果通常是包的數量比 Arch 要多個 3 到 10 倍，並且打包的細節也比 Arch Linux 簡單的 PKGBUILD 要複雜一個數量級。 每一個裝過 Arch Linux 的人大概都知道，裝了 Arch Linux 之後得到的系統非常樸素，按照 ArchWiki 上的流程一路走下來的話，最關鍵的一條命令就是 pacstrap /​mnt base ， 它在 /​mnt 裏作爲根調用 pacman -S base 裝上了整個 base 組， 然後就沒有然後了。這個系統一開始空無一物，你需要的任何東西都是後來一點點用 pacman 手動裝出來的，沒有累贅，按你所需。 然而時間長了，系統中難免會有一些包，是你裝過用過然後忘記了， 然後這些包就堆在系統的角落裏，就像家裏陳年的老傢俱，佔着地，落着灰。雖然 pacman -Qtd 能方便地幫你找出所有 曾經作爲依賴被裝進來，而現在不被任何包依賴 的包，但是對於那些你手動指定的包， 它就無能爲力了。 於是我就一直在找一個工具能幫我梳理系統中包的關係，方便我： 找出那些曾經用過而現在不需要的包 找出那些體積大而且佔地方的包 釐清系統中安裝了的包之間的關係 Android 系統架構 關於最後一點「釐清包的關係」，我曾經看到過 macOS 系統架構圖 和 Android 的系統架構圖，對其中的層次化架構印象深刻，之後就一直在想，是否能畫出現代 Linux 桌面系統上類似的架構圖呢？又或者 Linux 桌面系統是否會展現完全不同的樣貌？ 從維基百科或者別的渠道能找到 Linux 內核、或者 Linux 圖形棧， 或者某個桌面環境的架構，但是沒有找到覆蓋一整個發行版的樣貌的。 於是我便想，能不能從包的依賴關係中自動生成這樣一張圖呢。 PacVis的老前輩們 在開始寫 PacVis 之前，我試過一些類似的工具，他們都或多或少能解決一部分我的需要， 又在某些方面有所不足。這些工具成爲了 PacVis 的雛形，啓發了 PacVis 應該做成什麼樣子。 pactree pactree 曾經是一個 獨立的項目 ，現在則是 pacman 的一部分 了。 從手冊頁可以看出， pactree 的輸出是由某個包開始的依賴樹。 加上 --graph 參數之後 pactree 還能輸出 dot 格式的矢量圖描述，然後可以用 dot 畫出依賴圖： pactree pacvis-git -d3 --graph | dot -Tpng >pacvis-pactree.png $ pactree pacvis-git -d3 pacvis-git ├─python-tornado │ └─python │ ├─expat │ ├─bzip2 │ ├─gdbm │ ├─openssl │ ├─libffi │ └─zlib ├─pyalpm │ ├─python │ └─pacman │ ├─bash │ ├─glibc │ ├─libarchive │ ├─curl │ ├─gpgme │ ├─pacman-mirrorlist │ └─archlinux-keyring └─python-setuptools └─python-packaging ├─python-pyparsing └─python-six $ pactree pacvis-git -d3 --graph | dot -Tpng >pacvis-pactree.png 從畫出的圖可以看出，因爲有共用的依賴，所以從一個包開始的依賴關係已經不再是一棵 圖論意義上的樹(Tree) 了。最初嘗試做 PacVis 的早期實現的時候，就是試圖用 bash/python 腳本解析 pactree 和 pacman 的輸出，在 pactree 的基礎上把整個系統中所有安裝的包全都包含到一張圖裏。 當然後來畫出的結果並不那麼理想，首先由於圖非常巨大，導致 dot 的自動佈局要耗費數小時，最後畫出的圖也過於巨大基本上沒法看。 然而不得不說沒有 pactree 就不會有 PacVis ，甚至 pacman 被分離出 alpm 庫也和 pactree 用 C 重寫的過程有很大關係，而 PacVis 用來查詢 pacman 數據庫的庫 pyalpm 正是 alpm 的 Python 綁定。因爲 pactree 的需要而增加出的 alpm 庫奠定了 PacVis 實現的基石。 pacgraph pacgraph 的輸出 pacgraph 是一位 Arch Linux 的 Trusted User keenerd 寫的程序，和 PacVis 一樣也是用 Python 實現的。 比起 pactree ， pacgraph 明顯更接近我的需求，它默認繪製整個系統的所有安裝包， 並且用聰明的佈局算法解決了 dot 佈局的性能問題。 pacgraph 的輸出是一個富有藝術感的依賴圖，圖中用不同的字體大小表示出了每個包佔用 的磁盤空間。通過觀察 pacgraph 的輸出，我們可以清楚地把握系統全局的樣貌， 比如一眼看出這是個桌面系統還是個服務器系統，並且可以很容易地發現那些佔用磁盤空間 巨大的包，考慮清理這些包以節約空間。 更棒的是 pacgraph 還提供了一個交互性的 GUI 叫做 pacgraph-tk ，顯然通過 tk 實現。 用這個 GUI 可以縮放觀察整幅圖的細節，或者選中某個包觀察它和別的包的依賴關係。 pacgraph 還支持通過參數指定只繪製個別包的依賴關係，就像 pactree 那樣。 不過 pacgraph 也不是完全滿足我的需要。如我前面說過，我希望繪製出的圖能反應 這個發行版的架構面貌 ，而 pacgraph 似乎並不區別「該包依賴的包」和「依賴該包的包」 這兩種截然相反的依賴關係。換句話說 pacgraph 畫出的是一張無向圖， 而我更想要一張有向圖，或者說是 有層次結構的依賴關係圖 。 於是就有了 PacVis PacVis 剛打開的樣子 總結了老前輩們的優勢與不足，我便開始利用空餘時間做我心目中的 PacVis 。 前後斷斷續續寫了兩個月，又分爲兩個階段，第一階段做了基本的功能和雛形， 第二階段套用上 https://getmdl.io/ 的模板，總算有了能拿得出手給別人看的樣子。 於是乎前兩天在 AUR 上給 pacvis 打了個 pacvis-git 包，現在想在本地跑 pacvis 應該很方便了，用任何你熟悉的 aurhelper 就可以安裝，也可以直接從 aur 下載 PKGBUILD 打包： ~$ git clone aur@aur.archlinux.org:pacvis-git.git ~$ cd pacvis-git ~/pacvis-git$ makepkg -si ~/pacvis-git$ pacvis Start PacVis at http://localhost:8888/ 按照提示說的，接下來打開瀏覽器訪問 http://localhost:8888/ 就能看到 PacVis 的樣子了。僅僅作爲嘗試也可以直接打開跑在我的服務器上的 demo: https://pacvis.farseerfc.me/ ，這個作爲最小安裝的服務器載入速度大概比普通的桌面系統快一點。 在 Windows msys2 跑 PacVis 另外補充一下，因爲 PacVis 只依賴 pyalpm 和 tornado ，所以在別的基於 pacman 的系統上跑它應該也沒有任何問題，包括 Windows 上的 msys2 裏（儘管在 msys2 上編譯 tornado 的包可能要花些功夫）。 PacVis 的圖例和用法 操作上 PacVis 仿照地圖程序比如 Google Maps 的用法，可以用滾輪或者觸摸屏的手勢 縮放、拖拽，右上角有個側邊欄，不需要的話可以點叉隱藏掉，右下角有縮放的按鈕和 回到全局視圖的按鈕，用起來應該還算直觀。 pacvis-git 包的依賴 先解釋圖形本身，整張圖由很多小圓圈的節點，以及節點之間的箭頭組成。 一個圓圈就代表一個軟件包，而一條箭頭代表一個依賴關係。縮放到細節的話， 能看到每個小圓圈的下方標註了這個軟件包的名字，鼠標懸浮在圓圈上也會顯示響應信息。 還可以點開軟件包，在右側的邊欄裏會有更詳細的信息。 比如圖例中顯示了 pacvis-git 自己的依賴，它依賴 pyalpm, python-tornado 和 python-setuptools ，其中 pyalpm 又依賴 pacman 。圖中用 紫色 表示手動安裝的包， 橙色 表示被作爲依賴安裝的包， 箭頭的顏色也隨着包的顏色改變。 值得注意的是圖中大多數箭頭都是由下往上指的，這是因爲 PacVis 按照包的依賴關係做 了拓撲排序，並且給每個包賦予了一個拓撲層級。比如 pacvis-git 位於 39 層，那麼它依賴的 pyalpm 就位於 38 層，而 pyalpm 依賴的 pacman 就位於 37 層。根據層級關係排列包是 PacVis 於 pacgraph 之間最大的不同之處。 除了手動縮放， PacVis 還提供了搜索框，根據包名快速定位你感興趣的包。 以及在右側邊欄中的 Dep 和 Req-By 等頁中，包的依賴關係也是做成了按鈕的形式， 可以由此探索包和包之間的關聯。 最後稍微解釋一下兩個和實現相關的參數： Max Level 這是限制 PacVis 載入的最大拓撲層。系統包非常多的時候 PacVis 的佈局算法會顯得很慢，限制層數有助於加快載入，特別是在調試 PacVis 的時候比較有用。 Max Required-By 這是限制 PacVis 繪製的最大被依賴關係。稍微把玩一下 PacVis 就會發現系統內絕大多數 的包都直接依賴了 glibc 或者 gcc-libs 等個別的幾個包，而要繪製這些依賴的話會導致 渲染出的圖中有大量長直的依賴線，不便觀察。於是可以通過限制這個值，使得 PacVis 不繪製被依賴太多的包的依賴關係，有助於讓渲染出的圖更易觀察。 從 PacVis 能瞭解到的一些事實 一個 KDE 桌面的 PacVis 結果全圖， 放大（17M） 稍微玩一下 PacVis 就能發現不少有趣現象，上述「絕大多數包依賴 glibc 」就是一例。 除此之外還有不少值得玩味的地方。 依賴層次 系統中安裝的包被明顯地分成了這樣幾個層次： glibc 等 C 庫 Bash/Perl/Python 等腳本語言 coreutils/gcc/binutils 等核心工具 pacman / systemd 等較大的系統工具 gtk{2,3}/qt{4,5} 等 GUI toolkit chromium 等 GUI 應用 Plasma/Gnome 等桌面環境 大體上符合直觀的感受，不過細節上有很多有意思的地方，比如 zsh 因爲 gdbm 間接依賴了 bash，這也說明我們不可能在系統中用 zsh 完全替代掉 bash。 再比如 python （在 Arch Linux 中是 python3）和 python2 和 pypy 幾乎在同一個拓撲層級。 zsh 因爲 gdbm 間接依賴了 bash 不過偶爾顯示的依賴層級不太符合直觀，比如 qt5-base < qt4 < gtk2 < gtk3 。 qt5 因爲被拆成了數個包所以比 qt4 更低級這可以理解，而 gtk 系比 qt 系更高級這一點是很多人（包括我）沒有預料到的吧。 循環依賴 有些包的依賴關係形成了循環依賴，一個例子是 freetype2 和 harfbuzz，freetype2 是繪製字體的庫，harfbuzz 是解析 OpenType 字形的庫，兩者對對方互相依賴。 另一個例子是 KDE 的 kio 和 kinit，前者提供類似 FUSE 的資源訪問抽象層， 後者初始化 KDE 桌面環境。 freetype2 和 harfbuzz 之間的循環依賴 因爲這些循環依賴的存在，使得 PacVis 在實現時不能直接拓撲排序，我採用環探測 算法找出有向圖中所有的環，並且打破這些環，然後再使用拓撲排序。 因此我在圖中用紅色的箭頭表示這些會導致環的依賴關係。 有些包沒有依賴關係 man-pages 和 licenses 沒有依賴關係 有些包既不被別的包依賴，也不依賴別的包，而是孤立在整張圖中，比如 man-pages 和 licenses 。這些包在圖中位於最頂端，拓撲層級是 0 ，我用 藍色 正方形特別繪製它們。 只看依賴關係的話 Linux 內核完全不重要 所有用戶空間的程序都依賴着 glibc ，而 glibc 則從定義良好的 syscall 調用內核。 因此理所當然地，如果只看用戶空間的話， glibc 和別的 GNU 組件是整個 GNU/Linux 發行版的中心，而 Linux 則是位於依賴層次中很深的位置，甚至在我的 demo 服務器上 Linux 位於整個圖中的最底端，因爲它的安裝腳本依賴 mkinitcpio 而後者依賴了系統中的衆多組件。 pacman -Qtd 不能找到帶有循環依賴的孤兒包 msys2 中帶有循環依賴的孤兒包 這是我在 msys2 上測試 PacVis 的時候發現的，我看到在渲染的圖中有一片羣島， 沒有連上任何手動安裝的包。這種情況很不正常，因爲我一直在我的所有系統中跑 pacman -Qtd 找出孤兒包並刪掉他們。放大之後我發現這些包中有一條循環依賴， 這說明 pacman -Qtd 不能像語言的垃圾回收機制那樣找出有循環依賴的孤兒包。 PacVis 的未來 目前的 PacVis 基本上是我最初開始做的時候設想的樣子，隨着開發逐漸又增加了不少功能。 一些是迫於佈局算法的性能而增加的（比如限制層數）。 今後準備再加入以下這些特性： 更合理的 optdeps 處理。目前只是把 optdeps 關係在圖上畫出來了。 更合理的 依賴關係抉擇 。有時候包的依賴關係並不是直接根據包名，而是 provides 由一個包提供另一個包的依賴。目前 PacVis 用 alpm 提供的方式抉擇這種依賴，於是這種關係並沒有記錄在圖上。 目前的層級關係沒有考慮包所在的倉庫 (core/extra/community/...) 或者包所屬的組。 加入這些關係能更清晰地表達依賴層次。 目前沒有辦法只顯示一部分包的關係。以後準備加入像 pactree/pacgraph 一樣顯示部分包。 如果你希望 PacVis 出現某些有趣的用法和功能，也 請給我提 issue 。","tags":"tech","url":"//farseerfc.me/en/../pacvis.html"},{"title":"PacVis: 可视化 pacman 本地数据库","text":"PacVis 我为什么要做 PacVis 我喜欢 Arch Linux ，大概是因为唯有 Arch Linux 能给我对整个系统「了如指掌」的感觉。 在 Arch Linux 里我能清楚地知道我安装的每一个包，能知道系统里任何一个文件是来自哪个包， 以及我为什么要装它。或许对 Debian/Fedora/openSUSE 足够熟悉了之后也能做到这两点， 不过他们的细致打包的结果通常是包的数量比 Arch 要多个 3 到 10 倍，并且打包的细节也比 Arch Linux 简单的 PKGBUILD 要复杂一个数量级。 每一个装过 Arch Linux 的人大概都知道，装了 Arch Linux 之后得到的系统非常朴素，按照 ArchWiki 上的流程一路走下来的话，最关键的一条命令就是 pacstrap /​mnt base ， 它在 /​mnt 里作为根调用 pacman -S base 装上了整个 base 组， 然后就没有然后了。这个系统一开始空无一物，你需要的任何东西都是后来一点点用 pacman 手动装出来的，没有累赘，按你所需。 然而时间长了，系统中难免会有一些包，是你装过用过然后忘记了， 然后这些包就堆在系统的角落里，就像家里陈年的老家具，占着地，落着灰。虽然 pacman -Qtd 能方便地帮你找出所有 曾经作为依赖被装进来，而现在不被任何包依赖 的包，但是对于那些你手动指定的包， 它就无能为力了。 于是我就一直在找一个工具能帮我梳理系统中包的关系，方便我： 找出那些曾经用过而现在不需要的包 找出那些体积大而且占地方的包 厘清系统中安装了的包之间的关系 Android 系统架构 关于最后一点「厘清包的关系」，我曾经看到过 macOS 系统架构图 和 Android 的系统架构图，对其中的层次化架构印象深刻，之后就一直在想，是否能画出现代 Linux 桌面系统上类似的架构图呢？又或者 Linux 桌面系统是否会展现完全不同的样貌？ 从维基百科或者别的渠道能找到 Linux 内核、或者 Linux 图形栈， 或者某个桌面环境的架构，但是没有找到覆盖一整个发行版的样貌的。 于是我便想，能不能从包的依赖关系中自动生成这样一张图呢。 PacVis的老前辈们 在开始写 PacVis 之前，我试过一些类似的工具，他们都或多或少能解决一部分我的需要， 又在某些方面有所不足。这些工具成为了 PacVis 的雏形，启发了 PacVis 应该做成什么样子。 pactree pactree 曾经是一个 独立的项目 ，现在则是 pacman 的一部分 了。 从手册页可以看出， pactree 的输出是由某个包开始的依赖树。 加上 --graph 参数之后 pactree 还能输出 dot 格式的矢量图描述，然后可以用 dot 画出依赖图： pactree pacvis-git -d3 --graph | dot -Tpng >pacvis-pactree.png $ pactree pacvis-git -d3 pacvis-git ├─python-tornado │ └─python │ ├─expat │ ├─bzip2 │ ├─gdbm │ ├─openssl │ ├─libffi │ └─zlib ├─pyalpm │ ├─python │ └─pacman │ ├─bash │ ├─glibc │ ├─libarchive │ ├─curl │ ├─gpgme │ ├─pacman-mirrorlist │ └─archlinux-keyring └─python-setuptools └─python-packaging ├─python-pyparsing └─python-six $ pactree pacvis-git -d3 --graph | dot -Tpng >pacvis-pactree.png 从画出的图可以看出，因为有共用的依赖，所以从一个包开始的依赖关系已经不再是一棵 图论意义上的树(Tree) 了。最初尝试做 PacVis 的早期实现的时候，就是试图用 bash/python 脚本解析 pactree 和 pacman 的输出，在 pactree 的基础上把整个系统中所有安装的包全都包含到一张图里。 当然后来画出的结果并不那么理想，首先由于图非常巨大，导致 dot 的自动布局要耗费数小时，最后画出的图也过于巨大基本上没法看。 然而不得不说没有 pactree 就不会有 PacVis ，甚至 pacman 被分离出 alpm 库也和 pactree 用 C 重写的过程有很大关系，而 PacVis 用来查询 pacman 数据库的库 pyalpm 正是 alpm 的 Python 绑定。因为 pactree 的需要而增加出的 alpm 库奠定了 PacVis 实现的基石。 pacgraph pacgraph 的输出 pacgraph 是一位 Arch Linux 的 Trusted User keenerd 写的程序，和 PacVis 一样也是用 Python 实现的。 比起 pactree ， pacgraph 明显更接近我的需求，它默认绘制整个系统的所有安装包， 并且用聪明的布局算法解决了 dot 布局的性能问题。 pacgraph 的输出是一个富有艺术感的依赖图，图中用不同的字体大小表示出了每个包占用 的磁盘空间。通过观察 pacgraph 的输出，我们可以清楚地把握系统全局的样貌， 比如一眼看出这是个桌面系统还是个服务器系统，并且可以很容易地发现那些占用磁盘空间 巨大的包，考虑清理这些包以节约空间。 更棒的是 pacgraph 还提供了一个交互性的 GUI 叫做 pacgraph-tk ，显然通过 tk 实现。 用这个 GUI 可以缩放观察整幅图的细节，或者选中某个包观察它和别的包的依赖关系。 pacgraph 还支持通过参数指定只绘制个别包的依赖关系，就像 pactree 那样。 不过 pacgraph 也不是完全满足我的需要。如我前面说过，我希望绘制出的图能反应 这个发行版的架构面貌 ，而 pacgraph 似乎并不区别「该包依赖的包」和「依赖该包的包」 这两种截然相反的依赖关系。换句话说 pacgraph 画出的是一张无向图， 而我更想要一张有向图，或者说是 有层次结构的依赖关系图 。 于是就有了 PacVis PacVis 刚打开的样子 总结了老前辈们的优势与不足，我便开始利用空余时间做我心目中的 PacVis 。 前后断断续续写了两个月，又分为两个阶段，第一阶段做了基本的功能和雏形， 第二阶段套用上 https://getmdl.io/ 的模板，总算有了能拿得出手给别人看的样子。 于是乎前两天在 AUR 上给 pacvis 打了个 pacvis-git 包，现在想在本地跑 pacvis 应该很方便了，用任何你熟悉的 aurhelper 就可以安装，也可以直接从 aur 下载 PKGBUILD 打包： ~$ git clone aur@aur.archlinux.org:pacvis-git.git ~$ cd pacvis-git ~/pacvis-git$ makepkg -si ~/pacvis-git$ pacvis Start PacVis at http://localhost:8888/ 按照提示说的，接下来打开浏览器访问 http://localhost:8888/ 就能看到 PacVis 的样子了。仅仅作为尝试也可以直接打开跑在我的服务器上的 demo: https://pacvis.farseerfc.me/ ，这个作为最小安装的服务器载入速度大概比普通的桌面系统快一点。 在 Windows msys2 跑 PacVis 另外补充一下，因为 PacVis 只依赖 pyalpm 和 tornado ，所以在别的基于 pacman 的系统上跑它应该也没有任何问题，包括 Windows 上的 msys2 里（尽管在 msys2 上编译 tornado 的包可能要花些功夫）。 PacVis 的图例和用法 操作上 PacVis 仿照地图程序比如 Google Maps 的用法，可以用滚轮或者触摸屏的手势 缩放、拖拽，右上角有个侧边栏，不需要的话可以点叉隐藏掉，右下角有缩放的按钮和 回到全局视图的按钮，用起来应该还算直观。 pacvis-git 包的依赖 先解释图形本身，整张图由很多小圆圈的节点，以及节点之间的箭头组成。 一个圆圈就代表一个软件包，而一条箭头代表一个依赖关系。缩放到细节的话， 能看到每个小圆圈的下方标注了这个软件包的名字，鼠标悬浮在圆圈上也会显示响应信息。 还可以点开软件包，在右侧的边栏里会有更详细的信息。 比如图例中显示了 pacvis-git 自己的依赖，它依赖 pyalpm, python-tornado 和 python-setuptools ，其中 pyalpm 又依赖 pacman 。图中用 紫色 表示手动安装的包， 橙色 表示被作为依赖安装的包， 箭头的颜色也随着包的颜色改变。 值得注意的是图中大多数箭头都是由下往上指的，这是因为 PacVis 按照包的依赖关系做 了拓扑排序，并且给每个包赋予了一个拓扑层级。比如 pacvis-git 位于 39 层，那么它依赖的 pyalpm 就位于 38 层，而 pyalpm 依赖的 pacman 就位于 37 层。根据层级关系排列包是 PacVis 于 pacgraph 之间最大的不同之处。 除了手动缩放， PacVis 还提供了搜索框，根据包名快速定位你感兴趣的包。 以及在右侧边栏中的 Dep 和 Req-By 等页中，包的依赖关系也是做成了按钮的形式， 可以由此探索包和包之间的关联。 最后稍微解释一下两个和实现相关的参数： Max Level 这是限制 PacVis 载入的最大拓扑层。系统包非常多的时候 PacVis 的布局算法会显得很慢，限制层数有助于加快载入，特别是在调试 PacVis 的时候比较有用。 Max Required-By 这是限制 PacVis 绘制的最大被依赖关系。稍微把玩一下 PacVis 就会发现系统内绝大多数 的包都直接依赖了 glibc 或者 gcc-libs 等个别的几个包，而要绘制这些依赖的话会导致 渲染出的图中有大量长直的依赖线，不便观察。于是可以通过限制这个值，使得 PacVis 不绘制被依赖太多的包的依赖关系，有助于让渲染出的图更易观察。 从 PacVis 能了解到的一些事实 一个 KDE 桌面的 PacVis 结果全图， 放大（17M） 稍微玩一下 PacVis 就能发现不少有趣现象，上述「绝大多数包依赖 glibc 」就是一例。 除此之外还有不少值得玩味的地方。 依赖层次 系统中安装的包被明显地分成了这样几个层次： glibc 等 C 库 Bash/Perl/Python 等脚本语言 coreutils/gcc/binutils 等核心工具 pacman / systemd 等较大的系统工具 gtk{2,3}/qt{4,5} 等 GUI toolkit chromium 等 GUI 应用 Plasma/Gnome 等桌面环境 大体上符合直观的感受，不过细节上有很多有意思的地方，比如 zsh 因为 gdbm 间接依赖了 bash，这也说明我们不可能在系统中用 zsh 完全替代掉 bash。 再比如 python （在 Arch Linux 中是 python3）和 python2 和 pypy 几乎在同一个拓扑层级。 zsh 因为 gdbm 间接依赖了 bash 不过偶尔显示的依赖层级不太符合直观，比如 qt5-base < qt4 < gtk2 < gtk3 。 qt5 因为被拆成了数个包所以比 qt4 更低级这可以理解，而 gtk 系比 qt 系更高级这一点是很多人（包括我）没有预料到的吧。 循环依赖 有些包的依赖关系形成了循环依赖，一个例子是 freetype2 和 harfbuzz，freetype2 是绘制字体的库，harfbuzz 是解析 OpenType 字形的库，两者对对方互相依赖。 另一个例子是 KDE 的 kio 和 kinit，前者提供类似 FUSE 的资源访问抽象层， 后者初始化 KDE 桌面环境。 freetype2 和 harfbuzz 之间的循环依赖 因为这些循环依赖的存在，使得 PacVis 在实现时不能直接拓扑排序，我采用环探测 算法找出有向图中所有的环，并且打破这些环，然后再使用拓扑排序。 因此我在图中用红色的箭头表示这些会导致环的依赖关系。 有些包没有依赖关系 man-pages 和 licenses 没有依赖关系 有些包既不被别的包依赖，也不依赖别的包，而是孤立在整张图中，比如 man-pages 和 licenses 。这些包在图中位于最顶端，拓扑层级是 0 ，我用 蓝色 正方形特别绘制它们。 只看依赖关系的话 Linux 内核完全不重要 所有用户空间的程序都依赖着 glibc ，而 glibc 则从定义良好的 syscall 调用内核。 因此理所当然地，如果只看用户空间的话， glibc 和别的 GNU 组件是整个 GNU/Linux 发行版的中心，而 Linux 则是位于依赖层次中很深的位置，甚至在我的 demo 服务器上 Linux 位于整个图中的最底端，因为它的安装脚本依赖 mkinitcpio 而后者依赖了系统中的众多组件。 pacman -Qtd 不能找到带有循环依赖的孤儿包 msys2 中带有循环依赖的孤儿包 这是我在 msys2 上测试 PacVis 的时候发现的，我看到在渲染的图中有一片群岛， 没有连上任何手动安装的包。这种情况很不正常，因为我一直在我的所有系统中跑 pacman -Qtd 找出孤儿包并删掉他们。放大之后我发现这些包中有一条循环依赖， 这说明 pacman -Qtd 不能像语言的垃圾回收机制那样找出有循环依赖的孤儿包。 PacVis 的未来 目前的 PacVis 基本上是我最初开始做的时候设想的样子，随着开发逐渐又增加了不少功能。 一些是迫于布局算法的性能而增加的（比如限制层数）。 今后准备再加入以下这些特性： 更合理的 optdeps 处理。目前只是把 optdeps 关系在图上画出来了。 更合理的 依赖关系抉择 。有时候包的依赖关系并不是直接根据包名，而是 provides 由一个包提供另一个包的依赖。目前 PacVis 用 alpm 提供的方式抉择这种依赖，于是这种关系并没有记录在图上。 目前的层级关系没有考虑包所在的仓库 (core/extra/community/...) 或者包所属的组。 加入这些关系能更清晰地表达依赖层次。 目前没有办法只显示一部分包的关系。以后准备加入像 pactree/pacgraph 一样显示部分包。 如果你希望 PacVis 出现某些有趣的用法和功能，也 请给我提 issue 。","tags":"tech","url":"//farseerfc.me/en/../zhs/pacvis.html"},{"title":"KDE5 Plasma の踊る活動ボタン","text":"今日 KDE5 Plasma の「活動」を切り替えている際に偶々この現象を発見しました。 この活動ボタンを画面の外に持ち出すと、デスクトップの縁で踊り出します。 ビデオはこちらに： Youtube Youku 勿論画面の中に引っ張ってきたら問題はなくなるので、大したバグではない。単なる面白い現象です。 この前に Gnome3 にも画面がおかしくなるバグがありました。それを比べて KDE5 のほうはよぽと増しと思います。 Youtube Youku ちなみにですが、KDE5 Plasma のミュート画面の中国語翻訳もなかなか面白いミスがございます： KDE5のミュート画面の中国語翻訳、「静音」のはずだが「镜音」になっている。Vocaloidファンのネタだか、単なる入力ミスだか分からない。 pic.twitter.com/ipyHjXMscR — Jiachen YANG (@farseerfc) 2014 12月 8日","tags":"tech","url":"//farseerfc.me/en/../jp/jumping-kde5-plasma-activities-button.html"},{"title":"KDE5 Plasma 之跳動賣萌的活動按鈕","text":"今天嘗試 KDE5 Plasma 的活動的時候無意間發現這個現象。 只要把活動按鈕拖出桌面，它就會在桌面邊緣來回跳動。 視頻如下： Youtube Youku 當然你可以把它再拖回來，所以這個問題還無傷大雅，只是賣萌。 比比之前 Gnome3 那個跳動的界面真是好太多了： Youtube Youku 順便，今天還看到一個賣萌的 KDE5 Plasma 靜音圖標的翻譯： KDE5のミュート画面の中国語翻訳、「静音」のはずだが「镜音」になっている。Vocaloidファンのネタだか、単なる入力ミスだか分からない。 pic.twitter.com/ipyHjXMscR — Jiachen YANG (@farseerfc) 2014 12月 8日","tags":"tech","url":"//farseerfc.me/en/../jumping-kde5-plasma-activities-button.html"},{"title":"KDE5 Plasma 之跳动卖萌的活动按钮","text":"今天尝试 KDE5 Plasma 的活动的时候无意间发现这个现象。 只要把活动按钮拖出桌面，它就会在桌面边缘来回跳动。 视频如下： Youtube Youku 当然你可以把它再拖回来，所以这个问题还无伤大雅，只是卖萌。 比比之前 Gnome3 那个跳动的界面真是好太多了： Youtube Youku 顺便，今天还看到一个卖萌的 KDE5 Plasma 静音图标的翻译： KDE5のミュート画面の中国语翻訳、「静音」のはずだが「镜音」になっている。Vocaloidファンのネタだか、単なる入力ミスだか分からない。 pic.twitter.com/ipyHjXMscR — Jiachen YANG (@farseerfc) 2014 12月 8日","tags":"tech","url":"//farseerfc.me/en/../zhs/jumping-kde5-plasma-activities-button.html"},{"title":"嫁になってくれませんか？","text":"画像はこのように 上のは飾りだけ、遊べるのはこれ： * WASD←→ で移動する，WebGL が必要","tags":"life","url":"//farseerfc.me/en/../jp/marry-me.html"},{"title":"嫁給我好麼","text":"渲染的樣子 可以玩的是下面這個： * 用 WASD←→ 移動，需要 WebGL 支持","tags":"life","url":"//farseerfc.me/en/../marry-me.html"},{"title":"嫁给我好么","text":"渲染的样子 可以玩的是下面这个： * 用 WASD←→ 移动，需要 WebGL 支持","tags":"life","url":"//farseerfc.me/en/../zhs/marry-me.html"},{"title":"MSR 2012 @ ICSE","text":"Mining Software Repository 2012 @ ICSE 今年のMSRを参加しました、会場はチューリッヒ大学にあります。朝早く大学に 着いて、登録するときちょっと事情をありました。スイス人は明らかに中国人 の名前をわからないから、３つの中国からの楊（Yang）の名札を間違えた。そ して堀田先輩の名札に\"Japan, Japan\"になって、日本代表になった。 MSR(MicroSoft Research) talk @ MSR(Mining Software Repositories) まず一番目のKeynoteはマイクロソフトアジア研究院(MicroSoft Research @ Asia ,MSR Asia)のZhang氏が発表する、こうしてMSRがMSRに発表するになった。 Zhangの発表はSoftware AnalysisとXIAOの２つの紹介です。XIAOはマイクロソフト が開発したCode Clone Detector、ある会社が私達に任せるのもこのようなシステム です。もっと詳しく知りたいが、実装に関わるものは言ってなかった。 Towards Improving BTS with Game Mechanisms これの内容は基本的にこのブロクに書いています： http://www.joelonsoftware.com/items/2008/09/15.html 同じ理論をIssue Trackingとかに応用できるかを言いました。個人的にこれは 意味ない気がします。stackoverflowの成功はOpen Software Communityにもと もとある名誉システムを具現化したですから、それを会社の中に応用するのは 難しい気がする。 GHTorrent この研究のスライドはこちらに： http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524 Data exporter for github. Githubの主なデータはコード、それは既にgitから アクセスできます、wikiはgitとして保存しているからそれも含まれている。 ですからこのプロジェクトの目的は他のデータを表せる、つまりissues, commit commentsなど。このプロジェクトはgithub apiを通じて、分布システムとして apiの制限を超える、そしてtorrentの形で歴史をdownloadできます。元のデータ はbsonとしてMongoDBの保存して、Schemaを追加したデータはMySQLに保存する。 わたしの意見では、データをgitのrepoの形で保存するの方がいいかもしれない。 今のwikiのように、そしてgitoliteも全てのデータをgit自身の中に保存している。 The evolution of software 二日目のkeynotes, social mediaをソフトウェア開発に巻き込めるについて 話しました。もしかしてこれはGithubの成功の理論かもしれない。IDEの中に social mediaのアクセスを欲しいと言いました。 Do Faster Releases Imporve Software Quality? Firefoxを例として研究しました。 結論としては、早い発行はbugを多く持たされ、crashがもっと頻繁になるが、 bugの修復も早くなって、そしてユーザー側はもっと早く新しい発行に移動する ことをわかりました。 Security vs Performance Bugs in Firefox 性能に関するbugはregression テストが要る、そして発行を阻止する。 思いつき topicに基づいてcommitの分析と分割 よく使うツール（例えばgit）のユーザーはツールの設計者の意図を従って ツールを使うことはない、設計者が思った用途以外にも使っていることが多い、 それはMiningに対しては色々困難を持たされています。例えばgitには完璧な branch機能がある、通常にgitのユーザーが一つのcommitに一つの機能を実現 してほしい、例としてはbugの修復とか、機能の追加とか。それは難しいなら branchを使って、一連のcommitを一つのbranchになって、一つのbranchに一つ の機能を実現してほしい。それなのに、現状では、沢山の編集を一つのcommit に含まれていて、後の管理とか情報の収集とかが困難になってしまう。 それはユーザーの悪いと思わない、ツールの方がもっと頑張らないとユーザー は正しく使えない。もしcommitの時、自動的にcommitの内容を分析して、 その中にtopicによって分けて、ユーザーに推薦するのをてきたらいいなぁ、 と思っています。このように一つのcommitを多くに分割したら、commitの履歴 をもっと見やすくなって、続いて分析とかも便利になるはずです。 今回に皆使っているslideのシステム タイトルは Incorporating Version Histories in Information Retrieval Based Bug Localization の人が使っているのはbeamerです。数式が多くて、 overlayも多くて，iterateも多い、図だけ少ない、典型的にbeamerに作れそうな スライドです。mindmapの使いもうまい。今日の一日に少なくとも3個のslideは beamerで作られています。 タイトルは Towards Improving Bug Tracking Systems with Game Mechanisms の人はpreziを使いました、図が多くて、transitionも多い。但しスライド としては必要なページ数とかがなくて、このような国際会議の場合にはもっと 工夫をした方がいいかもしれな。 少なくとも六人以上はAppleのKeynoteをつかていまう。Keynoteによる作った スライドはPowerpointのになかなか区別しがたいですが、その中に二人は defaultのthemeを使ったからわかります、他の人はPPTに決してありえない アニメションを使っていますから、多分keynote。 残りは勿論Powerpointです。MSRAの張さんが作ったのはpowerpointなんですけど、 すごくbeamerの感じがします、例えばheaderとfooterの使い方とか、overlay 見たいのものでページのitemを一つずつ展開するとか。それらを全部powerpoint で作るのは相当手間がかかりそうです。 ちなみに言いたいのは一つタイトルは Green Mining: A Methodology of Relating Software Change to Power Consumption のスライドは全部 下手 な手描きの漫画で表せている、火狐のアイコンさえ手描きする、効果は意外に 評判がいい。省エネでグリンで環境にいいで可愛らしい。具体的な効果は下の リンクから見えます、現場で見たのは別のバージョンなんですけど： http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv マイクロソフトは腹黒っ子! まぁ大したニュースではないですけど、MSR2012のMining Challengeのスバンサー はマイクロソフトで、商品はXboxとKinectですけど、今年のチャレンジのテーマは： Mining Android Bug マイクロソフトの殺意を感じしました。","tags":"life","url":"//farseerfc.me/en/../jp/msr2012.html"},{"title":"MSR 2012 @ ICSE","text":"Mining Software Repository 2012 @ ICSE 參加了今年的MSR，會場在University of Zurich。一大早來到大學，註冊有點 小插曲，顯然瑞士人搞不清楚中國人的名字，3個楊（Yang）姓的中國人的名牌 被搞錯了。然後堀田學長的所屬被寫作了\"Japan, Japan\"，成爲了全日本的代表。 MSR(MicroSoft Research) talk @ MSR(Mining Software Repositories) 首先是來自微軟亞洲研究院（MicroSoft Research @ Asia, MSR Asia）的Keynots， 於是就變成了MSR在MSR的演講。MSR的張冬梅（Dongmei Zhang）女士的演講 分爲關於Software Analysis和XIAO的兩部分。XIAO是MSRA開發的Code Clone Detector，似乎我要給井上研做的就是這個。想更多瞭解Xiao的細節，不過張女士 演講結束的時候的鼓掌導致了話筒的小故障。 Towards Improving BTS with Game Mechanisms 感覺這篇的內容基本上就是關於 http://www.joelonsoftware.com/items/2008/09/15.html 這裏寫到的東西，然後說同樣的理論是否可以用於Issue Tracking之類的事情上。 個人感覺這個意義不大，stackoverflow之所以成功是因爲它把開源社區本身就 具有的名譽體系具現化了，本着大家都喜歡被別人奉爲大牛的心態，就如同 wikipedia一樣。同樣的理論如果用於公司內部的Issue Tracking系統上，會得到 完全不同的東西吧。就像MSDN的組織方式雖然和wikipedia是一樣的，但是在MSDN 裏找信息的感覺和在wikipedia完全不一樣。個人不太看好這個方向。 GHTorrent 這篇的slide在這裏可以看到： http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524 Data exporter for github. Github的主要數據，代碼，已經可以通過git接口 獲得了，wiki是git的形式保存的。所以這個項目的目的就是暴露別的數據，主要 是issue tracking，code comments，這種。代碼訪問github api，然後用分佈式 實現以克服api的限制，然後提供torrents形式的history下載。github api獲得 的json數據以bson的形式保存在MongoDB裏，解析過的有了Schema之後的數據保存 在MySQL裏並可以導出SQL。 個人的想法，覺得數據如果能夠更統一，全部存在Git裏或許更好，像Wiki一樣。 同樣是要暴露全部歷史記錄的目的，用Torrent自己實現的歷史遠不如用Git的 接口實現的歷史記錄方便吧，git blame之類的也更方便追蹤code comment之類的 作者信息。當然對git的raw date直接讀寫，需要對git的內部原理有足夠的理解， 或許只有github的人有這種能力了。 Topic Mining 用得兩個參數， DE 和 AIC，完全不能理解，過後研究。實驗針對了Firefox, Mylyn, Eclipse三個軟件。試圖從Repo中分析源代碼的identifier和comments， 找到topic和bug之間的關係，比如怎樣的topic更容易導致bug。得出的結論似乎 也很曖昧，只是說核心功能被報告的bug更多，但是不知道原因。這只能表示核心 功能受到更多關注和更多測試吧，並不能說明核心功能就容易產生bug。 不過這個的Slide做得很漂亮，很容易理解。 SeCold A linked data platform for mining software repositories 沒聽懂這個項目的目的。 The evolution of software 第二天的Keynotes，關於將Social Media和Software Development相結合的想法。 或許就是Github賴以成功的基礎。講到代碼中的comment, Tags, uBlog, blog之類 的social的特性和IDE的融合的趨勢。 Do Faster Releases Imporve Software Quality? 使用Firefox作爲例子。 結論是快速發佈導致bug更多，更容易crash，但是bug更快得到修復，並且用戶 更快轉向新的發佈。 Security vs Performance Bugs in Firefox Performance bugs are regression, blocks release. 一些感想 基於自然語義分析的commit分割 經常工具（比如git）的使用者並沒有按照工具設計者的意圖使用工具，這給MSR 帶來很多困難。舉個例子，git有非常完美的branch系統，通常期望git的使用者 能夠在一次commit裏commit一個功能，比如一個bug的修復，或者一個feature的 添加，但是事實上經常有很多邏輯上的commit被合併在一個裏面了。 或許這不是使用者的錯，而是工具仍然不夠人性的表現。或許我們可以自動把 一次的commit按照語義分割成多個。 分割之後，可以更容易地把issue和commit關聯，也更容易組織更多的研究。 關於這次發表中大家用的slides系統 題目爲``Incorporating Version Histories in Information Retrieval Based Bug Localization''的人用的slide是beamer的。公式很多，overlay很多，列表 很多，圖片很少，典型的beamer做出的slide。思維導圖用得很不錯。今天一天 有至少3個slide是用beamer做的。 題目爲``Towards Improving Bug Tracking Systems with Game Mechanisms'' 的人用了prezi，圖片很多，過度很多。但是比如沒有頁號沒有頁眉頁腳，正式 會議的場合不太方便。 至少有六個以上用了Apple Keynotes，Keynotes做出來的東西真的和Powerpoint 做出來的很難區別，其中兩個人用了初始的主題所以才看出來。 剩下的自然是PPT。MSRA的張女士做的雖然是PPT，倒是有很多beamer的感覺， 比如頁眉頁腳和overlay的用法。這些如果都是PPT做出來的，會多很多額外的 人力吧。 值得一提的是有一個題目爲``Green Mining: A Methodology of Relating Software Change to Power Consumption''的人的slide全是``劣質''的手繪漫畫， 效果意外地好，很低碳很環保很綠色很可愛。具體效果可以參考下面的動畫，雖然 現場看到的不是一個版本： http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv 微軟是個腹黑娘！ 嘛雖然這也不是什麼新聞了。MSR2012的Mining Challenge的贊助商是微軟，管理 組織者來自微軟研究院，獎品是Xbox和Kinect。然後今年的題目是： Mining Android Bug 我看到了微軟滿滿的怨氣……","tags":"life","url":"//farseerfc.me/en/../msr2012.html"},{"title":"MSR 2012 @ ICSE","text":"Mining Software Repository 2012 @ ICSE 参加了今年的MSR，会场在University of Zurich。一大早来到大学，注册有点 小插曲，显然瑞士人搞不清楚中国人的名字，3个杨（Yang）姓的中国人的名牌 被搞错了。然后堀田学长的所属被写作了\"Japan, Japan\"，成为了全日本的代表。 MSR(MicroSoft Research) talk @ MSR(Mining Software Repositories) 首先是来自微软亚洲研究院（MicroSoft Research @ Asia, MSR Asia）的Keynots， 于是就变成了MSR在MSR的演讲。MSR的张冬梅（Dongmei Zhang）女士的演讲 分为关于Software Analysis和XIAO的两部分。XIAO是MSRA开发的Code Clone Detector，似乎我要给井上研做的就是这个。想更多了解Xiao的细节，不过张女士 演讲结束的时候的鼓掌导致了话筒的小故障。 Towards Improving BTS with Game Mechanisms 感觉这篇的内容基本上就是关于 http://www.joelonsoftware.com/items/2008/09/15.html 这里写到的东西，然后说同样的理论是否可以用于Issue Tracking之类的事情上。 个人感觉这个意义不大，stackoverflow之所以成功是因为它把开源社区本身就 具有的名誉体系具现化了，本着大家都喜欢被别人奉为大牛的心态，就如同 wikipedia一样。同样的理论如果用于公司内部的Issue Tracking系统上，会得到 完全不同的东西吧。就像MSDN的组织方式虽然和wikipedia是一样的，但是在MSDN 里找信息的感觉和在wikipedia完全不一样。个人不太看好这个方向。 GHTorrent 这篇的slide在这里可以看到： http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524 Data exporter for github. Github的主要数据，代码，已经可以通过git接口 获得了，wiki是git的形式保存的。所以这个项目的目的就是暴露别的数据，主要 是issue tracking，code comments，这种。代码访问github api，然后用分布式 实现以克服api的限制，然后提供torrents形式的history下载。github api获得 的json数据以bson的形式保存在MongoDB里，解析过的有了Schema之后的数据保存 在MySQL里并可以导出SQL。 个人的想法，觉得数据如果能够更统一，全部存在Git里或许更好，像Wiki一样。 同样是要暴露全部历史记录的目的，用Torrent自己实现的历史远不如用Git的 接口实现的历史记录方便吧，git blame之类的也更方便追踪code comment之类的 作者信息。当然对git的raw date直接读写，需要对git的内部原理有足够的理解， 或许只有github的人有这种能力了。 Topic Mining 用得两个参数， DE 和 AIC，完全不能理解，过后研究。实验针对了Firefox, Mylyn, Eclipse三个软件。试图从Repo中分析源代码的identifier和comments， 找到topic和bug之间的关系，比如怎样的topic更容易导致bug。得出的结论似乎 也很暧昧，只是说核心功能被报告的bug更多，但是不知道原因。这只能表示核心 功能受到更多关注和更多测试吧，并不能说明核心功能就容易产生bug。 不过这个的Slide做得很漂亮，很容易理解。 SeCold A linked data platform for mining software repositories 没听懂这个项目的目的。 The evolution of software 第二天的Keynotes，关于将Social Media和Software Development相结合的想法。 或许就是Github赖以成功的基础。讲到代码中的comment, Tags, uBlog, blog之类 的social的特性和IDE的融合的趋势。 Do Faster Releases Imporve Software Quality? 使用Firefox作为例子。 结论是快速发布导致bug更多，更容易crash，但是bug更快得到修复，并且用户 更快转向新的发布。 Security vs Performance Bugs in Firefox Performance bugs are regression, blocks release. 一些感想 基于自然语义分析的commit分割 经常工具（比如git）的使用者并没有按照工具设计者的意图使用工具，这给MSR 带来很多困难。举个例子，git有非常完美的branch系统，通常期望git的使用者 能够在一次commit里commit一个功能，比如一个bug的修复，或者一个feature的 添加，但是事实上经常有很多逻辑上的commit被合并在一个里面了。 或许这不是使用者的错，而是工具仍然不够人性的表现。或许我们可以自动把 一次的commit按照语义分割成多个。 分割之后，可以更容易地把issue和commit关联，也更容易组织更多的研究。 关于这次发表中大家用的slides系统 题目为``Incorporating Version Histories in Information Retrieval Based Bug Localization''的人用的slide是beamer的。公式很多，overlay很多，列表 很多，图片很少，典型的beamer做出的slide。思维导图用得很不错。今天一天 有至少3个slide是用beamer做的。 题目为``Towards Improving Bug Tracking Systems with Game Mechanisms'' 的人用了prezi，图片很多，过度很多。但是比如没有页号没有页眉页脚，正式 会议的场合不太方便。 至少有六个以上用了Apple Keynotes，Keynotes做出来的东西真的和Powerpoint 做出来的很难区别，其中两个人用了初始的主题所以才看出来。 剩下的自然是PPT。MSRA的张女士做的虽然是PPT，倒是有很多beamer的感觉， 比如页眉页脚和overlay的用法。这些如果都是PPT做出来的，会多很多额外的 人力吧。 值得一提的是有一个题目为``Green Mining: A Methodology of Relating Software Change to Power Consumption''的人的slide全是``劣质''的手绘漫画， 效果意外地好，很低碳很环保很绿色很可爱。具体效果可以参考下面的动画，虽然 现场看到的不是一个版本： http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv 微软是个腹黑娘！ 嘛虽然这也不是什么新闻了。MSR2012的Mining Challenge的赞助商是微软，管理 组织者来自微软研究院，奖品是Xbox和Kinect。然后今年的题目是： Mining Android Bug 我看到了微软满满的怨气……","tags":"life","url":"//farseerfc.me/en/../zhs/msr2012.html"},{"title":"PyRuby","text":"きょう、Githubに PyRuby というプロジェクトを見ました。それの説明にこう書いています: PyRuby - Some Ruby for your Python! PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful. Usage All you have to do is import the ruby module: import ruby From now on you should be able to write Ruby code within a regular Python module. An example: 1.upto(10) { |n| puts n } さらに、 PyPI にそれのパッケージもあった。 最初に、これはもう一つのPyPyで実現したRubyだと思った。少なくとも、本当のRubyをPythonから呼び出すの何かの魔法も可能かもしれない。 それのソースコートはこうなっています。 ruby.py # -*- coding: utf-8 -*- print ( \"\"\" `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:` .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms. `:ohmdys+//::/::--::::////:-.```......`````.://:-` `/dNs. .+hNds:`-:-:///::------::///++///:--....--::///::-`.///. `oMm/ /hNmo.` `` `....``````````` ...------:::-:/+/-.:/:` /NMs oMd/` `::::--.---://+` //` `````-:::::+/-`::.` :NM+ yN` -+.` `/` o. ``::.-:. `` :NN: :Nm - ./ : `.-://///:-. `-` `` :NN- /NM/ .-:::-.` `/ `:sdmdhyMMMMMMNNmy/` :mNo` :hMd: /dmddddNNmdy+-. `smmy/-```hMMMMMMMhydm/ `-.`` `...:mMm+. -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+- dMN-`-+hmmmmdhhhhdddmMN-`-/o: .-::::/oydms- oNMo:+/::. ``...--:/+ohNMNhs- :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms. .MMo:/`o:.:+sso+:-` sM+ ./-` /mNh+-....-/ymNNdo::--/shd+` -`:mm: /MM-o ./ ohhsooohNmy::sh. `yM/ `:oyyyyyyhys+:.` hy `/Nh` : -NN. -MM// -: `` y: odddhh+ -omNh- `--.` `` ```` .:ohMMs. +Ms / yMo hMoo .+. :Mh ```` `/hNd/.` ohdddy::...`..` `-/sdmdyo+NMNh+- :Mh / sMs .mmh:..:. :NMm `-/dMNM+ ./+++/:`.hM:`.````.` `-/shmNmh+-` /Mmooso.hM/ .: `mM/ .mNs://: .NMNMs- -:-.`/+-sms. ` `shyyyhy`sNd` `.:+sdmmmdMM-. .oNM+ :m/ `s``yMh -mMo . sMNdMNNh+-. .ydyoyy` ``+o::+shdddhs+:-.:MM.`.-+hNMMh- `.`-/::dNs` -NM- mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.` `/mMMdmmddNMm+` ..-/hNh- sMy NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs `..:+ymMMMMd+--yNh. `+hNh: -Mm NMMM/yMh -NM-`..--:NMo:--.`+My :MNoydmNMMNmhdMh` -dNs` `yMd: `MN mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/ yMy` MN yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-. `yMMNs. /My `MN :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM- ./hNNy- /Nd` -Mh dMydMmsNMNdNNMMmmmNMMMdddhys+yMo`` /Nm: `:yNNdo. .sNd. +Ms .mMsMN::NN:.:MN: `.+NM. +Mo +Mm+ymNdo- .omm+` yM: .hNMd+:sMN. oMm. oMo +Mh ```.:+shMNmy+-``.-:-..-//-`:yNmo` mM. :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/` .Mm `` .-:/+osyyhhddddddddddhhyysoo+/:-. `./+//--+oo/--+ymmy/. :Mh .: `+:` `.------------` ```-////:/++/:../ydNdo:` +Ms `/` :+o+:-``` ``..-::///++///:-.`-+ydNdo:` oMs :/:.`` `..---.``` ````````..-:/:::---.` `-ohmmh+:` /Mh .://///:::-----.-----.......` `-+hmmy+- sMy` ``````-+ydmy+- /mNs-` `./ohmNMNNNmy+- /yNmho/:.``````````.-:/+syhdNmdyso+/-.` `:+ydmNMNNNNNNNNNmdhys+/:.` ``.....` LOL U MAD? \"\"\" ) import sys sys . exit ( 1 ) 本当だ、Pythonの中にRubyを呼び出すという考えはアホだ。","tags":"tech","url":"//farseerfc.me/en/../jp/mix-ruby.html"},{"title":"PyRuby","text":"今天在GitHub上閒逛的時候看到一個叫做 PyRuby 的項目。項目的Readme說得很好： PyRuby - Some Ruby for your Python! PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful. Usage All you have to do is import the ruby module: import ruby From now on you should be able to write Ruby code within a regular Python module. An example: 1.upto(10) { |n| puts n } 甚至 PyPI 上還有這個項目的包。 一開始我還以爲這又是一個野心勃勃的基於PyPy的Ruby實現，或者某種trick在Python裏面直接調用Ruby解釋器。 然後我想看看這個的源代碼 只有一個ruby.py文件，內容是： # -*- coding: utf-8 -*- print ( \"\"\" `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:` .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms. `:ohmdys+//::/::--::::////:-.```......`````.://:-` `/dNs. .+hNds:`-:-:///::------::///++///:--....--::///::-`.///. `oMm/ /hNmo.` `` `....``````````` ...------:::-:/+/-.:/:` /NMs oMd/` `::::--.---://+` //` `````-:::::+/-`::.` :NM+ yN` -+.` `/` o. ``::.-:. `` :NN: :Nm - ./ : `.-://///:-. `-` `` :NN- /NM/ .-:::-.` `/ `:sdmdhyMMMMMMNNmy/` :mNo` :hMd: /dmddddNNmdy+-. `smmy/-```hMMMMMMMhydm/ `-.`` `...:mMm+. -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+- dMN-`-+hmmmmdhhhhdddmMN-`-/o: .-::::/oydms- oNMo:+/::. ``...--:/+ohNMNhs- :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms. .MMo:/`o:.:+sso+:-` sM+ ./-` /mNh+-....-/ymNNdo::--/shd+` -`:mm: /MM-o ./ ohhsooohNmy::sh. `yM/ `:oyyyyyyhys+:.` hy `/Nh` : -NN. -MM// -: `` y: odddhh+ -omNh- `--.` `` ```` .:ohMMs. +Ms / yMo hMoo .+. :Mh ```` `/hNd/.` ohdddy::...`..` `-/sdmdyo+NMNh+- :Mh / sMs .mmh:..:. :NMm `-/dMNM+ ./+++/:`.hM:`.````.` `-/shmNmh+-` /Mmooso.hM/ .: `mM/ .mNs://: .NMNMs- -:-.`/+-sms. ` `shyyyhy`sNd` `.:+sdmmmdMM-. .oNM+ :m/ `s``yMh -mMo . sMNdMNNh+-. .ydyoyy` ``+o::+shdddhs+:-.:MM.`.-+hNMMh- `.`-/::dNs` -NM- mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.` `/mMMdmmddNMm+` ..-/hNh- sMy NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs `..:+ymMMMMd+--yNh. `+hNh: -Mm NMMM/yMh -NM-`..--:NMo:--.`+My :MNoydmNMMNmhdMh` -dNs` `yMd: `MN mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/ yMy` MN yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-. `yMMNs. /My `MN :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM- ./hNNy- /Nd` -Mh dMydMmsNMNdNNMMmmmNMMMdddhys+yMo`` /Nm: `:yNNdo. .sNd. +Ms .mMsMN::NN:.:MN: `.+NM. +Mo +Mm+ymNdo- .omm+` yM: .hNMd+:sMN. oMm. oMo +Mh ```.:+shMNmy+-``.-:-..-//-`:yNmo` mM. :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/` .Mm `` .-:/+osyyhhddddddddddhhyysoo+/:-. `./+//--+oo/--+ymmy/. :Mh .: `+:` `.------------` ```-////:/++/:../ydNdo:` +Ms `/` :+o+:-``` ``..-::///++///:-.`-+ydNdo:` oMs :/:.`` `..---.``` ````````..-:/:::---.` `-ohmmh+:` /Mh .://///:::-----.-----.......` `-+hmmy+- sMy` ``````-+ydmy+- /mNs-` `./ohmNMNNNmy+- /yNmho/:.``````````.-:/+syhdNmdyso+/-.` `:+ydmNMNNNNNNNNNmdhys+/:.` ``.....` LOL U MAD? \"\"\" ) import sys sys . exit ( 1 ) 是的……的確……這種嘗試把Python和Ruby放在一起的想法絕對是瘋了……","tags":"tech","url":"//farseerfc.me/en/../mix-ruby.html"},{"title":"PyRuby","text":"今天在GitHub上闲逛的时候看到一个叫做 PyRuby 的项目。项目的Readme说得很好： PyRuby - Some Ruby for your Python! PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful. Usage All you have to do is import the ruby module: import ruby From now on you should be able to write Ruby code within a regular Python module. An example: 1.upto(10) { |n| puts n } 甚至 PyPI 上还有这个项目的包。 一开始我还以为这又是一个野心勃勃的基于PyPy的Ruby实现，或者某种trick在Python里面直接调用Ruby解释器。 然后我想看看这个的源代码 只有一个ruby.py文件，内容是： # -*- coding: utf-8 -*- print ( \"\"\" `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:` .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms. `:ohmdys+//::/::--::::////:-.```......`````.://:-` `/dNs. .+hNds:`-:-:///::------::///++///:--....--::///::-`.///. `oMm/ /hNmo.` `` `....``````````` ...------:::-:/+/-.:/:` /NMs oMd/` `::::--.---://+` //` `````-:::::+/-`::.` :NM+ yN` -+.` `/` o. ``::.-:. `` :NN: :Nm - ./ : `.-://///:-. `-` `` :NN- /NM/ .-:::-.` `/ `:sdmdhyMMMMMMNNmy/` :mNo` :hMd: /dmddddNNmdy+-. `smmy/-```hMMMMMMMhydm/ `-.`` `...:mMm+. -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+- dMN-`-+hmmmmdhhhhdddmMN-`-/o: .-::::/oydms- oNMo:+/::. ``...--:/+ohNMNhs- :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms. .MMo:/`o:.:+sso+:-` sM+ ./-` /mNh+-....-/ymNNdo::--/shd+` -`:mm: /MM-o ./ ohhsooohNmy::sh. `yM/ `:oyyyyyyhys+:.` hy `/Nh` : -NN. -MM// -: `` y: odddhh+ -omNh- `--.` `` ```` .:ohMMs. +Ms / yMo hMoo .+. :Mh ```` `/hNd/.` ohdddy::...`..` `-/sdmdyo+NMNh+- :Mh / sMs .mmh:..:. :NMm `-/dMNM+ ./+++/:`.hM:`.````.` `-/shmNmh+-` /Mmooso.hM/ .: `mM/ .mNs://: .NMNMs- -:-.`/+-sms. ` `shyyyhy`sNd` `.:+sdmmmdMM-. .oNM+ :m/ `s``yMh -mMo . sMNdMNNh+-. .ydyoyy` ``+o::+shdddhs+:-.:MM.`.-+hNMMh- `.`-/::dNs` -NM- mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.` `/mMMdmmddNMm+` ..-/hNh- sMy NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs `..:+ymMMMMd+--yNh. `+hNh: -Mm NMMM/yMh -NM-`..--:NMo:--.`+My :MNoydmNMMNmhdMh` -dNs` `yMd: `MN mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/ yMy` MN yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-. `yMMNs. /My `MN :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM- ./hNNy- /Nd` -Mh dMydMmsNMNdNNMMmmmNMMMdddhys+yMo`` /Nm: `:yNNdo. .sNd. +Ms .mMsMN::NN:.:MN: `.+NM. +Mo +Mm+ymNdo- .omm+` yM: .hNMd+:sMN. oMm. oMo +Mh ```.:+shMNmy+-``.-:-..-//-`:yNmo` mM. :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/` .Mm `` .-:/+osyyhhddddddddddhhyysoo+/:-. `./+//--+oo/--+ymmy/. :Mh .: `+:` `.------------` ```-////:/++/:../ydNdo:` +Ms `/` :+o+:-``` ``..-::///++///:-.`-+ydNdo:` oMs :/:.`` `..---.``` ````````..-:/:::---.` `-ohmmh+:` /Mh .://///:::-----.-----.......` `-+hmmy+- sMy` ``````-+ydmy+- /mNs-` `./ohmNMNNNmy+- /yNmho/:.``````````.-:/+syhdNmdyso+/-.` `:+ydmNMNNNNNNNNNmdhys+/:.` ``.....` LOL U MAD? \"\"\" ) import sys sys . exit ( 1 ) 是的……的确……这种尝试把Python和Ruby放在一起的想法绝对是疯了……","tags":"tech","url":"//farseerfc.me/en/../zhs/mix-ruby.html"},{"title":"關於C++模板的類型轉換的討論","text":"這兩天在飲水思源的C板，關於C++模板的類型轉換的一個討論，後面是我的解答。 討論地址 http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html 原問題 今天在書上看到模板演繹的時候可以允許cast-down，於是我寫了個東西： template < bool _Test , class _Type = void > struct enable_if { }; template < class _Type > struct enable_if < true , _Type > { typedef _Type type ; }; class A { }; class B : A { }; template < typename T > struct traits { static int const value = false ; }; template <> struct traits < A > { static int const value = true ; }; template < typename T > void f ( T , typename enable_if < traits < T >:: value >:: type * = 0 ) { } template <> void f < A > ( A , enable_if < traits < A >:: value >:: type * ) { } template < typename T > class BB {}; template < typename T > class DD : public BB < T > {}; template < typename T > void ff ( BB < T > ) {}; int main ( int argc , char * argv []) { A a ; B b ; DD < long > dd ; //f(b); ff ( dd ); } 奇怪的是重載決議的時候， f 的情況下它就不讓我特化的 f<A> 進來。 但是在 ff 的情況下， ff<BB<long>> 卻進來了。 在VC10和GCC3.4下測試 我的解答 我們來設身處地地作爲編譯器，看一遍到底發生了什麼。 約定符號 # : A#B 是把 B 帶入 A<T> 的參數 T 之後實例化得到的結果。 首先看ff的情況。 DD < long > dd ; 處理到這句的時候，編譯器看到了 DD<long> 的實例化，於是去實例化 DD#long ，繼而實例 化了 BB#long 。 ff ( dd ); 這句，首先計算重載函數集合。 第一步，需要從參數 DD#long -> BB<T> 推斷 ff<T> 的 T 。根據函數模板參數推斷規則： :code:`class_template_name<T>` 類型的參數，可以用於推斷 :code:`T` 。 於是編譯器推斷 T 爲 long 。這裏就算不是 BB 而是完全無關的 CC 都可以推斷成功，只要 CC 也 是一個 CC<T> 形式的模板。 第二步，模板特化匹配。因爲只有一個模板，所以匹配了最泛化的 ff<T> 。 第三步，模板實例化。 推斷了 long -> T 之後，編譯器實例化 ff#long 。 重載函數集合： {ff#long} 然後重載抉擇找到唯一的可匹配的實例 ff#long ，檢查實際參數 DD#long 可以隱式轉換到 形式參數 BB#long ，從而生成了這次函數調用。 再來看f的情況。 f ( b ); 計算候選重載函數集合。 第一步，對所有 f 模板推斷實參。根據函數模板參數推斷規則： 帶有 :code:`T` 類型的參數，可以用於推斷 :code:`T` 。 於是 B -> T 被推斷出來了。 第二步，模板特化匹配。 這裏 B 不是 A ，所以不能用 f<A> 特化，只能用 f<T> 模板。 第三步，模板實例化。 B 帶入 f<T> 實例化成 f#B 的過程中，實例化 traits#B 。 由於沒有針對 B 的特化，所以用 traits<T> 模板， traits#B::value=false ，進而 enable_if#false 沒有 type ，出錯。 唯一的模板匹配出錯，重載函數集合爲空，SFINAE原則不能找到合適的匹配，於是報錯。","tags":"tech","url":"//farseerfc.me/en/../discuss-cpp-template-downcast.html"},{"title":"关于C++模板的类型转换的讨论","text":"这两天在饮水思源的C板，关于C++模板的类型转换的一个讨论，后面是我的解答。 讨论地址 http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html 原问题 今天在书上看到模板演绎的时候可以允许cast-down，于是我写了个东西： template < bool _Test , class _Type = void > struct enable_if { }; template < class _Type > struct enable_if < true , _Type > { typedef _Type type ; }; class A { }; class B : A { }; template < typename T > struct traits { static int const value = false ; }; template <> struct traits < A > { static int const value = true ; }; template < typename T > void f ( T , typename enable_if < traits < T >:: value >:: type * = 0 ) { } template <> void f < A > ( A , enable_if < traits < A >:: value >:: type * ) { } template < typename T > class BB {}; template < typename T > class DD : public BB < T > {}; template < typename T > void ff ( BB < T > ) {}; int main ( int argc , char * argv []) { A a ; B b ; DD < long > dd ; //f(b); ff ( dd ); } 奇怪的是重载决议的时候， f 的情况下它就不让我特化的 f<A> 进来。 但是在 ff 的情况下， ff<BB<long>> 却进来了。 在VC10和GCC3.4下测试 我的解答 我们来设身处地地作为编译器，看一遍到底发生了什么。 约定符号 # : A#B 是把 B 带入 A<T> 的参数 T 之后实例化得到的结果。 首先看ff的情况。 DD < long > dd ; 处理到这句的时候，编译器看到了 DD<long> 的实例化，于是去实例化 DD#long ，继而实例 化了 BB#long 。 ff ( dd ); 这句，首先计算重载函数集合。 第一步，需要从参数 DD#long -> BB<T> 推断 ff<T> 的 T 。根据函数模板参数推断规则： :code:`class_template_name<T>` 类型的参数，可以用于推断 :code:`T` 。 于是编译器推断 T 为 long 。这里就算不是 BB 而是完全无关的 CC 都可以推断成功，只要 CC 也 是一个 CC<T> 形式的模板。 第二步，模板特化匹配。因为只有一个模板，所以匹配了最泛化的 ff<T> 。 第三步，模板实例化。 推断了 long -> T 之后，编译器实例化 ff#long 。 重载函数集合： {ff#long} 然后重载抉择找到唯一的可匹配的实例 ff#long ，检查实际参数 DD#long 可以隐式转换到 形式参数 BB#long ，从而生成了这次函数调用。 再来看f的情况。 f ( b ); 计算候选重载函数集合。 第一步，对所有 f 模板推断实参。根据函数模板参数推断规则： 带有 :code:`T` 类型的参数，可以用于推断 :code:`T` 。 于是 B -> T 被推断出来了。 第二步，模板特化匹配。 这里 B 不是 A ，所以不能用 f<A> 特化，只能用 f<T> 模板。 第三步，模板实例化。 B 带入 f<T> 实例化成 f#B 的过程中，实例化 traits#B 。 由于没有针对 B 的特化，所以用 traits<T> 模板， traits#B::value=false ，进而 enable_if#false 没有 type ，出错。 唯一的模板匹配出错，重载函数集合为空，SFINAE原则不能找到合适的匹配，于是报错。","tags":"tech","url":"//farseerfc.me/en/../zhs/discuss-cpp-template-downcast.html"},{"title":"Pelicanを試してみた","text":"一日の間に全ての ギーク たち が 自分の Githubユーザーページ と Octopress ブログを導入したような気がします。皆がブログに書いた通りに、静的ブログは確かに WordPress などの従来の動的ブログ・エンジンより便利だと思います。これらブログを見ると、私も自分の Octopress ブログを立ちましょう とずっと思っています。 ですが Octopress は私に向いてないかも 初めのところに Octopressの配置手順 に迷わされた。 RVM とはなに？ rbenv とは何のこと？見るところ Ruby コミュニティーの発展するハイペースは既に私の想像に超えましたみたい。 彼らは Ruby の各バージョン間に互換性を持つために、バージョン管理が必要らしいです。同様の互換性問題が Python コミュニティーにもある ですが [1] 、 Python は今のところこのようなバージョン管理の必要がないと思います [2] 。 実際に迷惑したのは、私は今自由に持って遊べる Linux 環境が持っていないということ（ほしいなぁ……）。 ですが RVM それとも rbenv 両方も Unix/Linux/MacOSX しか実行できないらしいです。ギークとしたの皆は絶対に Windows つかっじゃいけないんですか？（本当かも……）。 残りは Ruby と Python の争いです。私は Markdown に詳しくない、比べると ReST のほうが私に向いています。それに、どっちでも Pygments を依存しシンタックス・ハイライトをしているから、 Rubyist 達も少なくとも Python を入れなきゃダメみたいです。 私の好みは一切の Ruby コンポーネントを頼らず、 C 拡張もない純粋な Python の実現がほしいです。 そこから Github に Python で実現した静的ブログ・エンジンを探し始めた。 Flask の作者である mitsuhiko 氏が書いた rstblog が素晴らしいが、あんまり他人に使われていないようです。 Hyde は多く使われているけれと、ホームページにブログの感じがみえないです。最後に Pelican を見かけました。 [1] 例えば Python 2.x と 3.x の間にあまりにも巨大なる差、それと PyPy 、 CPython 、 Stackless 、 Cython など各実現間に微妙な違いがあります。 [2] はい、こっちに easy_install とか pip があります、ですがそれらはパッケージ管理、特定なPython環境を入れた後の話です。Python自身はまだ管理する必要がないです。 Python のバージョン問題も 2to3.py とか 3to2.py のようなツールで変換すればいいです、違うソフトを実行するためたくさんの Python バージョンを残る必要はないです。もしバージョンの違いが気にするなら virtualenv を使うのも構わないが、それも別のことです。 それでは Pelican にしよう 私自身にとって、 Pelican は Octopress よりいいところ： 純粋な Python で実現した。ですから CPython のほかべつの実現を使うのも心配がない。例えばわたしは PyPy を使ています。 多言語。 Pelican の原作者はフランス人らしいです。ほとんどの人はこれの必要がないと思うが……できるだけ、わたしは三つの言語で書く。 ReST 。それなら Leo の @auto-rst を使って直接 ReST をかけます。 でも Pelican は Octopress のほど注目されていないから、一部問題があります。 pelican-import は WordPress から導入する時、日本語や中国語は問題となります。 多言語の機能と日付、タイムゾーンなどにバグがある。 私は改善しています。 テンプレートは少ない。 プラグインも少ない…… こんなに優れたツールにもっと注目されてほしい。 配置 Pelican を入れるのは簡単： $ pip install pelican 文章を ReST で書いて、 posts フォルダーに置きます。ページを生成する： $ pelican -s settings.py Github に送る: $ git commit -am \"Commit message\" $ git push 私の配置ファイル： # -*- coding: utf-8 -*- TIMEZONE = 'Asia/Tokyo' DATE_FORMATS = { 'en' :( 'usa' , ' %a , %d %b %Y' ), 'zh' :( 'chs' , '%Y-%m- %d , %a ' ), 'jp' :( 'jpn' , '%Y年%m月 %d 日( %a )' ), } # windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx LOCALE = [ 'usa' , 'chs' , 'jpn' , # windows 'en_US' , 'zh_CN' , 'ja_JP' ] # Unix/Linux DEFAULT_LANG = 'zh' SITENAME = 'Farseerfc Blog' AUTHOR = 'Jiachen Yang' DISQUS_SITENAME = 'farseerfcgithub' GITHUB_URL = 'https://github.com/farseerfc' SITEURL = 'http://farseerfc.github.com' TAG_FEED = 'feeds/ %s .atom.xml' SOCIAL = (( 'twitter' , 'http://twitter.com/farseerfc' ), ( 'github' , 'https://github.com/farseerfc' ), ( 'facebook' , 'http://www.facebook.com/farseerfc' ), ( 'weibo' , 'http://weibo.com/farseerfc' ), ( 'renren' , 'http://www.renren.com/farseer' ), ) TWITTER_USERNAME = 'farseerfc' THEME = 'notmyidea' CSS_FILE = \"wide.css\" DEFAULT_CATEGORY = 'Others' OUTPUT_PATH = '.' PATH = 'posts'","tags":"tech","url":"//farseerfc.me/en/../jp/try-pelican.html"},{"title":"嘗試一下 Pelican","text":"似乎一夜之間所有的 極客們 都 有了 自己 的 Github主頁 和 Octopress 博客。就像所有人在他們的博客中指出的，靜態博客的確比傳統的WordPress方式具有更多優勢。 自從看到這些 我就一直在想着自己搭一個 Octopress 。 但是似乎 Octopress 不適合我 一上手就被 Octopress的搭建步驟 煩到了。 RVM 是什麼？ rbenv 又是什麼？ 看來 Ruby 社區的快節奏發展已經超過了我的想象，他們似乎需要一套發行版管理器來調和不同版本之間的 Ruby 的兼容性問題。 雖然同樣的兼容性問題在 Python 社區也有 [1] ，不過總覺得 Python 至少還沒到需要一個發行版管理器的程度 [2] 。 真正的問題是我手上還沒有一個可以讓我隨便玩的 Linux 環境（真的想要……）。 而無論是 RVM 還是 rbenv 似乎都只支持 Unix/Linux/MacOSX 。 身爲極客就註定不能用 Windows 麼？（或許是的……）。 剩下的問題就是 Ruby 和 Python 兩大陣營的對立問題了。我不熟悉 Markdown ， 相對來說比較喜歡 ReST 。 似乎無論哪邊都要 依賴 Pygments 作爲代碼着色器，那麼其實 Rubyist 也至少需要安裝 Python 。 我傾向於不依賴任何 Ruby 組件，最好沒有 C 擴展 的純 Python 實現。 於是我開始在 Github 上找 Python 的靜態博客引擎。 Flask 的作者 mitsuhiko 寫的 rstblog 看起來不錯，不過似乎沒有多少人在用。 Hyde 似乎很完善，不過默認的標記語言是 MarkDown ， 又依賴於幾個 Ruby 組建，而且官方網站的設計實在太前衛。 最終我看到了 Pelican 。 [1] 比如 Python 2.x 與 3.x 之間看似難以跨越的鴻溝，以及 PyPy 、 CPython 、 Stackless 、 Cython 等各個實現之間的微妙差別。 [2] 是的，我們有 easy_install ，我們有 pip ， 不過這些都是包管理器，都是裝好特定的Python實現之後的事情。 Python實現本身還不需要包管理器來管理。 Python 的版本問題基本上也只需要 2to3.py 和 3to2.py 這樣的輕量級轉換器就可以了，你不需要爲了安裝多個軟件而在硬盤裏留下多個不同版本的 Python 。 如果爲了引用的穩定性，你可以用 virtualenv ，不過這又是另一回事情了。 那麼就 Pelican 吧 對我而言， Pelican 相比於 Octopress 有幾個好處： 純 Python 實現。 這意味着我可以換用任何 Python 解釋器而不必擔心兼容性問題。比如我就換成了 PyPy 。 多語言支持。因爲 Pelican 的作者似乎是個法國人。不過這個似乎大部分人不需要…… 我是想儘量把一篇博客寫成三種語言作爲鍛鍊吧。 ReST 。這樣我就可以用 Leo 的 @auto-rst 直接寫 ReST了。簡單方便快捷有效。 不過似乎 Pelican 的關注度不如 Octopress 那麼高，現在一些部分還有細微的問題： pelican-import 從 WordPress 導入的時候對中文、日文的支持似乎很成問題。 日期格式、時區、字符集、和多語言功能的結合度還不夠。 我在嘗試改善它。 模板還不夠豐富。 插件也不夠多…… 希望這麼優秀的工具能夠受到更多關注，以上這些問題都是增加關注度之後很快就能解決的問題。 我的設置 settings.py 安裝 Pelican 很容易，一句話就夠了： $ pip install pelican 然後把文章寫成ReST的格式，放在`pages`文件夾裏面。(重新)生成只要： $ pelican -s settings.py 上傳到 Github: $ git commit -am \"Commit message\" $ git push 就這麼簡單。附上我的配置文件： # -*- coding: utf-8 -*- TIMEZONE = 'Asia/Tokyo' DATE_FORMATS = { 'en' :( 'usa' , ' %a , %d %b %Y' ), 'zh' :( 'chs' , '%Y-%m- %d , %a ' ), 'jp' :( 'jpn' , '%Y/%m/ %d ( %a )' ), } # windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx LOCALE = [ 'usa' , 'chs' , 'jpn' , # windows 'en_US' , 'zh_CN' , 'ja_JP' ] # Unix/Linux DEFAULT_LANG = 'zh' SITENAME = 'Farseerfc Blog' AUTHOR = 'Jiachen Yang' DISQUS_SITENAME = 'farseerfcgithub' GITHUB_URL = 'https://github.com/farseerfc' SITEURL = 'http://farseerfc.github.com' TAG_FEED = 'feeds/ %s .atom.xml' SOCIAL = (( 'twitter' , 'http://twitter.com/farseerfc' ), ( 'github' , 'https://github.com/farseerfc' ), ( 'facebook' , 'http://www.facebook.com/farseerfc' ), ( 'weibo' , 'http://weibo.com/farseerfc' ), ( 'renren' , 'http://www.renren.com/farseer' ), ) TWITTER_USERNAME = 'farseerfc' THEME = 'notmyidea' CSS_FILE = \"wide.css\" DEFAULT_CATEGORY = 'Others' OUTPUT_PATH = '.' PATH = 'posts'","tags":"tech","url":"//farseerfc.me/en/../try-pelican.html"},{"title":"尝试一下 Pelican","text":"似乎一夜之间所有的 极客们 都 有了 自己 的 Github主页 和 Octopress 博客。就像所有人在他们的博客中指出的，静态博客的确比传统的WordPress方式具有更多优势。 自从看到这些 我就一直在想着自己搭一个 Octopress 。 但是似乎 Octopress 不适合我 一上手就被 Octopress的搭建步骤 烦到了。 RVM 是什么？ rbenv 又是什么？ 看来 Ruby 社区的快节奏发展已经超过了我的想象，他们似乎需要一套发行版管理器来调和不同版本之间的 Ruby 的兼容性问题。 虽然同样的兼容性问题在 Python 社区也有 [1] ，不过总觉得 Python 至少还没到需要一个发行版管理器的程度 [2] 。 真正的问题是我手上还没有一个可以让我随便玩的 Linux 环境（真的想要……）。 而无论是 RVM 还是 rbenv 似乎都只支持 Unix/Linux/MacOSX 。 身为极客就注定不能用 Windows 么？（或许是的……）。 剩下的问题就是 Ruby 和 Python 两大阵营的对立问题了。我不熟悉 Markdown ， 相对来说比较喜欢 ReST 。 似乎无论哪边都要 依赖 Pygments 作为代码着色器，那么其实 Rubyist 也至少需要安装 Python 。 我倾向于不依赖任何 Ruby 组件，最好没有 C 扩展 的纯 Python 实现。 于是我开始在 Github 上找 Python 的静态博客引擎。 Flask 的作者 mitsuhiko 写的 rstblog 看起来不错，不过似乎没有多少人在用。 Hyde 似乎很完善，不过默认的标记语言是 MarkDown ， 又依赖于几个 Ruby 组建，而且官方网站的设计实在太前卫。 最终我看到了 Pelican 。 [1] 比如 Python 2.x 与 3.x 之间看似难以跨越的鸿沟，以及 PyPy 、 CPython 、 Stackless 、 Cython 等各个实现之间的微妙差别。 [2] 是的，我们有 easy_install ，我们有 pip ， 不过这些都是包管理器，都是装好特定的Python实现之后的事情。 Python实现本身还不需要包管理器来管理。 Python 的版本问题基本上也只需要 2to3.py 和 3to2.py 这样的轻量级转换器就可以了，你不需要为了安装多个软件而在硬盘里留下多个不同版本的 Python 。 如果为了引用的稳定性，你可以用 virtualenv ，不过这又是另一回事情了。 那么就 Pelican 吧 对我而言， Pelican 相比于 Octopress 有几个好处： 纯 Python 实现。 这意味着我可以换用任何 Python 解释器而不必担心兼容性问题。比如我就换成了 PyPy 。 多语言支持。因为 Pelican 的作者似乎是个法国人。不过这个似乎大部分人不需要…… 我是想尽量把一篇博客写成三种语言作为锻炼吧。 ReST 。这样我就可以用 Leo 的 @auto-rst 直接写 ReST了。简单方便快捷有效。 不过似乎 Pelican 的关注度不如 Octopress 那么高，现在一些部分还有细微的问题： pelican-import 从 WordPress 导入的时候对中文、日文的支持似乎很成问题。 日期格式、时区、字符集、和多语言功能的结合度还不够。 我在尝试改善它。 模板还不够丰富。 插件也不够多…… 希望这么优秀的工具能够受到更多关注，以上这些问题都是增加关注度之后很快就能解决的问题。 我的设置 settings.py 安装 Pelican 很容易，一句话就够了： $ pip install pelican 然后把文章写成ReST的格式，放在`pages`文件夹里面。(重新)生成只要： $ pelican -s settings.py 上传到 Github: $ git commit -am \"Commit message\" $ git push 就这么简单。附上我的配置文件： # -*- coding: utf-8 -*- TIMEZONE = 'Asia/Tokyo' DATE_FORMATS = { 'en' :( 'usa' , ' %a , %d %b %Y' ), 'zh' :( 'chs' , '%Y-%m- %d , %a ' ), 'jp' :( 'jpn' , '%Y/%m/ %d ( %a )' ), } # windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx LOCALE = [ 'usa' , 'chs' , 'jpn' , # windows 'en_US' , 'zh_CN' , 'ja_JP' ] # Unix/Linux DEFAULT_LANG = 'zh' SITENAME = 'Farseerfc Blog' AUTHOR = 'Jiachen Yang' DISQUS_SITENAME = 'farseerfcgithub' GITHUB_URL = 'https://github.com/farseerfc' SITEURL = 'http://farseerfc.github.com' TAG_FEED = 'feeds/ %s .atom.xml' SOCIAL = (( 'twitter' , 'http://twitter.com/farseerfc' ), ( 'github' , 'https://github.com/farseerfc' ), ( 'facebook' , 'http://www.facebook.com/farseerfc' ), ( 'weibo' , 'http://weibo.com/farseerfc' ), ( 'renren' , 'http://www.renren.com/farseer' ), ) TWITTER_USERNAME = 'farseerfc' THEME = 'notmyidea' CSS_FILE = \"wide.css\" DEFAULT_CATEGORY = 'Others' OUTPUT_PATH = '.' PATH = 'posts'","tags":"tech","url":"//farseerfc.me/en/../zhs/try-pelican.html"},{"title":"\"…if we do this work … \" --Bill Gates","text":"renren から導入した。 From: Bill Gates '-- Sent: Sunday, January 24, 1999 8:41 AM Jeff Westorinon; Ben Fathi ; TO: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder Subject: ACPI extensions One thing I find myself wondering about is whether we shouldn't try and make the \"ACPI\" extensions somehow Windows specific. It seems unfortunate if we do this work and get our partners to do the work and the result is that Linux works great without having to do the work . Maybe there is no way to avoid this problem but it does bother me. Maybe we could define the APIs so that they work well with NT and not the others even if they are open. Or maybe we could patent something relaled to this. From: http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf もしこれは今更Xen4.0の上にACPI 3.0完全的なサポートが得ない原因、ならBill Gatesを呪います！","tags":"import","url":"//farseerfc.me/en/../jp/if-we-do-this-work.html"},{"title":"\"…if we do this work … \" --Bill Gates","text":"導入自 renren From: Bill Gates '-- Sent: Sunday, January 24, 1999 8:41 AM Jeff Westorinon; Ben Fathi ; TO: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder Subject: ACPI extensions One thing I find myself wondering about is whether we shouldn't try and make the \"ACPI\" extensions somehow Windows specific. It seems unfortunate if we do this work and get our partners to do the work and the result is that Linux works great without having to do the work . Maybe there is no way to avoid this problem but it does bother me. Maybe we could define the APIs so that they work well with NT and not the others even if they are open. Or maybe we could patent something relaled to this. From: http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf 如果這就是我至今在Xen4.0上得不到ACPI 3.0的完善支持的原因，那麼我詛咒Bill Gates！","tags":"import","url":"//farseerfc.me/en/../if-we-do-this-work.html"},{"title":"\"…if we do this work … \" --Bill Gates","text":"导入自 renren From: Bill Gates '-- Sent: Sunday, January 24, 1999 8:41 AM Jeff Westorinon; Ben Fathi ; TO: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder Subject: ACPI extensions One thing I find myself wondering about is whether we shouldn't try and make the \"ACPI\" extensions somehow Windows specific. It seems unfortunate if we do this work and get our partners to do the work and the result is that Linux works great without having to do the work . Maybe there is no way to avoid this problem but it does bother me. Maybe we could define the APIs so that they work well with NT and not the others even if they are open. Or maybe we could patent something relaled to this. From: http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf 如果这就是我至今在Xen4.0上得不到ACPI 3.0的完善支持的原因，那么我诅咒Bill Gates！","tags":"import","url":"//farseerfc.me/en/../zhs/if-we-do-this-work.html"},{"title":"寫程序讓CPU佔用率保持正弦函數","text":"導入自 renren 據說是一道微軟的面試題。如題，寫程序，讓Windows的任務管理器中的性能監視器呈現正弦曲線。 潛心鑽研良久，得代碼：（java） public class sincpu { private static final int cycle = 1024 , tick = 256 ; public static void main ( String [] args ) throws InterruptedException { for ( int i = 0 ;; i ++ ){ work ( calcNextSleep ( i % cycle )); sleep ( tick - calcNextSleep ( i % cycle )); } } private static long calcNextSleep ( long i ){ return ( int )( Math . sin (( double ) i * 2 * Math . PI / cycle ) * tick + tick ) / 2 ; } private static void sleep ( long sleepTime ) throws InterruptedException { if ( sleepTime < 2 ) Thread . yield (); else Thread . sleep ( sleepTime ); } private static void work ( long period ) { long start = System . currentTimeMillis (); for (;;){ Math . sin ( 1 ); if ( System . currentTimeMillis () - start >= period ) break ; } } } 多核CPU上測試時要注意關掉一個CPU：","tags":"import","url":"//farseerfc.me/en/../sine-cpu.html"},{"title":"写程序让CPU占用率保持正弦函数","text":"导入自 renren 据说是一道微软的面试题。如题，写程序，让Windows的任务管理器中的性能监视器呈现正弦曲线。 潜心钻研良久，得代码：（java） public class sincpu { private static final int cycle = 1024 , tick = 256 ; public static void main ( String [] args ) throws InterruptedException { for ( int i = 0 ;; i ++ ){ work ( calcNextSleep ( i % cycle )); sleep ( tick - calcNextSleep ( i % cycle )); } } private static long calcNextSleep ( long i ){ return ( int )( Math . sin (( double ) i * 2 * Math . PI / cycle ) * tick + tick ) / 2 ; } private static void sleep ( long sleepTime ) throws InterruptedException { if ( sleepTime < 2 ) Thread . yield (); else Thread . sleep ( sleepTime ); } private static void work ( long period ) { long start = System . currentTimeMillis (); for (;;){ Math . sin ( 1 ); if ( System . currentTimeMillis () - start >= period ) break ; } } } 多核CPU上测试时要注意关掉一个CPU：","tags":"import","url":"//farseerfc.me/en/../zhs/sine-cpu.html"}]}