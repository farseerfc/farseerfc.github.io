<div class="highlight"><pre><span class="gh">重新设计了 Pelican 的主题与插件</span>
<span class="gh">=======================================</span>

<span class="nc">:slug:</span> <span class="nf">redesign-pelican-theme</span>
<span class="nc">:lang:</span> <span class="nf">zhs</span>
<span class="nc">:date:</span> <span class="nf">2015-01-25 22:45</span>
<span class="nc">:tags:</span> <span class="nf">python, pelican, bootstrap, material, subsite</span>
<span class="nc">:series:</span> <span class="nf">pelican</span>

<span class="p">..</span> <span class="ow">contents</span><span class="p">::</span>


<span class="cp">.. PELICAN_BEGIN_SUMMARY</span>

<span class="p">..</span> <span class="ow">label-warning</span><span class="p">::</span>

    <span class="ge">*2015年2月14日更新*</span>

<span class="cp">.. PELICAN_END_SUMMARY</span>


<span class="gh">前言: 新天新地，将一切都更新了 [#]_</span>
<span class="gh">++++++++++++++++++++++++++++++++++++++++</span>

<span class="cp">.. PELICAN_BEGIN_SUMMARY</span>

不知不觉间放任这边长草很久了，从上次
<span class="s">`折腾主题 </span><span class="si">&lt;{filename}/tech/try_pelican.zhs.rst&gt;</span><span class="s">`_</span> 到现在都快三年了，
而从上次 <span class="s">`写了篇告白信 </span><span class="si">&lt;{filename}/life/marry-me.zhs.rst&gt;</span><span class="s">`_</span> 到现在也有快两年了。
这期间曾经把主题配色从 <span class="s">`Bootstrap 2 </span><span class="si">&lt;http://getbootstrap.com/2.3.2/&gt;</span><span class="s">`_</span> 默认的
白底黑字改成了让眼睛更舒适的黑底白字，也不过是用 drop-in 的配色方案而已，没有本质上的改进。

洞中一日世上千载，两年里 Bootstrap 已经升上 <span class="s">`v3.3 </span><span class="si">&lt;http://getbootstrap.com/&gt;</span><span class="s">`_</span> ,
而 Pelican 则已经升到 <span class="s">`3.5 </span><span class="si">&lt;https://github.com/getpelican/pelican/releases/tag/3.5.0&gt;</span><span class="s">`_</span> 了。
早就眼馋 Bootstrap 和 Pelican 中的诸多新功能新设计，不过无奈于时间有限只能饱饱眼福。

近日想写的东西越积越多，终于下定决心花了前前后后 <span class="ge">*两个月*</span> 的时间重新设计了一遍
Pelican 的主题，配合一些我觉得有用的插件。于是本博客就变成你们现在看到的样子了。
（以及本篇博文也用了两个月的时间写完，其间还发了几篇别的短文，算是恢复写博客的尝试吧。）

<span class="cp">.. PELICAN_END_SUMMARY</span>

<span class="p">..</span> <span class="ow">panel-default</span><span class="p">::</span>
  <span class="nc">:title:</span> <span class="nf">在迈阿密参加 `ICSR 2015 &lt;http://icsr2015.ipd.kit.edu/&gt;`_ 的时候</span>
          拍到的街边一家叫 Pelican 的旅馆

<span class="p">  ..</span> <span class="ow">image</span><span class="p">::</span> {filename}/images/pelican.jpg
      <span class="nc">:alt:</span> <span class="nf">Pelican Hotel</span>


<span class="gh">Bootstrap 3 的新设计</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="m">-</span> 全新的 <span class="na">:ruby:</span><span class="nv">`优先移动设备|mobile-first`</span> <span class="na">:ruby:</span><span class="nv">`响应式|responsive`</span> 设计。
  原本Bootstrap 2虽然有响应式设计，
  不过诸多细节不能符合我的需求，最终还是得手工 hack <span class="na">:code:</span><span class="nv">`@media`</span> 查询去微调。
  现在的 <span class="na">:ruby:</span><span class="nv">`优先移动设备|mobile-first`</span> <span class="na">:ruby:</span><span class="nv">`响应式|responsive`</span>
  <span class="na">:ruby:</span><span class="nv">`栅格系统|grid system`</span> 则相对显得科学很多了，也终于能在手持
  设备上看起来舒服一些。诸位可以尝试改变窗口宽度，或者在不同的手持设备上打开这个
  blog ，体验一下这个页面在不同显示器大小中的效果。如果仍有问题欢迎
  <span class="s">`发 Issue 给我 </span><span class="si">&lt;https://github.com/farseerfc/pelican-bootstrap3/issues&gt;</span><span class="s">`_</span>  。

<span class="m">-</span> 科学的 <span class="na">:ruby:</span><span class="nv">`导航栏|Navbar`</span> 。
  比 Bootstrap 2 那个科学很多了。无论是 <span class="na">:ruby:</span><span class="nv">`保持|sticky`</span> 在上端还是跟着浮动，
  或者像这边这样 <span class="s">`自动隐藏 </span><span class="si">&lt;http://www.virtuosoft.eu/code/bootstrap-autohidingnavbar/&gt;</span><span class="s">`_</span> 都很简单。

更多细节参考 <span class="s">`Bootstrap 3 主页 </span><span class="si">&lt;http://getbootstrap.com/&gt;</span><span class="s">`_</span> 。


<span class="gh">Pelican 3.5 的新功能</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="m">-</span> Python 2 和 Python 3 统一代码：
  再没有恼人的 unicode 相关的问题了。这对 blog 系统来说相当重要啊。
  而且还能方便切换 pypy 等不同的解释器。

<span class="m">-</span> 全新的插件系统：非常多功能强大的 <span class="s">`插件 </span><span class="si">&lt;https://github.com/getpelican/pelican-plugins&gt;</span><span class="s">`_</span> 等着你。

<span class="m">-</span> 增强了导入系统：嗯总算可以导入我的中文的 wordpress 博客了。（虽然那边长草更久了……）

<span class="m">-</span> <span class="s">`站内链接 </span><span class="si">&lt;http://pelican.readthedocs.org/en/latest/content.html#linking-to-internal-content&gt;</span><span class="s">`_</span>
  ：不用 <span class="na">:ruby:</span><span class="nv">`硬编码|hard code`</span> 目标页面的链接了，可以直接写源文件的位置然后让 pelican
  处理，这样能简化各种 <span class="na">:ruby:</span><span class="nv">`插件|plugin`</span> 和 <span class="na">:ruby:</span><span class="nv">`主题|theme`</span> 的实现。

更多细节参考 <span class="s">`Pelican 文档 </span><span class="si">&lt;http://pelican.readthedocs.org/en/latest/&gt;</span><span class="s">`_</span> 。



<span class="gh">新的文件夹布局</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="p">..</span> <span class="ow">panel-default</span><span class="p">::</span>
    <span class="nc">:title:</span> <span class="nf">Pelican 的新文件夹布局</span>

<span class="p">    ..</span> <span class="ow">raw</span><span class="p">::</span> html

        &lt;pre&gt;
        &lt;span style=&quot;color:blue;font-weight:bold;&quot;&gt;.&lt;/span&gt;
        ├── &lt;span style=&quot;color:blue;font-weight:bold;&quot;&gt;cache&lt;/span&gt;             生成页面的 pickle 缓存
        ├── &lt;span style=&quot;color:blue;font-weight:bold;&quot;&gt;content&lt;/span&gt;           读取的全部内容
        │   ├── &lt;span style=&quot;color:blue;font-weight:bold;&quot;&gt;&amp;lt;categories&amp;gt;&lt;/span&gt;      按分类存放的文章
        │   ├── &lt;span style=&quot;color:blue;font-weight:bold;&quot;&gt;pages&lt;/span&gt;             像 About 这样的固定页面
        │   └── &lt;span style=&quot;color:blue;font-weight:bold;&quot;&gt;static&lt;/span&gt;            文章内用到的静态内容
        ├── &lt;span style=&quot;color:blue;font-weight:bold;&quot;&gt;drafts&lt;/span&gt;            文章的草稿箱
        ├── &lt;span style=&quot;color:green;font-weight:bold;&quot;&gt;Makefile&lt;/span&gt;          生成用的 makefile
        ├── &lt;span style=&quot;color:green;font-weight:bold;&quot;&gt;pelicanconf.py&lt;/span&gt;    测试时用的快速 Pelican 配置
        ├── &lt;span style=&quot;color:green;font-weight:bold;&quot;&gt;publishconf.py&lt;/span&gt;    部署时用的耗时 Pelican 配置
        ├── &lt;span style=&quot;color:teal;font-weight:bold;&quot;&gt;output&lt;/span&gt;          -&amp;gt; &lt;span style=&quot;color:blue;font-weight:bold;&quot;&gt;../farseerfc.github.io&lt;/span&gt;
        ├── &lt;span style=&quot;color:teal;font-weight:bold;&quot;&gt;plugins&lt;/span&gt;         -&amp;gt; &lt;span style=&quot;color:blue;font-weight:bold;&quot;&gt;../pelican-plugins&lt;/span&gt;
        └── &lt;span style=&quot;color:teal;font-weight:bold;&quot;&gt;theme&lt;/span&gt;           -&amp;gt; &lt;span style=&quot;color:blue;font-weight:bold;&quot;&gt;../pelican-bootstrap3&lt;/span&gt;
        &lt;/pre&gt;

<span class="s">`之前的博客 </span><span class="si">&lt;https://github.com/farseerfc/farseerfc.github.com&gt;</span><span class="s">`_</span> 仍然留在
github 上，其中的内容完全搬过来了。开始写老博客的时候 Pelican 版本较早，没有形成好的
文件夹布局，导致生成的文章、使用的模板和撰写的内容全都混在一起，非常难以管理，
于是趁改版之际用了新的文件夹布局方式，并分为 4 个 git repo 分别管理历史。

首先是存放 <span class="s">`总的博客内容的 repo </span><span class="si">&lt;https://github.com/farseerfc/farseerfc&gt;</span><span class="s">`_</span> ，
其布局是如图那样的。这样将生成的静态网站和生成网站用的配置啦内容啦分开之后，顿时清晰了很多。

然后这个内容 repo 中的三个符号链接分别指向三个子 repo（没用 <span class="na">:code:</span><span class="nv">`git submodule`</span>
管理纯粹是因为偷懒）。 theme 指向
<span class="s">`pelican-bootstrap3 </span><span class="si">&lt;https://github.com/farseerfc/pelican-bootstrap3&gt;</span><span class="s">`_</span>
，是我修改过的 pelican 主题。
plugins 指向 <span class="s">`pelican-plugins </span><span class="si">&lt;https://github.com/farseerfc/pelican-plugins&gt;</span><span class="s">`_</span>
，由于 plugins 的质量有些参差不齐，其中不少 plugin
都按我的需要做了些许修改，一些是功能改进，另一些则是修bug（比如不少plugin只支持 python 2）。
最后 output 指向
<span class="s">`farseerfc.github.io </span><span class="si">&lt;https://github.com/farseerfc/farseerfc.github.io&gt;</span><span class="s">`_</span>
也就是发布的静态网站啦。

接下来从 <span class="ge">*主题*</span> 和 <span class="ge">*插件*</span> 两个方面介绍一下改版的细节。

<span class="gh">主题： Material Design 风格的 Bootstrap 3</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>

上篇 <span class="s">`博文 </span><span class="si">&lt;{filename}/tech/summary-material-design-css-framework.zhs.rst&gt;</span><span class="s">`_</span>
就总结了我为了这个博客寻找了一堆 CSS 框架，并且最终决定用
<span class="s">`bootstrap-material-design </span><span class="si">&lt;http://fezvrasta.github.io/bootstrap-material-design/&gt;</span><span class="s">`_</span>
, <span class="s">`DandyDev/pelican-bootstrap3 </span><span class="si">&lt;https://github.com/DandyDev/pelican-bootstrap3&gt;</span><span class="s">`_</span>
和 <span class="s">`Bootstrap 3 </span><span class="si">&lt;http://getbootstrap.com/&gt;</span><span class="s">`_</span> 这三个项目结合的方式实现这个模板的主题。
这三个项目都或多或少经过了我的修改，修改后的项目以 pelican-bootstrap3 为基础放在
<span class="s">`这里 </span><span class="si">&lt;https://github.com/farseerfc/pelican-bootstrap3&gt;</span><span class="s">`_</span> ，包括 <span class="s">`Bootstrap3 样式 </span><span class="si">&lt;https://github.com/farseerfc/pelican-bootstrap3/tree/master/static/bootstrap&gt;</span><span class="s">`_</span>
和 <span class="s">`Material 样式 </span><span class="si">&lt;https://github.com/farseerfc/pelican-bootstrap3/tree/master/static/material&gt;</span><span class="s">`_</span>。

<span class="gh">对 Bootstrap 3 的定制</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

由于架构完善，修改 Bootstrap 3 感觉非常简单。另一方面我在 Web 前端技术上的技能点也不多，
所以修改的地方非常有限，只能按我自己的需求定制而已。


<span class="gh">响应式设备的大小</span>
<span class="gh">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>

<span class="p">..</span> <span class="ow">panel-default</span><span class="p">::</span>
    <span class="nc">:title:</span> <span class="nf">修改了 Bootstrap 3 响应式设备的大小</span>

<span class="p">    ..</span> <span class="ow">code-block</span><span class="p">::</span> <span class="k">css</span>

        <span class="k">@screen-xs</span><span class="o">:</span>     <span class="nt">320px</span><span class="p">;</span>
        <span class="k">@screen-sm</span><span class="o">:</span>     <span class="nt">598px</span><span class="p">;</span> <span class="c">/*  768px; */</span>
        <span class="k">@screen-md</span><span class="o">:</span>     <span class="nt">952px</span><span class="p">;</span> <span class="c">/*  992px; */</span>
        <span class="k">@screen-lg</span><span class="o">:</span>    <span class="nt">1350px</span><span class="p">;</span> <span class="c">/* 1200px; */</span>
        <span class="k">@screen-xl</span><span class="o">:</span>    <span class="nt">2030px</span><span class="p">;</span>
        <span class="k">@container-sm</span><span class="o">:</span>  <span class="nt">582px</span><span class="p">;</span> <span class="c">/*  750px; */</span>
        <span class="k">@container-md</span><span class="o">:</span>  <span class="nt">930px</span><span class="p">;</span> <span class="c">/*  970px; */</span>
        <span class="k">@container-lg</span><span class="o">:</span> <span class="nt">1320px</span><span class="p">;</span> <span class="c">/* 1170px; */</span>
        <span class="k">@container-xl</span><span class="o">:</span> <span class="nt">1990px</span><span class="p">;</span>

首先把 Bootstrap 3 默认适配的几个 <span class="s">`响应式设备的大小 </span><span class="si">&lt;http://getbootstrap.com/css/#grid&gt;</span><span class="s">`_</span>
改成了我需要的大小。 <span class="na">:code:</span><span class="nv">`xs`</span> 和 <span class="na">:code:</span><span class="nv">`sm`</span> 的大小分别按照我的手机屏幕 <span class="ge">*竖屏*</span> 和
<span class="ge">*横屏*</span> 时候的浏览器页面宽度来算， <span class="na">:code:</span><span class="nv">`md`</span> 是想兼容 Nexus 7 横屏 960 的宽度以及
一个常见上网本 1024 的宽度。 <span class="na">:code:</span><span class="nv">`lg`</span> 的大小则按照常见的笔记本 1366 宽的屏幕来适配。

这里 Bootstrap 3 支持的设备大小的一个问题是，它最多考虑到 1200 像素宽的显示器，而更宽的
比如 1600、 2048 甚至 2560 像素宽的显示器现在也并不少见，其结果就是页面中左右两侧
有很大的空间被浪费掉了。作为深受这一问题困扰的用户之一，我用
<span class="s">`这里介绍的方法 </span><span class="si">&lt;http://stackoverflow.com/a/25644266&gt;</span><span class="s">`_</span>
给 bootstrap 增加了一类「 <span class="na">:ruby:</span><span class="nv">`比大更大|bigger than bigger`</span> 」的
<span class="na">:code:</span><span class="nv">`xl`</span> 响应式设备尺寸，宽度设为支持 2048 像素宽的显示器，具体的修改反映在
<span class="s">`variables.less </span><span class="si">&lt;https://github.com/farseerfc/pelican-bootstrap3/blob/master/static/bootstrap/variables.less&gt;</span><span class="s">`_</span>
文件里。


<span class="gh">根据宽度自动分栏和瀑布式布局</span>
<span class="gh">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>

接下来目标是让主页的文章列表像 Google+ 主页那样根据显示器宽度自动调整分栏，使得宽度不同的
显示器上每个分栏的宽度接近。想要达到的效果是，根据上面定义的屏幕宽度尺寸：

+-------------------+--------------------------+----------------------------+
<span class="o">|</span>     |xs|          |     |sm|                 |     |md|                   |
+-------------------+--------------------------+----------------------------+
<span class="o">|</span> +-----------+     | +---------+--------+     | +---------+--------+       |
<span class="o">|</span> | |Navbarr| |     | |     |Navbar|     |     | | |Navbar|         |       |
<span class="o">|</span> +-----------+     | +---------+--------+     | +---------+--------+       |
<span class="o">|</span> | |art|     |     | | |art|            |     | | |art| 1 | |sb| 1 |       |
<span class="o">|</span> +-----------+     | +---------+--------+     | +---------+--------+       |
<span class="o">|</span> | |sb|      |     | | |sb| 1  | |sb| 2 |     | | |art| 2 | |sb| 2 |       |
<span class="o">|</span> +-----------+     | +---------+--------+     | +---------+--------+       |
<span class="o">|</span> | |Footerr| |     | | |Footer|         |     | | |Footer|         |       |
<span class="o">|</span> +-----------+     | +---------+--------+     | +---------+--------+       |
+-------------------+------------+-------------+----------------------------+
<span class="o">|</span>     |lg|                       |     |xl|                                 |
+--------------------------------+------------------------------------------+
<span class="o">|</span> +---------+---------+--------+ | +---------+---------+---------+--------+ |
<span class="o">|</span> |      |Navbar|              | | |      |Navbar|                        | |
<span class="o">|</span> +---------+---------+--------+ | +---------+---------+---------+--------+ |
<span class="o">|</span> | |art| 1 | |art| 3 | |sb| 1 | | | |art| 1 | |art| 3 | |art| 5 | |sb| 1 | |
<span class="o">|</span> +---------+---------+--------+ | +---------+---------+---------+--------+ |
<span class="o">|</span> | |art| 2 | |art| 4 | |sb| 2 | | | |art| 2 | |art| 4 | |art| 6 | |sb| 2 | |
<span class="o">|</span> +---------+---------+--------+ | +---------+---------+---------+--------+ |
<span class="o">|</span> |      |Footer|              | | |      |Footer|                        | |
<span class="o">|</span> +---------+---------+--------+ | +---------+---------+---------+--------+ |
+--------------------------------+------------------------------------------+

<span class="p">..</span> <span class="nt">|xs|</span> <span class="ow">replace</span><span class="p">::</span> <span class="na">:code:</span><span class="nv">`xs`</span> 用单栏 <span class="na">:ruby:</span><span class="nv">`流动|fluid`</span> 布局
<span class="p">..</span> <span class="nt">|sm|</span> <span class="ow">replace</span><span class="p">::</span> <span class="na">:code:</span><span class="nv">`sm`</span> 用上方单栏文章列表、下方双栏 |sidebarr| 固定布局
<span class="p">..</span> <span class="nt">|md|</span> <span class="ow">replace</span><span class="p">::</span> <span class="na">:code:</span><span class="nv">`md`</span> 用单栏文章列表、单栏 |sb| 固定布局
<span class="p">..</span> <span class="nt">|lg|</span> <span class="ow">replace</span><span class="p">::</span> <span class="na">:code:</span><span class="nv">`lg`</span> 用双栏文章列表、单栏 |sb| 固定布局
<span class="p">..</span> <span class="nt">|xl|</span> <span class="ow">replace</span><span class="p">::</span> <span class="na">:code:</span><span class="nv">`xl`</span> 用三栏文章列表、双栏 |sb| 固定布局
<span class="p">..</span> <span class="nt">|Navbarr|</span> <span class="ow">replace</span><span class="p">::</span> <span class="na">:ruby:</span><span class="nv">`导航栏|Navbar`</span>
<span class="p">..</span> <span class="nt">|Navbar|</span> <span class="ow">replace</span><span class="p">::</span> 导航栏
<span class="p">..</span> <span class="nt">|Footer|</span> <span class="ow">replace</span><span class="p">::</span> <span class="na">:ruby:</span><span class="nv">`底栏|footer`</span>
<span class="p">..</span> <span class="nt">|Footerr|</span> <span class="ow">replace</span><span class="p">::</span> 底栏
<span class="p">..</span> <span class="nt">|sidebarr|</span> <span class="ow">replace</span><span class="p">::</span> <span class="na">:ruby:</span><span class="nv">`侧边栏|sidebar`</span>
<span class="p">..</span> <span class="nt">|sb|</span> <span class="ow">replace</span><span class="p">::</span> 侧边栏
<span class="p">..</span> <span class="nt">|art|</span> <span class="ow">replace</span><span class="p">::</span> 文章

一开始纯粹用 Bootstrap3 的响应式栅格实现这个分栏布局，结果发现效果不太理想，
因为文章列表和侧边栏的高度是变化的，会导致栅格间留下大片空白。后来改用
<span class="s">`这里示范的纯CSS瀑布式布局 </span><span class="si">&lt;http://cssdeck.com/labs/pinterest-like-waterfall-design-purely-css&gt;</span><span class="s">`_</span>
实现文章和侧边栏的布局，具体的实现代码在
<span class="s">`waterfall.less </span><span class="si">&lt;https://github.com/farseerfc/pelican-bootstrap3/blob/master/static/bootstrap/waterfall.less&gt;</span><span class="s">`_</span>
，总算达到了想要的布局了。



<span class="gh">正文的样式</span>
<span class="gh">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>

最最重要的是文章正文的样式。这里我想要达到的效果是，在大屏幕上用更大的字号，让读者
看起来更舒适，同时在小屏幕上用比较小的字号，最终保证基本上「一行」的文字数接近。这个修改
主要针对 <span class="na">:code:</span><span class="nv">`.jumbotron`</span>，
用了 <span class="s">`不太科学的方式 </span><span class="si">&lt;https://github.com/farseerfc/pelican-bootstrap3/blob/master/static/bootstrap/jumbotron.less&gt;</span><span class="s">`_</span>
代码太长就不贴全了。


<span class="gh">一些细微的定制</span>
<span class="gh">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>

把主题配色改成了现在这样的淡紫色
<span class="nc">:code:`@brand-primary:</span> <span class="nf">darken(#6B5594, 6.5%);`</span>
，配合我的头像风格， 这个修改只需要一行。
接着删掉了 <span class="na">:code:</span><span class="nv">`.btn`</span> 的 <span class="na">:code:</span><span class="nv">`white-space: nowrap;`</span> 让按钮的文字可以换行，
这也只是一行修改。

<span class="p">..</span> <span class="ow">label-warning</span><span class="p">::</span>

    <span class="ge">*2015年1月29日更新*</span>

另外我也不太喜欢 Bootstrap 3 默认在手机上的 <span class="na">:ruby:</span><span class="nv">`折叠导航栏|collapsed navbar`</span> ，
折叠之后的操作不够直观方便而且依赖 javascript 所以有 bug …… 于是我把它关掉了，
具体方式是在 variables.less 把 <span class="na">:code:</span><span class="nv">`@grid-float-breakpoint`</span> 和
<span class="na">:code:</span><span class="nv">`@grid-float-breakpoint-max`</span> 都设为0就可以了。


<span class="gh">对 bootstrap-material-design 的定制</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

这里定制的地方不多。原样式中一个不太科学的做法是所有 <span class="na">:code:</span><span class="nv">`.btn`</span> 都强制加上了阴影
效果，这在已经有阴影的环境里用的话非常碍眼，像是 Win9x 风格的厚重睫毛膏。既然可以单独
给每个样式加阴影，于是就把 <span class="na">:code:</span><span class="nv">`.btn`</span> 强制的阴影去掉了，只保留鼠标悬停之后强调的阴影。

其它定制的细节么就是统一配色风格，修补漏洞错误，微调响应式效果而已，这里不细说。


<span class="gh">将以上两者整合在 pelican-bootstrap3 里</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="p">..</span> <span class="ow">panel-default</span><span class="p">::</span>
    <span class="nc">:title:</span> <span class="nf">Pelican 实现显示源代码按钮</span>

    显示源代码按钮借用了 Pelican 配置中自带的 <span class="na">:code:</span><span class="nv">`OUTPUT_SOURCES`</span> 选项将源文件复制到输出文件夹：

<span class="p">    ..</span> <span class="ow">code-block</span><span class="p">::</span> <span class="k">python</span>

        <span class="n">OUTPUT_SOURCES</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">OUTPUT_SOURCES_EXTENSION</span> <span class="o">=</span> <span class="s">&#39;.rst&#39;</span>

    然后在 Makefile 里用 pygmentize 把所有源代码文件着色：

<span class="p">    ..</span> <span class="ow">code-block</span><span class="p">::</span> <span class="k">bash</span>

        find -iname <span class="s2">&quot;*.rst&quot;</span> <span class="p">|</span> parallel -I@  pygmentize -f html -o @.html @

    最后在按钮按下的时候用 jQuery 载入源代码：

<span class="p">    ..</span> <span class="ow">code-block</span><span class="p">::</span> <span class="k">html</span>

        <span class="nt">&lt;a</span> <span class="na">onclick=</span><span class="s">&quot;$.get(&#39;{{SITEURL}}/{{article.slug}}.rst.html&#39;, function(data){$(&#39;#source-code&#39;).html(data)});$(&#39;#article-content&#39;).toggle();$(&#39;#source-content&#39;).toggle();&quot;</span><span class="nt">&gt;</span>

    虽然难看的 hack 比较多，但是能用！


虽说 pelican-bootstrap3 是我 fork 出来的，不过由于我修改的地方实在太多，代码看来基本上
接近重写了一份。好在之前有给 pelican 写 bootstrap 2 主题的经验，这次修改算得上驾轻就熟。
可以对比一下 <span class="s">`上游作者的博客 </span><span class="si">&lt;http://dandydev.net/&gt;</span><span class="s">`_</span> 和这里的样子体会一下感觉。
具体修改过的地方包括：

<span class="m">#.</span> 套用 bootstrap-material-design 的各个元素样式。
<span class="m">#.</span> 在文章列表模板应用上面提到的 Bootstrap 3 的栅格布局和瀑布式布局。
<span class="m">#.</span> 翻译到多个语言，这里在后面的 i18n-subsite 插件里详述。
<span class="m">#.</span> 套用后面会介绍到的各种插件。
<span class="m">#.</span> 统一侧边栏的样式到一个模板里。
<span class="m">#.</span> 添加 Atom 订阅按钮和 breadcrumb 条。
<span class="m">#.</span> 对正文中出现的插图，添加点击放大的功能，通过 Bootstrap 的 <span class="na">:code:</span><span class="nv">`modal`</span> 实现。
<span class="m">#.</span> 上面提到的用 <span class="s">`这个bootstrap插件 </span><span class="si">&lt;http://www.virtuosoft.eu/code/bootstrap-autohidingnavbar/&gt;</span><span class="s">`_</span>
   让导航栏自动隐藏。
<span class="m">#.</span> <span class="ge">*显示源代码按钮*</span> ，也就是每篇文章信息栏中的
   <span class="na">:html:</span><span class="nv">`&lt;button class=&quot;btn btn-primary&quot;&gt;&lt;i class=&quot;fa fa-code&quot;&gt;&lt;/i&gt;&lt;/button&gt;`</span> 按钮。



<span class="gh">插件: 发挥 Pelican 和 reStructuredText 的优势</span>
<span class="gh">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>

先列举一下我目前用到的所有插件：

<span class="p">..</span> <span class="ow">code-block</span><span class="p">::</span> <span class="k">python</span>

    <span class="n">PLUGINS</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;i18n_subsites&quot;</span><span class="p">,</span>
               <span class="s">&quot;plantuml&quot;</span><span class="p">,</span>
               <span class="s">&quot;youku&quot;</span><span class="p">,</span>
               <span class="s">&quot;youtube&quot;</span><span class="p">,</span>
               <span class="s">&#39;tipue_search&#39;</span><span class="p">,</span>
               <span class="s">&#39;neighbors&#39;</span><span class="p">,</span>
               <span class="s">&#39;series&#39;</span><span class="p">,</span>
               <span class="s">&#39;bootstrapify&#39;</span><span class="p">,</span>
               <span class="s">&#39;twitter_bootstrap_rst_directives&#39;</span><span class="p">,</span>
               <span class="s">&quot;render_math&quot;</span><span class="p">,</span>
               <span class="s">&#39;extract_toc&#39;</span><span class="p">,</span>
               <span class="s">&#39;summary&#39;</span><span class="p">]</span>

嗯其实不算多。接下来逐一介绍一下这些各具特色的插件。

<span class="gh">i18n-subsites</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

这个插件的目的是创建 <span class="na">:ruby:</span><span class="nv">`国际化|internationalization`</span>
<span class="na">:ruby:</span><span class="nv">`子站|subsite`</span> 。

之前介绍 Pelican 配置的时候就提到过，
原本的 Pelican 就支持一篇文章用多种语言书写，有 <span class="na">:code:</span><span class="nv">`lang`</span> 属性注明这篇文章使用的
语言，以及 <span class="na">:code:</span><span class="nv">`slug`</span> 属性注明多语言的翻译之间的关联，换句话说同一篇文章的多个语言
版本应该有相同的 <span class="na">:code:</span><span class="nv">`slug`</span> 和不同的 <span class="na">:code:</span><span class="nv">`lang`</span>。然后原本 Pelican 里对多语言的
实现方式是，首先有一个 <span class="ge">*主语言*</span> 是模板和大部分文章采用的语言，文章列表中会优先列出
用 <span class="ge">*主语言*</span> 撰写的文章，然后从 <span class="ge">*主语言*</span> 的文章链接到别的翻译版本。
很多博客系统和CMS对多语言的支持都是这样的，这种处理方式的缺点也显而易见：作为 <span class="ge">*主语言*</span>
的语言必须足够通用，才能让进来的人找到合适的翻译版本，所以通常 <span class="ge">*主语言*</span> 都是英语。

而这个插件做的事情描述起来很简单：将文章按语言属性分到多个子站，每个子站独立放在各自的文件夹。
比如主站是 https://farseerfc.github.io/ 的话，那么英语的子站就可以是
https://farseerfc.github.io/en/ 。
然后分别对多个子站生成静态页面。具体的实现方式是对 pelican 的页面生成步骤做了拆分：

<span class="m">#.</span> pelican 按正常情况读入文章，生成元信息。
<span class="m">#.</span> i18n-subsites 针对每个语言，覆盖掉 pelican 的一些选项设置比如路径和 URL ，
   分别调用 pelican 的页面生成器按模板生成文章。
<span class="m">#.</span> 对共用的静态内容比如模板的 js 和 css 文件，只在主站中生成，子站中的相应链接全部链回主站。

虽然描述起来简单，但是这个插件可以说最大化利用了 Pelican 的插件系统，实现细节相对比较
复杂，大概是我用的这些插件里面最复杂的了。不夸张的说 Pelican 3.4 支持的新插件 API 和
站内链接功能基本上就是为了配合这个插件的。至于具体它会覆盖哪些 Pelican 的配置，请参阅它的
<span class="s">`README.md文件 </span><span class="si">&lt;https://github.com/farseerfc/pelican-plugins/blob/master/i18n_subsites/README.rst&gt;</span><span class="s">`_</span> 。

按内容拆分多语言子站的做法只解决了问题的一半，还留下另一半的问题，也即对模板的翻译。
对这个问题， i18n-subsites 提供了两套方案供选择：

<span class="m">#.</span> 用覆盖配置路径的方式让每个子站套用不同的模板。这配置起来简单，但是对模板维护起来有点困难。
<span class="m">#.</span> 用 jinja2 的 i18n 插件，配合 Python 的 gettext 库实现内容翻译。这个方案
   <span class="s">`配置起来比较复杂 </span><span class="si">&lt;https://github.com/farseerfc/pelican-plugins/blob/master/i18n_subsites/localizing_using_jinja2.rst&gt;</span><span class="s">`_</span> ，但是配置好之后用起来就很方便了。
   只是要记得每次修改了模板都要更新翻译，处理 \*.po 和 \*.mo 文件等等琐碎事宜。

这里我用 jinja2 的 i18n 插件的方式实现了模板的翻译，
<span class="s">`各个语言的翻译在这里 </span><span class="si">&lt;https://github.com/farseerfc/pelican-bootstrap3/tree/master/translations&gt;</span><span class="s">`_</span> ，
然后用 <span class="s">`这里的 SCons 脚本 </span><span class="si">&lt;https://github.com/farseerfc/pelican-bootstrap3/blob/master/SConstruct&gt;</span><span class="s">`_</span>
根据内容是否变化自动更新 po 和 mo 文件。

配置好这一套方案之后，还要注意在模板和文章中处理好链接。用 Pelican 3.4 之后推荐的
新的文章间链接的写法以及将 <span class="na">:code:</span><span class="nv">`SITEURL`</span> 设置为实际 URL 并且关闭 <span class="na">:code:</span><span class="nv">`RELATIVE_URLS`</span>
之后，应该就不会出没什么问题了（可能还要考虑使用的模板和插件的兼容性，大部分都是写死了 URL 的问题）。

<span class="gh">plantuml</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="p">..</span> <span class="ow">panel-default</span><span class="p">::</span>
    <span class="nc">:title:</span> <span class="nf">嵌入 PlantUML 的示例</span>

<span class="p">    ..</span> <span class="ow">uml</span><span class="p">::</span>

        Object &lt;|-- ArrayList

        Object : equals()
        ArrayList : Object[] elementData
        ArrayList : size()

<span class="s">`PlantUML </span><span class="si">&lt;http://plantuml.sourceforge.net/&gt;</span><span class="s">`_</span> 是一个Java实现的，
用接近文字描述的语言绘制 UML 图或者 GUI 界面图的工具，非常适合嵌入在
Markdown、 reStructuredText、 AsciiDoc 等这种轻量级标记语言里。
然后么这个 plantuml 插件就是定义了一个新的 reStructuredText
<span class="na">:ruby:</span><span class="nv">`指示符|directive`</span> <span class="na">:code:</span><span class="nv">`.. uml::`</span>，把嵌入的内容提取出来调用 plantuml 命令处理
成图像然后再插入到文章中。

比如示例里的这个 UML 图就是用这样一段简单的文字描述生成的：

<span class="p">..</span> <span class="ow">code-block</span><span class="p">::</span> <span class="k">rst</span>

    <span class="p">..</span> <span class="ow">uml</span><span class="p">::</span>

        Object &lt;|-- ArrayList

        Object : equals()
        ArrayList : Object[] elementData
        ArrayList : size()

实际用起来这个插件实现上稍微有点小问题：首先它只支持 python2，所以我把它改写成了 python
2 和 3 都通用的语法；其次它原本输出的文件夹似乎会被 pelican 删掉，所以把它改了个位置；
然后它输出的 URL 也和 i18n-subsites 插件间有不兼容的问题，也顺带修掉了。
<span class="s">`修改之后的代码在这里 </span><span class="si">&lt;https://github.com/farseerfc/pelican-plugins/tree/master/plantuml&gt;</span><span class="s">`_</span> 。

<span class="p">..</span> <span class="ow">label-warning</span><span class="p">::</span>

    <span class="ge">*2015年1月30日更新*</span>

<span class="p">..</span> <span class="ow">panel-default</span><span class="p">::</span>
    <span class="nc">:title:</span> <span class="nf">嵌入 Ditaa 的示例</span>

<span class="p">    ..</span> <span class="ow">ditaa</span><span class="p">::</span>

                           +-------------+
                           <span class="o">|</span>   ditaa     |-------+
                           <span class="o">|</span>  Diagram    |       |
                           +-------------+       | PNG out
                               ^                 |
                               <span class="o">|</span> ditaa in        |
                               <span class="o">|</span>                 v
         +--------+   +--------+----+    /----------------\
         <span class="o">|</span>        | --+   Pelican   +--&gt; |                |
         <span class="o">|</span>  Text  |   +-------------+    | Beautiful Blog |
         |Document|   |   !magic!   |    |                |
         <span class="o">|</span>     {d}|   |             |    |                |
         +---+----+   +-------------+    \----------------/
             :                                   ^
             <span class="o">|</span>          Lots of work             |
             +-----------------------------------+


plantuml 是绘制UML的，除此之外还有一个类似的工具是绘制一般的 <span class="na">:ruby:</span><span class="nv">`流程图|diagram`</span>
的，叫 <span class="s">`ditaa </span><span class="si">&lt;http://ditaa.sourceforge.net/&gt;</span><span class="s">`_</span> ，和 plantuml 非常像，也比较像
reStructuredText 的表格。
于是我也照猫画虎实现了一个 ditaa 的 <span class="na">:ruby:</span><span class="nv">`指示符|directive`</span> ，用起来类似这样：

<span class="p">..</span> <span class="ow">code-block</span><span class="p">::</span> <span class="k">rst</span>

    <span class="p">..</span> <span class="ow">ditaa</span><span class="p">::</span>

                           +-------------+
                           <span class="o">|</span>   ditaa     |-------+
                           <span class="o">|</span>  Diagram    |       |
                           +-------------+       | PNG out
                               ^                 |
                               <span class="o">|</span> ditaa in        |
                               <span class="o">|</span>                 v
         +--------+   +--------+----+    /----------------\
         <span class="o">|</span>        | --+   Pelican   +--&gt; |                |
         <span class="o">|</span>  Text  |   +-------------+    | Beautiful Blog |
         |Document|   |   !magic!   |    |                |
         <span class="o">|</span>     {d}|   |             |    |                |
         +---+----+   +-------------+    \----------------/
             :                                   ^
             <span class="o">|</span>          Lots of work             |
             +-----------------------------------+


<span class="gh">render-math</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="p">..</span> <span class="ow">panel-default</span><span class="p">::</span>
    <span class="nc">:title:</span> <span class="nf">嵌入公式的示例</span>

    示范行内公式 <span class="na">:math:</span><span class="nv">`A_\text{c} = (\pi/4) d^2`</span>.

    整行公式

<span class="p">    ..</span> <span class="ow">math</span><span class="p">::</span>

      \alpha{}_t(i) = P(O_1, O_2, … O_t, q_t = S_i \lambda{})

这个插件提供在 reStructuredText 中用 LaTeX 语法插入数学公式的能力，定义了
<span class="na">:code:</span><span class="nv">`:math:`</span> <span class="na">:ruby:</span><span class="nv">`行内角色|role`</span> 和 <span class="na">:code:</span><span class="nv">`.. math::`</span> <span class="na">:ruby:</span><span class="nv">`指示符|directive`</span> 。
实际工作的渲染库当然是大名鼎鼎的 <span class="s">`MathJax </span><span class="si">&lt;http://www.mathjax.org/&gt;</span><span class="s">`_</span> ，这个插件
会用 MathJax 的 CDN 载入，所以也没有额外的依赖文件。（只是不知道是否会被国内墙掉，
如果公式显示不正常请 <span class="ge">*务必*</span> 告诉我。）


<span class="gh">youtube 和 youku</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

顾名思义，这两个插件分别实现嵌入 youtube 和 youku 视频。其中 youtube 是原本就有的插件，
youku 是我照猫画虎抄的。
之前写了一篇
<span class="s">`KDE5 Plasma 之跳动卖萌的活动按钮 </span><span class="si">&lt;{filename}/tech/jumping-kde5-plasma-activities-button.zhs.rst&gt;</span><span class="s">`_</span>
用到了这两个插件。

<span class="gh">tipue_search</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="s">`Tipue search </span><span class="si">&lt;http://www.tipue.com/search/&gt;</span><span class="s">`_</span> 是一个非常有意思也很强大的搜索工具，
通过 jQuery 实现静态博客的站内搜索功能。实现方式是，它需要你写一个 json 文件，包含
整个网站的 <span class="ge">*全部*</span> 文章的标题和文字内容，然后在搜索的时候读入这个 json 做搜索（是不是有点耍赖）。
虽然听起来会有性能问题，但是应用在小型的静态博客上效果意外很不错，比如本站的所有文章内容
放在一起的 json 也只有 300KiB 左右。

这个插件就是自动在 pelican 输出完全部静态网页之后，调用 beautifulsoup4 从所有网页中抽取出
纯文本，产生这个 json 给 Tipue 用。

<span class="gh">neighbors 和 series</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

这两个插件比较类似也都比较简单， neighbors 提供一篇文章的前后文章信息，
在主题模板里可以用来制作 <span class="ge">*上一篇*</span> 和 <span class="ge">*下一篇*</span> 按钮。
series 提供将多篇文章归类为一个 <span class="ge">*系列*</span> 的支持，当然也需要在
主题模板中定义显示「文章系列」的列表。这两个插件的效果都能在本文末尾，评论区上方的部分看到。


<span class="gh">bootstrapify 和 twitter_bootstrap_rst_directives</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

这两个插件让文章的 <span class="ge">*正文*</span> 套用上 Bootstrap 的样式。

bootstrapify 这个插件实现得比较简单，用 beautifulsoup4 在静态网页的结果里面过滤元素，
对 <span class="na">:code:</span><span class="nv">`table`</span> , <span class="na">:code:</span><span class="nv">`img`</span> , <span class="na">:code:</span><span class="nv">`embed`</span> , <span class="na">:code:</span><span class="nv">`iframe`</span> ,
<span class="na">:code:</span><span class="nv">`video`</span> , <span class="na">:code:</span><span class="nv">`object`</span> 这几个标签套用上
<span class="s">`响应式嵌入对象的类 </span><span class="si">&lt;http://getbootstrap.com/components/#responsive-embed&gt;</span><span class="s">`_</span>
让他们更美观。

twitter_bootstrap_rst_directives 这个插件则是增加了几个 reStructuredText 的
<span class="na">:ruby:</span><span class="nv">`行内角色|role`</span> 和 <span class="na">:ruby:</span><span class="nv">`指示符|directive`</span> 。
它实现的 <span class="na">:ruby:</span><span class="nv">`行内角色|role`</span> 包括：
用 <span class="na">:code:</span><span class="nv">`:kbd:`</span> 实现如 <span class="na">:kbd:</span><span class="nv">`Ctrl+C`</span> 这样的键盘快捷键，
用 <span class="na">:code:</span><span class="nv">`:code:`</span> 嵌入代码片段，用 <span class="na">:code:</span><span class="nv">`:glyph:`</span> 嵌入字符图标。
它实现的 <span class="na">:ruby:</span><span class="nv">`指示符|directive`</span> 包括：
<span class="s">`labels 行内标签 </span><span class="si">&lt;http://getbootstrap.com/components/#labels&gt;</span><span class="s">`_</span> ，
<span class="s">`alerts 提示段落 </span><span class="si">&lt;http://getbootstrap.com/components/#alerts&gt;</span><span class="s">`_</span> ，
<span class="s">`panels 嵌入面板 </span><span class="si">&lt;http://getbootstrap.com/components/#panels&gt;</span><span class="s">`_</span> ，
以及还有一个 <span class="s">`media 混排图标 </span><span class="si">&lt;http://getbootstrap.com/components/#media&gt;</span><span class="s">`_</span> 。

对其中的 <span class="na">:code:</span><span class="nv">`panel`</span> 我改写了它在文章正文中的样式，在 <span class="na">:code:</span><span class="nv">`lg`</span> 或者 <span class="na">:code:</span><span class="nv">`xl`</span>
的屏幕宽度下，分别用 <span class="na">:math:</span><span class="nv">`\frac{1}{2}`</span> 和 <span class="na">:math:</span><span class="nv">`\frac{1}{3}`</span> 大小的嵌入面板，
简单实现和正文文字的图文混排。

除此以外我还在 twitter_bootstrap_rst_directives 这个插件里套用它的框架实现了两个额外
的 <span class="na">:ruby:</span><span class="nv">`行内角色|role`</span> ， 分别是 <span class="na">:code:</span><span class="nv">`:ruby:`</span> ：通过 html5 的 <span class="na">:code:</span><span class="nv">`&lt;ruby&gt;`</span>
标签实现文字上方的注音（firefox下
<span class="s">`不支持 </span><span class="si">&lt;https://bugzilla.mozilla.org/show_bug.cgi?id=33339&gt;</span><span class="s">`_</span>
，会使用文字后的括号显示）， 以及 <span class="na">:code:</span><span class="nv">`:html:`</span> ：在
行内插入 <span class="na">:ruby:</span><span class="nv">`裸|raw`</span> html 标签（这属于 Markdown 的基本功能，在 reStructuredText
这边由于要考虑多种输出格式于是就比较麻烦了）。这两个 <span class="na">:ruby:</span><span class="nv">`行内角色|role`</span> 的
<span class="s">`实现代码在这里 </span><span class="si">&lt;https://github.com/farseerfc/pelican-plugins/blob/master/twitter_bootstrap_rst_directives/bootstrap_rst_directives.py#L140&gt;</span><span class="s">`_</span> 。

<span class="p">..</span> <span class="ow">label-warning</span><span class="p">::</span>

    <span class="ge">*2015年2月3日更新*</span>

今天又在 twitter_bootstrap_rst_directives 里增加了两个 <span class="na">:ruby:</span><span class="nv">`行内角色|role`</span> 。
一个是 <span class="na">:code:</span><span class="nv">`:twi:`</span> 用来写 twitter 用户的链接，比如 <span class="na">:twi:</span><span class="nv">`farseerfc`</span> ，另一个是
<span class="na">:code:</span><span class="nv">`:irc:`</span> 用来指向 freenode 的 channel ，比如 <span class="na">:irc:</span><span class="nv">`yssyd3`</span> 。

<span class="p">..</span> <span class="ow">label-warning</span><span class="p">::</span>

    <span class="ge">*2015年2月14日更新*</span>

今天增加了 <span class="na">:code:</span><span class="nv">`.. friend::`</span> 用来写好友链接，以及 <span class="na">:code:</span><span class="nv">`fref`</span> 用来引用好友，
比如 <span class="na">:fref:</span><span class="nv">`LQYMGT`</span> 这样。


<span class="gh">extract_toc 和 summary</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

最后是这两个有点「名不副实」的插件。

reStructuredText 原本就有自动生成
<span class="na">:ruby:</span><span class="nv">`目录|toc`</span> 的功能，用起来也非常简单，只需要在想要插入目录的地方写一行
<span class="na">:code:</span><span class="nv">`.. contents::`</span> ，剩下的都由 docutils 自动生成了。
只是当然这样生成的目录肯定会插入在文章的正文里，而 extract_toc 这个插件的作用就是简单地
把这个目录抽取出来，让模板能在别的地方放置这个目录。比如我这里就把目录放在了一个
<span class="na">:code:</span><span class="nv">`panel`</span> 里。

然后 Pelican 也原本就有从文章中抽取 <span class="na">:ruby:</span><span class="nv">`总结|summary`</span> 显示在文章列表的功能。
Pelican 原始的实现似乎是按照文字数抽取前半段，不总是适合作为总结。 于是这个 summary
插件的作用其实是允许在正文中以特殊的注释的方式标注哪些部分应该被抽出来作为总结。
summary 这个插件原本的实现只允许抽取一段文字，我又对它的实现做了少许扩充，允许标注多段
文字合并起来作为总结。


<span class="p">..</span> <span class="ow">label-warning</span><span class="p">::</span>

    <span class="ge">*2015年1月29日更新*</span>

今天在 extract_toc 插件的帮助下，在侧边栏里放了一个 Bootstrap affix 的目录，
它保持在页面的右侧位置不变，方便导航到文章的各个地方。具体实现方法除了 Bootstrap 3 的
<span class="s">`Affix 文档 </span><span class="si">&lt;http://getbootstrap.com/javascript/#affix&gt;</span><span class="s">`_</span> ，还参考了
<span class="s">`这篇更详细的说明 </span><span class="si">&lt;http://tutsme-webdesign.info/bootstrap-3-affix/&gt;</span><span class="s">`_</span> 。

<span class="gh">结语</span>
<span class="gh">++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>

这个博客的配置都可以在
<span class="s">`github 上找到 </span><span class="si">&lt;https://github.com/farseerfc/farseerfc/blob/master/pelicanconf.py&gt;</span><span class="s">`_</span>
，包括用来
<span class="s">`自动生成整个博客的 Makefile </span><span class="si">&lt;https://github.com/farseerfc/farseerfc/blob/master/Makefile&gt;</span><span class="s">`_</span>
，由于比较长，这里就不再贴了。

折腾这个主题前后历时两个月，期间学会了不少东西，也算是不错的收获吧。
现在既然基础打好了，接下来就要开始多写博客了。（希望拖延症不会再犯……）

最近发现除了我的博客之外还有一个网站
<span class="s">`Kansas Linux Fest </span><span class="si">&lt;http://www.kansaslinuxfest.us/&gt;</span><span class="s">`_</span> fork
了我的主题，不过他们用了我修改的早期版本，还是原本的 Bootstrap 3 和
bootstrap-material-design 样式。自己草草修改的东西被别人用到果然还是有点小激动呢，
以及接下来不能马马虎虎地写 commit 消息了。


<span class="p">..</span> <span class="nt">[#]</span> 赛65:17「看哪！我造新天新地」启21:5「我将一切都更新了。」
</pre></div>
