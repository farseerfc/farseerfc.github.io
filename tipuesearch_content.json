{"pages":[{"text":"關於這個Blog 我會儘量用中文(Chinese, zh)，日語(Japanese, jp)，英語(English, en)這 三門語言同時寫這個blog，在有意義的情況下。中文有繁體(zh)與簡體(zhs) 之分，我以繁體撰寫，再以 OpenCC 將繁體轉化爲對應的簡體。 近況 我叫 楊嘉晨 1989年6月生 目前就讀於 大阪大學大學院 情報科學研究科 計算機科學專攻 博士2年級 ( http://sdl.ist.osaka-u.ac.jp/ ) 本科畢業於 上海交通大學 軟件學院 軟件工程專業 F0703701班 ( http://se.sjtu.edu.cn/ ) 聯繫方式 生活中你可以通過這些方式找到我： 手機（softbank）: 080-3853-2770 手機郵箱: jc-yang@softbank.ne.jp 網絡上你可以通過這些方式找到我： Skype: farseerfc GTalk: farseerfc@gmail.com MSN : firechildren@hotmail.com Tencent QQ : 76635424 ( farseerfc@qq.com ) twitter: http://twitter.com/farseerfc Github: https://github.com/farseerfc weibo(微博): http://weibo.com/farseerfc facebook: http://www.facebook.com/farseerfc renren（人人）: http://renren.com/farseer","tags":"pages","loc":"//farseerfc.github.io/pages/about.html","title":"About"},{"text":"* 用 WASD ←→ 移動，需要 WebGL 支持","tags":"life","loc":"//farseerfc.github.io/marry-me.html","title":"嫁給我好麼"},{"text":"Contents June 6 Keynote 1 Cost Estimation for Distributed Software Project Characterizing Logging Practices in Open-Source Software Combine Functional and Imperative Pgrm for Multicore Sw: Scala & Java Sound Empirical Evidence in Software Testing Identifing Linux Bug Fixing Patch Active Refinement of Clone Anomaly Reports June7 Keynotes 2: Sustainability with Software - An Industrial Perspective Green IT What can we do? Green by IT On How Often code is cloned across repositories Graph-based analysis and prediction for sw evolution graph are everywhere predictors Conclusion What make long term contributors: willingness and opportunity in OSS approach summeray develop of auxiliary functions: should you be agile? experiment research questions result Static Detection of Resource Contention Problems in Server-side script Amplifying Tests to Validate Exception Handling Code A tactic-centric approach automating traceability of quality concerns June 6 Keynote 1 沒怎麼聽懂，只記得講到了finance is not money但是沒聽懂這個和軟件有什麼 關係。 Cost Estimation for Distributed Software Project 講到他們試圖改善現有的模型去更精確地評估軟件開發的開銷。 他們會給 PM 建議之前的項目的歷史數據，然後對於新項目，他們建議歷史上已有 的項目的數據，從而幫助 PM 得到更精確的評估。他們試圖儘量減少項目評估對 PM 的經驗的需求，從而幫助即使經驗很少的 PM 也能準確評估項目的開銷。 他們的觀點： Context-specfic solutions needed! 我們需要更上下文相關的解決方案！ Early user paticipation is key! 早期用戶的參與是關鍵 Characterizing Logging Practices in Open-Source Software Common mistakes in logging messages 在日誌記錄中容易犯的錯誤 他們學習了歷史上的log記錄，然後試圖找到重複修改的輸出log的語句，確定log 中存在的問題。他們首先確定修改是事後修改。 通常的修改的比例（9027個修改） 45% 靜態文本 27% 打印出的變量 26% 調試等級verbosity 2% 日誌輸出的位置 他們發現有調試等級的變化，是因爲安全漏洞之類的原因，或者在開銷和數據 之間的權衡。 大多數對log的變量的修改都是爲了增加一個參數。他們之前的LogEnhancer是爲了 解決這個問題而提出的，通過靜態檢查，提醒程序員是否忘記了某個參數 對text的修改是因爲要改掉過時的代碼信息，避免誤導用戶。 他們的實驗是採用了基於code clone 的技術，找到所有log語句，然後找不一致 的clone，然後自動提出建議。 Combine Functional and Imperative Pgrm for Multicore Sw: Scala & Java 趨勢：到處都是多核，但是併發程序呢？ 他們研究的對象是Scala和Java，因爲可以編譯後確認 JVM 字節碼的語義。 Java: 共享內存 顯示創建的線程 手動同步 Wait/Notify機制 Scala: 高階函數 Actors, 消息傳遞 lists, filters, iterators while 共享狀態, OO import java.* 能從java導入任何庫 auto type inferance 自動類型推導 實驗的參與者都經過4周的訓練，實驗項目是工業等級的開發項目 結果： scala 的項目平均比java多花38%的時間，主要都是花在Test和debug上的時間。 程序員的經驗和總體時間相關，但是對test和debug沒有顯著影響。 scala的爲了讓編程更有效率的設計，導致debug更困難。比如類型推導，debug 的時候需要手動推導，來理解正在發生什麼。 scala的程序比java小，中位數2.6%，平均15.2% 性能比較： 單核：scala的線性程序的性能比java好 4核： scala 7s @ 4 threads java 4si @ 8 threads median 83s scala 98s java 32core: best scala 34s @ 64 threads 結論 java有更好的scalability scala類型推導 45%說對攜帶碼有幫助 85%說導致程序錯誤 調試 23%認爲scala簡單 77%認爲java簡單 multi-paradigram are better Sound Empirical Evidence in Software Testing Test data generation 測試數據自動生成 Large Empirical Studies - not always possible For open source software - big enough Identifing Linux Bug Fixing Patch current practice: manual Current research: keywords in commits link bug reports in bugzilla Try to solve classification problem issue pre-identified post-identified data from commit log feature extraction text pre-process stemmed non-stop words model learning research questions Active Refinement of Clone Anomaly Reports motivating code clones, clone groups clone used to detect bugs anomaly : inconsistent clone group many anomaly clone are note bug, high false positive approach reorder by sorted bug reports June7 Keynotes 2: Sustainability with Software - An Industrial Perspective Sustainability Classic View: Idenpendent view with overlap Social Environment Economic Nested viw Environment Social Economic Triple bottom line economic -global business, networks , global econ env natural res, climate change, population grow social awareness, connectivity, accountability Green IT reduce IT energy more than 50% cooling - doing nothing mini e-waste: not properly recycled 80% in EU 75% in US foster dematerialization In-Memory Technology: Expected Sustainable Benefits What can we do? consider all software lifecycle phases in your design avoid energy expensive behavior in your codes design lean architectures Green by IT 2% green IT 98% green IT On How Often code is cloned across repositories Line based hashing code clone detection never do anything harder than sorting hashing a window of 5 lines of normalized (tokenized) code, dropping 3/4 of the hashing 把ccfinder一個月的工作縮短到了3, 4天。沒有比較presion和recall。 14% type1 16% type2 17% type3 (not really type2) Graph-based analysis and prediction for sw evolution graph are everywhere internet topology social net chemistry biology in sw - func call graph - module dependency graph developer interaction graph - commit logs - bug reports experiment 11 oss, 27~171 release, > 9 years predictors NodeRank similar to pagerank of google measure relative importance of each node func call graph with noderank compare rank with severity scale on bugzilla correlation between noderank and BugSeverity func level 0.48 ~ 0.86 varies among projects. model level > func level ModularityRatio cohesion/coupling ratio: IntraDep(M)/InterDep(M) forecast mantencance effort use for identify modules that need redesign or refactoring EditDistance bug-based developer collaboration graphs ED (G1,G2)=|V1|+|V2|-2|V1交V2|+|E1|+|E2|-2|E1交E2| use for release planning resource allocation graph metrics graph diameter average node degree indicates reuse clustering coefficient assortativity num of cycles Conclusion \"Actionable intelligence\" from graph evolution studie 11 large long-live projs predictors identify pivotal moments in evolution What make long term contributors: willingness and opportunity in OSS OSS don't work without contributors form community mozilla (2000-2008) 10&#94;2.2 LTC <- 2 order -> 10&#94;4.2 new contributors <- 3.5 order -> 10&#94;7.7 users gnome (1999-2007) 10&#94;2.5 LTC <- 1.5 order -> 10&#94;4.0 new contributors <- 3.5 order -> 10&#94;6.5 users approach read issues of 20 LTC and 20 non- LTC suvery 56 (36 non- LTC and 20 LTC ) extract practices published on project web sites summeray Ability/Willingness distinguishes LTCs Environment macro-climate popularity micro-climate attention bumber of peers performance of peers regression model newcomers to LTC conversion drops actions in first month predicts LTCs 24% recall 37% precision develop of auxiliary functions: should you be agile? a empirial assessment of pair programming and test-first programming can agile help auxiliary functions? experiment pair vs solo test-first vs test-last students vs professors research questions r1: can pair help obtain more correct impl r2: can test-first r3: dst test1 encourage the impl or more test cases? r4: does test1 course more coverage result test-first higher coverage non change with correctness pair improve on correctness longer total programming time Static Detection of Resource Contention Problems in Server-side script Addressed the race condition of accessing database or filesystem of PHP Amplifying Tests to Validate Exception Handling Code 異常處理的代碼不但難寫，而且難以驗證。各種組合情況難以估計，尤其是手機 系統上。 A tactic-centric approach automating traceability of quality concerns tactic traceability information models","tags":"life","loc":"//farseerfc.github.io/icse2012.html","title":"ICSE 2012"},{"text":"Mining Software Repository 2012 @ ICSE 參加了今年的 MSR ，會場在University of Zurich。一大早來到大學，註冊有點 小插曲，顯然瑞士人搞不清楚中國人的名字，3個楊（Yang）姓的中國人的名牌 被搞錯了。然後堀田學長的所屬被寫作了\"Japan, Japan\"，成爲了全日本的代表。 MSR (MicroSoft Research) talk @ MSR (Mining Software Repositories) 首先是來自微軟亞洲研究院（MicroSoft Research @ Asia, MSR Asia）的Keynots， 於是就變成了 MSR 在 MSR 的演講。 MSR 的張冬梅（Dongmei Zhang）女士的演講 分爲關於Software Analysis和 XIAO 的兩部分。 XIAO 是 MSRA 開發的Code Clone Detector，似乎我要給井上研做的就是這個。想更多瞭解Xiao的細節，不過張女士 演講結束的時候的鼓掌導致了話筒的小故障。 Towards Improving BTS with Game Mechanisms 感覺這篇的內容基本上就是關於 http://www.joelonsoftware.com/items/2008/09/15.html 這裏寫到的東西，然後說同樣的理論是否可以用於Issue Tracking之類的事情上。 個人感覺這個意義不大，stackoverflow之所以成功是因爲它把開源社區本身就 具有的名譽體系具現化了，本着大家都喜歡被別人奉爲大牛的心態，就如同 wikipedia一樣。同樣的理論如果用於公司內部的Issue Tracking系統上，會得到 完全不同的東西吧。就像 MSDN 的組織方式雖然和wikipedia是一樣的，但是在 MSDN 裏找信息的感覺和在wikipedia完全不一樣。個人不太看好這個方向。 GHTorrent 這篇的slide在這裏可以看到： http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524 Data exporter for github. Github的主要數據，代碼，已經可以通過git接口 獲得了，wiki是git的形式保存的。所以這個項目的目的就是暴露別的數據，主要 是issue tracking，code comments，這種。代碼訪問github api，然後用分佈式 實現以克服api的限制，然後提供torrents形式的history下載。github api獲得 的json數據以bson的形式保存在MongoDB裏，解析過的有了Schema之後的數據保存 在MySQL裏並可以導出 SQL 。 個人的想法，覺得數據如果能夠更統一，全部存在Git裏或許更好，像Wiki一樣。 同樣是要暴露全部歷史記錄的目的，用Torrent自己實現的歷史遠不如用Git的 接口實現的歷史記錄方便吧，git blame之類的也更方便追蹤code comment之類的 作者信息。當然對git的raw date直接讀寫，需要對git的內部原理有足夠的理解， 或許只有github的人有這種能力了。 Topic Mining 用得兩個參數， DE 和 AIC ，完全不能理解，過後研究。實驗針對了Firefox, Mylyn, Eclipse三個軟件。試圖從Repo中分析源代碼的identifier和comments， 找到topic和bug之間的關係，比如怎樣的topic更容易導致bug。得出的結論似乎 也很曖昧，只是說核心功能被報告的bug更多，但是不知道原因。這只能表示核心 功能受到更多關注和更多測試吧，並不能說明核心功能就容易產生bug。 不過這個的Slide做得很漂亮，很容易理解。 SeCold A linked data platform for mining software repositories 沒聽懂這個項目的目的。 The evolution of software 第二天的Keynotes，關於將Social Media和Software Development相結合的想法。 或許就是Github賴以成功的基礎。講到代碼中的comment, Tags, uBlog, blog之類 的social的特性和 IDE 的融合的趨勢。 Do Faster Releases Imporve Software Quality? 使用Firefox作爲例子。 結論是快速發佈導致bug更多，更容易crash，但是bug更快得到修復，並且用戶 更快轉向新的發佈。 Security vs Performance Bugs in Firefox Performance bugs are regression, blocks release. 一些感想 基於自然語義分析的commit分割 經常工具（比如git）的使用者並沒有按照工具設計者的意圖使用工具，這給 MSR 帶來很多困難。舉個例子，git有非常完美的branch系統，通常期望git的使用者 能夠在一次commit裏commit一個功能，比如一個bug的修復，或者一個feature的 添加，但是事實上經常有很多邏輯上的commit被合併在一個裏面了。 或許這不是使用者的錯，而是工具仍然不夠人性的表現。或許我們可以自動把 一次的commit按照語義分割成多個。 分割之後，可以更容易地把issue和commit關聯，也更容易組織更多的研究。 關於這次發表中大家用的slides系統 題目爲\"Incorporating Version Histories in Information Retrieval Based Bug Localization\"的人用的slide是beamer的。公式很多，overlay很多，列表 很多，圖片很少，典型的beamer做出的slide。思維導圖用得很不錯。今天一天 有至少3個slide是用beamer做的。 題目爲\"Towards Improving Bug Tracking Systems with Game Mechanisms\" 的人用了prezi，圖片很多，過度很多。但是比如沒有頁號沒有頁眉頁腳，正式 會議的場合不太方便。 至少有六個以上用了Apple Keynotes，Keynotes做出來的東西真的和Powerpoint 做出來的很難區別，其中兩個人用了初始的主題所以才看出來。 剩下的自然是 PPT 。 MSRA 的張女士做的雖然是 PPT ，倒是有很多beamer的感覺， 比如頁眉頁腳和overlay的用法。這些如果都是 PPT 做出來的，會多很多額外的 人力吧。 值得一提的是有一個題目爲\"Green Mining: A Methodology of Relating Software Change to Power Consumption\"的人的slide全是\"劣質\"的手繪漫畫， 效果意外地好，很低碳很環保很綠色很可愛。具體效果可以參考下面的動畫，雖然 現場看到的不是一個版本： http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv 微軟是個腹黑娘！ 嘛雖然這也不是什麼新聞了。 MSR2012 的Mining Challenge的贊助商是微軟，管理 組織者來自微軟研究院，獎品是Xbox和Kinect。然後今年的題目是： Mining Android Bug 我看到了微軟滿滿的怨氣……","tags":"life","loc":"//farseerfc.github.io/msr2012.html","title":"MSR 2012 @ ICSE"},{"text":"簡介 Pyssy 是用於 上海交通大學 飲水思源站 的一系列 Python 腳本和工具。 Pyssy 被有意設計爲既可以託管寄宿在 SAE [1] 上，也可以在單機上獨立使用。 項目地址： http://pyssy.sinaapp.com/ Github上的源代碼地址： https://github.com/yssy-d3/pyssy [1] Sina App Engine ，新浪雲平臺，類似 Google App Engine 的東西。 依賴關係 Pyssy 使用 Flask 作爲網頁服務器， 並且使用 Memcached 或者 Redis 作爲抓取 水源Web 的緩存。 SAE Python 環境下請開啓 Memcached 支持。 本地環境下請安裝 Redis-py 並運行 redis-server 服務器程序。","tags":"python","loc":"//farseerfc.github.io/pyssy.html","title":"Pyssy 項目"},{"text":"今天在GitHub上閒逛的時候看到一個叫做 PyRuby 的項目。項目的Readme說得很好： PyRuby - Some Ruby for your Python! PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful. Usage All you have to do is import the ruby module: import ruby From now on you should be able to write Ruby code within a regular Python module. An example: 1.upto(10) { |n| puts n } 甚至 PyPI 上還有這個項目的包。 一開始我還以爲這又是一個野心勃勃的基於PyPy的Ruby實現，或者某種trick在Python裏面直接調用Ruby解釋器。 然後我想看看這個的源代碼 只有一個ruby.py文件，內容是： # -*- coding: utf-8 -*- print ( \"\"\" `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:` .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms. `:ohmdys+//::/::--::::////:-.```......`````.://:-` `/dNs. .+hNds:`-:-:///::------::///++///:--....--::///::-`.///. `oMm/ /hNmo.` `` `....``````````` ...------:::-:/+/-.:/:` /NMs oMd/` `::::--.---://+` //` `````-:::::+/-`::.` :NM+ yN` -+.` `/` o. ``::.-:. `` :NN: :Nm - ./ : `.-://///:-. `-` `` :NN- /NM/ .-:::-.` `/ `:sdmdhyMMMMMMNNmy/` :mNo` :hMd: /dmddddNNmdy+-. `smmy/-```hMMMMMMMhydm/ `-.`` `...:mMm+. -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+- dMN-`-+hmmmmdhhhhdddmMN-`-/o: .-::::/oydms- oNMo:+/::. ``...--:/+ohNMNhs- :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms. .MMo:/`o:.:+sso+:-` sM+ ./-` /mNh+-....-/ymNNdo::--/shd+` -`:mm: /MM-o ./ ohhsooohNmy::sh. `yM/ `:oyyyyyyhys+:.` hy `/Nh` : -NN. -MM// -: `` y: odddhh+ -omNh- `--.` `` ```` .:ohMMs. +Ms / yMo hMoo .+. :Mh ```` `/hNd/.` ohdddy::...`..` `-/sdmdyo+NMNh+- :Mh / sMs .mmh:..:. :NMm `-/dMNM+ ./+++/:`.hM:`.````.` `-/shmNmh+-` /Mmooso.hM/ .: `mM/ .mNs://: .NMNMs- -:-.`/+-sms. ` `shyyyhy`sNd` `.:+sdmmmdMM-. .oNM+ :m/ `s``yMh -mMo . sMNdMNNh+-. .ydyoyy` ``+o::+shdddhs+:-.:MM.`.-+hNMMh- `.`-/::dNs` -NM- mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.` `/mMMdmmddNMm+` ..-/hNh- sMy NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs `..:+ymMMMMd+--yNh. `+hNh: -Mm NMMM/yMh -NM-`..--:NMo:--.`+My :MNoydmNMMNmhdMh` -dNs` `yMd: `MN mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/ yMy` MN yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-. `yMMNs. /My `MN :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM- ./hNNy- /Nd` -Mh dMydMmsNMNdNNMMmmmNMMMdddhys+yMo`` /Nm: `:yNNdo. .sNd. +Ms .mMsMN::NN:.:MN: `.+NM. +Mo +Mm+ymNdo- .omm+` yM: .hNMd+:sMN. oMm. oMo +Mh ```.:+shMNmy+-``.-:-..-//-`:yNmo` mM. :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/` .Mm `` .-:/+osyyhhddddddddddhhyysoo+/:-. `./+//--+oo/--+ymmy/. :Mh .: `+:` `.------------` ```-////:/++/:../ydNdo:` +Ms `/` :+o+:-``` ``..-::///++///:-.`-+ydNdo:` oMs :/:.`` `..---.``` ````````..-:/:::---.` `-ohmmh+:` /Mh .://///:::-----.-----.......` `-+hmmy+- sMy` ``````-+ydmy+- /mNs-` `./ohmNMNNNmy+- /yNmho/:.``````````.-:/+syhdNmdyso+/-.` `:+ydmNMNNNNNNNNNmdhys+/:.` ``.....` LOL U MAD? \"\"\" ) import sys sys . exit ( 1 ) 是的……的確……這種嘗試把Python和Ruby放在一起的想法絕對是瘋了……","tags":"python","loc":"//farseerfc.github.io/mix-ruby.html","title":"PyRuby"},{"text":"這兩天在飲水思源的C板，關於C++模板的類型轉換的一個討論，後面是我的解答。 討論地址 http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html 原問題 今天在書上看到模板演繹的時候可以允許cast-down，於是我寫了個東西： template < bool _Test , class _Type = void > struct enable_if { }; template < class _Type > struct enable_if < true , _Type > { typedef _Type type ; }; class A { }; class B : A { }; template < typename T > struct traits { static int const value = false ; }; template <> struct traits < A > { static int const value = true ; }; template < typename T > void f ( T , typename enable_if < traits < T >:: value >:: type * = 0 ) { } template <> void f < A > ( A , enable_if < traits < A >:: value >:: type * ) { } template < typename T > class BB {}; template < typename T > class DD : public BB < T > {}; template < typename T > void ff ( BB < T > ) {}; int main ( int argc , char * argv []) { A a ; B b ; DD < long > dd ; //f(b); ff ( dd ); } 奇怪的是重載決議的時候， f 的情況下它就不讓我特化的 f<A> 進來。 但是在 ff 的情況下， ff< BB <long>> 卻進來了。 在 VC10 和 GCC3 .4下測試 我的解答 我們來設身處地地作爲編譯器，看一遍到底發生了什麼。 約定符號 # : A#B 是把 B 帶入 A<T> 的參數 T 之後實例化得到的結果。 首先看ff的情況。 DD < long > dd ; 處理到這句的時候，編譯器看到了 DD <long> 的實例化，於是去實例化 DD #long ，繼而實例 化了 BB #long 。 ff ( dd ); 這句，首先計算重載函數集合。 第一步，需要從參數 DD #long -> BB <T> 推斷 ff<T> 的 T 。根據函數模板參數推斷規則： ``class_template_name<T>`` 類型的參數，可以用於推斷 ``T`` 。 於是編譯器推斷 T 爲 long 。這裏就算不是 BB 而是完全無關的 CC 都可以推斷成功，只要 CC 也 是一個 CC <T> 形式的模板。 第二步，模板特化匹配。因爲只有一個模板，所以匹配了最泛化的 ff<T> 。 第三步，模板實例化。 推斷了 long -> T 之後，編譯器實例化 ff#long 。 重載函數集合： {ff#long} 然後重載抉擇找到唯一的可匹配的實例 ff#long ，檢查實際參數 DD #long 可以隱式轉換到 形式參數 BB #long ，從而生成了這次函數調用。 再來看f的情況。 f ( b ); 計算候選重載函數集合。 第一步，對所有 f 模板推斷實參。根據函數模板參數推斷規則： 帶有 ``T`` 類型的參數，可以用於推斷 ``T`` 。 於是 B -> T 被推斷出來了。 第二步，模板特化匹配。 這裏 B 不是 A ，所以不能用 f<A> 特化，只能用 f<T> 模板。 第三步，模板實例化。 B 帶入 f<T> 實例化成 f#B 的過程中，實例化 traits#B 。 由於沒有針對 B 的特化，所以用 traits<T> 模板， traits#B::value=false ，進而 enable_if#false 沒有 type ，出錯。 唯一的模板匹配出錯，重載函數集合爲空， SFINAE 原則不能找到合適的匹配，於是報錯。","tags":"c","loc":"//farseerfc.github.io/discuss-cpp-template-downcast.html","title":"關於C++模板的類型轉換的討論"},{"text":"似乎一夜之間所有的 極客們 都 有了 自己 的 Github主頁 和 Octopress 博客。就像所有人在他們的博客中指出的，靜態博客的確比傳統的WordPress方式具有更多優勢。 自從看到這些 我就一直在想着自己搭一個 Octopress 。 但是似乎 Octopress 不適合我 一上手就被 Octopress的搭建步驟 煩到了。 RVM 是什麼？ rbenv 又是什麼？ 看來 Ruby 社區的快節奏發展已經超過了我的想象，他們似乎需要一套發行版管理器來調和不同版本之間的 Ruby 的兼容性問題。 雖然同樣的兼容性問題在 Python 社區也有 [1] ，不過總覺得 Python 至少還沒到需要一個發行版管理器的程度 [2] 。 真正的問題是我手上還沒有一個可以讓我隨便玩的 Linux 環境（真的想要……）。 而無論是 RVM 還是 rbenv 似乎都只支持 Unix/Linux/MacOSX 。 身爲極客就註定不能用 Windows 麼？（或許是的……）。 剩下的問題就是 Ruby 和 Python 兩大陣營的對立問題了。我不熟悉 Markdown ， 相對來說比較喜歡 ReST 。 似乎無論哪邊都要 依賴 Pygments 作爲代碼着色器，那麼其實 Rubyist 也至少需要安裝 Python 。 我傾向於不依賴任何 Ruby 組件，最好沒有 C 擴展 的純 Python 實現。 於是我開始在 Github 上找 Python 的靜態博客引擎。 Flask 的作者 mitsuhiko 寫的 rstblog 看起來不錯，不過似乎沒有多少人在用。 Hyde 似乎很完善，不過默認的標記語言是 MarkDown ， 又依賴於幾個 Ruby 組建，而且官方網站的設計實在太前衛。 最終我看到了 Pelican 。 [1] 比如 Python 2.x 與 3.x 之間看似難以跨越的鴻溝，以及 PyPy 、 CPython 、 Stackless 、 Cython 等各個實現之間的微妙差別。 [2] 是的，我們有 easy_install ，我們有 pip ， 不過這些都是包管理器，都是裝好特定的Python實現之後的事情。 Python實現本身還不需要包管理器來管理。 Python 的版本問題基本上也只需要 2to3.py 和 3to2.py 這樣的輕量級轉換器就可以了，你不需要爲了安裝多個軟件而在硬盤裏留下多個不同版本的 Python 。 如果爲了引用的穩定性，你可以用 virtualenv ，不過這又是另一回事情了。 那麼就 Pelican 吧 對我而言， Pelican 相比於 Octopress 有幾個好處： 純 Python 實現。 這意味着我可以換用任何 Python 解釋器而不必擔心兼容性問題。比如我就換成了 PyPy 。 多語言支持。因爲 Pelican 的作者似乎是個法國人。不過這個似乎大部分人不需要…… 我是想儘量把一篇博客寫成三種語言作爲鍛鍊吧。 ReST 。這樣我就可以用 Leo 的 @auto-rst 直接寫 ReST了。簡單方便快捷有效。 不過似乎 Pelican 的關注度不如 Octopress 那麼高，現在一些部分還有細微的問題： pelican-import 從 WordPress 導入的時候對中文、日文的支持似乎很成問題。 日期格式、時區、字符集、和多語言功能的結合度還不夠。 我在嘗試改善它。 模板還不夠豐富。 插件也不夠多…… 希望這麼優秀的工具能夠受到更多關注，以上這些問題都是增加關注度之後很快就能解決的問題。 我的設置 settings.py 安裝 Pelican 很容易，一句話就夠了： $ pip install pelican 然後把文章寫成ReST的格式，放在`pages`文件夾裏面。(重新)生成只要： $ pelican -s settings.py 上傳到 Github: $ git commit -am \"Commit message\" $ git push 就這麼簡單。附上我的配置文件： # -*- coding: utf-8 -*- TIMEZONE = 'Asia/Tokyo' DATE_FORMATS = { 'en' :( 'usa' , '%a, %d %b %Y' ), 'zh' :( 'chs' , '%Y-%m- %d , %a' ), 'jp' :( 'jpn' , '%Y/%m/ %d (%a)' ), } # windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx LOCALE = [ 'usa' , 'chs' , 'jpn' , # windows 'en_US' , 'zh_CN' , 'ja_JP' ] # Unix/Linux DEFAULT_LANG = 'zh' SITENAME = 'Farseerfc Blog' AUTHOR = 'Jiachen Yang' DISQUS_SITENAME = 'farseerfcgithub' GITHUB_URL = 'https://github.com/farseerfc' SITEURL = 'http://farseerfc.github.com' TAG_FEED = 'feeds/ %s .atom.xml' SOCIAL = (( 'twitter' , 'http://twitter.com/farseerfc' ), ( 'github' , 'https://github.com/farseerfc' ), ( 'facebook' , 'http://www.facebook.com/farseerfc' ), ( 'weibo' , 'http://weibo.com/farseerfc' ), ( 'renren' , 'http://www.renren.com/farseer' ), ) TWITTER_USERNAME = 'farseerfc' THEME = 'notmyidea' CSS_FILE = \"wide.css\" DEFAULT_CATEGORY = 'Others' OUTPUT_PATH = '.' PATH = 'posts'","tags":"python","loc":"//farseerfc.github.io/try-pelican.html","title":"嘗試一下 Pelican"},{"text":"導入自 renren From: Bill Gates '— Sent: Sunday, January 24, 1999 8:41 AM Jeff Westorinon; Ben Fathi ; TO : Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder Subject: ACPI extensions One thing I find myself wondering about is whether we shouldn't try and make the \" ACPI \" extensions somehow Windows specific. It seems unfortunate if we do this work and get our partners to do the work and the result is that Linux works great without having to do the work . Maybe there is no way to avoid this problem but it does bother me. Maybe we could define the APIs so that they work well with NT and not the others even if they are open. Or maybe we could patent something relaled to this. From: http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/ PX03020 .pdf 如果這就是我至今在Xen4.0上得不到 ACPI 3.0的完善支持的原因，那麼我詛咒Bill Gates！","tags":"renren","loc":"//farseerfc.github.io/if-we-do-this-work.html","title":"\"…if we do this work … \" —Bill Gates"},{"text":"導入自 renren 據說是一道微軟的面試題。如題，寫程序，讓Windows的任務管理器中的性能監視器呈現正弦曲線。 潛心鑽研良久，得代碼：（java） public class sincpu { private static final int cycle = 1024 , tick = 256 ; public static void main ( String [] args ) throws InterruptedException { for ( int i = 0 ;; i ++){ work ( calcNextSleep ( i % cycle )); sleep ( tick - calcNextSleep ( i % cycle )); } } private static long calcNextSleep ( long i ){ return ( int )( Math . sin (( double ) i * 2 * Math . PI / cycle ) * tick + tick ) / 2 ; } private static void sleep ( long sleepTime ) throws InterruptedException { if ( sleepTime < 2 ) Thread . yield (); else Thread . sleep ( sleepTime ); } private static void work ( long period ) { long start = System . currentTimeMillis (); for (;;){ Math . sin ( 1 ); if ( System . currentTimeMillis () - start >= period ) break ; } } } 多核 CPU 上測試時要注意關掉一個 CPU ：","tags":"renren","loc":"//farseerfc.github.io/sine-cpu.html","title":"寫程序讓 CPU 佔用率保持正弦函數"},{"text":"導入自 renren 看到陳驫同學很有感想的一篇神創論與命運日誌，覺得近日很久沒有看到這樣的評論了。想說幾句自己的觀點。 首先我認爲，神創論與宿命論沒有多少關聯，甚至進化論者相較於神創論者更容易接受宿命論的觀點。因爲神創論主張意志的存在，人所具有的個體意志與神的意志，因此在神創論者的眼中事件的結果是可以通過意志來改變的，亦即如果我從物理樓11樓跳下，那麼我就可以改變自己死亡時間的宿命。上帝的意志同樣可以左右事件的結果，也就是所謂的宿命不復存在。而進化論者不承認意志獨立於物質世界的存在，你我的思考、行爲，都受到物理學法則諸如量子力學的約束，這就引出了北大物理系教授的那句\"宇宙中的一切都是可以計算的\"，亦即宿命論。如我我選擇現在從物理樓上跳下，我這一行爲並不是處於個人的獨立意志，乃是想證明這一點，亦即我跳樓這一舉動是有其背後的動機與原因的，就如同計算機的輸入必然導致了輸出，宿命的必然終結於此。 其次，關於事件的複雜度所導致的隨機化，在大量混沌隨機中也存在着如統計學和隨機分形學這樣的規律，並不是否認宿命的充分理由。 關於神創論的合理性問題。我認爲是否相信神的存在只是一個boolean二值問題，它爲true爲false本身並不重要，重要的是確定它的取值之後得到的推論與結果。如果否認神的存在，如現代數學這樣的完美又何以存在，進化論者的解釋是事物最終會向着更好更高級的方向發展，產生現代數學乃至現代科學是發展的必然。而這種論調顯然有悖於物理中以熱力學第二定律爲首的，預言事物會隨時間推演愈發混亂的論斷。更進一步，甚至整個人類、整個生物系統的存在都是有悖於熱力學推論的現象，是某種理論只能以\"小概率事件\"解釋的現象。 神創論的核心觀點之一，是神的唯一存在性，按照鄒恆明的比喻，這就如同數學中集閤中元素的的唯一性一般至關重要。數學乃至近代科學的發展，其起源在於這種對神性的探求，而不僅僅是好奇心就可以解釋的。反觀東方文化中數學的發展，開始時領先於西方科學千餘每年，但是始終作爲一種craft-oriented的實用主義學科。可以說沒有了神的唯一性支持，人們就不能確信自己能找到這樣一種完美高效的學科，只能在實用的基礎上發展其基礎算數。可以想象，沒有神的完美與唯一性，數學必將發展成現代化學或者微軟軟件這樣，龐大而充滿特例，到處都是修補與查表，怎麼會像現在的完美、簡潔與和諧。 神創論者並不是將難題推與\"神\"然後放任不管，他們相信神是最爲理智的存在，創人時人同樣得到了神的智慧和理智，也就是神可以用人的理智來理解。 引用牛頓《自然哲學的數學原理》中終章的話\"太陽、恆星、行星的這個極精緻的結構不可能存在，除非通過一個有理智的和有權能的存在的設計和主宰……他不是作爲宇宙的靈魂，而是作爲一切的主宰而統治所有……\" 以上…… (發現最近的哲理思維果然慢了不少，寫作思緒也一片混亂&#94;_&#94;)","tags":"renren","loc":"//farseerfc.github.io/some-thought-on-creationism.html","title":"關於神創論的一些見解"},{"text":"Imported from renren I know, I know I\"ve let you down I\"ve been a fool to myself I thought that I could live for no one else But now through all the hurt and pain It\"s time for me to respect The ones you love mean more than anything So with sadness in my heart Feel the best thing I could do It\"s end it all And leave forever What\"s done is done it feel so bad What once was happy now is sad I\"ll never love again My world is ending I wish that I could turn back time Cause now the guilt is all mine Can\"t live without the trust from those you love I know we can\"t forget the past You can\"t forget love and pride Because that it\"s killing me inside It all returns to nothing It all comes tumbling down tumbling down tumbling down It all returns to nothing I just keep letting me down letting me down letting me down In my heart of hearts I know I could never love again I\"ve lost everything everything Everything that matters to me matters in this world I wish that I could turn back time Cause now the guilt is all mine Can\"t live without the trust from those you love I know we can\"t forget the past You can\"t forget love and pride Because that it\"s killing me inside It all returns to nothing It just keeps tumbling down tumbling down tumbling down It all returns to nothing I just keep letting me down letting me down letting me down Up up up up up Tumbling down tumbling down tumbling down Up up up up up Letting me down letting me down letting me down Up up up up up Tumbling down tumbling down tumbling down Up up up up up Letting me down letting me down letting me down","tags":"renren","loc":"//farseerfc.github.io/EVA-Komm-susser-Tod-en.html","title":"EVA -Komm,susser Tod"},{"text":"* Use WASD ←→ to move，need WebGL support","tags":"life","loc":"//farseerfc.github.io/marry-me-en.html","title":"Will You Marry Me?"},{"text":"* WASD ←→ で移動する，WebGL が必要","tags":"life","loc":"//farseerfc.github.io/marry-me-jp.html","title":"嫁になってくれませんか？"},{"text":"* 用 WASD ←→ 移动，需要 WebGL 支持","tags":"life","loc":"//farseerfc.github.io/marry-me-zhs.html","title":"嫁给我好么"},{"text":"Contents June 6 Keynote 1 Cost Estimation for Distributed Software Project Characterizing Logging Practices in Open-Source Software Combine Functional and Imperative Pgrm for Multicore Sw: Scala & Java Sound Empirical Evidence in Software Testing Identifing Linux Bug Fixing Patch Active Refinement of Clone Anomaly Reports June7 Keynotes 2: Sustainability with Software - An Industrial Perspective Green IT What can we do? Green by IT On How Often code is cloned across repositories Graph-based analysis and prediction for sw evolution graph are everywhere predictors Conclusion What make long term contributors: willingness and opportunity in OSS approach summeray develop of auxiliary functions: should you be agile? experiment research questions result Static Detection of Resource Contention Problems in Server-side script Amplifying Tests to Validate Exception Handling Code A tactic-centric approach automating traceability of quality concerns June 6 Keynote 1 没怎么听懂，只记得讲到了finance is not money但是没听懂这个和软件有什么 关系。 Cost Estimation for Distributed Software Project 讲到他们试图改善现有的模型去更精确地评估软件开发的开销。 他们会给 PM 建议之前的项目的历史数据，然后对于新项目，他们建议历史上已有 的项目的数据，从而帮助 PM 得到更精确的评估。他们试图尽量减少项目评估对 PM 的经验的需求，从而帮助即使经验很少的 PM 也能准确评估项目的开销。 他们的观点： Context-specfic solutions needed! 我们需要更上下文相关的解决方案！ Early user paticipation is key! 早期用户的参与是关键 Characterizing Logging Practices in Open-Source Software Common mistakes in logging messages 在日志记录中容易犯的错误 他们学习了历史上的log记录，然后试图找到重复修改的输出log的语句，确定log 中存在的问题。他们首先确定修改是事后修改。 通常的修改的比例（9027个修改） 45% 静态文本 27% 打印出的变量 26% 调试等级verbosity 2% 日志输出的位置 他们发现有调试等级的变化，是因为安全漏洞之类的原因，或者在开销和数据 之间的权衡。 大多数对log的变量的修改都是为了增加一个参数。他们之前的LogEnhancer是为了 解决这个问题而提出的，通过静态检查，提醒程序员是否忘记了某个参数 对text的修改是因为要改掉过时的代码信息，避免误导用户。 他们的实验是采用了基于code clone 的技术，找到所有log语句，然后找不一致 的clone，然后自动提出建议。 Combine Functional and Imperative Pgrm for Multicore Sw: Scala & Java 趋势：到处都是多核，但是并发程序呢？ 他们研究的对象是Scala和Java，因为可以编译后确认 JVM 字节码的语义。 Java: 共享内存 显示创建的线程 手动同步 Wait/Notify机制 Scala: 高阶函数 Actors, 消息传递 lists, filters, iterators while 共享状态, OO import java.* 能从java导入任何库 auto type inferance 自动类型推导 实验的参与者都经过4周的训练，实验项目是工业等级的开发项目 结果： scala 的项目平均比java多花38%的时间，主要都是花在Test和debug上的时间。 程序员的经验和总体时间相关，但是对test和debug没有显著影响。 scala的为了让编程更有效率的设计，导致debug更困难。比如类型推导，debug 的时候需要手动推导，来理解正在发生什么。 scala的程序比java小，中位数2.6%，平均15.2% 性能比较： 单核：scala的线性程序的性能比java好 4核： scala 7s @ 4 threads java 4si @ 8 threads median 83s scala 98s java 32core: best scala 34s @ 64 threads 结论 java有更好的scalability scala类型推导 45%说对携带码有帮助 85%说导致程序错误 调试 23%认为scala简单 77%认为java简单 multi-paradigram are better Sound Empirical Evidence in Software Testing Test data generation 测试数据自动生成 Large Empirical Studies - not always possible For open source software - big enough Identifing Linux Bug Fixing Patch current practice: manual Current research: keywords in commits link bug reports in bugzilla Try to solve classification problem issue pre-identified post-identified data from commit log feature extraction text pre-process stemmed non-stop words model learning research questions Active Refinement of Clone Anomaly Reports motivating code clones, clone groups clone used to detect bugs anomaly : inconsistent clone group many anomaly clone are note bug, high false positive approach reorder by sorted bug reports June7 Keynotes 2: Sustainability with Software - An Industrial Perspective Sustainability Classic View: Idenpendent view with overlap Social Environment Economic Nested viw Environment Social Economic Triple bottom line economic -global business, networks , global econ env natural res, climate change, population grow social awareness, connectivity, accountability Green IT reduce IT energy more than 50% cooling - doing nothing mini e-waste: not properly recycled 80% in EU 75% in US foster dematerialization In-Memory Technology: Expected Sustainable Benefits What can we do? consider all software lifecycle phases in your design avoid energy expensive behavior in your codes design lean architectures Green by IT 2% green IT 98% green IT On How Often code is cloned across repositories Line based hashing code clone detection never do anything harder than sorting hashing a window of 5 lines of normalized (tokenized) code, dropping 3/4 of the hashing 把ccfinder一个月的工作缩短到了3, 4天。没有比较presion和recall。 14% type1 16% type2 17% type3 (not really type2) Graph-based analysis and prediction for sw evolution graph are everywhere internet topology social net chemistry biology in sw - func call graph - module dependency graph developer interaction graph - commit logs - bug reports experiment 11 oss, 27~171 release, > 9 years predictors NodeRank similar to pagerank of google measure relative importance of each node func call graph with noderank compare rank with severity scale on bugzilla correlation between noderank and BugSeverity func level 0.48 ~ 0.86 varies among projects. model level > func level ModularityRatio cohesion/coupling ratio: IntraDep(M)/InterDep(M) forecast mantencance effort use for identify modules that need redesign or refactoring EditDistance bug-based developer collaboration graphs ED (G1,G2)=|V1|+|V2|-2|V1交V2|+|E1|+|E2|-2|E1交E2| use for release planning resource allocation graph metrics graph diameter average node degree indicates reuse clustering coefficient assortativity num of cycles Conclusion \"Actionable intelligence\" from graph evolution studie 11 large long-live projs predictors identify pivotal moments in evolution What make long term contributors: willingness and opportunity in OSS OSS don't work without contributors form community mozilla (2000-2008) 10&#94;2.2 LTC <- 2 order -> 10&#94;4.2 new contributors <- 3.5 order -> 10&#94;7.7 users gnome (1999-2007) 10&#94;2.5 LTC <- 1.5 order -> 10&#94;4.0 new contributors <- 3.5 order -> 10&#94;6.5 users approach read issues of 20 LTC and 20 non- LTC suvery 56 (36 non- LTC and 20 LTC ) extract practices published on project web sites summeray Ability/Willingness distinguishes LTCs Environment macro-climate popularity micro-climate attention bumber of peers performance of peers regression model newcomers to LTC conversion drops actions in first month predicts LTCs 24% recall 37% precision develop of auxiliary functions: should you be agile? a empirial assessment of pair programming and test-first programming can agile help auxiliary functions? experiment pair vs solo test-first vs test-last students vs professors research questions r1: can pair help obtain more correct impl r2: can test-first r3: dst test1 encourage the impl or more test cases? r4: does test1 course more coverage result test-first higher coverage non change with correctness pair improve on correctness longer total programming time Static Detection of Resource Contention Problems in Server-side script Addressed the race condition of accessing database or filesystem of PHP Amplifying Tests to Validate Exception Handling Code 异常处理的代码不但难写，而且难以验证。各种组合情况难以估计，尤其是手机 系统上。 A tactic-centric approach automating traceability of quality concerns tactic traceability information models","tags":"life","loc":"//farseerfc.github.io/icse2012-zhs.html","title":"ICSE 2012"},{"text":"Mining Software Repository 2012 @ ICSE I participated MSR of this year. We came to University of Zurich early in the morning. The registration got something wrong when it seems that Swisses cannot tell the difference among Asians so that name cards of 3 Chinese with family name of Yang are misplaced. And also the organization field of Hotta was Japan, Japan , as if he represented the Japan. MSR (MicroSoft Research) talk @ MSR (Mining Software Repositories) The first talk was the keynote given by Mrs Zhang from MSR (MicroSoft Research @ Asia), so it turned out to be MSR gave keynote of MSR . The talk was about Software Analysis and their clone detection tool called XIAO . XIAO was a clone detector developed by MSRA which can be used as a plugin for Microsoft Visual Studio. XIAO has two part, or system state: the statics state analysis all the clones which didn't consider the running time, while the dynamic state need real time response. The thing I need to develop for Samsung is something like dynamic mode. I wanted to know more about the internal details about XIAO but the talk was finished there. Towards Improving BTS with Game Mechanisms The contents of this talk is very much like this blog: http://www.joelonsoftware.com/items/2008/09/15.html The talk discussed whether the same game mechanism can be applied to the things like issue tracking or similar. From my point of view, it is useless to use game mechanism in this situation. The reason that stackoverflow can success lies on that they just captured the use of fade system in opensource community, as all hackers like to be approved as great hacker, as what is happening in Wikipedia. Whether the same theory can be applied in issue tracking systems inside a internal company is questionable. Although MSDN has basic the same structure as Wikipedia, the content of MSDN and Wikipedia have different involvement of users. So I myself didn't approve this research. GHTorrent They slide of this talk can be found from here: http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524 Data exporter for github. Main part of data of Github, namely the hosted code, are already exposed as git repos, and wiki of repos are stored in git repo. So the aim of this project is to expose other data such as issues, code comments, etc. The project access github api and fetch the needed data as distributed system in order to overcome the limitations of the github api. The project will provide download history as torrents. The json data from github api is stored as bson in MongoDB and the parsed data is stored in MySQL with schema. From my point of view, it will be better if the format of data can be uniformed and all data are stored in the git repo as wiki pages. As the history stored in git repo is more nature, and using git blame to trace author of code comments should also be more useful. Of course it is harder to read and write the raw data of git as we need more understanding of the internal format of git. Maybe only people from github can do this. Topic Mining I can not understand the two parameters, DE , AIC , used in this research, study this later. The experiment target of this research are Firefox, Mylyn and Eclipse. They are trying to analysis the identifiers and comments from source codes in software repos and find the relationship between topics and bugs, like what kind of topics are more likely to contain buggy codes. The result of this research is not so clear. Such as it said that the core functions of Firefox have more bug reports, but it said no reason about this. Maybe this only means that the core features are well tested, rather than that the core features are more buggy. But the slides showed by author are pretty and easy to understand. The evolution of software The keynote talk of the second day. It is about how should we combine the social media with software development. Maybe this is the reason why Github succeeded. In the talk she told about accessing tags, uBlogs, blogs etc. directly from Integrated Development Environments, or should we need cloud IDE such as Cloud9. Do Faster Releases Improve Software Quality? Used Firefox as example. The conclusion is that faster releases will lead to more bugs and more frequent crash, but bugs are get fixed more quickly and user will switch to new released more quickly. Security vs Performance Bugs in Firefox Performance bugs are regression, blocks release. Some of my thoughts Separation of commits based on Semantic analysis The user of some tools (such as git) are not following the design purposes of these tools which brings some difficulty to MSR . For example git has a prefect branch system, so it is desired for users of git to commit per topic. Commit per topic means that user send a commit for a single implementation of a feature or a bug fix, etc. If it is difficult to contain all modifications in a commit, then it should be in a separate branch and merged into master branch. But actually user tends to send very large commits, that contains many logical features, and they can not predict to open a new branch until a few commits. Maybe this is not the fault of the user of tools, this is the tools that are not smart enough. We should separate the commits according to the semantic topics inside a commit. About the slide systems used today The study with title Incorporating Version Histories in Information Retrieval Based Bug Localization used the slides made by beamer. It contains many equations, used many overlays are iterations, with few figures, is a typical beamer slide. It also used mindmap very well. There are at least 3 slides that are made by beamer today. The study with title Towards Improving Bug Tracking Systems with Game Mechanisms presented with prezi. It have many pictures and many transitions. But because of it is made by prezi, there are no headers and footers so no page numbers and section titles etc. This is not so convenient in such a official occasions because people need to refer to the page number in question session. There are at lease 6 presents used Apple Keynote. It is really difficult to tell the difference between slides made by PowerPoint and Keynote. 2 of them used the default theme of keynote. The rest are using PowerPoint. Mrs Zhang from Microsoft used PowerPoint but her slides looks like beamer very much such as the usage of footer and header and overlays. If these are made by PowerPoint that will involve many manually operations. It is worth to mention that the slides of a study with title Green Mining: A Methodology of Relating Software Change to Power Consumption are all badly drawn hand paintings. The effect of these slide are well received, they are green and clean and cute. You can refer to the following animation for the effect but it is not exactly the same version with what we saw : http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv Microsoft is MEANING It is not a news. But Microsoft is the sponsor of Mining Challenge, and the prize of this challenge will be Xbox and Kinect and the topic of this year is: Mining Android Bug I see what you are doing there Microsoft ……","tags":"life","loc":"//farseerfc.github.io/msr2012-en.html","title":"MSR 2012 @ ICSE"},{"text":"Mining Software Repository 2012 @ ICSE 今年の MSR を参加しました、会場はチューリッヒ大学にあります。朝早く大学に 着いて、登録するときちょっと事情をありました。スイス人は明らかに中国人 の名前をわからないから、３つの中国からの楊（Yang）の名札を間違えた。そ して堀田先輩の名札に\"Japan, Japan\"になって、日本代表になった。 MSR (MicroSoft Research) talk @ MSR (Mining Software Repositories) まず一番目のKeynoteはマイクロソフトアジア研究院(MicroSoft Research @ Asia , MSR Asia)のZhang氏が発表する、こうして MSR が MSR に発表するになった。 Zhangの発表はSoftware Analysisと XIAO の２つの紹介です。 XIAO はマイクロソフト が開発したCode Clone Detector、ある会社が私達に任せるのもこのようなシステム です。もっと詳しく知りたいが、実装に関わるものは言ってなかった。 Towards Improving BTS with Game Mechanisms これの内容は基本的にこのブロクに書いています： http://www.joelonsoftware.com/items/2008/09/15.html 同じ理論をIssue Trackingとかに応用できるかを言いました。個人的にこれは 意味ない気がします。stackoverflowの成功はOpen Software Communityにもと もとある名誉システムを具現化したですから、それを会社の中に応用するのは 難しい気がする。 GHTorrent この研究のスライドはこちらに： http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524 Data exporter for github. Githubの主なデータはコード、それは既にgitから アクセスできます、wikiはgitとして保存しているからそれも含まれている。 ですからこのプロジェクトの目的は他のデータを表せる、つまりissues, commit commentsなど。このプロジェクトはgithub apiを通じて、分布システムとして apiの制限を超える、そしてtorrentの形で歴史をdownloadできます。元のデータ はbsonとしてMongoDBの保存して、Schemaを追加したデータはMySQLに保存する。 わたしの意見では、データをgitのrepoの形で保存するの方がいいかもしれない。 今のwikiのように、そしてgitoliteも全てのデータをgit自身の中に保存している。 The evolution of software 二日目のkeynotes, social mediaをソフトウェア開発に巻き込めるについて 話しました。もしかしてこれはGithubの成功の理論かもしれない。 IDE の中に social mediaのアクセスを欲しいと言いました。 Do Faster Releases Imporve Software Quality? Firefoxを例として研究しました。 結論としては、早い発行はbugを多く持たされ、crashがもっと頻繁になるが、 bugの修復も早くなって、そしてユーザー側はもっと早く新しい発行に移動する ことをわかりました。 Security vs Performance Bugs in Firefox 性能に関するbugはregression テストが要る、そして発行を阻止する。 思いつき topicに基づいてcommitの分析と分割 よく使うツール（例えばgit）のユーザーはツールの設計者の意図を従って ツールを使うことはない、設計者が思った用途以外にも使っていることが多い、 それはMiningに対しては色々困難を持たされています。例えばgitには完璧な branch機能がある、通常にgitのユーザーが一つのcommitに一つの機能を実現 してほしい、例としてはbugの修復とか、機能の追加とか。それは難しいなら branchを使って、一連のcommitを一つのbranchになって、一つのbranchに一つ の機能を実現してほしい。それなのに、現状では、沢山の編集を一つのcommit に含まれていて、後の管理とか情報の収集とかが困難になってしまう。 それはユーザーの悪いと思わない、ツールの方がもっと頑張らないとユーザー は正しく使えない。もしcommitの時、自動的にcommitの内容を分析して、 その中にtopicによって分けて、ユーザーに推薦するのをてきたらいいなぁ、 と思っています。このように一つのcommitを多くに分割したら、commitの履歴 をもっと見やすくなって、続いて分析とかも便利になるはずです。 今回に皆使っているslideのシステム タイトルは Incorporating Version Histories in Information Retrieval Based Bug Localization の人が使っているのはbeamerです。数式が多くて、 overlayも多くて，iterateも多い、図だけ少ない、典型的にbeamerに作れそうな スライドです。mindmapの使いもうまい。今日の一日に少なくとも3個のslideは beamerで作られています。 タイトルは Towards Improving Bug Tracking Systems with Game Mechanisms の人はpreziを使いました、図が多くて、transitionも多い。但しスライド としては必要なページ数とかがなくて、このような国際会議の場合にはもっと 工夫をした方がいいかもしれな。 少なくとも六人以上はAppleのKeynoteをつかていまう。Keynoteによる作った スライドはPowerpointのになかなか区別しがたいですが、その中に二人は defaultのthemeを使ったからわかります、他の人は PPT に決してありえない アニメションを使っていますから、多分keynote。 残りは勿論Powerpointです。 MSRA の張さんが作ったのはpowerpointなんですけど、 すごくbeamerの感じがします、例えばheaderとfooterの使い方とか、overlay 見たいのものでページのitemを一つずつ展開するとか。それらを全部powerpoint で作るのは相当手間がかかりそうです。 ちなみに言いたいのは一つタイトルは Green Mining: A Methodology of Relating Software Change to Power Consumption のスライドは全部 下手 な手描きの漫画で表せている、火狐のアイコンさえ手描きする、効果は意外に 評判がいい。省エネでグリンで環境にいいで可愛らしい。具体的な効果は下の リンクから見えます、現場で見たのは別のバージョンなんですけど： http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv マイクロソフトは腹黒っ子! まぁ大したニュースではないですけど、 MSR2012 のMining Challengeのスバンサー はマイクロソフトで、商品はXboxとKinectですけど、今年のチャレンジのテーマは： Mining Android Bug マイクロソフトの殺意を感じしました。","tags":"life","loc":"//farseerfc.github.io/msr2012-jp.html","title":"MSR 2012 @ ICSE"},{"text":"Mining Software Repository 2012 @ ICSE 参加了今年的 MSR ，会场在University of Zurich。一大早来到大学，注册有点 小插曲，显然瑞士人搞不清楚中国人的名字，3个杨（Yang）姓的中国人的名牌 被搞错了。然后堀田学长的所属被写作了\"Japan, Japan\"，成为了全日本的代表。 MSR (MicroSoft Research) talk @ MSR (Mining Software Repositories) 首先是来自微软亚洲研究院（MicroSoft Research @ Asia, MSR Asia）的Keynots， 于是就变成了 MSR 在 MSR 的演讲。 MSR 的张冬梅（Dongmei Zhang）女士的演讲 分为关于Software Analysis和 XIAO 的两部分。 XIAO 是 MSRA 开发的Code Clone Detector，似乎我要给井上研做的就是这个。想更多了解Xiao的细节，不过张女士 演讲结束的时候的鼓掌导致了话筒的小故障。 Towards Improving BTS with Game Mechanisms 感觉这篇的内容基本上就是关于 http://www.joelonsoftware.com/items/2008/09/15.html 这里写到的东西，然后说同样的理论是否可以用于Issue Tracking之类的事情上。 个人感觉这个意义不大，stackoverflow之所以成功是因为它把开源社区本身就 具有的名誉体系具现化了，本着大家都喜欢被别人奉为大牛的心态，就如同 wikipedia一样。同样的理论如果用于公司内部的Issue Tracking系统上，会得到 完全不同的东西吧。就像 MSDN 的组织方式虽然和wikipedia是一样的，但是在 MSDN 里找信息的感觉和在wikipedia完全不一样。个人不太看好这个方向。 GHTorrent 这篇的slide在这里可以看到： http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524 Data exporter for github. Github的主要数据，代码，已经可以通过git接口 获得了，wiki是git的形式保存的。所以这个项目的目的就是暴露别的数据，主要 是issue tracking，code comments，这种。代码访问github api，然后用分布式 实现以克服api的限制，然后提供torrents形式的history下载。github api获得 的json数据以bson的形式保存在MongoDB里，解析过的有了Schema之后的数据保存 在MySQL里并可以导出 SQL 。 个人的想法，觉得数据如果能够更统一，全部存在Git里或许更好，像Wiki一样。 同样是要暴露全部历史记录的目的，用Torrent自己实现的历史远不如用Git的 接口实现的历史记录方便吧，git blame之类的也更方便追踪code comment之类的 作者信息。当然对git的raw date直接读写，需要对git的内部原理有足够的理解， 或许只有github的人有这种能力了。 Topic Mining 用得两个参数， DE 和 AIC ，完全不能理解，过后研究。实验针对了Firefox, Mylyn, Eclipse三个软件。试图从Repo中分析源代码的identifier和comments， 找到topic和bug之间的关系，比如怎样的topic更容易导致bug。得出的结论似乎 也很暧昧，只是说核心功能被报告的bug更多，但是不知道原因。这只能表示核心 功能受到更多关注和更多测试吧，并不能说明核心功能就容易产生bug。 不过这个的Slide做得很漂亮，很容易理解。 SeCold A linked data platform for mining software repositories 没听懂这个项目的目的。 The evolution of software 第二天的Keynotes，关于将Social Media和Software Development相结合的想法。 或许就是Github赖以成功的基础。讲到代码中的comment, Tags, uBlog, blog之类 的social的特性和 IDE 的融合的趋势。 Do Faster Releases Imporve Software Quality? 使用Firefox作为例子。 结论是快速发布导致bug更多，更容易crash，但是bug更快得到修复，并且用户 更快转向新的发布。 Security vs Performance Bugs in Firefox Performance bugs are regression, blocks release. 一些感想 基于自然语义分析的commit分割 经常工具（比如git）的使用者并没有按照工具设计者的意图使用工具，这给 MSR 带来很多困难。举个例子，git有非常完美的branch系统，通常期望git的使用者 能够在一次commit里commit一个功能，比如一个bug的修复，或者一个feature的 添加，但是事实上经常有很多逻辑上的commit被合并在一个里面了。 或许这不是使用者的错，而是工具仍然不够人性的表现。或许我们可以自动把 一次的commit按照语义分割成多个。 分割之后，可以更容易地把issue和commit关联，也更容易组织更多的研究。 关于这次发表中大家用的slides系统 题目为\"Incorporating Version Histories in Information Retrieval Based Bug Localization\"的人用的slide是beamer的。公式很多，overlay很多，列表 很多，图片很少，典型的beamer做出的slide。思维导图用得很不错。今天一天 有至少3个slide是用beamer做的。 题目为\"Towards Improving Bug Tracking Systems with Game Mechanisms\" 的人用了prezi，图片很多，过度很多。但是比如没有页号没有页眉页脚，正式 会议的场合不太方便。 至少有六个以上用了Apple Keynotes，Keynotes做出来的东西真的和Powerpoint 做出来的很难区别，其中两个人用了初始的主题所以才看出来。 剩下的自然是 PPT 。 MSRA 的张女士做的虽然是 PPT ，倒是有很多beamer的感觉， 比如页眉页脚和overlay的用法。这些如果都是 PPT 做出来的，会多很多额外的 人力吧。 值得一提的是有一个题目为\"Green Mining: A Methodology of Relating Software Change to Power Consumption\"的人的slide全是\"劣质\"的手绘漫画， 效果意外地好，很低碳很环保很绿色很可爱。具体效果可以参考下面的动画，虽然 现场看到的不是一个版本： http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv 微软是个腹黑娘！ 嘛虽然这也不是什么新闻了。 MSR2012 的Mining Challenge的赞助商是微软，管理 组织者来自微软研究院，奖品是Xbox和Kinect。然后今年的题目是： Mining Android Bug 我看到了微软满满的怨气……","tags":"life","loc":"//farseerfc.github.io/msr2012-zhs.html","title":"MSR 2012 @ ICSE"},{"text":"简介 Pyssy 是用于 上海交通大学 饮水思源站 的一系列 Python 脚本和工具。 Pyssy 被有意设计为既可以托管寄宿在 SAE [1] 上，也可以在单机上独立使用。 项目地址： http://pyssy.sinaapp.com/ Github上的源代码地址： https://github.com/yssy-d3/pyssy [1] Sina App Engine ，新浪云平台，类似 Google App Engine 的东西。 依赖关系 Pyssy 使用 Flask 作为网页服务器， 并且使用 Memcached 或者 Redis 作为抓取 水源Web 的缓存。 SAE Python 环境下请开启 Memcached 支持。 本地环境下请安装 Redis-py 并运行 redis-server 服务器程序。","tags":"python","loc":"//farseerfc.github.io/pyssy-zhs.html","title":"Pyssy 项目"},{"text":"Today I saw a package called PyRuby in Github. The readme says: PyRuby - Some Ruby for your Python! PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful. Usage All you have to do is import the ruby module: import ruby From now on you should be able to write Ruby code within a regular Python module. An example: 1.upto(10) { |n| puts n } Even PyPI has listed this as a package. In the beginning I thought this was again a Ruby implementation by PyPy project. Or at least it use some magic trick to write ruby code directly in Python. Then I browse into the source code of it. It contains only one file: ruby.py # -*- coding: utf-8 -*- print ( \"\"\" `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:` .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms. `:ohmdys+//::/::--::::////:-.```......`````.://:-` `/dNs. .+hNds:`-:-:///::------::///++///:--....--::///::-`.///. `oMm/ /hNmo.` `` `....``````````` ...------:::-:/+/-.:/:` /NMs oMd/` `::::--.---://+` //` `````-:::::+/-`::.` :NM+ yN` -+.` `/` o. ``::.-:. `` :NN: :Nm - ./ : `.-://///:-. `-` `` :NN- /NM/ .-:::-.` `/ `:sdmdhyMMMMMMNNmy/` :mNo` :hMd: /dmddddNNmdy+-. `smmy/-```hMMMMMMMhydm/ `-.`` `...:mMm+. -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+- dMN-`-+hmmmmdhhhhdddmMN-`-/o: .-::::/oydms- oNMo:+/::. ``...--:/+ohNMNhs- :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms. .MMo:/`o:.:+sso+:-` sM+ ./-` /mNh+-....-/ymNNdo::--/shd+` -`:mm: /MM-o ./ ohhsooohNmy::sh. `yM/ `:oyyyyyyhys+:.` hy `/Nh` : -NN. -MM// -: `` y: odddhh+ -omNh- `--.` `` ```` .:ohMMs. +Ms / yMo hMoo .+. :Mh ```` `/hNd/.` ohdddy::...`..` `-/sdmdyo+NMNh+- :Mh / sMs .mmh:..:. :NMm `-/dMNM+ ./+++/:`.hM:`.````.` `-/shmNmh+-` /Mmooso.hM/ .: `mM/ .mNs://: .NMNMs- -:-.`/+-sms. ` `shyyyhy`sNd` `.:+sdmmmdMM-. .oNM+ :m/ `s``yMh -mMo . sMNdMNNh+-. .ydyoyy` ``+o::+shdddhs+:-.:MM.`.-+hNMMh- `.`-/::dNs` -NM- mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.` `/mMMdmmddNMm+` ..-/hNh- sMy NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs `..:+ymMMMMd+--yNh. `+hNh: -Mm NMMM/yMh -NM-`..--:NMo:--.`+My :MNoydmNMMNmhdMh` -dNs` `yMd: `MN mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/ yMy` MN yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-. `yMMNs. /My `MN :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM- ./hNNy- /Nd` -Mh dMydMmsNMNdNNMMmmmNMMMdddhys+yMo`` /Nm: `:yNNdo. .sNd. +Ms .mMsMN::NN:.:MN: `.+NM. +Mo +Mm+ymNdo- .omm+` yM: .hNMd+:sMN. oMm. oMo +Mh ```.:+shMNmy+-``.-:-..-//-`:yNmo` mM. :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/` .Mm `` .-:/+osyyhhddddddddddhhyysoo+/:-. `./+//--+oo/--+ymmy/. :Mh .: `+:` `.------------` ```-////:/++/:../ydNdo:` +Ms `/` :+o+:-``` ``..-::///++///:-.`-+ydNdo:` oMs :/:.`` `..---.``` ````````..-:/:::---.` `-ohmmh+:` /Mh .://///:::-----.-----.......` `-+hmmy+- sMy` ``````-+ydmy+- /mNs-` `./ohmNMNNNmy+- /yNmho/:.``````````.-:/+syhdNmdyso+/-.` `:+ydmNMNNNNNNNNNmdhys+/:.` ``.....` LOL U MAD? \"\"\" ) import sys sys . exit ( 1 ) Yes, indead. The idea of using Ruby in Python is totally mad.","tags":"python","loc":"//farseerfc.github.io/mix-ruby-en.html","title":"PyRuby"},{"text":"きょう、Githubに PyRuby というプロジェクトを見ました。それの説明にこう書いています: PyRuby - Some Ruby for your Python! PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful. Usage All you have to do is import the ruby module: import ruby From now on you should be able to write Ruby code within a regular Python module. An example: 1.upto(10) { |n| puts n } さらに、 PyPI にそれのパッケージもあった。 最初に、これはもう一つのPyPyで実現したRubyだと思った。少なくとも、本当のRubyをPythonから呼び出すの何かの魔法も可能かもしれない。 それのソースコートはこうなっています。 ruby.py # -*- coding: utf-8 -*- print ( \"\"\" `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:` .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms. `:ohmdys+//::/::--::::////:-.```......`````.://:-` `/dNs. .+hNds:`-:-:///::------::///++///:--....--::///::-`.///. `oMm/ /hNmo.` `` `....``````````` ...------:::-:/+/-.:/:` /NMs oMd/` `::::--.---://+` //` `````-:::::+/-`::.` :NM+ yN` -+.` `/` o. ``::.-:. `` :NN: :Nm - ./ : `.-://///:-. `-` `` :NN- /NM/ .-:::-.` `/ `:sdmdhyMMMMMMNNmy/` :mNo` :hMd: /dmddddNNmdy+-. `smmy/-```hMMMMMMMhydm/ `-.`` `...:mMm+. -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+- dMN-`-+hmmmmdhhhhdddmMN-`-/o: .-::::/oydms- oNMo:+/::. ``...--:/+ohNMNhs- :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms. .MMo:/`o:.:+sso+:-` sM+ ./-` /mNh+-....-/ymNNdo::--/shd+` -`:mm: /MM-o ./ ohhsooohNmy::sh. `yM/ `:oyyyyyyhys+:.` hy `/Nh` : -NN. -MM// -: `` y: odddhh+ -omNh- `--.` `` ```` .:ohMMs. +Ms / yMo hMoo .+. :Mh ```` `/hNd/.` ohdddy::...`..` `-/sdmdyo+NMNh+- :Mh / sMs .mmh:..:. :NMm `-/dMNM+ ./+++/:`.hM:`.````.` `-/shmNmh+-` /Mmooso.hM/ .: `mM/ .mNs://: .NMNMs- -:-.`/+-sms. ` `shyyyhy`sNd` `.:+sdmmmdMM-. .oNM+ :m/ `s``yMh -mMo . sMNdMNNh+-. .ydyoyy` ``+o::+shdddhs+:-.:MM.`.-+hNMMh- `.`-/::dNs` -NM- mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.` `/mMMdmmddNMm+` ..-/hNh- sMy NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs `..:+ymMMMMd+--yNh. `+hNh: -Mm NMMM/yMh -NM-`..--:NMo:--.`+My :MNoydmNMMNmhdMh` -dNs` `yMd: `MN mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/ yMy` MN yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-. `yMMNs. /My `MN :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM- ./hNNy- /Nd` -Mh dMydMmsNMNdNNMMmmmNMMMdddhys+yMo`` /Nm: `:yNNdo. .sNd. +Ms .mMsMN::NN:.:MN: `.+NM. +Mo +Mm+ymNdo- .omm+` yM: .hNMd+:sMN. oMm. oMo +Mh ```.:+shMNmy+-``.-:-..-//-`:yNmo` mM. :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/` .Mm `` .-:/+osyyhhddddddddddhhyysoo+/:-. `./+//--+oo/--+ymmy/. :Mh .: `+:` `.------------` ```-////:/++/:../ydNdo:` +Ms `/` :+o+:-``` ``..-::///++///:-.`-+ydNdo:` oMs :/:.`` `..---.``` ````````..-:/:::---.` `-ohmmh+:` /Mh .://///:::-----.-----.......` `-+hmmy+- sMy` ``````-+ydmy+- /mNs-` `./ohmNMNNNmy+- /yNmho/:.``````````.-:/+syhdNmdyso+/-.` `:+ydmNMNNNNNNNNNmdhys+/:.` ``.....` LOL U MAD? \"\"\" ) import sys sys . exit ( 1 ) 本当だ、Pythonの中にRubyを呼び出すという考えはアホだ。","tags":"python","loc":"//farseerfc.github.io/mix-ruby-jp.html","title":"PyRuby"},{"text":"今天在GitHub上闲逛的时候看到一个叫做 PyRuby 的项目。项目的Readme说得很好： PyRuby - Some Ruby for your Python! PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful. Usage All you have to do is import the ruby module: import ruby From now on you should be able to write Ruby code within a regular Python module. An example: 1.upto(10) { |n| puts n } 甚至 PyPI 上还有这个项目的包。 一开始我还以为这又是一个野心勃勃的基于PyPy的Ruby实现，或者某种trick在Python里面直接调用Ruby解释器。 然后我想看看这个的源代码 只有一个ruby.py文件，内容是： # -*- coding: utf-8 -*- print ( \"\"\" `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:` .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms. `:ohmdys+//::/::--::::////:-.```......`````.://:-` `/dNs. .+hNds:`-:-:///::------::///++///:--....--::///::-`.///. `oMm/ /hNmo.` `` `....``````````` ...------:::-:/+/-.:/:` /NMs oMd/` `::::--.---://+` //` `````-:::::+/-`::.` :NM+ yN` -+.` `/` o. ``::.-:. `` :NN: :Nm - ./ : `.-://///:-. `-` `` :NN- /NM/ .-:::-.` `/ `:sdmdhyMMMMMMNNmy/` :mNo` :hMd: /dmddddNNmdy+-. `smmy/-```hMMMMMMMhydm/ `-.`` `...:mMm+. -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+- dMN-`-+hmmmmdhhhhdddmMN-`-/o: .-::::/oydms- oNMo:+/::. ``...--:/+ohNMNhs- :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms. .MMo:/`o:.:+sso+:-` sM+ ./-` /mNh+-....-/ymNNdo::--/shd+` -`:mm: /MM-o ./ ohhsooohNmy::sh. `yM/ `:oyyyyyyhys+:.` hy `/Nh` : -NN. -MM// -: `` y: odddhh+ -omNh- `--.` `` ```` .:ohMMs. +Ms / yMo hMoo .+. :Mh ```` `/hNd/.` ohdddy::...`..` `-/sdmdyo+NMNh+- :Mh / sMs .mmh:..:. :NMm `-/dMNM+ ./+++/:`.hM:`.````.` `-/shmNmh+-` /Mmooso.hM/ .: `mM/ .mNs://: .NMNMs- -:-.`/+-sms. ` `shyyyhy`sNd` `.:+sdmmmdMM-. .oNM+ :m/ `s``yMh -mMo . sMNdMNNh+-. .ydyoyy` ``+o::+shdddhs+:-.:MM.`.-+hNMMh- `.`-/::dNs` -NM- mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.` `/mMMdmmddNMm+` ..-/hNh- sMy NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs `..:+ymMMMMd+--yNh. `+hNh: -Mm NMMM/yMh -NM-`..--:NMo:--.`+My :MNoydmNMMNmhdMh` -dNs` `yMd: `MN mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/ yMy` MN yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-. `yMMNs. /My `MN :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM- ./hNNy- /Nd` -Mh dMydMmsNMNdNNMMmmmNMMMdddhys+yMo`` /Nm: `:yNNdo. .sNd. +Ms .mMsMN::NN:.:MN: `.+NM. +Mo +Mm+ymNdo- .omm+` yM: .hNMd+:sMN. oMm. oMo +Mh ```.:+shMNmy+-``.-:-..-//-`:yNmo` mM. :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/` .Mm `` .-:/+osyyhhddddddddddhhyysoo+/:-. `./+//--+oo/--+ymmy/. :Mh .: `+:` `.------------` ```-////:/++/:../ydNdo:` +Ms `/` :+o+:-``` ``..-::///++///:-.`-+ydNdo:` oMs :/:.`` `..---.``` ````````..-:/:::---.` `-ohmmh+:` /Mh .://///:::-----.-----.......` `-+hmmy+- sMy` ``````-+ydmy+- /mNs-` `./ohmNMNNNmy+- /yNmho/:.``````````.-:/+syhdNmdyso+/-.` `:+ydmNMNNNNNNNNNmdhys+/:.` ``.....` LOL U MAD? \"\"\" ) import sys sys . exit ( 1 ) 是的……的确……这种尝试把Python和Ruby放在一起的想法绝对是疯了……","tags":"python","loc":"//farseerfc.github.io/mix-ruby-zhs.html","title":"PyRuby"},{"text":"This is a discuss in C board in bbs.sjtu.edu.cn, about type down-cast in C++ template. Original Discuss http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html The problem Today I read a book about we can do cast-down in template, so I write this to test: template < bool _Test , class _Type = void > struct enable_if { }; template < class _Type > struct enable_if < true , _Type > { typedef _Type type ; }; class A { }; class B : A { }; template < typename T > struct traits { static int const value = false ; }; template <> struct traits < A > { static int const value = true ; }; template < typename T > void f ( T , typename enable_if < traits < T >:: value >:: type * = 0 ) { } template <> void f < A > ( A , enable_if < traits < A >:: value >:: type * ) { } template < typename T > class BB {}; template < typename T > class DD : public BB < T > {}; template < typename T > void ff ( BB < T > ) {}; int main ( int argc , char * argv []) { A a ; B b ; DD < long > dd ; //f(b); ff ( dd ); } It is strange when f it don't allow my specified f<A> . But in ff it allowed ff< BB <long>> . Tested under VC10 and GCC3 .4 My answer to the problem Let's think ourself as compiler to see what happened there. Define mark # : A#B is the instantiated result when we put B into the parameter T of A<T> . First we discuss ff DD < long > dd ; After this sentense, the compiler saw the instantiation of DD <long> , so it instantiate DD #long , and also BB #long . ff ( dd ); This sentense required the compiler to calculate set of overloading functions. Step 1 we need to infer T of ff<T> from argument DD #long -> BB <T> . Based on the inference rule: Argument with type ``class_template_name<T>`` can be use to infer ``T``. So compiler inferred T as long . Here if it is not BB but CC which is complete un-related, we can also infer, as long as CC is a template like CC <T> . Step 2 Template Specialization Resolution. There is only one template here so we matched ff<T> . Step 3 Template Instantiation After inferred long -> T , compiler instantiated ff#long . Set of available overloading functions : {ff#long} Then overloading resolution found the only match ff#long , checked its real parameter DD #long can be down-cast to formal parameter BB #long . Then we discuss f f ( b ); Calculate set of overloading functions. Step 1 infer all template parameters for template f . According to inference rule: Parameter with type ``T`` can be used to infer ``T`` 。 So B -> T is inferred. Step 2 Template Specialization Resolution. Here B is not A so we can not apply specialization of f<A> , remaining f<T> as the only alternative. Step 3 Template Instantiation. When we put B into f<T> to instantiate as f#B , we need to instantiate traits#B . There is no specialization for B so we use template traits<T> , traits#B::value=false , so enable_if#false didn't contains a type , an error occurred. The only template is mismatch, available overloading functions is empty set. So we got an error.","tags":"c","loc":"//farseerfc.github.io/discuss-cpp-template-downcast-en.html","title":"Discuss C++ Template Downcast"},{"text":"这两天在饮水思源的C板，关于C++模板的类型转换的一个讨论，后面是我的解答。 讨论地址 http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html 原问题 今天在书上看到模板演绎的时候可以允许cast-down，于是我写了个东西： template < bool _Test , class _Type = void > struct enable_if { }; template < class _Type > struct enable_if < true , _Type > { typedef _Type type ; }; class A { }; class B : A { }; template < typename T > struct traits { static int const value = false ; }; template <> struct traits < A > { static int const value = true ; }; template < typename T > void f ( T , typename enable_if < traits < T >:: value >:: type * = 0 ) { } template <> void f < A > ( A , enable_if < traits < A >:: value >:: type * ) { } template < typename T > class BB {}; template < typename T > class DD : public BB < T > {}; template < typename T > void ff ( BB < T > ) {}; int main ( int argc , char * argv []) { A a ; B b ; DD < long > dd ; //f(b); ff ( dd ); } 奇怪的是重载决议的时候， f 的情况下它就不让我特化的 f<A> 进来。 但是在 ff 的情况下， ff< BB <long>> 却进来了。 在 VC10 和 GCC3 .4下测试 我的解答 我们来设身处地地作为编译器，看一遍到底发生了什么。 约定符号 # : A#B 是把 B 带入 A<T> 的参数 T 之后实例化得到的结果。 首先看ff的情况。 DD < long > dd ; 处理到这句的时候，编译器看到了 DD <long> 的实例化，于是去实例化 DD #long ，继而实例 化了 BB #long 。 ff ( dd ); 这句，首先计算重载函数集合。 第一步，需要从参数 DD #long -> BB <T> 推断 ff<T> 的 T 。根据函数模板参数推断规则： ``class_template_name<T>`` 类型的参数，可以用于推断 ``T`` 。 于是编译器推断 T 为 long 。这里就算不是 BB 而是完全无关的 CC 都可以推断成功，只要 CC 也 是一个 CC <T> 形式的模板。 第二步，模板特化匹配。因为只有一个模板，所以匹配了最泛化的 ff<T> 。 第三步，模板实例化。 推断了 long -> T 之后，编译器实例化 ff#long 。 重载函数集合： {ff#long} 然后重载抉择找到唯一的可匹配的实例 ff#long ，检查实际参数 DD #long 可以隐式转换到 形式参数 BB #long ，从而生成了这次函数调用。 再来看f的情况。 f ( b ); 计算候选重载函数集合。 第一步，对所有 f 模板推断实参。根据函数模板参数推断规则： 带有 ``T`` 类型的参数，可以用于推断 ``T`` 。 于是 B -> T 被推断出来了。 第二步，模板特化匹配。 这里 B 不是 A ，所以不能用 f<A> 特化，只能用 f<T> 模板。 第三步，模板实例化。 B 带入 f<T> 实例化成 f#B 的过程中，实例化 traits#B 。 由于没有针对 B 的特化，所以用 traits<T> 模板， traits#B::value=false ，进而 enable_if#false 没有 type ，出错。 唯一的模板匹配出错，重载函数集合为空， SFINAE 原则不能找到合适的匹配，于是报错。","tags":"c","loc":"//farseerfc.github.io/discuss-cpp-template-downcast-zhs.html","title":"关于C++模板的类型转换的讨论"},{"text":"It seems in one night all geeks have their own Github User Page and Octopress Blog. Like everyone posted in their blogs, Static Blog is indeed more convenient than traditional Blog systems such as WordPress. I have been wanting my own Octopress since then. But it seems that Octopress isn't for me At first I was confused by Setup Steps of Octopress . What is this RVM thing? And what is that rbenv thing? It seems the high pace of Ruby community has beyond my imagination to a degree that they need a version manager to ensure the compatibility of different versions of Ruby. Althrough the same compatibility issue also troubles Python community [1] , but at least Python don't need a version manager (yet) to control this mass [2] . Real problem for me is that I haven't yet a Linux box that I can play around freely. (I really want one … ) Both RVM and rbenv needs to run on Unix/Linux/MacOSX. One can not be a geek if he use Windows ? (Maybe it's true…) Remaining problem is the battle between Ruby and Python campaign. I haven't tried Markdown , and I rather like ReST . It seems that both sides depend on Pygments as code block highlighter so Rubyists need Python environment anyway. I simply don't want to depend on any Ruby component. It is better when it is in pure Python, no C extensions so that I can debug into it and make minor modifications. So I started searching for Static Blog Engine in Python on Github. The author of the great framework Flask , mitsuhiko , wrote a rstblog , but it's not well developed. Hyde seems to be complete enough, but it use MarkDown as its default markup language, and the design of its homepage is too fashion to be used as blog. Finally I found Pelican . [1] Such as the difference between Python 2.x and 3.x , and also difference in C- API of implementations of PyPy , CPython , Stackless , Cython . [2] Yes, we have easy_install and pip , but all these are package manager, running in a perticular Python implementation. Python implementation itself don't need a manager. Version issue of Python largely have been solved by lightweight converters such as 2to3.py and 3to2.py , you don't need to store multiple implementations of Python in your disk for different packages. Yes you can use virtualenv if you need to preserve stablility but this is another story. Let it be Pelican For my own use, Pelican offers me some advantages over Octopress : Implemented in pure Python . This means that I can use different implementation of Python other than CPython easily. I use PyPy myself. Translation of multi-languages. The original author of Pelican is a France. This is unnecessory for most people, but I will post my blog mainly in three languages: English, Japanese and Chinese. ReST . So that I can use the @auto-rst feature of Leo . And also I don't need to switch between my blog and documentation of my projects. But it seems that Pelican was less contributed than Octopress . Some minor issues remains in latest version: Support of pelican-import from WordPress for Chinese and Japanese articles are buggy. Datetime format, timezone, and locale support for multi-language blogs are not so natural. I will work on this in these days There are not so many templates compared to Octopress . And less plugins . I hope more people from Python community can contribute to this excellent project, then all these issues will be fixed soon. My settings To install Pelican is simple: $ pip install pelican Write posts in ReST , with rst extensions, and put them in pages folder. (Re)Build all pages is simply: $ pelican -s settings.py Push to Github: $ git commit -am \"Commit message\" $ git push And following is my settings.py : # -*- coding: utf-8 -*- TIMEZONE = 'Asia/Tokyo' DATE_FORMATS = { 'en' :( 'usa' , '%a, %d %b %Y' ), 'zh' :( 'chs' , '%Y-%m- %d , %a' ), 'jp' :( 'jpn' , '%Y/%m/ %d (%a)' ), } # windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx LOCALE = [ 'usa' , 'chs' , 'jpn' , # windows 'en_US' , 'zh_CN' , 'ja_JP' ] # Unix/Linux DEFAULT_LANG = 'zh' SITENAME = 'Farseerfc Blog' AUTHOR = 'Jiachen Yang' DISQUS_SITENAME = 'farseerfcgithub' GITHUB_URL = 'https://github.com/farseerfc' SITEURL = 'http://farseerfc.github.com' TAG_FEED = 'feeds/ %s .atom.xml' SOCIAL = (( 'twitter' , 'http://twitter.com/farseerfc' ), ( 'github' , 'https://github.com/farseerfc' ), ( 'facebook' , 'http://www.facebook.com/farseerfc' ), ( 'weibo' , 'http://weibo.com/farseerfc' ), ( 'renren' , 'http://www.renren.com/farseer' ), ) TWITTER_USERNAME = 'farseerfc' THEME = 'notmyidea' CSS_FILE = \"wide.css\" DEFAULT_CATEGORY = 'Others' OUTPUT_PATH = '.' PATH = 'posts'","tags":"python","loc":"//farseerfc.github.io/try-pelican-en.html","title":"Give a try to Pelican"},{"text":"一日の間に全ての ギーク たち が 自分の Githubユーザーページ と Octopress ブログを導入したような気がします。皆がブログに書いた通りに、静的ブログは確かに WordPress などの従来の動的ブログ・エンジンより便利だと思います。これらブログを見ると、私も自分の Octopress ブログを立ちましょう とずっと思っています。 ですが Octopress は私に向いてないかも 初めのところに Octopressの配置手順 に迷わされた。 RVM とはなに？ rbenv とは何のこと？見るところ Ruby コミュニティーの発展するハイペースは既に私の想像に超えましたみたい。 彼らは Ruby の各バージョン間に互換性を持つために、バージョン管理が必要らしいです。同様の互換性問題が Python コミュニティーにもある ですが [1] 、 Python は今のところこのようなバージョン管理の必要がないと思います [2] 。 実際に迷惑したのは、私は今自由に持って遊べる Linux 環境が持っていないということ（ほしいなぁ……）。 ですが RVM それとも rbenv 両方も Unix/Linux/MacOSX しか実行できないらしいです。ギークとしたの皆は絶対に Windows つかっじゃいけないんですか？（本当かも……）。 残りは Ruby と Python の争いです。私は Markdown に詳しくない、比べると ReST のほうが私に向いています。それに、どっちでも Pygments を依存しシンタックス・ハイライトをしているから、 Rubyist 達も少なくとも Python を入れなきゃダメみたいです。 私の好みは一切の Ruby コンポーネントを頼らず、 C 拡張もない純粋な Python の実現がほしいです。 そこから Github に Python で実現した静的ブログ・エンジンを探し始めた。 Flask の作者である mitsuhiko 氏が書いた rstblog が素晴らしいが、あんまり他人に使われていないようです。 Hyde は多く使われているけれと、ホームページにブログの感じがみえないです。最後に Pelican を見かけました。 [1] 例えば Python 2.x と 3.x の間にあまりにも巨大なる差、それと PyPy 、 CPython 、 Stackless 、 Cython など各実現間に微妙な違いがあります。 [2] はい、こっちに easy_install とか pip があります、ですがそれらはパッケージ管理、特定なPython環境を入れた後の話です。Python自身はまだ管理する必要がないです。 Python のバージョン問題も 2to3.py とか 3to2.py のようなツールで変換すればいいです、違うソフトを実行するためたくさんの Python バージョンを残る必要はないです。もしバージョンの違いが気にするなら virtualenv を使うのも構わないが、それも別のことです。 それでは Pelican にしよう 私自身にとって、 Pelican は Octopress よりいいところ： 純粋な Python で実現した。ですから CPython のほかべつの実現を使うのも心配がない。例えばわたしは PyPy を使ています。 多言語。 Pelican の原作者はフランス人らしいです。ほとんどの人はこれの必要がないと思うが……できるだけ、わたしは三つの言語で書く。 ReST 。それなら Leo の @auto-rst を使って直接 ReST をかけます。 でも Pelican は Octopress のほど注目されていないから、一部問題があります。 pelican-import は WordPress から導入する時、日本語や中国語は問題となります。 多言語の機能と日付、タイムゾーンなどにバグがある。 私は改善しています。 テンプレートは少ない。 プラグインも少ない…… こんなに優れたツールにもっと注目されてほしい。 配置 Pelican を入れるのは簡単： $ pip install pelican 文章を ReST で書いて、 posts フォルダーに置きます。ページを生成する： $ pelican -s settings.py Github に送る: $ git commit -am \"Commit message\" $ git push 私の配置ファイル： # -*- coding: utf-8 -*- TIMEZONE = 'Asia/Tokyo' DATE_FORMATS = { 'en' :( 'usa' , '%a, %d %b %Y' ), 'zh' :( 'chs' , '%Y-%m- %d , %a' ), 'jp' :( 'jpn' , '%Y年%m月 %d 日(%a)' ), } # windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx LOCALE = [ 'usa' , 'chs' , 'jpn' , # windows 'en_US' , 'zh_CN' , 'ja_JP' ] # Unix/Linux DEFAULT_LANG = 'zh' SITENAME = 'Farseerfc Blog' AUTHOR = 'Jiachen Yang' DISQUS_SITENAME = 'farseerfcgithub' GITHUB_URL = 'https://github.com/farseerfc' SITEURL = 'http://farseerfc.github.com' TAG_FEED = 'feeds/ %s .atom.xml' SOCIAL = (( 'twitter' , 'http://twitter.com/farseerfc' ), ( 'github' , 'https://github.com/farseerfc' ), ( 'facebook' , 'http://www.facebook.com/farseerfc' ), ( 'weibo' , 'http://weibo.com/farseerfc' ), ( 'renren' , 'http://www.renren.com/farseer' ), ) TWITTER_USERNAME = 'farseerfc' THEME = 'notmyidea' CSS_FILE = \"wide.css\" DEFAULT_CATEGORY = 'Others' OUTPUT_PATH = '.' PATH = 'posts'","tags":"python","loc":"//farseerfc.github.io/try-pelican-jp.html","title":"Pelicanを試してみた"},{"text":"似乎一夜之间所有的 极客们 都 有了 自己 的 Github主页 和 Octopress 博客。就像所有人在他们的博客中指出的，静态博客的确比传统的WordPress方式具有更多优势。 自从看到这些 我就一直在想着自己搭一个 Octopress 。 但是似乎 Octopress 不适合我 一上手就被 Octopress的搭建步骤 烦到了。 RVM 是什么？ rbenv 又是什么？ 看来 Ruby 社区的快节奏发展已经超过了我的想象，他们似乎需要一套发行版管理器来调和不同版本之间的 Ruby 的兼容性问题。 虽然同样的兼容性问题在 Python 社区也有 [1] ，不过总觉得 Python 至少还没到需要一个发行版管理器的程度 [2] 。 真正的问题是我手上还没有一个可以让我随便玩的 Linux 环境（真的想要……）。 而无论是 RVM 还是 rbenv 似乎都只支持 Unix/Linux/MacOSX 。 身为极客就注定不能用 Windows 么？（或许是的……）。 剩下的问题就是 Ruby 和 Python 两大阵营的对立问题了。我不熟悉 Markdown ， 相对来说比较喜欢 ReST 。 似乎无论哪边都要 依赖 Pygments 作为代码着色器，那么其实 Rubyist 也至少需要安装 Python 。 我倾向于不依赖任何 Ruby 组件，最好没有 C 扩展 的纯 Python 实现。 于是我开始在 Github 上找 Python 的静态博客引擎。 Flask 的作者 mitsuhiko 写的 rstblog 看起来不错，不过似乎没有多少人在用。 Hyde 似乎很完善，不过默认的标记语言是 MarkDown ， 又依赖于几个 Ruby 组建，而且官方网站的设计实在太前卫。 最终我看到了 Pelican 。 [1] 比如 Python 2.x 与 3.x 之间看似难以跨越的鸿沟，以及 PyPy 、 CPython 、 Stackless 、 Cython 等各个实现之间的微妙差别。 [2] 是的，我们有 easy_install ，我们有 pip ， 不过这些都是包管理器，都是装好特定的Python实现之后的事情。 Python实现本身还不需要包管理器来管理。 Python 的版本问题基本上也只需要 2to3.py 和 3to2.py 这样的轻量级转换器就可以了，你不需要为了安装多个软件而在硬盘里留下多个不同版本的 Python 。 如果为了引用的稳定性，你可以用 virtualenv ，不过这又是另一回事情了。 那么就 Pelican 吧 对我而言， Pelican 相比于 Octopress 有几个好处： 纯 Python 实现。 这意味着我可以换用任何 Python 解释器而不必担心兼容性问题。比如我就换成了 PyPy 。 多语言支持。因为 Pelican 的作者似乎是个法国人。不过这个似乎大部分人不需要…… 我是想尽量把一篇博客写成三种语言作为锻炼吧。 ReST 。这样我就可以用 Leo 的 @auto-rst 直接写 ReST了。简单方便快捷有效。 不过似乎 Pelican 的关注度不如 Octopress 那么高，现在一些部分还有细微的问题： pelican-import 从 WordPress 导入的时候对中文、日文的支持似乎很成问题。 日期格式、时区、字符集、和多语言功能的结合度还不够。 我在尝试改善它。 模板还不够丰富。 插件也不够多…… 希望这么优秀的工具能够受到更多关注，以上这些问题都是增加关注度之后很快就能解决的问题。 我的设置 settings.py 安装 Pelican 很容易，一句话就够了： $ pip install pelican 然后把文章写成ReST的格式，放在`pages`文件夹里面。(重新)生成只要： $ pelican -s settings.py 上传到 Github: $ git commit -am \"Commit message\" $ git push 就这么简单。附上我的配置文件： # -*- coding: utf-8 -*- TIMEZONE = 'Asia/Tokyo' DATE_FORMATS = { 'en' :( 'usa' , '%a, %d %b %Y' ), 'zh' :( 'chs' , '%Y-%m- %d , %a' ), 'jp' :( 'jpn' , '%Y/%m/ %d (%a)' ), } # windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx LOCALE = [ 'usa' , 'chs' , 'jpn' , # windows 'en_US' , 'zh_CN' , 'ja_JP' ] # Unix/Linux DEFAULT_LANG = 'zh' SITENAME = 'Farseerfc Blog' AUTHOR = 'Jiachen Yang' DISQUS_SITENAME = 'farseerfcgithub' GITHUB_URL = 'https://github.com/farseerfc' SITEURL = 'http://farseerfc.github.com' TAG_FEED = 'feeds/ %s .atom.xml' SOCIAL = (( 'twitter' , 'http://twitter.com/farseerfc' ), ( 'github' , 'https://github.com/farseerfc' ), ( 'facebook' , 'http://www.facebook.com/farseerfc' ), ( 'weibo' , 'http://weibo.com/farseerfc' ), ( 'renren' , 'http://www.renren.com/farseer' ), ) TWITTER_USERNAME = 'farseerfc' THEME = 'notmyidea' CSS_FILE = \"wide.css\" DEFAULT_CATEGORY = 'Others' OUTPUT_PATH = '.' PATH = 'posts'","tags":"python","loc":"//farseerfc.github.io/try-pelican-zhs.html","title":"尝试一下 Pelican"},{"text":"renren から導入した。 From: Bill Gates '— Sent: Sunday, January 24, 1999 8:41 AM Jeff Westorinon; Ben Fathi ; TO : Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder Subject: ACPI extensions One thing I find myself wondering about is whether we shouldn't try and make the \" ACPI \" extensions somehow Windows specific. It seems unfortunate if we do this work and get our partners to do the work and the result is that Linux works great without having to do the work . Maybe there is no way to avoid this problem but it does bother me. Maybe we could define the APIs so that they work well with NT and not the others even if they are open. Or maybe we could patent something relaled to this. From: http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/ PX03020 .pdf もしこれは今更Xen4.0の上に ACPI 3.0完全的なサポートが得ない原因、ならBill Gatesを呪います！","tags":"renren","loc":"//farseerfc.github.io/if-we-do-this-work-jp.html","title":"\"…if we do this work … \" —Bill Gates"},{"text":"Imported from renren \"…if we do this work … and the result is that Linux works great …\" —Bill Gates From: Bill Gates '— Sent: Sunday, January 24, 1999 8:41 AM Jeff Westorinon; Ben Fathi ; TO : Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder Subject: ACPI extensions One thing I find myself wondering about is whether we shouldn't try and make the \" ACPI \" extensions somehow Windows specific. It seems unfortunate if we do this work and get our partners to do the work and the result is that Linux works great without having to do the work . Maybe there is no way to avoid this problem but it does bother me. Maybe we could define the APIs so that they work well with NT and not the others even if they are open. Or maybe we could patent something relaled to this. From: http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/ PX03020 .pdf If this is the reason that Xen 4.0 is still not fully support ACPI 3.0, then f*ck you Bill Gates!","tags":"renren","loc":"//farseerfc.github.io/if-we-do-this-work-en.html","title":"\"…if we do this work … \" —Bill Gates"},{"text":"导入自 renren From: Bill Gates '— Sent: Sunday, January 24, 1999 8:41 AM Jeff Westorinon; Ben Fathi ; TO : Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder Subject: ACPI extensions One thing I find myself wondering about is whether we shouldn't try and make the \" ACPI \" extensions somehow Windows specific. It seems unfortunate if we do this work and get our partners to do the work and the result is that Linux works great without having to do the work . Maybe there is no way to avoid this problem but it does bother me. Maybe we could define the APIs so that they work well with NT and not the others even if they are open. Or maybe we could patent something relaled to this. From: http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/ PX03020 .pdf 如果这就是我至今在Xen4.0上得不到 ACPI 3.0的完善支持的原因，那么我诅咒Bill Gates！","tags":"renren","loc":"//farseerfc.github.io/if-we-do-this-work-zhs.html","title":"\"…if we do this work … \" —Bill Gates"},{"text":"Imported from: renren . It is said that this is a problem from interview of Microsoft. Write a program, which makes the CPU usage curve in Windows Task Manager shows a Sin function. The program below is written in java: public class sincpu { private static final int cycle = 1024 , tick = 256 ; public static void main ( String [] args ) throws InterruptedException { for ( int i = 0 ;; i ++){ work ( calcNextSleep ( i % cycle )); sleep ( tick - calcNextSleep ( i % cycle )); } } private static long calcNextSleep ( long i ){ return ( int )( Math . sin (( double ) i * 2 * Math . PI / cycle ) * tick + tick ) / 2 ; } private static void sleep ( long sleepTime ) throws InterruptedException { if ( sleepTime < 2 ) Thread . yield (); else Thread . sleep ( sleepTime ); } private static void work ( long period ) { long start = System . currentTimeMillis (); for (;;){ Math . sin ( 1 ); if ( System . currentTimeMillis () - start >= period ) break ; } } } Be careful you need to turn off other cores if you have multi-core CPU .","tags":"renren","loc":"//farseerfc.github.io/sine-cpu-en.html","title":"Write a program to keep CPU usage as sin funcion"},{"text":"导入自 renren 据说是一道微软的面试题。如题，写程序，让Windows的任务管理器中的性能监视器呈现正弦曲线。 潜心钻研良久，得代码：（java） public class sincpu { private static final int cycle = 1024 , tick = 256 ; public static void main ( String [] args ) throws InterruptedException { for ( int i = 0 ;; i ++){ work ( calcNextSleep ( i % cycle )); sleep ( tick - calcNextSleep ( i % cycle )); } } private static long calcNextSleep ( long i ){ return ( int )( Math . sin (( double ) i * 2 * Math . PI / cycle ) * tick + tick ) / 2 ; } private static void sleep ( long sleepTime ) throws InterruptedException { if ( sleepTime < 2 ) Thread . yield (); else Thread . sleep ( sleepTime ); } private static void work ( long period ) { long start = System . currentTimeMillis (); for (;;){ Math . sin ( 1 ); if ( System . currentTimeMillis () - start >= period ) break ; } } } 多核 CPU 上测试时要注意关掉一个 CPU ：","tags":"renren","loc":"//farseerfc.github.io/sine-cpu-zhs.html","title":"写程序让 CPU 占用率保持正弦函数"},{"text":"导入自 renren 看到陈骉同学很有感想的一篇神创论与命运日志，觉得近日很久没有看到这样的评论了。想说几句自己的观点。 首先我认为，神创论与宿命论没有多少关联，甚至进化论者相较于神创论者更容易接受宿命论的观点。因为神创论主张意志的存在，人所具有的个体意志与神的意志，因此在神创论者的眼中事件的结果是可以通过意志来改变的，亦即如果我从物理楼11楼跳下，那么我就可以改变自己死亡时间的宿命。上帝的意志同样可以左右事件的结果，也就是所谓的宿命不复存在。而进化论者不承认意志独立于物质世界的存在，你我的思考、行为，都受到物理学法则诸如量子力学的约束，这就引出了北大物理系教授的那句\"宇宙中的一切都是可以计算的\"，亦即宿命论。如我我选择现在从物理楼上跳下，我这一行为并不是处于个人的独立意志，乃是想证明这一点，亦即我跳楼这一举动是有其背后的动机与原因的，就如同计算机的输入必然导致了输出，宿命的必然终结于此。 其次，关于事件的复杂度所导致的随机化，在大量混沌随机中也存在着如统计学和随机分形学这样的规律，并不是否认宿命的充分理由。 关于神创论的合理性问题。我认为是否相信神的存在只是一个boolean二值问题，它为true为false本身并不重要，重要的是确定它的取值之后得到的推论与结果。如果否认神的存在，如现代数学这样的完美又何以存在，进化论者的解释是事物最终会向着更好更高级的方向发展，产生现代数学乃至现代科学是发展的必然。而这种论调显然有悖于物理中以热力学第二定律为首的，预言事物会随时间推演愈发混乱的论断。更进一步，甚至整个人类、整个生物系统的存在都是有悖于热力学推论的现象，是某种理论只能以\"小概率事件\"解释的现象。 神创论的核心观点之一，是神的唯一存在性，按照邹恒明的比喻，这就如同数学中集合中元素的的唯一性一般至关重要。数学乃至近代科学的发展，其起源在于这种对神性的探求，而不仅仅是好奇心就可以解释的。反观东方文化中数学的发展，开始时领先于西方科学千余每年，但是始终作为一种craft-oriented的实用主义学科。可以说没有了神的唯一性支持，人们就不能确信自己能找到这样一种完美高效的学科，只能在实用的基础上发展其基础算数。可以想象，没有神的完美与唯一性，数学必将发展成现代化学或者微软软件这样，庞大而充满特例，到处都是修补与查表，怎么会像现在的完美、简洁与和谐。 神创论者并不是将难题推与\"神\"然后放任不管，他们相信神是最为理智的存在，创人时人同样得到了神的智慧和理智，也就是神可以用人的理智来理解。 引用牛顿《自然哲学的数学原理》中终章的话\"太阳、恒星、行星的这个极精致的结构不可能存在，除非通过一个有理智的和有权能的存在的设计和主宰……他不是作为宇宙的灵魂，而是作为一切的主宰而统治所有……\" 以上…… (发现最近的哲理思维果然慢了不少，写作思绪也一片混乱&#94;_&#94;)","tags":"renren","loc":"//farseerfc.github.io/some-thought-on-creationism-zhs.html","title":"关于神创论的一些见解"}]}