<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Farseerfc的小窝</title><link href="//farseerfc.me/zhs/" rel="alternate"></link><link href="//farseerfc.me/feeds/tag-c.atom.xml" rel="self"></link><id>//farseerfc.me/zhs/</id><updated>2014-12-12T17:06:00+09:00</updated><entry><title>从非缓冲输入流到 Linux 控制台的历史</title><link href="//farseerfc.me/zhs/from-unbuffered-stdin-to-history-of-linux-tty.html" rel="alternate"></link><updated>2014-12-12T17:06:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2014-12-12:zhs/from-unbuffered-stdin-to-history-of-linux-tty.html</id><summary type="html">&lt;html&gt;&lt;body&gt;
&lt;p&gt;这篇也是源自于水源C板上板友的一个问题，涉及Linux上的控制台的实现方式和历史原因。因为内容比较长，所以在这里再排版一下发出来。
&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1418138991,file,M.1418138991.A.html"&gt;原帖在这里&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;可以设置不带缓冲的标准输入流吗？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;WaterElement(UnChanged) 于 2014年12月09日23:29:51 星期二 问到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请问对于标准输入流可以设置不带缓冲吗？比如以下程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;似乎还是需要在命令行输入后按回车才会让 &lt;code class="code"&gt;
fgets&lt;/code&gt;
 返回，不带缓冲究竟体现在哪里？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;这和缓存无关，是控制台的实现方式的问题。&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;再讲细节一点，这里有很多个程序和设备。以下按 linux 的情况讲：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;终端模拟器窗口（比如xterm）收到键盘事件&lt;/li&gt;
&lt;li&gt;终端模拟器(xterm)把键盘事件发给虚拟终端 pty1&lt;/li&gt;
&lt;li&gt;pty1 检查目前的输入状态，把键盘事件转换成 stdin 的输入，发给你的程序&lt;/li&gt;
&lt;li&gt;你的程序的 c 库从 stdin 读入一个输入，处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;标准库说的输入缓存是在 4 的这一步进行的。而行输入是在 3 的这一步被缓存起来的。&lt;/p&gt;
&lt;p&gt;终端pty有多种状态，一般控制台程序所在的状态叫「回显行缓存」状态，这个状态的意思是:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;所有普通字符的按键，会回显到屏幕上，同时记录在行缓存区里。&lt;/li&gt;
&lt;li&gt;处理退格( &lt;kbd class="kbd"&gt;
BackSpace&lt;/kbd&gt;
 )，删除( &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;
 )按键为删掉字符，左右按键移动光标。&lt;/li&gt;
&lt;li&gt;收到回车的时候把整个一行的内容发给stdin。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Cooked_mode"&gt;http://en.wikipedia.org/wiki/Cooked_mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时在Linux/Unix下可以发特殊控制符号给pty让它进入「raw」状态，这种状态下按键
不会被回显，显示什么内容都靠你程序自己控制。
如果你想得到每一个按键事件需要用raw状态，这需要自己控制回显自己处理缓冲，
简单点的方法是用 readline 这样的库（基本就是「回显行缓存」的高级扩展，支持了
Home/End，支持历史）或者 ncurses 这样的库（在raw状态下实现了一个简单的窗口/
事件处理框架）。&lt;/p&gt;
&lt;p&gt;参考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/POSIX_terminal_interface#History"&gt;http://en.wikipedia.org/wiki/POSIX_terminal_interface#History&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除此之外， &lt;kbd class="kbd"&gt;
Ctrl-C&lt;/kbd&gt;
 转换到 SIGINT ， &lt;kbd class="kbd"&gt;
Ctrl-D&lt;/kbd&gt;
 转换到 EOF 这种也是在 3 这一步做的。&lt;/p&gt;
&lt;p&gt;以及，有些终端模拟器提供的 &lt;kbd class="kbd"&gt;
Ctrl-Shift-C&lt;/kbd&gt;
 表示复制这种是在 2 这一步做的。&lt;/p&gt;
&lt;p&gt;以上是 Linux/unix 的方式。 Windows的情况大体类似，只是细节上有很多地方不一样：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;窗口事件的接收者是创建 cmd 窗口的 Win32 子系统。&lt;/li&gt;
&lt;li&gt;Win32子系统接收到事件之后，传递给位于 命令行子系统 的 cmd 程序&lt;/li&gt;
&lt;li&gt;cmd 程序再传递给你的程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Windows上同样有类似行缓存模式和raw模式的区别，只不过实现细节不太一样。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="strace"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;strace查看了下&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WaterElement(UnChanged) 于 2014年12月10日21:53:54 星期三 回复：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;感谢FC的详尽解答。&lt;/p&gt;
&lt;p&gt;用strace查看了下，设置标准输入没有缓存的话读每个字符都会调用一次 &lt;code class="code"&gt;
read&lt;/code&gt;
 系统调用，
比如输入abc：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;read(0, abc
"a", 1)                         = 1
read(0, "b", 1)                         = 1
read(0, "c", 1)                         = 1
read(0, "\n", 1)                        = 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有缓存的话就只调用一次了 &lt;code class="code"&gt;
read&lt;/code&gt;
 系统调用了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;read(0, abc
"abc\n", 1024)                  = 4
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="raw-mode"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;如果想感受一下 raw mode&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;没错，这个是你的进程内C库做的缓存，tty属于字符设备所以是一个一个字符塞给你的
程序的。&lt;/p&gt;
&lt;p&gt;如果想感受一下 raw mode 可以试试下面这段程序（没有检测错误返回值）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;termios.h&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ttyfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/* reset tty - useful also for restoring the terminal when this process&lt;/span&gt;
&lt;span class="cm"&gt;   wishes to temporarily relinquish the tty&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="cm"&gt;/* flush and reset */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="cm"&gt;/* put terminal in raw mode - see termio(7I) for modes */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;raw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* copy original and then modify below */&lt;/span&gt;

    &lt;span class="cm"&gt;/* input modes - clear indicated ones giving: no break, no CR to NL,&lt;/span&gt;
&lt;span class="cm"&gt;       no parity check, no strip char, no start/stop output (sic) control */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_iflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BRKINT&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICRNL&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;INPCK&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISTRIP&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IXON&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* output modes - clear giving: no post processing such as NL to CR+NL */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_oflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OPOST&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* control modes - set 8 bit chars */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cflag&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CS8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* local modes - clear giving: echoing off, canonical off (no erase with&lt;/span&gt;
&lt;span class="cm"&gt;       backspace, ^U,...),  no extended functions, no signal chars (^Z,^C) */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_lflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ECHO&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICANON&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IEXTEN&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISIG&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* control chars - set return condition: min number of bytes and timer */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after 5 bytes or .8 seconds&lt;/span&gt;
&lt;span class="cm"&gt;                                                after first byte seen      */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* immediate - anything       */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after two bytes, no timer  */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after a byte or .8 seconds */&lt;/span&gt;

    &lt;span class="cm"&gt;/* put terminal in raw mode after flushing */&lt;/span&gt;
    &lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;atexit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;终端上的字符编程&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;vander(大青蛙) 于 2014年12月12日08:52:20 星期五 问到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;学习了！&lt;/p&gt;
&lt;p&gt;进一步想请教一下fc大神。如果我在Linux上做终端上的字符编程，是否除了用ncurses库
之外，也可以不用该库而直接与终端打交道，就是你所说的直接在raw模式？
另外，终端类型vt100和linux的差别在哪里？为什么Kevin Boone的KBox配置手册里面说必
须把终端类型设成linux，而且要加上terminfo文件，才能让终端上的vim正常工作？term
info文件又是干什么的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;Linux控制台的历史&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;嗯理论上可以不用 ncurses 库直接在 raw 模式操纵终端。&lt;/p&gt;
&lt;p&gt;这里稍微聊一下terminfo/termcap的历史，详细的历史和吐槽参考
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater's Handbook&lt;/a&gt;
第6章 Terminal Insanity。&lt;/p&gt;
&lt;p&gt;首先一个真正意义上的终端就是一个输入设备（通常是键盘）加上一个输出设备（打印
机或者显示器）。很显然不同的终端的能力不同，比如如果输出设备是打印机的话，显
示出来的字符就不能删掉了（但是能覆盖），而且输出了一行之后就不能回到那一行了
。再比如显示器终端有的支持粗体和下划线，有的支持颜色，而有的什么都不支持。
早期Unix工作在电传打字机（TeleTYpe）终端上，后来Unix被port到越来越多的机器上
，然后越来越多类型的终端会被连到Unix上，很可能同一台Unix主机连了多个不同类型
的终端。由于是不同厂商提供的不同的终端，能力各有不同，自然控制他们工作的方式
也是不一样的。所有终端都支持回显行编辑模式，所以一般的面向行的程序还比较好写
，但是那时候要撰写支持所有终端的「全屏」程序就非常痛苦，这种情况就像现在浏览
器没有统一标准下写HTML要测试各种浏览器兼容性一样。
通常的做法是&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;使用最小功能子集&lt;/li&gt;
&lt;li&gt;假设终端是某个特殊设备，不管别的设备。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;水源的代码源头 Firebird2000 就是那样的一个程序，只支持固定大小的vt102终端。&lt;/p&gt;
&lt;p&gt;这时有一个划时代意义的程序出现了，就是 vi，试图要做到「全屏可视化编辑」。这在
现在看起来很简单，但是在当时基本是天方夜谭。
vi 的做法是提出一层抽象，记录它所需要的所有终端操作，然后有一个终端类型数据库
，把那些操作映射到终端类型的具体指令上。当然并不是所有操作在所有终端类型上都
支持，所以会有一堆 fallback，比如要「强调」某段文字，在彩色终端上可能
fallback 到红色，在黑白终端上可能 fallback 到粗体。&lt;/p&gt;
&lt;p&gt;vi 一出现大家都觉得好顶赞，然后想要写更多类似 vi 这样的全屏程序。然后 vi 的作
者就把终端抽象的这部分数据库放出来形成一个单独的项目，叫 termcap （Terminal
Capibility），对应的描述终端的数据库就是 termcap 格式。然后 termcap 只是一个
数据库（所以无状态）还不够方便易用，所以后来又有人用 termcap 实现了 curses 。&lt;/p&gt;
&lt;p&gt;再后来大家用 curses/termcap 的时候渐渐发现这个数据库有一点不足：它是为 vi 设
计的，所以只实现了 vi 需要的那部分终端能力。然后对它改进的努力就形成了新的
terminfo 数据库和 pcurses 和后来的 ncurses 。 然后 VIM 出现了自然也用
terminfo 实现这部分终端操作。&lt;/p&gt;
&lt;p&gt;然后么就是 X 出现了， xterm 出现了，大家都用显示器了，然后 xterm 为了兼容各种
老程序加入了各种老终端的模拟模式。不过因为最普及的终端是 vt100 所以 xterm 默
认是工作在兼容 vt100 的模式下。然后接下来各种新程序（偷懒不用*curses的那些）
都以 xterm/vt100 的方式写。&lt;/p&gt;
&lt;p&gt;嗯到此为止是 Unix 世界的黑历史。&lt;/p&gt;
&lt;p&gt;知道这段历史的话就可以明白为什么需要 TERM 变量配合 terminfo 数据库才能用一些
Unix 下的全屏程序了。类比一下的话这就是现代浏览器的 user-agent。&lt;/p&gt;
&lt;p&gt;然后话题回到 Linux 。 大家知道 Linux 早期代码不是一个 OS， 而是 Linus 大神想
在他的崭新蹭亮的 386-PC 上远程登录他学校的 Unix 主机，接收邮件和逛水源（咳咳
）。于是 Linux 最早的那部分代码并不是一个通用 OS 而只是一个 bootloader 加一个
终端模拟器。所以现在 Linux 内核里还留有他当年实现的终端模拟器的部分代码，而这
个终端模拟器的终端类型就是 linux 啦。然后他当时是为了逛水源嘛所以 linux 终端
基本上是 vt102 的一个接近完整子集。&lt;/p&gt;
&lt;p&gt;说到这里脉络大概应该清晰了， xterm终端类型基本模拟 vt100，linux终端类型基本模
拟 vt102。这两个的区别其实很细微，都是同一个厂商的两代产品嘛。有差别的地方差
不多就是 &lt;kbd class="kbd"&gt;
Home&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
End&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageUp&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageDown&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;

这些不在 ASCII 控制字符表里的按键的映射关系不同。&lt;/p&gt;
&lt;p&gt;嗯这也就解释了为什么在linux环境的图形界面的终端里 telnet 上水源的话，上面这些
按键会错乱…… 如果设置终端类型是 linux/vt102 的话就不会乱了。在 linux 的
TTY 里 telnet 也不会乱的样子。&lt;/p&gt;
&lt;p&gt;写到这里才发现貌似有点长…… 总之可以参考
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater's Handbook&lt;/a&gt;
里的相关历史评论和吐槽，那一段非常有意思。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="c"></category><category term="linux"></category><category term="stdio"></category><category term="tty"></category><category term="unix"></category><category term="ugh"></category><category term="ncurses"></category><category term="termcap"></category><category term="terminfo"></category></entry><entry><title>关于C++模板的类型转换的讨论</title><link href="//farseerfc.me/zhs/discuss-cpp-template-downcast.html" rel="alternate"></link><updated>2012-02-26T05:54:57+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2012-02-26:zhs/discuss-cpp-template-downcast.html</id><summary type="html">&lt;html&gt;&lt;body&gt;
&lt;p&gt;这两天在饮水思源的C板，关于C++模板的类型转换的一个讨论，后面是我的解答。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;讨论地址&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html"&gt;http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;原问题&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;今天在书上看到模板演绎的时候可以允许cast-down，于是我写了个东西：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;_Test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BB&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DD&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//f(b);&lt;/span&gt;
    &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;奇怪的是重载决议的时候， &lt;code class="code"&gt;
f&lt;/code&gt;
 的情况下它就不让我特化的 &lt;code class="code"&gt;
f&amp;lt;A&amp;gt;&lt;/code&gt;
 进来。&lt;/p&gt;
&lt;p&gt;但是在 &lt;code class="code"&gt;
ff&lt;/code&gt;
 的情况下， &lt;code class="code"&gt;
ff&amp;lt;BB&amp;lt;long&amp;gt;&amp;gt;&lt;/code&gt;
 却进来了。&lt;/p&gt;
&lt;p&gt;在VC10和GCC3.4下测试&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;我的解答&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我们来设身处地地作为编译器，看一遍到底发生了什么。&lt;/p&gt;
&lt;p&gt;约定符号 &lt;code class="code"&gt;
#&lt;/code&gt;
 : &lt;code class="code"&gt;
A#B&lt;/code&gt;
 是把 &lt;code class="code"&gt;
B&lt;/code&gt;
 带入 &lt;code class="code"&gt;
A&amp;lt;T&amp;gt;&lt;/code&gt;
 的参数 &lt;code class="code"&gt;
T&lt;/code&gt;
 之后实例化得到的结果。&lt;/p&gt;
&lt;div class="section" id="ff"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;首先看ff的情况。&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;处理到这句的时候，编译器看到了 &lt;code class="code"&gt;
DD&amp;lt;long&amp;gt;&lt;/code&gt;
 的实例化，于是去实例化 &lt;code class="code"&gt;
DD#long&lt;/code&gt;
 ，继而实例
化了 &lt;code class="code"&gt;
BB#long&lt;/code&gt;
 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这句，首先计算重载函数集合。&lt;/p&gt;
&lt;p&gt;第一步，需要从参数 &lt;code class="code"&gt;
DD#long -&amp;gt; BB&amp;lt;T&amp;gt;&lt;/code&gt;
 推断 &lt;code class="code"&gt;
ff&amp;lt;T&amp;gt;&lt;/code&gt;
 的 &lt;code class="code"&gt;
T&lt;/code&gt;
 。根据函数模板参数推断规则：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:code:`class_template_name&amp;lt;T&amp;gt;` 类型的参数，可以用于推断 :code:`T` 。
&lt;/pre&gt;
&lt;p&gt;于是编译器推断 &lt;code class="code"&gt;
T&lt;/code&gt;
 为 &lt;code class="code"&gt;
long&lt;/code&gt;
 。这里就算不是 &lt;code class="code"&gt;
BB&lt;/code&gt;
 而是完全无关的 &lt;code class="code"&gt;
CC&lt;/code&gt;
 都可以推断成功，只要 &lt;code class="code"&gt;
CC&lt;/code&gt;
 也
是一个 &lt;code class="code"&gt;
CC&amp;lt;T&amp;gt;&lt;/code&gt;
 形式的模板。&lt;/p&gt;
&lt;p&gt;第二步，模板特化匹配。因为只有一个模板，所以匹配了最泛化的 &lt;code class="code"&gt;
ff&amp;lt;T&amp;gt;&lt;/code&gt;
 。&lt;/p&gt;
&lt;p&gt;第三步，模板实例化。&lt;/p&gt;
&lt;p&gt;推断了 &lt;code class="code"&gt;
long -&amp;gt; T&lt;/code&gt;
 之后，编译器实例化 &lt;code class="code"&gt;
ff#long&lt;/code&gt;
 。&lt;/p&gt;
&lt;p&gt;重载函数集合： &lt;code class="code"&gt;
{ff#long}&lt;/code&gt;
&lt;/p&gt;
&lt;p&gt;然后重载抉择找到唯一的可匹配的实例 &lt;code class="code"&gt;
ff#long&lt;/code&gt;
 ，检查实际参数 &lt;code class="code"&gt;
DD#long&lt;/code&gt;
 可以隐式转换到
形式参数 &lt;code class="code"&gt;
BB#long&lt;/code&gt;
 ，从而生成了这次函数调用。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="f"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;再来看f的情况。&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;计算候选重载函数集合。&lt;/p&gt;
&lt;p&gt;第一步，对所有 &lt;code class="code"&gt;
f&lt;/code&gt;
 模板推断实参。根据函数模板参数推断规则：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
带有 :code:`T` 类型的参数，可以用于推断 :code:`T` 。
&lt;/pre&gt;
&lt;p&gt;于是 &lt;code class="code"&gt;
B -&amp;gt; T&lt;/code&gt;
 被推断出来了。&lt;/p&gt;
&lt;p&gt;第二步，模板特化匹配。&lt;/p&gt;
&lt;p&gt;这里 &lt;code class="code"&gt;
B&lt;/code&gt;
 不是 &lt;code class="code"&gt;
A&lt;/code&gt;
 ，所以不能用 &lt;code class="code"&gt;
f&amp;lt;A&amp;gt;&lt;/code&gt;
 特化，只能用 &lt;code class="code"&gt;
f&amp;lt;T&amp;gt;&lt;/code&gt;
 模板。&lt;/p&gt;
&lt;p&gt;第三步，模板实例化。&lt;/p&gt;
&lt;p&gt;&lt;code class="code"&gt;
B&lt;/code&gt;
 带入 &lt;code class="code"&gt;
f&amp;lt;T&amp;gt;&lt;/code&gt;
 实例化成 &lt;code class="code"&gt;
f#B&lt;/code&gt;
 的过程中，实例化 &lt;code class="code"&gt;
traits#B&lt;/code&gt;
 。&lt;/p&gt;
&lt;p&gt;由于没有针对 &lt;code class="code"&gt;
B&lt;/code&gt;
 的特化，所以用 &lt;code class="code"&gt;
traits&amp;lt;T&amp;gt;&lt;/code&gt;
 模板， &lt;code class="code"&gt;
traits#B::value=false&lt;/code&gt;
 ，进而 &lt;code class="code"&gt;
enable_if#false&lt;/code&gt;
 没有 &lt;code class="code"&gt;
type&lt;/code&gt;
 ，出错。&lt;/p&gt;
&lt;p&gt;唯一的模板匹配出错，重载函数集合为空，SFINAE原则不能找到合适的匹配，于是报错。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="template"></category><category term="C"></category></entry><entry><title>C++ Tricks 3.2 标号、goto，以及switch的实现</title><link href="//farseerfc.me/zhs/c-tricks-3-2-label-goto-and-implementation-of-switch.html" rel="alternate"></link><updated>2007-09-16T13:08:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-09-16:zhs/c-tricks-3-2-label-goto-and-implementation-of-switch.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 导入&lt;/p&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h2&gt;3.2 标号、goto，以及switch的实现&lt;/h2&gt;
&lt;p&gt;goto语句及标号(label)是最古老的C语言特性，也是最早被人们抛弃的语言特性之一。像汇编语言中的jmp指令一样，goto语句可以跳转到同一函数体中任何标号位置：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{int i=0;&lt;/p&gt;
&lt;p&gt;Loop: //A label&lt;/p&gt;
&lt;p&gt;++i;&lt;/p&gt;
&lt;p&gt;if(i&amp;lt;10)goto Loop; //Jump to the label&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;在原始而和谐的早期Fortran和Basic时代，我们没有if then
else，没有for和while，甚至没有函数的概念，一切控制结构都靠goto(带条件的或无条件的)构件。软件工程师将这样的代码称作“意大利面条”代码。实践证明这样的代码极容易造成混乱。&lt;/p&gt;
&lt;p&gt;自从证明了结构化的程序可以做意大利面条做到的任何事情，人们就开始不遗余力地推广结构化设计思想，将goto像猛兽一般囚禁在牢笼，标号也因此消失。&lt;/p&gt;
&lt;p&gt;标号唯一散发余热的地方，是在switch中控制分支流程。&lt;/p&gt;
&lt;p&gt;很多人不甚了解switch存在的意义，认为它只是大型嵌套if then
else结构的缩略形式，并且比if语句多了很多“不合理”的限制。如果你了解到switch在编译器内部的实现机制，就不难理解强加在switch之上的诸多限制，比如case后只能跟一个编译期整型常量，比如用break结束每一个case。首先看一个switch实例：&lt;/p&gt;
&lt;p&gt;switch (shape.getAngle())&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;case 3: cout&amp;lt;&amp;lt;”Triangle”;break;&lt;/p&gt;
&lt;p&gt;case 4: cout&amp;lt;&amp;lt;”Square”;break;&lt;/p&gt;
&lt;p&gt;case 0:case1: cout&amp;lt;&amp;lt;”Not a sharp!”;break;&lt;/p&gt;
&lt;p&gt;default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;任何程序员都可以写出与之对应的if结构：&lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i==3) cout&amp;lt;&amp;lt;”Triangle”;&lt;/p&gt;
&lt;p&gt;else if(i==4) cout&amp;lt;&amp;lt;”Square”;&lt;/p&gt;
&lt;p&gt;else if(i==0||i==1) cout&amp;lt;&amp;lt;”Not a sharp!”;&lt;/p&gt;
&lt;p&gt;else cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;看起来这两段代码在语义上是完全一样的，不是么？&lt;/p&gt;
&lt;p&gt;不！或许代码的执行结果完全一样，但是就执行效率而言，switch版本的更快！&lt;/p&gt;
&lt;p&gt;要了解为什么switch的更快，我们需要知道编译器是怎样生成switch的实现代码的：&lt;/p&gt;
&lt;p&gt;首先，保留switch之后由{}括起来的语具体，仅将其中case、default和break替换为真正的标号：&lt;/p&gt;
&lt;p&gt;switch (getAngle(shape))&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;随后，对于所有出现在case之后的常量，列出一张只有goto的跳转表，其顺序按case后的常量排列：&lt;/p&gt;
&lt;p&gt;goto _case_0;&lt;/p&gt;
&lt;p&gt;goto _case_1;&lt;/p&gt;
&lt;p&gt;goto _case_3;&lt;/p&gt;
&lt;p&gt;goto _case_4;&lt;/p&gt;
&lt;p&gt;然后，计算case之后的常量与跳转表地址之间的关系，如有需要，在跳转表中插入空缺的项目：&lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default; //因为没有case 2，所以插入此项以条转到default&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt;假设一个goto语句占用5个字节，那么在本例中，goto的地址=case后的常量*5+100105&lt;/p&gt;
&lt;p&gt;之后，生成跳转代码，在其余条件下跳转至default，在已知范围内按照公式跳转，全部的实现如下：&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i&amp;lt;0||i&amp;gt;=5)goto _default;&lt;/p&gt;
&lt;p&gt;i=i*5+100105; //按照得出的公式算出跳转地址&lt;/p&gt;
&lt;p&gt;goto i; //伪代码，C中不允许跳转到整数，但是汇编允许&lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default;&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;经过这样处理整个switch结构，使得无论switch后的变量为何值，都可以通过最多两次跳转到达目标代码。相比之下if版本的代码则采用线性的比较和跳转，在case语句很多的情况下效率极低。&lt;/p&gt;
&lt;p&gt;由此,我们也可以知道,为什么case后跟的一定是编译期整型常数，因为编译器需要根据这个值制作跳转表。我们可以明白为什么case与case之间应该用break分隔，因为编译器不改变switch语句体的结构，case其本身只是一个具有语义的标号而已，要想跳出switch，就必须用break语句。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 3.1 左值右值与常量性(lvalue，rvalue &amp; constant)</title><link href="//farseerfc.me/zhs/c-tricks-3-1-lvalue-rvalue-constant.html" rel="alternate"></link><updated>2007-09-16T13:07:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-09-16:zhs/c-tricks-3-1-lvalue-rvalue-constant.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 导入&lt;/p&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h2&gt;3.1 左值右值与常量性(lvalue，rvalue &amp;amp; constant)&lt;/h2&gt;
&lt;p&gt;首先要搞清楚的是，什么是左值，什么是右值。这里给出左值右值的定义：&lt;/p&gt;
&lt;p&gt;1、左值是可以出现在等号(=)左边的值，右值是只能出现在等号右边的值。&lt;/p&gt;
&lt;p&gt;2、左值是可读可写的值，右值是只读的值。&lt;/p&gt;
&lt;p&gt;3、左值有地址，右值没有地址。&lt;/p&gt;
&lt;p&gt;根据左值右值的第二定义，值的左右性就是值的常量性——常量是右值，非常量是左值。比如：&lt;/p&gt;
&lt;p&gt;1=1;//Error&lt;/p&gt;
&lt;p&gt;这个复制操作在C++中是语法错误，MSVC给出的错误提示为“error C2106: '=' :
left operand must be
l-value”，就是说’=’的左操作数必须是一个左值，而字面常数1是一个右值。可见，严格的区分左值右值可以从语法分析的角度找出程序的逻辑错误。&lt;/p&gt;
&lt;p&gt;根据第二定义，一个左值也是一个右值，因为左值也可读，而一个右值不是一个左值，因为右值不可写。&lt;/p&gt;
&lt;p&gt;通常情况下，声明的变量是一个左值，除非你指定const将它变成一个右值：&lt;/p&gt;
&lt;p&gt;int lv=1;&lt;/p&gt;
&lt;p&gt;const int rv=lv;&lt;/p&gt;
&lt;p&gt;由于右值的值在程序执行期间不能改变，所以必须用另一个右值初始化它。&lt;/p&gt;
&lt;p&gt;一个普通变量只能用右值初始化，如果你想传递左值，必须声明一个引用或一个指针：&lt;/p&gt;
&lt;p&gt;int &amp;amp; ref=lv;//用引用传递左值&lt;/p&gt;
&lt;p&gt;int * plv=&amp;amp;lv;//传递指针以间接传递左值&lt;/p&gt;
&lt;p&gt;必须用左值初始化引用，然而，可以用右值初始化常量引用：&lt;/p&gt;
&lt;p&gt;int &amp;amp; r1=1; //Error!&lt;/p&gt;
&lt;p&gt;const int &amp;amp; r2=1; //OK&lt;/p&gt;
&lt;p&gt;这实际上相当于：&lt;/p&gt;
&lt;p&gt;int _r2=1;&lt;/p&gt;
&lt;p&gt;const int &amp;amp; r2=_r2;&lt;/p&gt;
&lt;p&gt;这样的写法在函数体内没什么作用，但是在传递函数参数时，它可以避免潜在的(传递左值时的)复制操作，同时又可以接受右值。&lt;/p&gt;
&lt;p&gt;通常情况下，函数的参数和返回值都只传回右值，除非你明确的通过引用传递左值。&lt;/p&gt;
&lt;p&gt;明确了左值与右值的区别，有助于我们写函数时确定什么时候应该有const，什么时候不该有。比如，我们写了一个代表数学中复数的类Complex：&lt;/p&gt;
&lt;p&gt;class Complex;&lt;/p&gt;
&lt;p&gt;然后，我们写针对Complex的运算符重载：operator+和operator=。问题在于，参数和返回值应该是什么类型，可选类型有四种：
Complex、const Complex、Complex&amp;amp;、const Complex&amp;amp;。&lt;/p&gt;
&lt;p&gt;对于operator+，我们不会改变参数的值，所以可以通过const
Complex&amp;amp;传递参数。至于返回值类型，由于int类型的加法返回右值，所以根据Do
as the ints do的原则，返回值类型为const Complex：&lt;/p&gt;
&lt;p&gt;const Complex operator+(const Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt;对于operator=，同样要思考这些问题。我们写入第一个参数，所以第一个参数为Complex&amp;amp;，我们只读取第二个参数，所以第二个参数为const
Complex&amp;amp;。至于返回值，还是Do as the ints
do。int的赋值返回左值，不信你可以试一试：&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;(i=1)=2;&lt;/p&gt;
&lt;p&gt;虽然比较傻，先将i赋为1，再将其改为2，但是这是被C++语法支持的做法，我们就理应遵守。所以返回第一个参数的左值：&lt;/p&gt;
&lt;p&gt;Complex&amp;amp; operator=(Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt;const是C++引入的语言特性，也被ANSI
C99借鉴，在经典版本的C语言中是没有的。关于const的历史，有几点值得玩味。最初Bjarne
Stroustrup引入const时，可写性是和可读性分开的。那时使用关键字readonly和writeonly。这个特点被首先提交到C的ANSI标准化委员会(当时还没有C++标准化的计划)，但是ANSI
C标准只接受了readonly的概念，并将其命名为const。随后，有人发现在多线程同步的环境下，有些变量的值会在编译器的预料之外改变，为了防止过度优化破坏这些变量，C++又引入关键字violate。从语义特点来看，violate是const的反义词，因为const表示不会变的量，而violate表示会不按照预期自行变化的量。从语法特点而言，violate与const是极为相似的，适用于const的一切语法规则同样适用于violate。&lt;/p&gt;
&lt;p&gt;值的常量性可以被划分为两种：编译期常量和运行期常量。C++语法并没有严格区分这两种常量，导致了少许混乱：&lt;/p&gt;
&lt;p&gt;const int i=5;const int * pi=&amp;amp;i;&lt;/p&gt;
&lt;p&gt;const_cast&amp;lt;int&amp;amp;&amp;gt;i=1;//对于运行期常量，在需要时可以去除它的常量性&lt;/p&gt;
&lt;p&gt;int a[i];//对于编译期常量，可以用它来指定数组大小&lt;/p&gt;
&lt;p&gt;cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;sizeof(a)/sizeof(a[0])&amp;lt;&amp;lt;*pi;&lt;/p&gt;
&lt;p&gt;这种将编译期与运行期常量的特性混用的方法，势必导致语义的混乱。数组a的大小最终是5，因为采用了i的编译期值，而不管i在运行期是否被改变了值。最后一句代码将（有可能）输出551，第一个i的值作为一种优化在编译期绑定，第二个值标明了a的大小，第三个值通过指针显示地输出i的运行期真实值。&lt;/p&gt;
&lt;p&gt;在C++的近亲C#的语法中，这两种常量被严格地区分开：编译期常量由const指定，只能是内建类型变量；运行期常量由readonly指定，可以是任何类型。永远不会改变的常量，如圆周率pi的值，应该用const声明；而其它有可能改变的常量，皆由readonly声明。&lt;/p&gt;
&lt;p&gt;C++中的const的特点更倾向于C#中的readonly，虽然语法上允许使用const的编译期常量性，但正如上文所展示的，这容易造成混乱。为了得到C#中const的语义，在C++中，我们不必回归恶魔#define的怀抱，可以使用所谓“匿名enum技巧”。当匿名声明一个enum类型时，其中的枚举值就是一个int类型的编译期常量，比如：&lt;/p&gt;
&lt;p&gt;enum{Size=5;};&lt;/p&gt;
&lt;p&gt;int a[Size];&lt;/p&gt;
&lt;p&gt;这种使用匿名enum来声明编译期常量的做法，被广泛应用于STL、boost等模板库的实现代码中。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.2 I386平台的内存布局</title><link href="//farseerfc.me/zhs/c-tricks-2-2-i386-memory-layout.html" rel="alternate"></link><updated>2007-08-28T14:30:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:zhs/c-tricks-2-2-i386-memory-layout.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 导入&lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.2 I386平台的内存布局&lt;/h2&gt;
&lt;p&gt;众所周知，I386是32位体系结构。因此对于绝大多数I386平台的C++编译器而言，sizeof(int)=sizeof(long)=sizeof(void*)=4。当然C++标准对此没有任何保证，我们也不应该试图编写依赖于此的代码。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;32位指针的可寻址空间为4GB。为充分利用这么大的寻址空间，也是为了支持其它更先进的技术比如多任务技术或者动态链接库技术，WinNT使用虚拟内存技术，给与每个应用程序全部4GB的内存空间。4GB的地址被一分为二，前2GB供应用程序自己使用，后2GB由系统内核分配和管理。这2GB的内存地址，通常被划分成3种内存区使用：&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;1 代码及静态数据区&lt;/h3&gt;
&lt;p&gt;由代码加载器从动态链接库镜像(通常是exe或dll文件)加载，通常定位到镜像文件中指定的基址开始的内存区。如果基址所在内存已被占用，动态连接器会将代码或数据重定向到其它可用地址。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;在C++中，静态数据包括：名字空间(namespace)和全局(global)对象、函数的static对象、类的static数据成员。这些静态数据由编译器分配地址(但可能被重定向)，由静态连接器写入代码文件(通常是exe或dll)的静态数据区段。所以标准说，这些静态数据在编译期就已经具有地址。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stack"&gt;
&lt;h3&gt;2 栈(Stack)&lt;/h3&gt;
&lt;p&gt;栈是最常用的动态数据存储区，所有函数的non-static对象和函数参数都在程序运行期在栈上分配内存。在数据结构中，术语“栈(Stack)”意指先进后出(FILO，First
In Last
Out)，与“队列(Queue)”所指的FIFO相对。相对于基于堆的对象分配技术，默认使用栈的对象分配有两点优势：&lt;/p&gt;
&lt;p&gt;一、栈的FILO与人的思维方式相同&lt;/p&gt;
&lt;p&gt;现实生活中有许多事例都使用FILO的方式，比如人们必须先提起话筒再拨打号码，而后挂断电话之后再放下话筒。使用FILO的栈，可以保证事物的销毁顺序以其诞生顺序相反的顺序进行，不会产生在挂断电话之前就放下话筒的尴尬。&lt;/p&gt;
&lt;p&gt;二、栈的分配管理仅需要两个额外指针：栈顶(esp)和栈底(ebp)指针&lt;/p&gt;
&lt;p&gt;从实现的技术层面而言，栈的管理比其它动态分配技术要简单很多。I386平台上的动态栈管理，仅需要栈顶和栈底两个指针。这两个指针的存储显然不能放置于栈中，置于静态数据区又有损效率。I386平台为管理动态栈专门预留了两个通用寄存器变量esp与ebp，分别代表栈顶(esp,Extended
Stack Pointer)与栈底(Extended Bottom
Pointer)指针。其中的extended代表它们是32位指针，以区分16位的sp和bp寄存器。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;栈是动态存储区的特点，表明它的内存占用将随着程序的运行而变化。I386平台上WinNT将应用程序的栈置于程序空间，向下增长。程序初始化时，由操作系统将esp指向系统分配的栈空间的顶部。当程序需要在栈上分配变量时，就将esp减去变量所需字节数，这被称作“压栈(Push)”；随后又要销毁变量时，就将esp加上变量所需字节数，这被称作“弹出(Pop)”。esp与ebp两者之间所夹的空间，就是当前函数正在使用的栈空间。由于栈向下增长，esp(栈顶)的值总是小于ebp(栈底)的值，新分配的变量地址总是小于旧变量的地址。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="heap"&gt;
&lt;h3&gt;3 堆(Heap)和自由存储区&lt;/h3&gt;
&lt;p&gt;栈中的变量对于分配与释放的顺序有特定要求，这在一定程度上限制了栈的适用范围。面向对象(OO，Object
Oriented)的程序设计思想也要求能自由地控制变量的分配与销毁。由此，现代操作系统都提供了被称作“堆(Heap)”的自由存储区，以允许由程序员控制的对象创建和销毁过程。C标准库函数malloc和free则是对操作系统提供的堆操作的封装。C++提供的自由存储区运算符new和delete则通常是malloc和free的又一层封装。&lt;/p&gt;
&lt;p&gt;操作系统经由malloc和free控制对堆的访问。堆的存储管理技术各不相同，简单的使用双链表管理，复杂的可以比拟一个完整的文件系统。&lt;/p&gt;
&lt;p&gt;由于额外的管理需求，使用系统提供的通用分配器在堆上分配和销毁变量的代价，无论从空间角度还是效率角度而言，都比在栈上分配对象要高昂很多。对于sizeof上百的大型对象，这样的高昂代价还是可以接受的，但是对于sizeof只有个位数的小对象，这样的代价通常是一个数量级的差距。正因为这个原因，STL不使用new和delete，转而使用分配子(alllocor)分配对象。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks</title><link href="//farseerfc.me/zhs/c-tricks.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:zhs/c-tricks.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 导入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ Tricks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;By  FarseerFc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从今天起，我再将在&lt;a class="reference external" href="http://firechildren.spaces.live.com/"&gt;Live
Space&lt;/a&gt;和&lt;a class="reference external" href="http://76635424.qzone.qq.com/"&gt;QQZone&lt;/a&gt;同时发表一系列文章，暂定名为“C++Tricks”。&lt;/p&gt;
&lt;p&gt;本文旨在记录和阐述一些本人学习C++时所得的心得、技巧。总体来看，本文涉及的内容是每一个C++程序员都应该知道的，但是很少见诸C++教材。希望对各位同仁学习C++有所帮助。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;也可以通过QQ或MSN向我索要此文的DOC版或PDF版，会比网页上的更新的快一点。&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lexical-problems"&gt;
&lt;h2&gt;1      词法问题(Lexical Problems)&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!139.entry"&gt;1.1 条件运算符(?:)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!140.entry"&gt;1.2 逗号运算符(,)、逻辑运算符(&amp;amp;&amp;amp;,||)与运算符重载的陷阱&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="x86"&gt;
&lt;h3&gt;2      X86体系结构&lt;/h3&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!146.entry"&gt;2.1 X86概述&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!147.entry"&gt;2.2 I386平台的内存布局&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!148.entry"&gt;2.3 I386平台C函数内部的栈分配&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!149.entry"&gt;2.4 I386平台C函数调用边界的栈分配&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!150.entry"&gt;2.5 I386平台的边界对齐(Align)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!151.entry"&gt;2.6 I386平台C函数的可变参数表(Variable Arguments)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!152.entry"&gt;2.7 I386平台的其它函数调用模型&lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="id6"&gt;
&lt;h5&gt;3 过程式编程&lt;/h5&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!154.entry"&gt;3.1 左值右值与常量性(lvalue，rvalue &amp;amp; constant)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!155.entry"&gt;3.2 标号、goto，以及switch的实现&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.3 I386平台C函数内部的栈分配</title><link href="//farseerfc.me/zhs/c-tricks-2-3-i386-stack-allocation-in-c-functions.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:zhs/c-tricks-2-3-i386-stack-allocation-in-c-functions.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 导入&lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.3 I386平台C函数内部的栈分配&lt;/h2&gt;
&lt;p&gt;函数使用栈来保存局部变量，传递函数参数。进入函数时，函数在栈上为函数中的变量统一预留栈空间，将esp减去相应字节数。当函数执行流程途径变量声明语句时，如有需要就调用相应构造函数将变量初始化。当执行流程即将离开声明所在代码块时，以初始化的顺序的相反顺序逐一调用析构函数。当执行流程离开函数体时，将esp加上相应字节数，归还栈空间。&lt;/p&gt;
&lt;p&gt;为了访问函数变量，必须有方法定位每一个变量。变量相对于栈顶esp的位置在进入函数体时就已确定，但是由于esp会在函数执行期变动，所以将esp的值保存在ebp中，并事先将ebp的值压栈。随后，在函数体中通过ebp减去偏移量来访问变量。以一个最简单的函数为例：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int a=0; //a的地址被分配为ebp-4&lt;/p&gt;
&lt;p&gt;char c=1; //c的地址被分配为ebp-8&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;产生的汇编代码为：&lt;/p&gt;
&lt;p&gt;push ebp ;将ebp压栈&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;ebp=esp 用栈底备份栈顶指针&lt;/p&gt;
&lt;p&gt;sub esp,8 ;esp-=8，为a和c预留空间，包括边界对齐&lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],0 ;a=0&lt;/p&gt;
&lt;p&gt;mov byte ptr[ebp-8],1 ;c=1&lt;/p&gt;
&lt;p&gt;add esp,8 ;esp+=8，归还a和c的空间&lt;/p&gt;
&lt;p&gt;mov esp,ebp ;esp=ebp 从栈底恢复栈顶指针&lt;/p&gt;
&lt;p&gt;pop ebp ;恢复ebp&lt;/p&gt;
&lt;p&gt;ret ;返回&lt;/p&gt;
&lt;p&gt;相应的内存布局是这样：&lt;/p&gt;
&lt;p&gt;09992:c=1 &amp;lt;-esp&lt;/p&gt;
&lt;p&gt;09996:a=0&lt;/p&gt;
&lt;p&gt;10000:旧ebp &amp;lt;-ebp&lt;/p&gt;
&lt;p&gt;10004:……&lt;/p&gt;
&lt;p&gt;注:汇编中的pop、push、call、ret语句是栈操作指令，其功能可以用普通指令替换&lt;/p&gt;
&lt;p&gt;push ebp相当于:&lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;mov dword ptr[esp],ebp&lt;/p&gt;
&lt;p&gt;pop ebp相当于：&lt;/p&gt;
&lt;p&gt;mov ebp,dword ptr[esp]&lt;/p&gt;
&lt;p&gt;sub esp,4&lt;/p&gt;
&lt;p&gt;call fun_address相当于：&lt;/p&gt;
&lt;p&gt;push eip&lt;/p&gt;
&lt;p&gt;jmp fun_address&lt;/p&gt;
&lt;p&gt;ret相当于&lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt;带参数的ret&lt;/p&gt;
&lt;p&gt;ret 8相当于&lt;/p&gt;
&lt;p&gt;add esp,12&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt;所有局部变量都在栈中由函数统一分配，形成了类似逆序数组的结构，可以通过指针逐一访问。这一特点具有很多有趣性质，比如，考虑如下函数，找出其中的错误及其造成的结果：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i,a[10];&lt;/p&gt;
&lt;p&gt;for(i=0;i&amp;lt;=10;++i)a[i]=0;/An error occurs here!&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这个函数中包含的错误，即使是C++新手也很容易发现，这是老生常谈的越界访问问题。但是这个错误造成的结果，是很多人没有想到的。这次的越界访问，并不会像很多新手预料的那样造成一个“非法操作”消息，也不会像很多老手估计的那样会默不作声，而是导致一个，呃，死循环！&lt;/p&gt;
&lt;p&gt;错误的本质显而易见，我们访问了a[10]，但是a[10]并不存在。C++标准对于越界访问只是说“未定义操作”。我们知道，a[10]是数组a所在位置之后的一个位置，但问题是，是谁在这个位置上。是i!&lt;/p&gt;
&lt;p&gt;根据前面的讨论，i在数组a之前被声明，所以在a之前分配在栈上。但是，I386上栈是向下增长的，所以，a的地址低于i的地址。其结果是在循环的最后，a[i]引用到了i自己！接下来的事情就不难预见了，a[i]，也就是i，被重置为0，然后继续循环的条件仍然成立……这个循环会一直继续下去，直到在你的帐单上产生高额电费，直到耗光地球电能，直到太阳停止燃烧……呵呵，或者直到聪明的你把程序Kill了……&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.4 I386平台C函数调用边界的栈分配</title><link href="//farseerfc.me/zhs/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:zhs/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 导入&lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.4 I386平台C函数调用边界的栈分配&lt;/h2&gt;
&lt;p&gt;当调用一个函数时，主调函数将参数以声明中相反的顺序压栈，然后将当前的代码执行指针(eip)压栈，然后跳转到被调函数的入口点。在被调函数中，通过将ebp加上一个偏移量来访问函数参数，以声明中的顺序(即压栈的相反顺序)来确定参数偏移量。被调函数返回时，弹出主调函数压在栈中的代码执行指针，跳回主调函数。再由主调函数恢复到调用前的栈。&lt;/p&gt;
&lt;p&gt;函数的返回值不同于函数参数，通过寄存器传递。如果返回值类型可以放入32位变量，比如int、short、char、指针等类型，通过eax寄存器传递。如果返回值类型是64位变量，如_int64，同过edx+eax传递，edx存储高32位，eax存储低32位。如果返回值是浮点类型，如float和double，通过专用的浮点数寄存器栈的栈顶返回。如果返回值类型是用户自定义结构，或C++类类型，通过修改函数签名，以引用型参数的形式传回。&lt;/p&gt;
&lt;p&gt;同样以最简单的函数为例：&lt;/p&gt;
&lt;p&gt;void f(){&lt;/p&gt;
&lt;p&gt;int i=g(1,2);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int g(int a,int b){&lt;/p&gt;
&lt;p&gt;int c=a+b；&lt;/p&gt;
&lt;p&gt;return c;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;产生的汇编代码如下：&lt;/p&gt;
&lt;p&gt;f:&lt;/p&gt;
&lt;p&gt;push ebp ;备份ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;建立栈底&lt;/p&gt;
&lt;p&gt;sub esp,4 ;为i分配空间&lt;/p&gt;
&lt;p&gt;mov eax,2 ;准备参数b的值2&lt;/p&gt;
&lt;p&gt;push eax ;将b压栈&lt;/p&gt;
&lt;p&gt;mov eax,1 ;准备参数a的值1&lt;/p&gt;
&lt;p&gt;push eax ;将a压栈&lt;/p&gt;
&lt;p&gt;call g ;调用g&lt;/p&gt;
&lt;p&gt;add esp,8 ;将a和b一起弹出，恢复调用前的栈&lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ;将返回值保存进变量i&lt;/p&gt;
&lt;p&gt;mov esp,ebp ;恢复栈顶&lt;/p&gt;
&lt;p&gt;pop ebp ;恢复栈底&lt;/p&gt;
&lt;p&gt;g:&lt;/p&gt;
&lt;p&gt;push ebp ;备份ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;建立栈底&lt;/p&gt;
&lt;p&gt;sub esp,4 ;为局部变量c在栈中分配内存&lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp+8] ;通过ebp间接读取参数a的值&lt;/p&gt;
&lt;p&gt;mov ebx,dword ptr[ebp+12] ;通过ebp间接读取参数b的值&lt;/p&gt;
&lt;p&gt;add eax,ebx ;将a和b的值相加，之和存在eax中&lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ;将和存入变量c&lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp-4] ;将c作为返回值，代码优化后会删除此句&lt;/p&gt;
&lt;p&gt;add esp,4 ;销毁c的内存&lt;/p&gt;
&lt;p&gt;mov esp,ebp ;恢复栈顶&lt;/p&gt;
&lt;p&gt;pop ebp ;恢复栈底&lt;/p&gt;
&lt;p&gt;ret ;返回函数f&lt;/p&gt;
&lt;p&gt;栈的内存布局如下：&lt;/p&gt;
&lt;p&gt;100076:c &amp;lt;- g的esp&lt;/p&gt;
&lt;p&gt;100080:f的ebp=100100 &amp;lt;- g的ebp&lt;/p&gt;
&lt;p&gt;100084:f的eip&lt;/p&gt;
&lt;p&gt;100088:a=1&lt;/p&gt;
&lt;p&gt;100092:b=2&lt;/p&gt;
&lt;p&gt;100096:i&lt;/p&gt;
&lt;p&gt;100100:旧ebp &amp;lt;-f的ebp&lt;/p&gt;
&lt;p&gt;100104:……&lt;/p&gt;
&lt;p&gt;注意在函数g的汇编代码中，访问函数的局部变量和访问函数参数的区别。局部变量总是通过将ebp减去偏移量来访问，函数参数总是通过将ebp加上偏移量来访问。对于32位变量而言，第一个局部变量位于ebp-4，第二个位于ebp-8，以此类推，32位局部变量在栈中形成一个逆序数组；第一个函数参数位于ebp+8，第二个位于ebp+12，以此类推，32位函数参数在栈中形成一个正序数组。&lt;/p&gt;
&lt;p&gt;由于函数返回值通过寄存器返回，不需要空间分配等操作，所以返回值的代价很低。基于这个原因，旧的C语法约定，不写明返回值类型的函数，返回值类型为int。这一规则与现行的C++语法相违背，因为C++中，不写明返回值类型的函数返回值类型为void，表示不返回值。这种语法不兼容性是为了加强C++的类型安全，但同时也带来了一些问题。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.5 I386平台的边界对齐(Align)</title><link href="//farseerfc.me/zhs/c-tricks-2-5-address-alignment.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:zhs/c-tricks-2-5-address-alignment.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 导入&lt;/p&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h2&gt;2.5 I386平台的边界对齐(Align)&lt;/h2&gt;
&lt;p&gt;首先提问，既然I386上sizeof(int)==4、sizeof(char)==1，那么如下结构(struct)A的sizeof是多少？&lt;/p&gt;
&lt;p&gt;struct A{int i;char c;};&lt;/p&gt;
&lt;p&gt;答案是sizeof(A)==8……1+5=8？&lt;/p&gt;
&lt;p&gt;呵呵，这就是I386上的边界对齐问题。我们知道，I386上有整整4GB的地址空间，不过并不是每一个字节上都可以放置任何东西的。由于内存总线带宽等等的技术原因，很多体系结构都要求内存中的变量被放置于某一个边界的地址上。如果违反这个要求，重则导致停机出错，轻则减慢运行速度。对于I386平台而言，类型为T的变量必须放置在sizeof(T)的整数倍的地址上，char可以随便放置，short必须放在2的整数倍的地址上，int必须放在4的整数倍的地址上，double必须放在8的整数倍的地址上。如果违反边界对齐要求，从内存中读取数据必须进行两次，然后将独到的两半数据拼接起来，这会严重影响效率。&lt;/p&gt;
&lt;p&gt;由于边界对齐问题的要求，在计算struct的sizeof的时候，编译器必须算入额外的字节填充，以保证每一个变量都能自然对齐。比如如下声明的struct:&lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;实际上相当于声明了这样一个结构：&lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;char _filling1 [3];//三个字节填充，保证下一个int的对齐&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2；&lt;/p&gt;
&lt;p&gt;char _filling2 [3];//又三个字节填充&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;值得注意的是尾部的3个字节填充，这是为了可以在一个数组中声明WASTE变量，并且每一个都自然对齐。因为有了这些填充，所以sizeof(WASTE)==12。这是一种浪费，因为只要我们重新安排变量的声明，就可以减少sizeof：&lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c1,c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;像这样的安排，sizeof就减少到8，只有2个字节的额外填充。为了与汇编代码相兼容，C语言语法规定，编译器无权擅自安排结构体内变量的布局顺序，必须从左向右逐一排列。所以，妥当安排成员顺序以避免内存空间的浪费，就成了我们程序员的责任之一。一般的，总是将结构体的成员按照其sizeof从大到小排列，double在最前，char在最后，这样总可以将结构的字节填充降至最小。&lt;/p&gt;
&lt;p&gt;C++继承了C语言关于结构体布局的规定，所以以上的布局准则也适用于C++的class的成员变量。C++进一步扩展了布局规定，同一访问区段(private、public、protected)中的变量，编译器无权重新排列，不过编译器有权排列访问区段的前后顺序。基于这个规则，C++中有的程序员建议给每一个成员变量放在单独区段，在每一个成员声明之前都加上private:、public:、protected:标志，这可以最大限度的利用编译器的决策优势。&lt;/p&gt;
&lt;p&gt;在栈中按顺序分配的变量，其边界也受到对齐要求的限制。与在结构中不同的是，栈中的变量还必须保证其后续变量无论是何种类型都可以自由对齐，所以在栈中的变量通常都有平台相关的对齐最小值。在MSVC编译器上，这个最小值可以由宏_INTSIZEOF(T)查询：&lt;/p&gt;
&lt;p&gt;#define _INTSIZEOF(T) ( (sizeof(T) + sizeof(int) - 1) &amp;amp; ~(sizeof(int) -
1) )&lt;/p&gt;
&lt;p&gt;_INTSIZEOF(T)会将sizeof(T)进位到sizeof(int)的整数倍。&lt;/p&gt;
&lt;p&gt;由于在栈中分配变量使用_INTSIZEOF而不是sizeof，在栈上连续分配多个小变量(sizeof小于int的变量)会造成内存浪费，不如使用结构(struct)或数组。也就是说：&lt;/p&gt;
&lt;p&gt;char c1,c2,c3,c4;//使用16字节&lt;/p&gt;
&lt;p&gt;char c[4];//使用4字节&lt;/p&gt;
&lt;p&gt;当然，使用数组的方法在访问数组变量(比如c[1])时有一次额外的指针运算和提领(dereference)操作，这会有执行效率的损失。这又是一种空间(内存占用)vs时间(执行效率)的折中，需要程序员自己根据情况权衡利弊。&lt;/p&gt;
&lt;p&gt;sizeof的大小可能比我们预期的大，也可能比我们预期的小。对于空类：&lt;/p&gt;
&lt;p&gt;class Empty {};&lt;/p&gt;
&lt;p&gt;在通常情况下，sizeof(Empty)至少为1。这是因为C++语法规定，对于任何实体类型的两个变量，都必须具有不同的地址。为了符合语法要求，编译器会给Empty加入1字节的填充。所以sizeof()的值不可能出现0的情况。可是对于以下的类声明：&lt;/p&gt;
&lt;p&gt;class A:public Empty{vitual ~A(){}};&lt;/p&gt;
&lt;p&gt;sizeof(A)有可能是6，也有可能是5，也有可能是4！必不可少的四个字节是一个指向虚函数表的指针。一个可能有的字节是Empty的大小，这是是因为编译器在特定情况下会将Empty视作一个“空基类”，从而实施“空基类优化”，省掉那毫无作用的一字节填充。另一个字节是A的一字节填充，因为从语法上讲，A没有成员声明，理应有1字节填充，而从语义上讲，编译器给A的声明加入了一个指向虚函数表的指针，从而A就不再是一个“空类”，是否实施这个优化，要看编译器作者对语法措词的理解。也就是说，sizeof也会出现4+1+1=4的情况。具体要看编译器有没有实施“空基类优化”和“含虚函数表的空类优化”。&lt;/p&gt;
&lt;p&gt;结构和类的空间中可能有填充的字节，这意味着填充字节中可能有数值，虽然这数值并不影响结构的逻辑状态，但是它也可能不知不觉中影响到你。比如说，你手头正好有一组依赖于底层硬件(比如多处理器)的函数，他们在操纵连续字节时比手动编码要快很多，而你想充分利用这种硬件优势：&lt;/p&gt;
&lt;p&gt;bool BitCompare(void* begin,void* end,void* another);&lt;/p&gt;
&lt;p&gt;这个函数将区间[begin,end)之间的字节与another开始的字节相比较，如果有一位不同就返回false，否则返回true。&lt;/p&gt;
&lt;p&gt;比如你想将这个函数用于你自己的类的operator==中，这样可以利用硬件加快速度。不过你在动手前要充分考虑，你的class是否真的要比较每一位。如果在类的成员中存在编译器填充的字节数，那么应用以上的函数就是不正确的，因为填充的字节中可以有不同的值。为了保证你可以用Bitwise
Compare，你必须确保填充的字节中的值也是相同的。这不仅要求你在类的构造函数中初始化类的每一bit而不是每一个成员，也要求你在复制初始化和复制赋值函数中也同时保证bitwise
copy语义，而不是编译器默认产生的memberwise语义。当然，你可能通过与BitCompare一同提供的BitCopy来完成这个艰巨的任务。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.6 I386平台C函数的可变参数表(Variable Arguments)</title><link href="//farseerfc.me/zhs/c-tricks-2-6-i386-variable-arguments.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:zhs/c-tricks-2-6-i386-variable-arguments.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 导入&lt;/p&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h2&gt;2.6 I386平台C函数的可变参数表(Variable Arguments)&lt;/h2&gt;
&lt;p&gt;基于前文(2.4节)分析，我们可以不通过函数签名，直接通过指针运算，来得到函数的参数。由于参数的压栈和弹出操作都由主调函数进行，所以被调函数对于参数的真实数量不需要知晓。因此，函数签名中的变量声明不是必需的。为了支持这种参数使用形式，C语言提供可变参数表。可变参数表的语法形式是在参数表末尾添加三个句点形成的省略号“...”：&lt;/p&gt;
&lt;p&gt;void g(int a,char* c,...);&lt;/p&gt;
&lt;p&gt;省略号之前的逗号是可选的，并不影响词法语法分析。上面的函数g可以接受2个或2个以上的参数，前两个参数的类型固定，其后的参数类型未知，参数的个数也未知。为了知道参数个数，我们必须通过其他方法，比如通过第一个参数传递：&lt;/p&gt;
&lt;p&gt;g(3,”Hello”,2,4,5);//调用g并传递5个参数，其中后3个为可变参数。&lt;/p&gt;
&lt;p&gt;在函数的实现代码中，可以通过2.4节叙述的，参数在栈中的排列顺序，来访问位于可变参数表的参数。比如:&lt;/p&gt;
&lt;p&gt;void g(int a,char* c...){&lt;/p&gt;
&lt;p&gt;void *pc=&amp;amp;c;int* pi=static_cast&amp;lt;int*&amp;gt;(pc)+1;//将pi指向首个可变参数&lt;/p&gt;
&lt;p&gt;for(int i=0;i&amp;lt;a;i++)std::cout&amp;lt;&amp;lt;pi[i]&amp;lt;&amp;lt;” ”；&lt;/p&gt;
&lt;p&gt;std::cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;std::endl;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;我们甚至可以让一个函数的所有参数都是可变参数，只要有办法获知参数的数量即可。比如，我们约定，在传递给addAll的参数都是int，并且最后一个以0结束：&lt;/p&gt;
&lt;p&gt;int addAll(...);&lt;/p&gt;
&lt;p&gt;int a=f(1,4,2,5,7,0);&lt;/p&gt;
&lt;p&gt;那么addAll可以这样实现：&lt;/p&gt;
&lt;p&gt;int addAll(...){&lt;/p&gt;
&lt;p&gt;int sum=0;int *p=&amp;amp;sum; //p指向第一个局部变量&lt;/p&gt;
&lt;p&gt;p+=3; //跳过sum，ebp，eip，现在p指向第一个参数&lt;/p&gt;
&lt;p&gt;for(;*p;++p) //如果p不指向0就继续循环&lt;/p&gt;
&lt;p&gt;sum+=*p;&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;可变参数表的最广泛应用是C的标准库函数中的格式化输入输出：printf和scanf。&lt;/p&gt;
&lt;p&gt;void printf(char *c,...);&lt;/p&gt;
&lt;p&gt;void scanf(char *c,...);&lt;/p&gt;
&lt;p&gt;两者都通过它的首个参数指出后续参数表中的参数类型和参数数量。&lt;/p&gt;
&lt;p&gt;如果可变参数表中的参数类型不一样，那么操纵可变参数表就需要复杂的指针运算，并且还要时刻注意边界对齐(align)问题，非常令人头痛。好在C标准库提供了用于操纵可变参数表的宏(macro)和结构(struct)，他们被定义在库文件stdarg.h中:&lt;/p&gt;
&lt;p&gt;typedef struct {char *p;int offset;} va_list;&lt;/p&gt;
&lt;p&gt;#define va_start(valist,arg)&lt;/p&gt;
&lt;p&gt;#define va_arg(valist,type)&lt;/p&gt;
&lt;p&gt;#define va_end(valist)&lt;/p&gt;
&lt;p&gt;其中结构va_list用于指示参数在栈中的位置，宏va_start接受一个va_list和函数的可变参数表之前的参数，通过第一个参数初始化va_list中的相应数据，因此要使用stdarg.h中的宏，你的可变参数表的函数必须至少有一个具名参数。va_arg返回下一个类型为type的参数，va_end结束可变参数表的使用。还是以上文的addAll为例，这次写出它的使用标准宏的版本：&lt;/p&gt;
&lt;p&gt;int addAll(int i,...)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;va_list vl; //定义一个va_list结构&lt;/p&gt;
&lt;p&gt;va_start(vl,i); //用省略号之前的参数初始化vl&lt;/p&gt;
&lt;p&gt;if(i=0)return 0; //如果第一个参数就是0，返回&lt;/p&gt;
&lt;p&gt;int sum=i; //将第一个参数加入sum&lt;/p&gt;
&lt;p&gt;for(;;){&lt;/p&gt;
&lt;p&gt;i=va_arg(vl,int); //取得下一个参数，类型是sum&lt;/p&gt;
&lt;p&gt;if(i==0)break; //如果参数是0，跳出循环&lt;/p&gt;
&lt;p&gt;sum+=i;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;va_end(vl);&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;可以看出，如果参数类型一致，使用标准库要多些几行代码。不过如果参数类型不一致或者未知(printf的情况)，使用标准库就要方便很多，因为我们很难猜出编译器处置边界对齐(align)等汇编代码的细节。使用标准库的代码是可以移植的，而使用上文所述的其它方法操纵可变参数表都是不可移植的，仅限于在I386平台上使用。&lt;/p&gt;
&lt;p&gt;纵使可变参数表有使用上的便利性，它的缺陷也有很多，不可移植性和平台依赖性只是其一，最大的问题在于它的类型不安全性。使用可变参数表就意味着编译器不对参数作任何类型检查，这在C中算是一言难尽的历史遗留问题，在C++中就意味着恶魔reinterpret_cast被你唤醒。C的可变参数表是C++代码错误频发的根源之一，以至于C++标准将可变参数表列为即将被废除的C语言遗留特性。C++语法中的许多新特性，比如重载函数、默认参数值、模板，都可以一定程度上替代可变参数表，并且比可变参数表更加安全。&lt;/p&gt;
&lt;p&gt;可变参数表在C++中惟一值得嘉奖的贡献，是在模板元编程(TMP)的SFINAE技术中利用可变参数表制作最差匹配重载。根据C++标准中有关函数重载决议的规则，具有可变参数表的函数总是最差匹配，编译器在被逼无奈走头无路时才会选择可变参数表。利用这一点，我们可以精心制作重载函数来提取类型信息。比如，要判断一个通过模板传递来的类型是不是int：&lt;/p&gt;
&lt;p&gt;long isIntImp(int);&lt;/p&gt;
&lt;p&gt;char isIntImp(...);&lt;/p&gt;
&lt;p&gt;template&amp;lt;typename T&amp;gt;&lt;/p&gt;
&lt;p&gt;struct isInt&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;enum{value=sizeof(isIntImp(T()))==sizeof(long);}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;然后，在一个具有模板参数T的函数中，我们就可以写&lt;/p&gt;
&lt;p&gt;if(isInt&amp;lt;T&amp;gt;::value)//...&lt;/p&gt;
&lt;p&gt;在这个(不怎么精致的)例子中，如果T是int，那么isIntImp的第一个重载版本就会被选中，返回值类型就是long，这样value就为1。否则，编译器只能选中第二个具有可变参数表的重载版本，返回值类型成为char，这样value就为0。把它说得再明白一些，上文的代码所表达的意思是：如果类型T是int，那它就是int，否则它就不是int，呵呵简单吧。这种通过重载决议规则来提取类型信息的技术，在模板元编程中被称作SFINAE，它和其它模板元编程技术被广泛运用于STL、Boost等模板库的开发实现之中。&lt;/p&gt;
&lt;p&gt;值得注意的是，在上文SFINAE的运用中，isIntImp并没有出现定义而只提供了声明，因为我们并没有实际调用isIntImp函数，而只是让它参与重载决议并用sizeof判断其返回值类型。这是C++的一个设计准则的完美体现：不需要的东西可以不出现。由于这一准则，我们避免了在C++中调用具有可变参数表的函数这一危险举动，而仅仅利用了可变参数表在语法分析过程中的特殊地位，这种对于危险语言特性的巧妙利用是善意而无害的。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.7 I386平台的其它函数调用模型</title><link href="//farseerfc.me/zhs/c-tricks-2-7-i386-calling-conventions.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:zhs/c-tricks-2-7-i386-calling-conventions.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 导入&lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.7 I386平台的其它函数调用模型&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;上文介绍的只是I386平台上C函数调用的标准模型，被称作__cdecl。事实上，Microsoft Visual C++编译器还支持其它一些函数调用模型，所有调用模型名称皆以双下划线开头，下面列出所有函数调用模型的异同：&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="cdecl"&gt;
&lt;h3&gt;1 __cdecl&lt;/h3&gt;
&lt;p&gt;参数压栈顺序：逆序(从右至左)&lt;/p&gt;
&lt;p&gt;参数堆栈恢复者：主调函数(caller)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__cdecl明确地指出函数使用C函数调用模型，这是默认的调用模型。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stdcall"&gt;
&lt;h3&gt;2 __stdcall&lt;/h3&gt;
&lt;p&gt;参数压栈顺序：逆序(从右至左)&lt;/p&gt;
&lt;p&gt;参数堆栈恢复者：被调函数(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__stdcall是微软所谓的标准调用模型。可惜的是它与__cdecl不兼容。几乎所有的Win32API函数使用这种函数调用模型，希望在DLL之间，或者在程序和WinNT操作系统之间传递函数指针的函数也应该使用这种模型。与__cdecl模型的不同之处在于，__stdcall模型下由被调函数恢复堆栈。主调函数在call语句之后，不需要再加上add语句。而被调函数的ret语句则被添加一个参数，代表函数参数堆栈的长度。因此，被调函数需要明确的知晓函数参数的数量和类型，所以在__stdcall模型下不支持可变参数表，所有参数必须写明。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="thiscall"&gt;
&lt;h3&gt;3 __thiscall&lt;/h3&gt;
&lt;p&gt;参数压栈顺序：逆序(从右至左)，this用ecx传递。&lt;/p&gt;
&lt;p&gt;参数堆栈恢复者：被调函数(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__thiscall是VC编译器中类的非静态成员函数(non-static member functon)的默认调用模型。但是如果此成员函数有可变参数表，VC编译器会使用__cdecl。和__stdcall一样，__thiscall由被调函数恢复堆栈。比较独特的是__thiscall会通过ecx寄存器传递成员函数的this指针，而__cdecl下this指针是通过在参数表最前面增加一个函数参数来传递的。__thiscall是VC编译器对this指针的使用的一种优化，大大提高了面向对象程序的效率。在VC2003及之前的编译器上__thiscall不是一个关键字，不能被显式指定。但可以给成员函数显式指定__cdecl来避免使用__thiscall。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="fastcall"&gt;
&lt;h3&gt;4 __fastcall&lt;/h3&gt;
&lt;p&gt;参数压栈顺序：逆序(从右至左)，前两个32位函数参数放入ecx和edx中&lt;/p&gt;
&lt;p&gt;参数堆栈恢复者：被调函数(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;快速函数调用模型，将前两个32位函数参数放入ecx和edx中，其余参数再逆序压栈。使用的是和__thiscall类似的优化技术，加快函数调用，适合运用在小型inline函数上。同样使用__stdcall形式的被调函数恢复堆栈，所以不支持可变参数表。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pascal"&gt;
&lt;h3&gt;5 __pascal&lt;/h3&gt;
&lt;p&gt;参数压栈顺序：正序(从左至右)&lt;/p&gt;
&lt;p&gt;参数堆栈恢复者：被调函数(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;过程式编程语言Pascal所使用的函数调用模型，由此得名。也是16位版本的Windows使用的API模型，过时的模型，现在已经废弃且禁止使用。你会看到有些书本仍会不时提到它，所以需要注意。__pascal是正序压栈，这与大部分I386函数模型都不相同。与__stdcall一样，由被调者恢复堆栈，不支持可变参数表。历史上曾有过的别名PASCAL、pascal、_pascal(单下划线)，现在都改成了__stdcall的别名，与__pascal(双下划线)不同。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;6 其它函数调用模型，以及模型别名。&lt;/h3&gt;
&lt;p&gt;__syscall：操作系统内部使用的函数调用模型，由用户模式向核心模式跳转时使用的模型。由于用户模式和核心模式使用不同的栈，所以没办法使用栈来传递参数，所有参数通过寄存器传递，这限制了参数的数量。用户模式编程中不允许使用。&lt;/p&gt;
&lt;p&gt;__fortran：数学运算语言fortran使用的函数模型，由此得名。在C中调用由fortran编译的函数时使用。&lt;/p&gt;
&lt;p&gt;__clrcall：微软.Net框架使用的函数模型，托管(Managed)C++默认使用，也可以从非托管代码调用托管函数时使用。参数在托管栈上正序(从左至右)压栈，不使用普通栈。&lt;/p&gt;
&lt;p&gt;CALLBACK、PASCAL、WINAPI、APIENTRY、APIPRIVATE：I386平台上是__stdcall的别名&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;WINAPIV：I386平台上是__cdecl的别名&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;7 函数调用模型的指定&lt;/h3&gt;
&lt;p&gt;函数调用模型的指定方式和inline关键字的指定方式相同，事实上，inline可以被看作是C++语言内建的一种函数调用模型。唯一不同的是，声明函数指针时，也要指明函数调用模型，而inline的指针是不能指明的，根本不存在指向inline函数的指针。比如：&lt;/p&gt;
&lt;p&gt;int CALLBACK GetVersion();&lt;/p&gt;
&lt;p&gt;int (CALLBACK * pf)()=GetVersion;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.1 X86概述</title><link href="//farseerfc.me/zhs/c-tricks-2-1-x86-architecture.html" rel="alternate"></link><updated>2007-08-27T16:33:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-27:zhs/c-tricks-2-1-x86-architecture.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 导入&lt;/p&gt;
&lt;div class="section" id="x86"&gt;
&lt;h2&gt;2.1   X86概述&lt;/h2&gt;
&lt;p&gt;所谓X86体系结构，是指以Intel
8086芯片为首的芯片所沿袭的CPU结构，一些文档中又被称作IA32体系结构。包括的芯片有但不限于:Intel
8086至
80486，奔腾(Pentium)系列处理器1至4，赛扬系列处理器，酷睿系列处理器，以及AMD的相应型号产品。X86体系结构在早期属于16位处理器，自80386之后扩展为32位处理器，所以一些文档中又把80386之后的32位处理器体系称作I386。自Pentium4后期，AMD的Athlon64开始，I386被进一步扩充为64位处理器，含有64位寻址能力的X86体系结构被称作X86-64或IA32-64。总之，市售的个人电脑用CPU，除苹果的Macintosh之外，全部采用X86体系结构芯片。&lt;/p&gt;
&lt;p&gt;在X86早期，16位的寻址能力只支持64KB(2^16=64K)内存，这显然是不够的。Intel采用分段寻址的方法，用4位段位+16位偏移量，提供了总共1MB(2^20=1M)的寻址能力。所以在X86的16位编程中，有两种指针类型：长指针(lp,long
pointer)和短指针(sp,short
pointer)，长指针(20位)提供整个内存空间寻址能力，短指针(16位)仅支持同一段中的寻址。在“古代”DOS及Win3.x编程过程中，两种类型的指针，以及总共1MB的内存大小，常常把程序员们折腾得焦头烂额。&lt;/p&gt;
&lt;p&gt;自I386之后，CPU才开始提供32位的寻址能力。有了整整4GB(2^32=4G)的寻址空间，所有指针统一为长指针(32位)。时至今日，我们仍可以看到微软文档中指针变量的lp前缀。由于内存管理的需要，分段机制被保留下来，但这一次不是因为地址空间太小，而是因为地址空间远大于实际内存容量，从而采用了虚拟内存机制。&lt;/p&gt;
&lt;p&gt;在从16位结构向32位结构转变的过程中，由于向下兼容的历史原因，曾一度长时间出现硬件32位(I386)、软件16位(Win3.x)的情况。同样也是为了兼容16位软件，Win9x操作系统(Win95、Win98、WinME)保留了16位代码和32位代码。混合代码的设计使得Win9x及其混乱和不稳定。直到完全32位内核的操作系统WinNT(以及构建于其上的Win2000，WinXP，Win2003)的出现，X86平台上内存布局混乱的局面才得以改善。有了从16位至32位移植的经验和准备，现今的从32位到64位的操作系统移植显得平稳顺利很多。WinXP和WinVista系统都同时发布了32位版本和64位版本，并且其x86-64系统都实现了对32位软件的无缝衔接支持。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 1.2 逗号运算符(,)、逻辑运算符(&amp;&amp;,||)与运算符重载的陷阱</title><link href="//farseerfc.me/zhs/c-tricks-1-2-trap-in-comma-logical-operator.html" rel="alternate"></link><updated>2007-08-22T18:06:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-22:zhs/c-tricks-1-2-trap-in-comma-logical-operator.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 导入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.2   逗号运算符(,)、逻辑运算符(&amp;amp;&amp;amp;,||)与运算符重载的陷阱&lt;/h2&gt;
&lt;p&gt;很多人甚至不知道逗号(,)也是个C++运算符。与语法上要求出现的逗号(比如分隔函数参数的逗号)不同的是，出现在表达式中的逗号运算符在语义上表示多个表达式操作的连续执行，类似于分隔多语句的分号。比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt;(&lt;strong&gt;int&lt;/strong&gt;i=0,j=9;i&amp;lt;10;++i&lt;strong&gt;,&lt;/strong&gt;--j)std::cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;”+”&amp;lt;&amp;lt;j&amp;lt;&amp;lt;”=9\n”;&lt;/p&gt;
&lt;p&gt;在这句语句中，出现了两个逗号，其中前者是语法上用来分隔声明的变量的，并非逗号运算符，而后者则是一个逗号运算符。根据C++标准，逗号运算符的执行顺序为从左到右依次执行，返回最后一个子表达式的结果。由于只有最后一个表达式返回结果，所以对于一个语义正常的逗号表达式而言，前几个子表达式必须具有副作用。同时，从语言的定义中也可以看出，逗号表达式对求值的顺序有严格要求。&lt;/p&gt;
&lt;p&gt;对求值顺序有要求的，除了逗号表达式和条件表达式(参见1.1)，在C++中还有逻辑运算符(&amp;amp;&amp;amp;和||)。逻辑运算相较于数学运算和位运算而言，有个显著的不同点：逻辑运算在计算到一半时，就有可能已经得到结果，这样继续运算另一半就不是必需的。对于A&amp;amp;&amp;amp;B，如果A=false，那么无论B为何值，整个的结果都是false；同样的A||B，如果A=true，那么不考虑B，结果一定是true。&lt;/p&gt;
&lt;p&gt;C++标准规定，如果逻辑运算到一半(算出A)时，就已经可以确定运算的结果，那么就不运算剩下的另一半(B)。这种执行语义被称作“短路”。在其它一些编程语言中，短路语义是可以选择的：在Ada里非短路的逻辑运算符为and和or，短路的逻辑运算符为and_then和or_else。但是在C++中，逻辑运算符的短路语义是语法上强制的，我们没有非短路版本的运算符。如果确实需要非短路语义，我们总是可以通过增加一个bool中间变量加以解决。有时，短路对于保证正确执行是必须的，比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char&lt;/strong&gt;*p=getString();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(p&lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;*p)std::cout&amp;lt;&amp;lt;p;&lt;/p&gt;
&lt;p&gt;这段代码在得到了一个字符串后，在字符串不为空时输出它。在C++中判断一个字符串不为空需要两个步骤：判断指针是否为0，以及指针不为0时判断指针指向的内容是否为’’。就像条件表达式中讨论到的(参见1.1)，在p为空时提领p是个极其危险的操作。逻辑运算符的短路语义则避免了这种危险。&lt;/p&gt;
&lt;p&gt;以上对逗号运算符与逻辑运算符的讨论，仅限于C++标准所定义的运算符语义。为什么这样说呢？这是因为在C++中，运算符的语义是可以由程序员自行定义的，这种机制叫做运算符重载(operator
overload)。运算符重载可以将人们熟悉的运算符表达式转换成函数调用，使编程灵活而直观，是个方便的语言特性。不过有时运算符重载也会使人困扰，那就是当运算符重载遇到求值顺序问题时。&lt;/p&gt;
&lt;p&gt;C++中，并不是所有合法运算符都可以被合法地重载。条件运算符虽然对求值顺序有要求，但它并不在可重载运算符之列，所以运算符重载机制对它没有影响。问题在于，逗号运算符和逻辑运算符都可以被合法地重载：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class&lt;/strong&gt; BadThing{/* Some Bad and Stupid Thing*/};&lt;/p&gt;
&lt;p&gt;BadThing&amp;amp; &lt;strong&gt;operator&lt;/strong&gt;,(BadThing&amp;amp;, BadThing&amp;amp;);//重载了逗号运算符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bool&lt;/strong&gt; &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(BadThing&amp;amp;, BadThing&amp;amp;);//重载了&amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;BadThing b1,b2;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(b1&amp;amp;&amp;amp;b2)b1,b2;//被替换成如下形式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(b1,b2))&lt;strong&gt;operator&lt;/strong&gt;,(b1,b2);&lt;/p&gt;
&lt;p&gt;可以看到，重载了运算符之后，对运算符的使用被替换为相应的函数调用形式。因此，旧有的运算符的执行顺序不再适用，取而代之的是函数参数的压栈顺序。&lt;/p&gt;
&lt;p&gt;根据C++标准规定，任何参数必须在进入函数之前压栈，所以在进入&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;之前，b1、b2就会被求值，这里不再有短路规则，任何依赖于短路语义的不知不觉间操作BadThing的代码(可能通过模板)都会混乱。&lt;/p&gt;
&lt;p&gt;短路语义只是一个方面，更重要的在于压栈顺序。鉴于执行效率和旧代码兼容性等细节问题，C++标准在压栈顺序上给编译器的开发者留有很大自主性。标准的说辞是，编译器可能以任何它觉得方便的顺序将参数压栈，从左到右，从右到左，甚至从中间到两边，在这一点上我们不能安全地做任何假设。在上面的例子中，编译器生成的代码可能先计算b1再计算b2，也可能是相反的顺序。再看看编译器的实际情况，在我试过的所有基于X86体系结构的编译器中，参数都是以逆向压栈，即从右到左，有悖于大多数人的阅读习惯和直觉(别说你是来自伊斯兰的……)。&lt;/p&gt;
&lt;p&gt;在C时代使用函数调用时，压栈顺序并不是什么大问题，毕竟大多数人会在函数调用的边界稍稍小心一些。但是到了C++中，事情变得有些复杂，因为简单如a+b的使用，就有可能被运算符重载机制替换为函数调用。更何况有模板参与之后，我们写代码时不能确定对象的真实类型，也就无法预知一个运算符是否真的被重载过，唯一稳妥的方法是，假定任何有可能被重载的运算符的使用都是函数调用。&lt;/p&gt;
&lt;blockquote&gt;
&amp;lt;p style="margin:0;"&amp;gt;&lt;/blockquote&gt;
&lt;p&gt;回到上文的示例中，由于,和&amp;amp;&amp;amp;都被替换为函数调用，程序的执行顺序将成为压栈顺序，在X86上很有可能是从右到左，与标准定义的运算符的顺序正好相反。逗号运算符原本就含有“先…后…”的语义，这种颠倒的执行顺序势必造成程序和程序员的混乱。以我的经验而言，含有&lt;strong&gt;operator&lt;/strong&gt;,的类，完全没有办法和STL或者iostream相互协作，反而会导致巨量的错误报告(什么叫巨量的错误报告有概念么？如果没有，那说明你还没玩过范式编程(GP,
Generic
Programming)。去玩玩GP吧，看看你的编译器对巨量的定义。在我手头，针对3.5KB的代码文件倾泻出3.8&lt;strong&gt;MB&lt;/strong&gt;的错误信息的编译器不在少数……)。有鉴于此，我的结论是，除非你有充足的依据支持你这么做(比如你的粗暴上司的键盘上只剩下逗号能用)，并且你清楚的了解这么做的后果的严重性(比如至少要看过此文)，否则我奉劝你，永远不要碰&lt;strong&gt;operator&lt;/strong&gt;,、&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;以及&lt;strong&gt;operator&lt;/strong&gt;||！&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 1.1 条件运算符(?:)</title><link href="//farseerfc.me/zhs/c-tricks-1-1-conditional-operator.html" rel="alternate"></link><updated>2007-08-22T18:05:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-22:zhs/c-tricks-1-1-conditional-operator.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 导入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.1   条件运算符(?:)&lt;/h2&gt;
&lt;p&gt;条件运算符(?:)是C++中唯一的三目运算符(trinary
operator)，用于在表达式中作条件判断，通常可以替换if语句，与Visual
Basic中的iif函数、Excel中的if函数有同样的作用。语法形式如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;condition&lt;/em&gt; ? &lt;em&gt;true_value&lt;/em&gt; : &lt;em&gt;false_value&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;em&gt;condition
*条件是任何可以转换为bool类型的表达式，包括但不仅限于**bool*&lt;/em&gt;、&lt;strong&gt;int&lt;/strong&gt;、指针。与&lt;strong&gt;if&lt;/strong&gt;和&lt;strong&gt;while&lt;/strong&gt;的条件部分稍显不同的是，这里不能定义变量，否则会导致语法错误。&lt;/p&gt;
&lt;p&gt;另外，条件语句会切实地控制执行流程，而不仅仅是控制返回值。也就是说，两个返回值表达式中永远只有一个会被求值，在表达式的执行顺序很重要时，这点尤为值得注意。比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=pi&lt;strong&gt;?&lt;/strong&gt;*pi&lt;strong&gt;:&lt;/strong&gt;0;&lt;/p&gt;
&lt;p&gt;这里，只有当pi的值不为0时，它才会被提领(dereference)。这种语义保证了程序的正确性，因为提领一个空指针将导致致命的运行期错误(通常是非法操作的警告)。同时，正因为条件运算符控制运算流程的特点，使得它不能用类似iif的普通函数来模拟：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; iif(&lt;strong&gt;int&lt;/strong&gt; con,&lt;strong&gt;int&lt;/strong&gt; t,&lt;strong&gt;int&lt;/strong&gt;f){&lt;strong&gt;if&lt;/strong&gt;(c)&lt;strong&gt;return&lt;/strong&gt; t;&lt;strong&gt;return&lt;/strong&gt; f;}//试图模拟?:&lt;/p&gt;
&lt;p&gt;…//in some function&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=iif(pi,*pi,0);//Error!&lt;/p&gt;
&lt;p&gt;这段代码会导致上文提到的致命运行期错误。C/C++标准规定，参数在被传递给函数之前求值，因此无论pi为何值，都会被提领。又因为函数传回一个空指针的情况比较少见，所以这样的错误在调试时很难被发现，一旦发生又势必造成重大灾难。这样的代码在实践中应尽量避免。&lt;/p&gt;
&lt;p&gt;有时，条件运算符控制流程的特点会不知不觉影响我们的代码。在C时代，最大值MAX通常用宏实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#define&lt;/strong&gt;MAX(a,b) ((a)&amp;gt;(b)&lt;strong&gt;?&lt;/strong&gt;(a)&lt;strong&gt;:&lt;/strong&gt;(b))&lt;/p&gt;
&lt;p&gt;需要用额外的括号将宏参数和宏本体保护起来，以免运算符优先级扰乱逻辑，这是宏丑陋的特点之一，这里暂且不提。矛盾在于，用具有副作用的表达式调用宏时，会出现问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=5,j=6;//…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=MAX(++i,++j);&lt;/p&gt;
&lt;p&gt;代码的作者原意显然是想先将i,j分别递增，再将其中较大的一个赋给a。执行这段代码，当i=5,j=6时，a=8，知道为什么吗？通过宏展开，赋值语句成这样：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=(++i)&amp;gt;(++j)&lt;strong&gt;?&lt;/strong&gt;(++i)&lt;strong&gt;:&lt;/strong&gt;(++j);//删除了多余括号&lt;/p&gt;
&lt;p&gt;在判断之前，i、j被分别自增一次，然后舍弃:之前的部分，j又被自增一次。执行之后，i=6,j=8。&lt;/p&gt;
&lt;p&gt;MAX的更正确更安全的实现，是利用模板将类型参数化。STL标准算法中就有一个这样的工具级模版函数std::max。&lt;/p&gt;
&lt;p&gt;条件运算符是表达式而不是语句，这使得它可以出现在任何需要表达式的地方，这扩大了它的适用范围。在那些语法上只能出现表达式而不能出现语句的地方（比如变量初始化），条件运算符有着不可替代的作用。&lt;/p&gt;
&lt;p&gt;条件运算符优于&lt;strong&gt;if&lt;/strong&gt;语句的另一个场合是“模板元编程”(TMP, Template
MetaProgramming)。在TMP这个古怪奇异的编译期运算编程技术中，一切旧有的技术和法则被全线击破，我们所能仰仗的工具，只有模板特化(Specialization)、&lt;strong&gt;typedef&lt;/strong&gt;s、函数声明(无法调用它们)、以及编译期常量运算。已经有人很深入地论证过，仅有以上这些，就已经形成了一个“图灵完善”的计算机语言。我们可以用模板特化技术，来模拟条件分支，循环迭代等一系列复杂的语言结构。由于可以参与编译期常量运算，条件运算符在TMP世界中很自然地扮演起重要角色。&lt;/p&gt;
&lt;p&gt;比如，给与类型T的一个变量t，我们想声明一个缓冲区存放t和一个int，缓冲区的大小不小于sizeof(T)也不小于sizeif(int)，我们可以这样写：&lt;/p&gt;
&lt;p&gt;char buffer[sizeof(T)&amp;gt;sizeof(int)? sizeof(T): sizeof(int)];&lt;/p&gt;
&lt;p&gt;我们不能用一个if语句替换这个运算：&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;if(sizeof(T)&amp;gt;sizeof(int))i=sizeof(T);&lt;/p&gt;
&lt;p&gt;else i=sizeof(int);&lt;/p&gt;
&lt;p&gt;char buffer[i];//语法错误!&lt;/p&gt;
&lt;p&gt;原因在于数组声明中的下标必须是一个编译期常量，而不是一个运行期的值，条件表达式的运算可以在编译期进行，if语句就只能在执行期执行。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry></feed>