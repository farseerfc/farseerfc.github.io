<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Farseerfc的小窝</title><link>//farseerfc.github.io/zhs/</link><description></description><atom:link href="//farseerfc.github.io/feeds/farseerfc.rss.xml" rel="self"></atom:link><lastBuildDate>Fri, 12 Dec 2014 17:06:00 +0900</lastBuildDate><item><title>从非缓冲输入流到 Linux 控制台的历史</title><link>//farseerfc.github.io/zhs/from-unbuffered-stdin-to-history-of-linux-tty.html</link><description>&lt;html&gt;&lt;body&gt;
&lt;p&gt; 这篇也是源自于水源 C 板上板友的一个问题，涉及 Linux 上的控制台的实现方式和历史原因。因为内容比较长，所以在这里再排版一下发出来。 &lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1418138991,file,M.1418138991.A.html"&gt; 原帖在这里 &lt;/a&gt;  。 &lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt; 可以设置不带缓冲的标准输入流吗？ &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;WaterElement(UnChanged)  于 2014 年 12 月 09 日 23:29:51  星期二   问到： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 请问对于标准输入流可以设置不带缓冲吗？比如以下程序 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 似乎还是需要在命令行输入后按回车才会让 &lt;code class="code"&gt;
fgets&lt;/code&gt;
  返回，不带缓冲究竟体现在哪里？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt; 这和缓存无关，是控制台的实现方式的问题。 &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 再讲细节一点，这里有很多个程序和设备。以下按 linux  的情况讲： &lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 终端模拟器窗口（比如 xterm ）收到键盘事件 &lt;/li&gt;
&lt;li&gt; 终端模拟器 (xterm) 把键盘事件发给虚拟终端  pty1&lt;/li&gt;
&lt;li&gt;pty1  检查目前的输入状态，把键盘事件转换成 stdin  的输入，发给你的程序 &lt;/li&gt;
&lt;li&gt; 你的程序的 c  库从 stdin  读入一个输入，处理 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 标准库说的输入缓存是在 4  的这一步进行的。而行输入是在 3  的这一步被缓存起来的。 &lt;/p&gt;
&lt;p&gt; 终端 pty 有多种状态，一般控制台程序所在的状态叫「回显行缓存」状态，这个状态的   意思是 :&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 所有普通字符的按键，会回显到屏幕上，同时记录在行缓存区里。 &lt;/li&gt;
&lt;li&gt; 处理退格 ( &lt;kbd class="kbd"&gt;
BackSpace&lt;/kbd&gt;
 ) ，删除 ( &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;
 ) 按键为删掉字符，左右按键移动光标。 &lt;/li&gt;
&lt;li&gt; 收到回车的时候把整个一行的内容发给 stdin 。 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 参考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Cooked_mode"&gt;http://en.wikipedia.org/wiki/Cooked_mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 同时在 Linux/Unix 下可以发特殊控制符号给 pty 让它进入「 raw 」状态，这种状态下按键不会被回显，显示什么内容都靠你程序自己控制。如果你想得到每一个按键事件需要用 raw 状态，这需要自己控制回显自己处理缓冲，简单点的方法是用 readline  这样的库（基本就是「回显行缓存」的高级扩展，支持了 Home/End ，支持历史）或者 ncurses  这样的库（在 raw 状态下实现了一个简单的窗口 /  事件处理框架）。 &lt;/p&gt;
&lt;p&gt; 参考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/POSIX_terminal_interface#History"&gt;http://en.wikipedia.org/wiki/POSIX_terminal_interface#History&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 除此之外， &lt;kbd class="kbd"&gt;
Ctrl-C&lt;/kbd&gt;
  转换到 &lt;span class="caps"&gt;SIGINT&lt;/span&gt;  ， &lt;kbd class="kbd"&gt;
Ctrl-D&lt;/kbd&gt;
  转换到 &lt;span class="caps"&gt;EOF&lt;/span&gt;  这种也是在 3  这一步做的。 &lt;/p&gt;
&lt;p&gt; 以及，有些终端模拟器提供的 &lt;kbd class="kbd"&gt;
Ctrl-Shift-C&lt;/kbd&gt;
  表示复制这种是在 2  这一步做的。 &lt;/p&gt;
&lt;p&gt; 以上是 Linux/unix  的方式。  Windows 的情况大体类似，只是细节上有很多地方不一样： &lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 窗口事件的接收者是创建 cmd  窗口的 Win32  子系统。 &lt;/li&gt;
&lt;li&gt;Win32 子系统接收到事件之后，传递给位于命令行子系统的 cmd  程序 &lt;/li&gt;
&lt;li&gt;cmd  程序再传递给你的程序。 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Windows 上同样有类似行缓存模式和 raw 模式的区别，只不过实现细节不太一样。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="strace"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;strace 查看了下 &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WaterElement(UnChanged)  于 2014 年 12 月 10 日 21:53:54  星期三   回复： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 感谢 FC 的详尽解答。 &lt;/p&gt;
&lt;p&gt; 用 strace 查看了下，设置标准输入没有缓存的话读每个字符都会调用一次 read 系统调用，   比如输入 abc ： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;read(0, abc
"a", 1)                         = 1
read(0, "b", 1)                         = 1
read(0, "c", 1)                         = 1
read(0, "\n", 1)                        = 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果有缓存的话就只调用一次了 read 系统调用了： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;read(0, abc
"abc\n", 1024)                  = 4
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="raw-mode"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt; 如果想感受一下 raw mode&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 没错，这个是你的进程内 C 库做的缓存， tty 属于字符设备所以是一个一个字符塞给你的   程序的。 &lt;/p&gt;
&lt;p&gt; 如果想感受一下 raw mode  可以试试下面这段程序（没有检测错误返回值） &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;termios.h&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ttyfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/* reset tty - useful also for restoring the terminal when this process&lt;/span&gt;
&lt;span class="cm"&gt;   wishes to temporarily relinquish the tty&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="cm"&gt;/* flush and reset */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="cm"&gt;/* put terminal in raw mode - see termio(7I) for modes */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;raw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* copy original and then modify below */&lt;/span&gt;

    &lt;span class="cm"&gt;/* input modes - clear indicated ones giving: no break, no CR to NL,&lt;/span&gt;
&lt;span class="cm"&gt;       no parity check, no strip char, no start/stop output (sic) control */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_iflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BRKINT&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICRNL&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;INPCK&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISTRIP&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IXON&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* output modes - clear giving: no post processing such as NL to CR+NL */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_oflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OPOST&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* control modes - set 8 bit chars */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cflag&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CS8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* local modes - clear giving: echoing off, canonical off (no erase with&lt;/span&gt;
&lt;span class="cm"&gt;       backspace, ^U,...),  no extended functions, no signal chars (^Z,^C) */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_lflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ECHO&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICANON&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IEXTEN&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISIG&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* control chars - set return condition: min number of bytes and timer */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after 5 bytes or .8 seconds&lt;/span&gt;
&lt;span class="cm"&gt;                                                after first byte seen      */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* immediate - anything       */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after two bytes, no timer  */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after a byte or .8 seconds */&lt;/span&gt;

    &lt;span class="cm"&gt;/* put terminal in raw mode after flushing */&lt;/span&gt;
    &lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;atexit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt; 终端上的字符编程 &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;vander( 大青蛙 )  于 2014 年 12 月 12 日 08:52:20  星期五   问到： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 学习了！ &lt;/p&gt;
&lt;p&gt; 进一步想请教一下 fc 大神。如果我在 Linux 上做终端上的字符编程，是否除了用 ncurses 库之外，也可以不用该库而直接与终端打交道，就是你所说的直接在 raw 模式？另外，终端类型 vt100 和 linux 的差别在哪里？为什么 Kevin Boone 的 KBox 配置手册里面说必须把终端类型设成 linux ，而且要加上 terminfo 文件，才能让终端上的 vim 正常工作？ term info 文件又是干什么的？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;Linux 控制台的历史 &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 嗯理论上可以不用 ncurses  库直接在 raw  模式操纵终端。 &lt;/p&gt;
&lt;p&gt; 这里稍微聊一下 terminfo/termcap 的历史，详细的历史和吐槽参考 &lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater’s Handbook&lt;/a&gt;
 第 6 章 Terminal Insanity 。 &lt;/p&gt;
&lt;p&gt; 首先一个真正意义上的终端就是一个输入设备（通常是键盘）加上一个输出设备（打印机或者显示器）。很显然不同的终端的能力不同，比如如果输出设备是打印机的话，显示出来的字符就不能删掉了（但是能覆盖），而且输出了一行之后就不能回到那一行了。再比如显示器终端有的支持粗体和下划线，有的支持颜色，而有的什么都不支持。早期 Unix 工作在电传打字机（ TeleTYpe ）终端上，后来 Unix 被 port 到越来越多的机器上，然后越来越多类型的终端会被连到 Unix 上，很可能同一台 Unix 主机连了多个不同类型的终端。由于是不同厂商提供的不同的终端，能力各有不同，自然控制他们工作的方式也是不一样的。所有终端都支持回显行编辑模式，所以一般的面向行的程序还比较好写，但是那时候要撰写支持所有终端的「全屏」程序就非常痛苦，这种情况就像现在浏览器没有统一标准下写 HTML 要测试各种浏览器兼容性一样。   通常的做法是 &lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 使用最小功能子集 &lt;/li&gt;
&lt;li&gt; 假设终端是某个特殊设备，不管别的设备。 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 水源的代码源头 Firebird2000  就是那样的一个程序，只支持固定大小的 vt102 终端。 &lt;/p&gt;
&lt;p&gt; 这时有一个划时代意义的程序出现了，就是 vi ，试图要做到「全屏可视化编辑」。这在现在看起来很简单，但是在当时基本是天方夜谭。 vi  的做法是提出一层抽象，记录它所需要的所有终端操作，然后有一个终端类型数据库，把那些操作映射到终端类型的具体指令上。当然并不是所有操作在所有终端类型上都支持，所以会有一堆 fallback ，比如要「强调」某段文字，在彩色终端上可能 fallback  到红色，在黑白终端上可能 fallback  到粗体。 &lt;/p&gt;
&lt;p&gt;vi  一出现大家都觉得好顶赞，然后想要写更多类似 vi  这样的全屏程序。然后 vi  的作者就把终端抽象的这部分数据库放出来形成一个单独的项目，叫 termcap  （ Terminal
Capibility ），对应的描述终端的数据库就是 termcap  格式。然后 termcap  只是一个数据库（所以无状态）还不够方便易用，所以后来又有人用 termcap  实现了 curses  。 &lt;/p&gt;
&lt;p&gt; 再后来大家用 curses/termcap  的时候渐渐发现这个数据库有一点不足：它是为 vi  设计的，所以只实现了 vi  需要的那部分终端能力。然后对它改进的努力就形成了新的 terminfo  数据库和 pcurses  和后来的 ncurses  。然后 &lt;span class="caps"&gt;VIM&lt;/span&gt;  出现了自然也用 terminfo  实现这部分终端操作。 &lt;/p&gt;
&lt;p&gt; 然后么就是 X  出现了， xterm  出现了，大家都用显示器了，然后 xterm  为了兼容各种老程序加入了各种老终端的模拟模式。不过因为最普及的终端是 vt100  所以 xterm  默认是工作在兼容 vt100  的模式下。然后接下来各种新程序（偷懒不用 *curses 的那些）都以 xterm/vt100  的方式写。 &lt;/p&gt;
&lt;p&gt; 嗯到此为止是 Unix  世界的黑历史。 &lt;/p&gt;
&lt;p&gt; 知道这段历史的话就可以明白为什么需要 &lt;span class="caps"&gt;TERM&lt;/span&gt;  变量配合 terminfo  数据库才能用一些 Unix  下的全屏程序了。类比一下的话这就是现代浏览器的  user-agent 。 &lt;/p&gt;
&lt;p&gt; 然后话题回到 Linux  。大家知道 Linux  早期代码不是一个 &lt;span class="caps"&gt;OS&lt;/span&gt; ，而是 Linus  大神想在他的崭新蹭亮的 386-&lt;span class="caps"&gt;PC&lt;/span&gt;  上远程登录他学校的 Unix  主机，接收邮件和逛水源（咳咳）。于是 Linux  最早的那部分代码并不是一个通用 &lt;span class="caps"&gt;OS&lt;/span&gt;  而只是一个 bootloader  加一个终端模拟器。所以现在 Linux  内核里还留有他当年实现的终端模拟器的部分代码，而这个终端模拟器的终端类型就是 linux  啦。然后他当时是为了逛水源嘛所以 linux  终端基本上是 vt102  的一个接近完整子集。 &lt;/p&gt;
&lt;p&gt; 说到这里脉络大概应该清晰了， xterm 终端类型基本模拟 vt100 ， linux 终端类型基本模拟 vt102 。这两个的区别其实很细微，都是同一个厂商的两代产品嘛。有差别的地方差不多就是 &lt;kbd class="kbd"&gt;
Home&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
End&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageUp&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageDown&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;

 这些不在 &lt;span class="caps"&gt;ASCII&lt;/span&gt;  控制字符表里的按键的映射关系不同。 &lt;/p&gt;
&lt;p&gt; 嗯这也就解释了为什么在 linux 环境的图形界面的终端里 telnet  上水源的话，上面这些按键会错乱 ……  如果设置终端类型是 linux/vt102  的话就不会乱了。在 linux  的 &lt;span class="caps"&gt;TTY&lt;/span&gt;  里 telnet  也不会乱的样子。 &lt;/p&gt;
&lt;p&gt; 写到这里才发现貌似有点长 ……  总之可以参考 &lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater’s Handbook&lt;/a&gt;  里的相关历史评论和吐槽，那一段非常有意思。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Fri, 12 Dec 2014 17:06:00 +0900</pubDate><guid>tag:farseerfc.github.io,2014-12-12:zhs/from-unbuffered-stdin-to-history-of-linux-tty.html</guid><category>c</category><category>linux</category><category>stdio</category><category>tty</category><category>unix</category><category>ugh</category><category>ncurses</category><category>termcap</category><category>terminfo</category></item><item><title>KDE5 Plasma 之跳动卖萌的活动按钮</title><link>//farseerfc.github.io/zhs/jumping-kde5-plasma-activities-button.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 今天尝试 &lt;span class="caps"&gt;KDE5&lt;/span&gt; Plasma  的活动的时候无意间发现这个现象。只要把活动按钮拖出桌面，它就会在桌面边缘来回跳动。   视频如下： &lt;/p&gt;

&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/SSbf97jGSpI"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;div align="left" class="embed-responsive embed-responsive-16by9"&gt;&lt;embed align="middle" allowfullscreen="true" allowscriptaccess="always" class="embed-responsive-item" quality="high" src="http://player.youku.com/player.php/sid/XODQ0NjM2MzQ4/v.swf" type="application/x-shockwave-flash"&gt;&lt;/embed&gt;&lt;/div&gt;&lt;p&gt; 当然你可以把它再拖回来，所以这个问题还无伤大雅，只是卖萌。 &lt;/p&gt;
&lt;p&gt; 比比之前 Gnome3  那个跳动的界面真是好太多了： &lt;/p&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/TRQJdRHYwrw"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;div align="left" class="embed-responsive embed-responsive-16by9"&gt;&lt;embed align="middle" allowfullscreen="true" allowscriptaccess="always" class="embed-responsive-item" quality="high" src="http://player.youku.com/player.php/sid/XNjc4MjQ5NjE2/v.swf" type="application/x-shockwave-flash"&gt;&lt;/embed&gt;&lt;/div&gt;&lt;p&gt; 顺便，今天还看到一个卖萌的 &lt;span class="caps"&gt;KDE5&lt;/span&gt; Plasma  静音图标的翻译： &lt;/p&gt;
&lt;blockquote class="twitter-tweet" lang="zh-tw"&gt;&lt;p&gt;KDE5 のミュート画面の中国语翻訳、「静音」のはずだが「镜音」になっている。 Vocaloid ファンのネタだか、単なる入力ミスだか分からない。 &lt;a href="http://t.co/ipyHjXMscR"&gt;pic.twitter.com/ipyHjXMscR&lt;/a&gt;&lt;/p&gt;— Jiachen &lt;span class="caps"&gt;YANG&lt;/span&gt; (@farseerfc) &lt;a href="https://twitter.com/farseerfc/status/541944351270518784"&gt;2014 12 月 8 日 &lt;/a&gt;&lt;/blockquote&gt;&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 09 Dec 2014 01:54:00 +0900</pubDate><guid>tag:farseerfc.github.io,2014-12-09:zhs/jumping-kde5-plasma-activities-button.html</guid><category>kde5</category><category>plasma</category><category>linux</category><category>gnome3</category></item><item><title>嫁给我好么</title><link>//farseerfc.github.io/zhs/marry-me.html</link><description>&lt;html&gt;&lt;body&gt;&lt;img alt=" 嫁给我好么 " class="img-responsive" src="/images/marry-me.png"/&gt;

&lt;p&gt; 上面那个是装饰 …… 可以玩的是下面这个： &lt;/p&gt;
&lt;script src="/static/three.min.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/FirstPersonControls.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/helvetiker_regular.typeface.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/214game.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;div id="game_area" style="width: 600px; height: 450px; margin-left: 10px;"&gt;
&lt;/div&gt;
&lt;p style="margin-left: 100px; margin-top: 10px; "&gt;*  用 &lt;span class="caps"&gt;WASD&lt;/span&gt;←→  移动，需要 WebGL  支持 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Wed, 20 Feb 2013 20:42:00 +0900</pubDate><guid>tag:farseerfc.github.io,2013-02-20:zhs/marry-me.html</guid><category>will</category><category>you</category><category>marry</category><category>me</category></item><item><title>ICSE 2012</title><link>//farseerfc.github.io/zhs/icse2012.html</link><description>&lt;html&gt;&lt;body&gt;
&lt;div class="section" id="june-6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;June 6&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="keynote-1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id2"&gt;Keynote 1&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 没怎么听懂，只记得讲到了 finance is not money 但是没听懂这个和软件有什么关系。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cost-estimation-for-distributed-software-project"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id3"&gt;Cost Estimation for Distributed Software Project&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 讲到他们试图改善现有的模型去更精确地评估软件开发的开销。 &lt;/p&gt;
&lt;p&gt; 他们会给 PM 建议之前的项目的历史数据，然后对于新项目，他们建议历史上已有的项目的数据，从而帮助 PM 得到更精确的评估。他们试图尽量减少项目评估对 PM  的经验的需求，从而帮助即使经验很少的 PM 也能准确评估项目的开销。 &lt;/p&gt;
&lt;p&gt; 他们的观点： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Context-specfic solutions needed!&lt;/p&gt;
&lt;p&gt; 我们需要更上下文相关的解决方案！ &lt;/p&gt;
&lt;p&gt;Early user paticipation is key!&lt;/p&gt;
&lt;p&gt; 早期用户的参与是关键 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="characterizing-logging-practices-in-open-source-software"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id4"&gt;Characterizing Logging Practices in Open-Source Software&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Common mistakes in logging messages&lt;/p&gt;
&lt;p&gt; 在日志记录中容易犯的错误 &lt;/p&gt;
&lt;p&gt; 他们学习了历史上的 log 记录，然后试图找到重复修改的输出 log 的语句，确定 log  中存在的问题。他们首先确定修改是事后修改。 &lt;/p&gt;
&lt;p&gt; 通常的修改的比例（ 9027 个修改） &lt;/p&gt;
&lt;table border="1" class="docutils table-hover table table-striped"&gt;
&lt;colgroup&gt;
&lt;col width="10%"&gt;&lt;/col&gt;
&lt;col width="90%"&gt;&lt;/col&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;45%&lt;/td&gt;
&lt;td&gt; 静态文本 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;27%&lt;/td&gt;
&lt;td&gt; 打印出的变量 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;26%&lt;/td&gt;
&lt;td&gt; 调试等级 verbosity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2%&lt;/td&gt;
&lt;td&gt; 日志输出的位置 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; 他们发现有调试等级的变化，是因为安全漏洞之类的原因，或者在开销和数据   之间的权衡。 &lt;/p&gt;
&lt;p&gt; 大多数对 log 的变量的修改都是为了增加一个参数。他们之前的 LogEnhancer 是为了   解决这个问题而提出的，通过静态检查，提醒程序员是否忘记了某个参数 &lt;/p&gt;
&lt;p&gt; 对 text 的修改是因为要改掉过时的代码信息，避免误导用户。 &lt;/p&gt;
&lt;p&gt; 他们的实验是采用了基于 code clone  的技术，找到所有 log 语句，然后找不一致   的 clone ，然后自动提出建议。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="combine-functional-and-imperative-pgrm-for-multicore-sw-scala-java"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id5"&gt;Combine Functional and Imperative Pgrm for Multicore Sw: Scala &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; Java&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 趋势：到处都是多核，但是并发程序呢？ &lt;/p&gt;
&lt;p&gt; 他们研究的对象是 Scala 和 Java ，因为可以编译后确认 JVM 字节码的语义。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Java:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt; 共享内存 &lt;/li&gt;
&lt;li&gt; 显示创建的线程 &lt;/li&gt;
&lt;li&gt; 手动同步 &lt;/li&gt;
&lt;li&gt;Wait/Notify 机制 &lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Scala:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt; 高阶函数 &lt;/li&gt;
&lt;li&gt;Actors,  消息传递 &lt;/li&gt;
&lt;li&gt;lists, filters, iterators&lt;/li&gt;
&lt;li&gt;while&lt;/li&gt;
&lt;li&gt; 共享状态 , &lt;span class="caps"&gt;OO&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;import java.*  能从 java 导入任何库 &lt;/li&gt;
&lt;li&gt;auto type inferance  自动类型推导 &lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 实验的参与者都经过 4 周的训练，实验项目是工业等级的开发项目 &lt;/p&gt;
&lt;p&gt; 结果： &lt;/p&gt;
&lt;p&gt;scala  的项目平均比 java 多花 38% 的时间，主要都是花在 Test 和 debug 上的时间。 &lt;/p&gt;
&lt;p&gt; 程序员的经验和总体时间相关，但是对 test 和 debug 没有显著影响。 &lt;/p&gt;
&lt;p&gt;scala 的为了让编程更有效率的设计，导致 debug 更困难。比如类型推导， debug  的时候需要手动推导，来理解正在发生什么。 &lt;/p&gt;
&lt;p&gt;scala 的程序比 java 小，中位数 2.6% ，平均 15.2%&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt; 性能比较： &lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt; 单核： scala 的线性程序的性能比 java 好 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;4 核： &lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;scala 7s @ 4 threads&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;java 4si @ 8 threads&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;median&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;83s scala&lt;/li&gt;
&lt;li&gt;98s java&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;32core: best scala 34s @ 64 threads&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt; 结论 &lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;java 有更好的 scalability&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;scala 类型推导 &lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;45% 说对携带码有帮助 &lt;/li&gt;
&lt;li&gt;85% 说导致程序错误 &lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt; 调试 &lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;23% 认为 scala 简单 &lt;/li&gt;
&lt;li&gt;77% 认为 java 简单 &lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;multi-paradigram are better&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sound-empirical-evidence-in-software-testing"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id6"&gt;Sound Empirical Evidence in Software Testing&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Test data generation  测试数据自动生成 &lt;/p&gt;
&lt;p&gt;Large Empirical Studies - not always possible&lt;/p&gt;
&lt;p&gt;For open source software - big enough&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="identifing-linux-bug-fixing-patch"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;Identifing Linux Bug Fixing Patch&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;current practice:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;manual&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Current research:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;keywords in commits&lt;/li&gt;
&lt;li&gt;link bug reports in bugzilla&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Try to solve classification problem&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;issue&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;pre-identified&lt;/li&gt;
&lt;li&gt;post-identified&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;data&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;from commit log&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;feature extraction&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;text pre-process stemmed non-stop words&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;model learning&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;research questions&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="active-refinement-of-clone-anomaly-reports"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;Active Refinement of Clone Anomaly Reports&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;motivating&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;code clones, clone groups&lt;/li&gt;
&lt;li&gt;clone used to detect bugs&lt;/li&gt;
&lt;li&gt;anomaly : inconsistent clone group
many anomaly clone are note bug, high false positive&lt;/li&gt;
&lt;/ul&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;approach&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;reorder by sorted bug reports&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr class="docutils"/&gt;
&lt;div class="section" id="june7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;June7&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="keynotes-2-sustainability-with-software-an-industrial-perspective"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;Keynotes 2: Sustainability with Software - An Industrial Perspective&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Sustainability&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Classic View: Idenpendent view with overlap&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Social&lt;/li&gt;
&lt;li&gt;Environment&lt;/li&gt;
&lt;li&gt;Economic&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Nested viw&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Environment&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Social&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Economic&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;Triple bottom line&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;economic&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;-global business, networks , global econ&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;env&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;natural res, climate change, population grow&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;social&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;awareness, connectivity, accountability&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;div class="section" id="green-it"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id11"&gt;Green &lt;span class="caps"&gt;IT&lt;/span&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;reduce &lt;span class="caps"&gt;IT&lt;/span&gt; energy&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;more than 50% cooling - doing nothing&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;mini e-waste: not properly recycled&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;80% in &lt;span class="caps"&gt;EU&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;75% in &lt;span class="caps"&gt;US&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;foster dematerialization&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In-Memory Technology: Expected Sustainable Benefits&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-can-we-do"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id12"&gt;What can we do?&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;consider all software lifecycle phases in your design&lt;/li&gt;
&lt;li&gt;avoid energy expensive behavior in your codes&lt;/li&gt;
&lt;li&gt;design lean architectures&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="green-by-it"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id13"&gt;Green by &lt;span class="caps"&gt;IT&lt;/span&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2% green &lt;span class="caps"&gt;IT&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;98% green &lt;span class="caps"&gt;IT&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="on-how-often-code-is-cloned-across-repositories"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;On How Often code is cloned across repositories&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Line based hashing code clone detection&lt;/p&gt;
&lt;p&gt;never do anything harder than sorting&lt;/p&gt;
&lt;p&gt;hashing a window of 5 lines of normalized (tokenized) code, dropping
3/4 of the hashing&lt;/p&gt;
&lt;p&gt; 把 ccfinder 一个月的工作缩短到了 3, 4 天。没有比较 presion 和 recall 。 &lt;/p&gt;
&lt;table border="1" class="docutils table-hover table table-striped"&gt;
&lt;colgroup&gt;
&lt;col width="11%"&gt;&lt;/col&gt;
&lt;col width="89%"&gt;&lt;/col&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;14%&lt;/td&gt;
&lt;td&gt;type1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16%&lt;/td&gt;
&lt;td&gt;type2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;17%&lt;/td&gt;
&lt;td&gt;type3 (not really type2)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="graph-based-analysis-and-prediction-for-sw-evolution"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;Graph-based analysis and prediction for sw evolution&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="graph-are-everywhere"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id16"&gt;graph are everywhere&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;internet topology&lt;/li&gt;
&lt;li&gt;social net&lt;/li&gt;
&lt;li&gt;chemistry&lt;/li&gt;
&lt;li&gt;biology&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;in sw
- func call graph
- module dependency graph&lt;/p&gt;
&lt;p&gt;developer interaction graph
- commit logs
- bug reports&lt;/p&gt;
&lt;p&gt;experiment 11 oss, 27~171 release, &amp;gt; 9 years&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="predictors"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id17"&gt;predictors&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;NodeRank&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;similar to pagerank of google&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;measure relative importance of each node&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;func call graph with noderank&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;compare rank with severity scale on bugzilla&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;correlation between noderank and BugSeverity&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;func level 0.48 ~ 0.86 varies among projects.&lt;/li&gt;
&lt;li&gt;model level &amp;gt; func level&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;ModularityRatio&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;cohesion/coupling ratio: IntraDep(M)/InterDep(M)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;forecast mantencance effort&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;use for&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;identify modules that need redesign or refactoring&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;EditDistance&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;bug-based developer collaboration graphs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="caps"&gt;ED&lt;/span&gt;(G1,G2)=|V1|+|V2|-2|V1 交 V2|+|E1|+|E2|-2|E1 交 E2|&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;use for&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;release planning&lt;/li&gt;
&lt;li&gt;resource allocation&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;graph metrics&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;graph diameter&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;average node degree indicates reuse&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;clustering coefficient&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;assortativity&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;num of cycles&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id18"&gt;Conclusion&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;"Actionable intelligence" from graph evolution&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;studie 11 large long-live projs&lt;/li&gt;
&lt;li&gt;predictors&lt;/li&gt;
&lt;li&gt;identify pivotal moments in evolution&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-make-long-term-contributors-willingness-and-opportunity-in-oss"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;What make long term contributors: willingness and opportunity in &lt;span class="caps"&gt;OSS&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class="caps"&gt;OSS&lt;/span&gt; don’t work without contributors form community&lt;/p&gt;
&lt;p&gt;mozilla (2000-2008)&lt;/p&gt;
&lt;p&gt;10^2.2 &lt;span class="caps"&gt;LTC&lt;/span&gt; &amp;lt;- 2 order -&amp;gt; 10^4.2 new contributors &amp;lt;- 3.5 order -&amp;gt; 10^7.7 users&lt;/p&gt;
&lt;p&gt;gnome (1999-2007)&lt;/p&gt;
&lt;p&gt;10^2.5 &lt;span class="caps"&gt;LTC&lt;/span&gt; &amp;lt;- 1.5 order -&amp;gt; 10^4.0 new contributors &amp;lt;- 3.5 order -&amp;gt; 10^6.5 users&lt;/p&gt;
&lt;div class="section" id="approach"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id20"&gt;approach&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;read issues of 20 &lt;span class="caps"&gt;LTC&lt;/span&gt; and 20 non-&lt;span class="caps"&gt;LTC&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;suvery 56 (36 non-&lt;span class="caps"&gt;LTC&lt;/span&gt; and 20 &lt;span class="caps"&gt;LTC&lt;/span&gt;)&lt;/li&gt;
&lt;li&gt;extract practices published on project web sites&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="summeray"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id21"&gt;summeray&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Ability/Willingness distinguishes LTCs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Environment&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;macro-climate&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;popularity&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;micro-climate&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;attention&lt;/li&gt;
&lt;li&gt;bumber of peers&lt;/li&gt;
&lt;li&gt;performance of peers&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;regression model&lt;/p&gt;
&lt;p&gt;newcomers to &lt;span class="caps"&gt;LTC&lt;/span&gt; conversion drops&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;actions in first month predicts LTCs&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;24% recall&lt;/li&gt;
&lt;li&gt;37% precision&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="develop-of-auxiliary-functions-should-you-be-agile"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id22"&gt;develop of auxiliary functions: should you be agile?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;a empirial assessment of pair programming and test-first programming&lt;/p&gt;
&lt;p&gt;can agile help auxiliary functions?&lt;/p&gt;
&lt;div class="section" id="experiment"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id23"&gt;experiment&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;pair vs solo&lt;/li&gt;
&lt;li&gt;test-first vs test-last&lt;/li&gt;
&lt;li&gt;students vs professors&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="research-questions"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id24"&gt;research questions&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;r1: can pair help obtain more correct impl&lt;/li&gt;
&lt;li&gt;r2: can test-first&lt;/li&gt;
&lt;li&gt;r3: dst test1 encourage the impl or more test cases?&lt;/li&gt;
&lt;li&gt;r4: does test1 course more coverage&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="result"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id25"&gt;result&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;test-first&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;higher coverage&lt;/li&gt;
&lt;li&gt;non change with correctness&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;pair&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;improve on correctness&lt;/li&gt;
&lt;li&gt;longer total programming time&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="static-detection-of-resource-contention-problems-in-server-side-script"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id26"&gt;Static Detection of Resource Contention Problems in Server-side script&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Addressed the race condition of accessing database or filesystem of &lt;span class="caps"&gt;PHP&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="amplifying-tests-to-validate-exception-handling-code"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id27"&gt;Amplifying Tests to Validate Exception Handling Code&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 异常处理的代码不但难写，而且难以验证。各种组合情况难以估计，尤其是手机   系统上。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-tactic-centric-approach-automating-traceability-of-quality-concerns"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id28"&gt;A tactic-centric approach automating traceability of quality concerns&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;tactic traceability information models&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Wed, 06 Jun 2012 10:42:00 +0900</pubDate><guid>tag:farseerfc.github.io,2012-06-06:zhs/icse2012.html</guid><category>icse</category><category>software</category></item><item><title>MSR 2012 @ ICSE</title><link>//farseerfc.github.io/zhs/msr2012.html</link><description>&lt;html&gt;&lt;body&gt;
&lt;div class="section" id="mining-software-repository-2012-icse"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;Mining Software Repository 2012 @ &lt;span class="caps"&gt;ICSE&lt;/span&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt; 参加了今年的 MSR ，会场在 University of Zurich 。一大早来到大学，注册有点小插曲，显然瑞士人搞不清楚中国人的名字， 3 个杨（ Yang ）姓的中国人的名牌被搞错了。然后堀田学长的所属被写作了 “Japan, Japan” ，成为了全日本的代表。 &lt;/p&gt;
&lt;div class="section" id="msr-microsoft-research-talk-msr-mining-software-repositories"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id4"&gt;&lt;span class="caps"&gt;MSR&lt;/span&gt;(MicroSoft Research) talk @ &lt;span class="caps"&gt;MSR&lt;/span&gt;(Mining Software Repositories)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 首先是来自微软亚洲研究院（ MicroSoft Research @ Asia, &lt;span class="caps"&gt;MSR&lt;/span&gt; Asia ）的 Keynots ，于是就变成了 MSR 在 MSR 的演讲。 MSR 的张冬梅（ Dongmei Zhang ）女士的演讲分为关于 Software Analysis 和 XIAO 的两部分。 XIAO 是 MSRA 开发的 Code Clone
Detector ，似乎我要给井上研做的就是这个。想更多了解 Xiao 的细节，不过张女士   演讲结束的时候的鼓掌导致了话筒的小故障。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="towards-improving-bts-with-game-mechanisms"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id5"&gt;Towards Improving &lt;span class="caps"&gt;BTS&lt;/span&gt; with Game Mechanisms&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 感觉这篇的内容基本上就是关于 &lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.joelonsoftware.com/items/2008/09/15.html"&gt;http://www.joelonsoftware.com/items/2008/09/15.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 这里写到的东西，然后说同样的理论是否可以用于 Issue Tracking 之类的事情上。个人感觉这个意义不大， stackoverflow 之所以成功是因为它把开源社区本身就具有的名誉体系具现化了，本着大家都喜欢被别人奉为大牛的心态，就如同 wikipedia 一样。同样的理论如果用于公司内部的 Issue Tracking 系统上，会得到完全不同的东西吧。就像 MSDN 的组织方式虽然和 wikipedia 是一样的，但是在 MSDN  里找信息的感觉和在 wikipedia 完全不一样。个人不太看好这个方向。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ghtorrent"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id6"&gt;GHTorrent&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 这篇的 slide 在这里可以看到： &lt;a class="reference external" href="http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524"&gt;http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Data exporter for github. Github 的主要数据，代码，已经可以通过 git 接口获得了， wiki 是 git 的形式保存的。所以这个项目的目的就是暴露别的数据，主要是 issue tracking ， code comments ，这种。代码访问 github api ，然后用分布式实现以克服 api 的限制，然后提供 torrents 形式的 history 下载。 github api 获得的 json 数据以 bson 的形式保存在 MongoDB 里，解析过的有了 Schema 之后的数据保存   在 MySQL 里并可以导出 SQL 。 &lt;/p&gt;
&lt;p&gt; 个人的想法，觉得数据如果能够更统一，全部存在 Git 里或许更好，像 Wiki 一样。同样是要暴露全部历史记录的目的，用 Torrent 自己实现的历史远不如用 Git 的接口实现的历史记录方便吧， git blame 之类的也更方便追踪 code comment 之类的作者信息。当然对 git 的 raw date 直接读写，需要对 git 的内部原理有足够的理解，   或许只有 github 的人有这种能力了。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="topic-mining"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;Topic Mining&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 用得两个参数， &lt;span class="caps"&gt;DE&lt;/span&gt;  和 &lt;span class="caps"&gt;AIC&lt;/span&gt; ，完全不能理解，过后研究。实验针对了 Firefox,
Mylyn, Eclipse 三个软件。试图从 Repo 中分析源代码的 identifier 和 comments ，找到 topic 和 bug 之间的关系，比如怎样的 topic 更容易导致 bug 。得出的结论似乎也很暧昧，只是说核心功能被报告的 bug 更多，但是不知道原因。这只能表示核心   功能受到更多关注和更多测试吧，并不能说明核心功能就容易产生 bug 。 &lt;/p&gt;
&lt;p&gt; 不过这个的 Slide 做得很漂亮，很容易理解。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="secold"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;SeCold&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A linked data platform for mining software repositories&lt;/p&gt;
&lt;p&gt; 没听懂这个项目的目的。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-evolution-of-software"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;The evolution of software&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 第二天的 Keynotes ，关于将 Social Media 和 Software Development 相结合的想法。或许就是 Github 赖以成功的基础。讲到代码中的 comment, Tags, uBlog, blog 之类   的 social 的特性和 IDE 的融合的趋势。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="do-faster-releases-imporve-software-quality"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;Do Faster Releases Imporve Software Quality?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 使用 Firefox 作为例子。 &lt;/p&gt;
&lt;p&gt; 结论是快速发布导致 bug 更多，更容易 crash ，但是 bug 更快得到修复，并且用户   更快转向新的发布。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="security-vs-performance-bugs-in-firefox"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;Security vs Performance Bugs in Firefox&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Performance bugs are regression, blocks release.&lt;/p&gt;
&lt;/div&gt;
&lt;hr class="docutils"/&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt; 一些感想 &lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="commit"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id13"&gt; 基于自然语义分析的 commit 分割 &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt; 经常工具（比如 git ）的使用者并没有按照工具设计者的意图使用工具，这给 MSR
 带来很多困难。举个例子， git 有非常完美的 branch 系统，通常期望 git 的使用者能够在一次 commit 里 commit 一个功能，比如一个 bug 的修复，或者一个 feature 的   添加，但是事实上经常有很多逻辑上的 commit 被合并在一个里面了。 &lt;/p&gt;
&lt;p&gt; 或许这不是使用者的错，而是工具仍然不够人性的表现。或许我们可以自动把   一次的 commit 按照语义分割成多个。 &lt;/p&gt;
&lt;p&gt; 分割之后，可以更容易地把 issue 和 commit 关联，也更容易组织更多的研究。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="slides"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id14"&gt; 关于这次发表中大家用的 slides 系统 &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt; 题目为 “Incorporating Version Histories in Information Retrieval Based
Bug Localization” 的人用的 slide 是 beamer 的。公式很多， overlay 很多，列表很多，图片很少，典型的 beamer 做出的 slide 。思维导图用得很不错。今天一天   有至少 3 个 slide 是用 beamer 做的。 &lt;/p&gt;
&lt;p&gt; 题目为 “Towards Improving Bug Tracking Systems with Game Mechanisms”
 的人用了 prezi ，图片很多，过度很多。但是比如没有页号没有页眉页脚，正式   会议的场合不太方便。 &lt;/p&gt;
&lt;p&gt; 至少有六个以上用了 Apple Keynotes ， Keynotes 做出来的东西真的和 Powerpoint  做出来的很难区别，其中两个人用了初始的主题所以才看出来。 &lt;/p&gt;
&lt;p&gt; 剩下的自然是 PPT 。 MSRA 的张女士做的虽然是 PPT ，倒是有很多 beamer 的感觉，比如页眉页脚和 overlay 的用法。这些如果都是 PPT 做出来的，会多很多额外的   人力吧。 &lt;/p&gt;
&lt;p&gt; 值得一提的是有一个题目为 “Green Mining: A Methodology of Relating
Software Change to Power Consumption” 的人的 slide 全是 “ 劣质 ” 的手绘漫画，效果意外地好，很低碳很环保很绿色很可爱。具体效果可以参考下面的动画，虽然   现场看到的不是一个版本： &lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv"&gt;http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id15"&gt; 微软是个腹黑娘！ &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt; 嘛虽然这也不是什么新闻了。 MSR2012 的 Mining Challenge 的赞助商是微软，管理   组织者来自微软研究院，奖品是 Xbox 和 Kinect 。然后今年的题目是： &lt;/p&gt;
&lt;pre class="literal-block"&gt;
Mining Android Bug
&lt;/pre&gt;
&lt;p&gt; 我看到了微软满满的怨气 ……&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Sat, 02 Jun 2012 10:42:00 +0900</pubDate><guid>tag:farseerfc.github.io,2012-06-02:zhs/msr2012.html</guid><category>msr</category><category>icse</category><category>mining</category><category>software</category><category>repository</category></item><item><title>Pyssy 项目</title><link>//farseerfc.github.io/zhs/pyssy.html</link><description>&lt;html&gt;&lt;body&gt;&lt;div class="section" id="id1"&gt;
&lt;h2&gt; 简介 &lt;/h2&gt;
&lt;p&gt;Pyssy  是用于 &lt;a class="reference external" href="https://bbs.sjtu.edu.cn"&gt; 上海交通大学饮水思源站 &lt;/a&gt;  的一系列 Python  脚本和工具。 &lt;/p&gt;
&lt;p&gt;Pyssy  被有意设计为既可以托管寄宿在 &lt;span class="caps"&gt;SAE&lt;/span&gt; &lt;a class="footnote-reference" href="#sae" id="id3"&gt;[1]&lt;/a&gt;  上，也可以在单机上独立使用。 &lt;/p&gt;
&lt;p&gt; 项目地址： &lt;a class="reference external" href="http://pyssy.sinaapp.com/"&gt;http://pyssy.sinaapp.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github 上的源代码地址： &lt;a class="reference external" href="https://github.com/yssy-d3/pyssy"&gt;https://github.com/yssy-d3/pyssy&lt;/a&gt;&lt;/p&gt;
&lt;table class="docutils table-hover table  table-striped footnote" frame="void" id="sae" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;/col&gt;&lt;col&gt;&lt;/col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://sae.sina.com.cn/"&gt;Sina App Engine&lt;/a&gt;  ，新浪云平台，类似 &lt;a class="reference external" href="https://appengine.google.com/"&gt;Google App Engine&lt;/a&gt;  的东西。 &lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt; 依赖关系 &lt;/h2&gt;
&lt;p&gt;Pyssy  使用 &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt;  作为网页服务器，并且使用 Memcached  或者 Redis  作为抓取 &lt;em&gt; 水源 Web&lt;/em&gt;  的缓存。 &lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;SAE&lt;/span&gt; Python  环境下请开启 Memcached  支持。 &lt;/p&gt;
&lt;p&gt; 本地环境下请安装 Redis-py  并运行 redis-server  服务器程序。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Mon, 02 Apr 2012 12:42:00 +0900</pubDate><guid>tag:farseerfc.github.io,2012-04-02:zhs/pyssy.html</guid><category>python</category><category>sjtu</category><category>yssy</category></item><item><title>PyRuby</title><link>//farseerfc.github.io/zhs/mix-ruby.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 今天在 GitHub 上闲逛的时候看到一个叫做 &lt;a class="reference external" href="https://github.com/danielfm/pyruby"&gt;PyRuby&lt;/a&gt;  的项目。项目的 Readme 说得很好： &lt;/p&gt;
&lt;pre class="literal-block"&gt;
PyRuby - Some Ruby for your Python!
PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful.

Usage
All you have to do is import the ruby module:

import ruby
From now on you should be able to write Ruby code within a regular Python module. An example:

1.upto(10) { |n| puts n }
&lt;/pre&gt;
&lt;p&gt; 甚至 &lt;a class="reference external" href="http://pypi.python.org/pypi/pyruby/1.0.0"&gt;PyPI&lt;/a&gt;  上还有这个项目的包。 &lt;/p&gt;
&lt;p&gt; 一开始我还以为这又是一个野心勃勃的基于 PyPy 的 Ruby 实现，或者某种 trick 在 Python 里面直接调用 Ruby 解释器。 &lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt; 然后我想看看这个的源代码 &lt;/h2&gt;
&lt;p&gt; 只有一个 ruby.py 文件，内容是： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"""&lt;/span&gt;

&lt;span class="s"&gt;                              `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:`&lt;/span&gt;
&lt;span class="s"&gt;                       .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms.&lt;/span&gt;
&lt;span class="s"&gt;                  `:ohmdys+//::/::--::::////:-.```......`````.://:-`         `/dNs.&lt;/span&gt;
&lt;span class="s"&gt;               .+hNds:`-:-:///::------::///++///:--....--::///::-`.///.        `oMm/&lt;/span&gt;
&lt;span class="s"&gt;             /hNmo.`   ``    `....```````````      ...------:::-:/+/-.:/:`       /NMs&lt;/span&gt;
&lt;span class="s"&gt;            oMd/`      `::::--.---://+`           //`     `````-:::::+/-`::.`     :NM+&lt;/span&gt;
&lt;span class="s"&gt;            yN`       -+.`         `/`           o.               ``::.-:. ``      :NN:&lt;/span&gt;
&lt;span class="s"&gt;           :Nm        -             ./           :    `.-://///:-.   `-` ``         :NN-&lt;/span&gt;
&lt;span class="s"&gt;          /NM/           .-:::-.`   `/            `:sdmdhyMMMMMMNNmy/`               :mNo`&lt;/span&gt;
&lt;span class="s"&gt;        :hMd:          /dmddddNNmdy+-.          `smmy/-```hMMMMMMMhydm/ `-.``     `...:mMm+.&lt;/span&gt;
&lt;span class="s"&gt;      -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+-      dMN-`-+hmmmmdhhhhdddmMN-`-/o:    .-::::/oydms-&lt;/span&gt;
&lt;span class="s"&gt;     oNMo:+/::.         ``...--:/+ohNMNhs-      :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms.&lt;/span&gt;
&lt;span class="s"&gt;    .MMo:/`o:.:+sso+:-`             sM+           ./-`       /mNh+-....-/ymNNdo::--/shd+`  -`:mm:&lt;/span&gt;
&lt;span class="s"&gt;    /MM-o ./ ohhsooohNmy::sh.      `yM/                       `:oyyyyyyhys+:.` hy    `/Nh`  : -NN.&lt;/span&gt;
&lt;span class="s"&gt;    -MM// -: ``   y: odddhh+     -omNh-          `--.` ``          ````    .:ohMMs.    +Ms  /  yMo&lt;/span&gt;
&lt;span class="s"&gt;     hMoo .+.    :Mh  ````    `/hNd/.`           ohdddy::...`..`      `-/sdmdyo+NMNh+- :Mh  /  sMs&lt;/span&gt;
&lt;span class="s"&gt;     .mmh:..:.  :NMm       `-/dMNM+         ./+++/:`.hM:`.````.` `-/shmNmh+-`  /Mmooso.hM/ .: `mM/&lt;/span&gt;
&lt;span class="s"&gt;      .mNs://: .NMNMs-   -:-.`/+-sms.   `  `shyyyhy`sNd`   `.:+sdmmmdMM-.    .oNM+    :m/ `s``yMh&lt;/span&gt;
&lt;span class="s"&gt;       -mMo  . sMNdMNNh+-.        .ydyoyy`        ``+o::+shdddhs+:-.:MM.`.-+hNMMh-    `.`-/::dNs`&lt;/span&gt;
&lt;span class="s"&gt;        -NM-   mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.`    `/mMMdmmddNMm+`      ..-/hNh-&lt;/span&gt;
&lt;span class="s"&gt;         sMy   NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs  `..:+ymMMMMd+--yNh.        `+hNh:&lt;/span&gt;
&lt;span class="s"&gt;         -Mm   NMMM/yMh  -NM-`..--:NMo:--.`+My         :MNoydmNMMNmhdMh` -dNs`        `yMd:&lt;/span&gt;
&lt;span class="s"&gt;         `MN   mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/          yMy`&lt;/span&gt;
&lt;span class="s"&gt;          MN   yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-.      `yMMNs.          /My&lt;/span&gt;
&lt;span class="s"&gt;         `MN   :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM-      ./hNNy-           /Nd`&lt;/span&gt;
&lt;span class="s"&gt;         -Mh    dMydMmsNMNdNNMMmmmNMMMdddhys+yMo``       /Nm:  `:yNNdo.           .sNd.&lt;/span&gt;
&lt;span class="s"&gt;         +Ms    .mMsMN::NN:.:MN: `.+NM.      +Mo          +Mm+ymNdo-            .omm+`&lt;/span&gt;
&lt;span class="s"&gt;         yM:     .hNMd+:sMN. oMm.   oMo      +Mh   ```.:+shMNmy+-``.-:-..-//-`:yNmo`&lt;/span&gt;
&lt;span class="s"&gt;         mM.       :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/`&lt;/span&gt;
&lt;span class="s"&gt;        .Mm        ``  .-:/+osyyhhddddddddddhhyysoo+/:-.  `./+//--+oo/--+ymmy/.&lt;/span&gt;
&lt;span class="s"&gt;        :Mh   .:   `+:`        `.------------`      ```-////:/++/:../ydNdo:`&lt;/span&gt;
&lt;span class="s"&gt;        +Ms   `/`    :+o+:-```              ``..-::///++///:-.`-+ydNdo:`&lt;/span&gt;
&lt;span class="s"&gt;        oMs     :/:.``  `..---.``` ````````..-:/:::---.`  `-ohmmh+:`&lt;/span&gt;
&lt;span class="s"&gt;        /Mh       .://///:::-----.-----.......`       `-+hmmy+-&lt;/span&gt;
&lt;span class="s"&gt;         sMy`                                ``````-+ydmy+-&lt;/span&gt;
&lt;span class="s"&gt;          /mNs-`                        `./ohmNMNNNmy+-&lt;/span&gt;
&lt;span class="s"&gt;            /yNmho/:.``````````.-:/+syhdNmdyso+/-.`&lt;/span&gt;
&lt;span class="s"&gt;              `:+ydmNMNNNNNNNNNmdhys+/:.`&lt;/span&gt;
&lt;span class="s"&gt;                     ``.....`&lt;/span&gt;

&lt;span class="s"&gt;    LOL U MAD?&lt;/span&gt;
&lt;span class="s"&gt;"""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 是的 …… 的确 …… 这种尝试把 Python 和 Ruby 放在一起的想法绝对是疯了 ……&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Fri, 02 Mar 2012 23:09:00 +0900</pubDate><guid>tag:farseerfc.github.io,2012-03-02:zhs/mix-ruby.html</guid><category>python</category><category>ruby</category></item><item><title>关于C++模板的类型转换的讨论</title><link>//farseerfc.github.io/zhs/discuss-cpp-template-downcast.html</link><description>&lt;html&gt;&lt;body&gt;
&lt;p&gt; 这两天在饮水思源的 C 板，关于 C++ 模板的类型转换的一个讨论，后面是我的解答。 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt; 讨论地址 &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html"&gt;http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt; 原问题 &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt; 今天在书上看到模板演绎的时候可以允许 cast-down ，于是我写了个东西： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;_Test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BB&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DD&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//f(b);&lt;/span&gt;
    &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 奇怪的是重载决议的时候， &lt;code class="code"&gt;
f&lt;/code&gt;
  的情况下它就不让我特化的 &lt;code class="code"&gt;
f&amp;lt;A&amp;gt;&lt;/code&gt;
  进来。 &lt;/p&gt;
&lt;p&gt; 但是在 &lt;code class="code"&gt;
ff&lt;/code&gt;
  的情况下， &lt;code class="code"&gt;
ff&amp;lt;BB&amp;lt;long&amp;gt;&amp;gt;&lt;/code&gt;
  却进来了。 &lt;/p&gt;
&lt;p&gt; 在 VC10 和 GCC3.4 下测试 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt; 我的解答 &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt; 我们来设身处地地作为编译器，看一遍到底发生了什么。 &lt;/p&gt;
&lt;p&gt; 约定符号 &lt;code class="code"&gt;
#&lt;/code&gt;
 : &lt;code class="code"&gt;
A#B&lt;/code&gt;
  是把 &lt;code class="code"&gt;
B&lt;/code&gt;
  带入 &lt;code class="code"&gt;
A&amp;lt;T&amp;gt;&lt;/code&gt;
  的参数 &lt;code class="code"&gt;
T&lt;/code&gt;
  之后实例化得到的结果。 &lt;/p&gt;
&lt;div class="section" id="ff"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt; 首先看 ff 的情况。 &lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 处理到这句的时候，编译器看到了 &lt;code class="code"&gt;
DD&amp;lt;long&amp;gt;&lt;/code&gt;
  的实例化，于是去实例化 &lt;code class="code"&gt;
DD#long&lt;/code&gt;
  ，继而实例化了 &lt;code class="code"&gt;
BB#long&lt;/code&gt;
  。 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这句，首先计算重载函数集合。 &lt;/p&gt;
&lt;p&gt; 第一步，需要从参数 &lt;code class="code"&gt;
DD#long -&amp;gt; BB&amp;lt;T&amp;gt;&lt;/code&gt;
  推断 &lt;code class="code"&gt;
ff&amp;lt;T&amp;gt;&lt;/code&gt;
  的 &lt;code class="code"&gt;
T&lt;/code&gt;
  。根据函数模板参数推断规则： &lt;/p&gt;
&lt;pre class="literal-block"&gt;
:code:`class_template_name&amp;lt;T&amp;gt;`  类型的参数，可以用于推断 :code:`T`  。 &lt;/pre&gt;
&lt;p&gt; 于是编译器推断 &lt;code class="code"&gt;
T&lt;/code&gt;
  为 &lt;code class="code"&gt;
long&lt;/code&gt;
  。这里就算不是 &lt;code class="code"&gt;
BB&lt;/code&gt;
  而是完全无关的 &lt;code class="code"&gt;
CC&lt;/code&gt;
  都可以推断成功，只要 &lt;code class="code"&gt;
CC&lt;/code&gt;
  也是一个 &lt;code class="code"&gt;
CC&amp;lt;T&amp;gt;&lt;/code&gt;
  形式的模板。 &lt;/p&gt;
&lt;p&gt; 第二步，模板特化匹配。因为只有一个模板，所以匹配了最泛化的 &lt;code class="code"&gt;
ff&amp;lt;T&amp;gt;&lt;/code&gt;
  。 &lt;/p&gt;
&lt;p&gt; 第三步，模板实例化。 &lt;/p&gt;
&lt;p&gt; 推断了 &lt;code class="code"&gt;
long -&amp;gt; T&lt;/code&gt;
  之后，编译器实例化 &lt;code class="code"&gt;
ff#long&lt;/code&gt;
  。 &lt;/p&gt;
&lt;p&gt; 重载函数集合： &lt;code class="code"&gt;
{ff#long}&lt;/code&gt;
&lt;/p&gt;
&lt;p&gt; 然后重载抉择找到唯一的可匹配的实例 &lt;code class="code"&gt;
ff#long&lt;/code&gt;
  ，检查实际参数 &lt;code class="code"&gt;
DD#long&lt;/code&gt;
  可以隐式转换到形式参数 &lt;code class="code"&gt;
BB#long&lt;/code&gt;
  ，从而生成了这次函数调用。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="f"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt; 再来看 f 的情况。 &lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 计算候选重载函数集合。 &lt;/p&gt;
&lt;p&gt; 第一步，对所有 &lt;code class="code"&gt;
f&lt;/code&gt;
  模板推断实参。根据函数模板参数推断规则： &lt;/p&gt;
&lt;pre class="literal-block"&gt;
 带有 :code:`T`  类型的参数，可以用于推断 :code:`T`  。 &lt;/pre&gt;
&lt;p&gt; 于是 &lt;code class="code"&gt;
B -&amp;gt; T&lt;/code&gt;
  被推断出来了。 &lt;/p&gt;
&lt;p&gt; 第二步，模板特化匹配。 &lt;/p&gt;
&lt;p&gt; 这里 &lt;code class="code"&gt;
B&lt;/code&gt;
  不是 &lt;code class="code"&gt;
A&lt;/code&gt;
  ，所以不能用 &lt;code class="code"&gt;
f&amp;lt;A&amp;gt;&lt;/code&gt;
  特化，只能用 &lt;code class="code"&gt;
f&amp;lt;T&amp;gt;&lt;/code&gt;
  模板。 &lt;/p&gt;
&lt;p&gt; 第三步，模板实例化。 &lt;/p&gt;
&lt;p&gt;&lt;code class="code"&gt;
B&lt;/code&gt;
  带入 &lt;code class="code"&gt;
f&amp;lt;T&amp;gt;&lt;/code&gt;
  实例化成 &lt;code class="code"&gt;
f#B&lt;/code&gt;
  的过程中，实例化 &lt;code class="code"&gt;
traits#B&lt;/code&gt;
  。 &lt;/p&gt;
&lt;p&gt; 由于没有针对 &lt;code class="code"&gt;
B&lt;/code&gt;
  的特化，所以用 &lt;code class="code"&gt;
traits&amp;lt;T&amp;gt;&lt;/code&gt;
  模板， &lt;code class="code"&gt;
traits#B::value=false&lt;/code&gt;
  ，进而 &lt;code class="code"&gt;
enable_if#false&lt;/code&gt;
  没有 &lt;code class="code"&gt;
type&lt;/code&gt;
  ，出错。 &lt;/p&gt;
&lt;p&gt; 唯一的模板匹配出错，重载函数集合为空， SFINAE 原则不能找到合适的匹配，于是报错。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Sun, 26 Feb 2012 05:54:57 +0900</pubDate><guid>tag:farseerfc.github.io,2012-02-26:zhs/discuss-cpp-template-downcast.html</guid><category>C++</category><category>template</category><category>C</category></item><item><title>尝试一下 Pelican</title><link>//farseerfc.github.io/zhs/try-pelican.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 似乎一夜之间所有的 &lt;a class="reference external" href="http://blog.yxwang.me/2011/11/migrated-to-octopress/"&gt; 极客们 &lt;/a&gt;
&lt;a class="reference external" href="http://xoyo.name/2012/02/migrate-to-octopress/"&gt; 都 &lt;/a&gt;
&lt;a class="reference external" href="http://blog.xdite.net/posts/2011/10/07/what-is-octopress/"&gt; 有了 &lt;/a&gt;
&lt;a class="reference external" href="http://www.yangzhiping.com/tech/octopress.html"&gt; 自己 &lt;/a&gt;
 的 &lt;a class="reference external" href="http://pages.github.com/#user__organization_pages"&gt;Github 主页 &lt;/a&gt;
 和 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt;  博客。就像所有人在他们的博客中指出的，静态博客的确比传统的 WordPress 方式具有更多优势。自从看到这些我就一直在想着自己搭一个 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt;  。 &lt;/p&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt; 但是似乎 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt;  不适合我 &lt;/h2&gt;
&lt;p&gt; 一上手就被 &lt;a class="reference external" href="http://octopress.org/docs/setup/"&gt;Octopress 的搭建步骤 &lt;/a&gt;  烦到了。 &lt;a class="reference external" href="http://beginrescueend.com/"&gt;&lt;span class="caps"&gt;RVM&lt;/span&gt;&lt;/a&gt;  是什么？ &lt;a class="reference external" href="https://github.com/sstephenson/rbenv"&gt;rbenv&lt;/a&gt;  又是什么？看来 Ruby  社区的快节奏发展已经超过了我的想象，他们似乎需要一套发行版管理器来调和不同版本之间的 Ruby  的兼容性问题。虽然同样的兼容性问题在 Python  社区也有 &lt;a class="footnote-reference" href="#id10" id="id8"&gt;[1]&lt;/a&gt;  ，不过总觉得 Python  至少还没到需要一个发行版管理器的程度 &lt;a class="footnote-reference" href="#id11" id="id9"&gt;[2]&lt;/a&gt;  。 &lt;/p&gt;
&lt;p&gt; 真正的问题是我手上还没有一个可以让我随便玩的 Linux  环境（真的想要 …… ）。而无论是 &lt;a class="reference external" href="http://beginrescueend.com/"&gt;&lt;span class="caps"&gt;RVM&lt;/span&gt;&lt;/a&gt;  还是 &lt;a class="reference external" href="https://github.com/sstephenson/rbenv"&gt;rbenv&lt;/a&gt;  似乎都只支持 Unix/Linux/MacOSX  。身为极客就注定不能用 Windows  么？（或许是的 …… ）。 &lt;/p&gt;
&lt;p&gt; 剩下的问题就是 Ruby  和 Python  两大阵营的对立问题了。我不熟悉 &lt;a class="reference external" href="http://daringfireball.net/projects/markdown/"&gt;Markdown&lt;/a&gt;  ，相对来说比较喜欢 &lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;ReST&lt;/a&gt;  。似乎无论哪边都要依赖 &lt;a class="reference external" href="http://pygments.org/"&gt;Pygments&lt;/a&gt;  作为代码着色器，那么其实 Rubyist  也至少需要安装 Python  。我倾向于不依赖任何 Ruby  组件，最好没有 C  扩展的纯 Python  实现。 &lt;/p&gt;
&lt;p&gt; 于是我开始在 Github  上找 Python  的静态博客引擎。 &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt;  的作者 &lt;a class="reference external" href="https://github.com/mitsuhiko"&gt;mitsuhiko&lt;/a&gt;  写的 &lt;a class="reference external" href="https://github.com/mitsuhiko/rstblog"&gt;rstblog&lt;/a&gt;  看起来不错，不过似乎没有多少人在用。 &lt;a class="reference external" href="http://ringce.com/hyde"&gt;Hyde&lt;/a&gt;  似乎很完善，不过默认的标记语言是 MarkDown  ，又依赖于几个 Ruby  组建，而且官方网站的设计实在太前卫。最终我看到了 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt;  。 &lt;/p&gt;
&lt;table class="docutils table-hover table  table-striped footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;/col&gt;&lt;col&gt;&lt;/col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id8"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt; 比如 Python 2.x  与 3.x  之间看似难以跨越的鸿沟，以及 &lt;a class="reference external" href="http://pypy.org/"&gt;PyPy&lt;/a&gt;  、 &lt;a class="reference external" href="http://python.org/"&gt;CPython&lt;/a&gt;  、 &lt;a class="reference external" href="http://www.stackless.com/"&gt;Stackless&lt;/a&gt;  、 &lt;a class="reference external" href="http://cython.org/"&gt;Cython&lt;/a&gt;  等各个实现之间的微妙差别。 &lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils table-hover table  table-striped footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;/col&gt;&lt;col&gt;&lt;/col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id9"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt; 是的，我们有 &lt;a class="reference external" href="http://packages.python.org/distribute/easy_install.html"&gt;easy_install&lt;/a&gt;  ，我们有 &lt;a class="reference external" href="http://www.pip-installer.org/en/latest/index.html"&gt;pip&lt;/a&gt;  ，不过这些都是包管理器，都是装好特定的 Python 实现之后的事情。 Python 实现本身还不需要包管理器来管理。 Python  的版本问题基本上也只需要 &lt;a class="reference external" href="http://docs.python.org/release/3.0.1/library/2to3.html"&gt;2to3.py&lt;/a&gt;  和 &lt;a class="reference external" href="http://www.startcodon.com/wordpress/?cat=8"&gt;3to2.py&lt;/a&gt;  这样的轻量级转换器就可以了，你不需要为了安装多个软件而在硬盘里留下多个不同版本的 Python  。如果为了引用的稳定性，你可以用 &lt;a class="reference external" href="http://pypi.python.org/pypi/virtualenv"&gt;virtualenv&lt;/a&gt;  ，不过这又是另一回事情了。 &lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h2&gt; 那么就 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt;  吧 &lt;/h2&gt;
&lt;p&gt; 对我而言， &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt;  相比于 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt;  有几个好处： &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 纯 Python  实现。这意味着我可以换用任何 Python  解释器而不必担心兼容性问题。比如我就换成了 &lt;a class="reference external" href="http://pypy.org/"&gt;PyPy&lt;/a&gt; 。 &lt;/li&gt;
&lt;li&gt; 多语言支持。因为 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt;  的作者似乎是个法国人。不过这个似乎大部分人不需要 ……  我是想尽量把一篇博客写成三种语言作为锻炼吧。 &lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;ReST&lt;/a&gt;  。这样我就可以用 &lt;a class="reference external" href="http://webpages.charter.net/edreamleo/front.html"&gt;Leo&lt;/a&gt;  的 @auto-rst  直接写  ReST 了。简单方便快捷有效。 &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt; 不过似乎 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt;  的关注度不如 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt;  那么高，现在一些部分还有细微的问题： &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;pelican-import  从 WordPress  导入的时候对中文、日文的支持似乎很成问题。 &lt;/li&gt;
&lt;li&gt; 日期格式、时区、字符集、和多语言功能的结合度还不够。 &lt;strong&gt; 我在尝试改善它。 &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt; 模板还不够丰富。 &lt;/li&gt;
&lt;li&gt; 插件也不够多 ……&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt; 希望这么优秀的工具能够受到更多关注，以上这些问题都是增加关注度之后很快就能解决的问题。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="settings-py"&gt;
&lt;h2&gt; 我的设置  settings.py&lt;/h2&gt;
&lt;p&gt; 安装 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt;  很容易，一句话就够了： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; pip install pelican
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后把文章写成 ReST 的格式，放在 `pages` 文件夹里面。 ( 重新 ) 生成只要： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; pelican -s settings.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上传到  Github:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; git commit -am &lt;span class="s2"&gt;"Commit message"&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; git push
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 就这么简单。附上我的配置文件： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class="n"&gt;TIMEZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'Asia/Tokyo'&lt;/span&gt;

&lt;span class="n"&gt;DATE_FORMATS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;'en'&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="s"&gt;'usa'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;'%a, &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt; %b %Y'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="s"&gt;'zh'&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="s"&gt;'chs'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;'%Y-%m-&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;, %a'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="s"&gt;'jp'&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="s"&gt;'jpn'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;'%Y/%m/&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt; (%a)'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;# windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx&lt;/span&gt;
&lt;span class="n"&gt;LOCALE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;'usa'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'chs'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'jpn'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;        &lt;span class="c"&gt;# windows&lt;/span&gt;
          &lt;span class="s"&gt;'en_US'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'zh_CN'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'ja_JP'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c"&gt;# Unix/Linux&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_LANG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'zh'&lt;/span&gt;

&lt;span class="n"&gt;SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'Farseerfc Blog'&lt;/span&gt;
&lt;span class="n"&gt;AUTHOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'Jiachen Yang'&lt;/span&gt;

&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'farseerfcgithub'&lt;/span&gt;
&lt;span class="n"&gt;GITHUB_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'https://github.com/farseerfc'&lt;/span&gt;
&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'http://farseerfc.github.com'&lt;/span&gt;
&lt;span class="n"&gt;TAG_FEED&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'feeds/&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.atom.xml'&lt;/span&gt;

&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;'twitter'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'http://twitter.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'github'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'https://github.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'facebook'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'http://www.facebook.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'weibo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'http://weibo.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'renren'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'http://www.renren.com/farseer'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="n"&gt;TWITTER_USERNAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'farseerfc'&lt;/span&gt;

&lt;span class="n"&gt;THEME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;'notmyidea'&lt;/span&gt;
&lt;span class="n"&gt;CSS_FILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"wide.css"&lt;/span&gt;

&lt;span class="n"&gt;DEFAULT_CATEGORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;'Others'&lt;/span&gt;
&lt;span class="n"&gt;OUTPUT_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'.'&lt;/span&gt;
&lt;span class="n"&gt;PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'posts'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Fri, 24 Feb 2012 17:33:00 +0900</pubDate><guid>tag:farseerfc.github.io,2012-02-24:zhs/try-pelican.html</guid><category>python</category><category>pelican</category></item><item><title>关于我的Blogs</title><link>//farseerfc.github.io/zhs/about-my-blogs.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;p&gt; 很久没有写过 blog 或者之类的东西了。这边一直荒废着。 &lt;/p&gt;
&lt;p&gt; 由于国内被墙的原因，另一个 wordpress ：  &lt;a class="reference external" href="http://fchome.sinaapp.com/"&gt;http://fchome.sinaapp.com/&lt;/a&gt;  应该会同步更新这里的内容。 &lt;/p&gt;
&lt;p&gt; 抽空写点什么吧。 &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 27 Sep 2011 02:35:00 +0900</pubDate><guid>tag:farseerfc.github.io,2011-09-27:zhs/about-my-blogs.html</guid></item><item><title>“…if we do this work … ” —Bill Gates</title><link>//farseerfc.github.io/zhs/if-we-do-this-work.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 导入自 &lt;a class="reference external" href="http://blog.renren.com/blog/230263946/716517729"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From: Bill Gates&lt;/p&gt;
&lt;p&gt;’— Sent: Sunday, January 24, 1999 8:41 &lt;span class="caps"&gt;AM&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Jeff Westorinon; Ben Fathi ;&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;TO&lt;/span&gt;: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder&lt;/p&gt;
&lt;p&gt;Subject: &lt;span class="caps"&gt;ACPI&lt;/span&gt; extensions&lt;/p&gt;
&lt;p&gt;One thing I find myself wondering about is whether we shouldn’t try and
make the "&lt;span class="caps"&gt;ACPI&lt;/span&gt;" extensions somehow Windows specific.&lt;/p&gt;
&lt;p&gt;It seems unfortunate if we do this work and get our partners to do the
work and the result is that &lt;strong&gt;Linux works great without having to do the work&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maybe there is no way to avoid this problem but it does bother me.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Maybe we could define the APIs so that they work well with &lt;span class="caps"&gt;NT&lt;/span&gt; and not
the others even if they are open.&lt;/p&gt;
&lt;p&gt;Or maybe we could patent something relaled to this.&lt;/p&gt;
&lt;p&gt;From:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf"&gt;http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/&lt;span class="caps"&gt;PX03020&lt;/span&gt;.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 如果这就是我至今在 Xen4.0 上得不到 ACPI 3.0 的完善支持的原因，那么我诅咒 Bill Gates ！ &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Mon, 14 Mar 2011 20:34:00 +0900</pubDate><guid>tag:farseerfc.github.io,2011-03-14:zhs/if-we-do-this-work.html</guid><category>microsoft</category><category>linux</category><category>acpi</category></item><item><title>[zz]“西厢计划”原理小解</title><link>//farseerfc.github.io/zhs/zz-introducing-scholarzhang.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;p&gt; 好神奇的想法，先存着，以后慢慢研究 &lt;/p&gt;
&lt;p&gt; 原文： &lt;a class="reference external" href="http://blog.youxu.info/2010/03/14/west-chamber/"&gt;http://blog.youxu.info/2010/03/14/west- chamber/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 待月西厢下，迎风户半开。隔墙花影动，疑是玉人来。 &lt;/p&gt;
&lt;p&gt; 最近推上最流行的一个关键词是 ” 西厢计划 ”,  这个计划名字取得很浪漫，客户端叫做张生，对，就是西厢记里面那个翻墙去见崔莺莺小姐的张生；显然，服务器端必然叫做崔莺莺。客户端的张生是最重要的部件，可以不依赖于服务端工作。因为西厢计划的作者只是简要的介绍了一下原理，其他报道又语焉不详，我当时就觉得很好奇，花了昨天一个晚上详细读了一下源代码，终于知道怎么回事了，觉得原理非常漂亮，所以写篇文章介绍总结一下。 &lt;/p&gt;
&lt;p&gt; 先说大方向。大家都知道，连接被重置的本质，是因为收到了破坏连接的一个 &lt;span class="caps"&gt;TCP&lt;/span&gt;
Reset  包。以前剑桥大学有人实验过，客户端和服务器都忽略 Reset,
 则通信可以不受影响。但是这个方法其实只有理论价值，因为绝大多数服务器都不可能忽略 Reset  的 ( 比如 Linux,  需要 root  权限配置 iptables,  而且这本身也把正常的 Reset  给忽略了 ) 。只要服务器不忽略 Reset,
 客户端再怎么弄都没用，因为服务器会停止发送数据， Reset
 这条连接。所以，很多报道说西厢计划是忽略 Reset,
 我从源代码来看应该不是这样。在我看来，西厢计划是利用了墙的一个可能的弱点 – 墙只在连接发起的时候把一个 &lt;span class="caps"&gt;TCP&lt;/span&gt;  连接加入监听序列，如果墙认为这个连接终止了，就会从监听序列中去掉这条记录，这样，这条连接上后续的包就不会被监听。西厢计划就是让墙 “ 认为 ” 这个连接终止的一个绝妙的方法。只要墙认为这个连接两端都是死老虎，墙就不会触发关键词检测，其后所有的数据，都不存在连接被重置的问题了。 &lt;/p&gt;
&lt;p&gt; 如何让一个连接置之死地而后生，就是西厢计划那帮黑客神奇的地方了。这也不是一日之功。首先，这帮牛人发现，墙的是一个入侵检测系统，把含有关键字的包当成一种 “ 入侵 ” 来对待。采取这种设计有很多好处，但缺点是入侵检测系统可能具有的问题，墙都可能有。西厢计划主页上那篇著名的论文就是讲这些七七八八的漏洞的。可以说处理这些七七八八的漏洞是非常困难的，迫使墙的设计者 “ 拆东墙，补西墙 ” 。这样补来补去，外表看起来好像很牛逼的墙，其实有很多本质上无法简单修补的漏洞，其中有一个致命的，就是 &lt;span class="caps"&gt;TCP&lt;/span&gt;  连接状态的判定问题。出于入侵检测系统这种设计的局限，墙没有，也没办法准确判定一条 &lt;span class="caps"&gt;TCP&lt;/span&gt;  连接的状态，而只是根据两边收到的数据来 “ 推测 ” 连接的状态。而所有的关键词检测功能，都是基于 “ 连接还活着 ” 的这个推测的结果的。因为墙的规则是在连接发起的时候开始对这条连接的检测，在连接终止的时候停止对这条连接的检测，所以，一旦对连接的状态推测错误，把还活着的连接当成已经关闭的连接，墙就会放弃对这条连接上随后所有的包的检测，他们都会都透明的穿过墙的入侵检测。 &lt;/p&gt;
&lt;p&gt; 上面只是想法，具体到 &lt;span class="caps"&gt;TCP&lt;/span&gt;
 协议实现这一层，就要只迷惑墙，还不能触及我要通信的服务器。最理想的情况下，在任何有效通信之前，就能让墙出现错误判断，这些，就需要对 &lt;span class="caps"&gt;TCP&lt;/span&gt;  协议有深刻理解了。西厢计划的那帮黑客，居然真的去读 &lt;span class="caps"&gt;TCP&lt;/span&gt;  几百页的 &lt;span class="caps"&gt;RFC&lt;/span&gt; ，还居然就发现了方法（这里我假设读者都知道 &lt;span class="caps"&gt;TCP&lt;/span&gt;
 的三次握手过程和序列号每次加一的规则）。我们都知道，三次握手的时候，在收到服务器的 &lt;span class="caps"&gt;SYN&lt;/span&gt;/&lt;span class="caps"&gt;ACK&lt;/span&gt;
 的时候，客户端如果发送 &lt;span class="caps"&gt;ACK&lt;/span&gt;  并且序列号 +1
 就算建立连接了，但是客户端如果发送一个序列号没 +1  的 &lt;span class="caps"&gt;FIN&lt;/span&gt;
 （表示连接终止，但是服务器知道，这时候连接还没建立呢， &lt;span class="caps"&gt;FIN&lt;/span&gt;
 这个包状态是错的，加上序列号也是错的，服务器自己一判断，就知道这个包是坏包，按照标准协议，服务器随手丢弃了这个包） ,
 但这个包，过墙的时候，在墙看来，是表示连接终止的 ( 墙是 ma de in china,
 是比较山寨的，不维护连接状态，并且，墙并没有记下刚才服务器出去的 &lt;span class="caps"&gt;SYN&lt;/span&gt;/&lt;span class="caps"&gt;ACK&lt;/span&gt;
 的序列号，所以墙不知道序列号错了）。所以，墙很高兴的理解为连接终止，舒了一口气去重置其他连接了，   而这个连接，就成了僵尸，墙不管你客户端了，而这时候，好戏才刚刚开始。 &lt;/p&gt;
&lt;p&gt; 事实上，墙是双向检测的（或者说对每个包都检测的），因此，对服务器和客户端实现相同的对待方法，所以，墙不管客户端还不行，假如服务端有关键词传给客户端，墙还是有可能要发飙的（这里说有可能，因为我也不知道）。所以，最好的办法就是，让服务端也给墙一个终止连接的标志就好了。可是这个说起来简单，做起来难，怎么能让不受自己控制的服务器发一个自己想要的包呢？西厢计划的那帮黑客，再次去读几百页的 &lt;span class="caps"&gt;RFC&lt;/span&gt;,  令人惊讶的发现，他们居然在 &lt;span class="caps"&gt;RFC&lt;/span&gt;
 上发现了一个可以用的特性。我们上面说了，三次握手的时候，在收到 &lt;span class="caps"&gt;SYN&lt;/span&gt;/&lt;span class="caps"&gt;ACK&lt;/span&gt;
 后，客户端要给服务器发送一个序列号 +1  的 ACK ，可是，假如我不 +1 呢，直接发 &lt;span class="caps"&gt;ACK&lt;/span&gt;  包给服务器。墙已经认为你客户端是死老虎了，不理你了，不知道你搞什么飞机，让这个 &lt;span class="caps"&gt;ACK&lt;/span&gt;
 过了。可是服务器一看，不对啊，你给我的不是我期待的那个序列号， &lt;span class="caps"&gt;RFC&lt;/span&gt;
 上说了， &lt;span class="caps"&gt;TCP&lt;/span&gt;  包如果序列号错了的话，就回复一个 Reset.
 所以，服务器就回复了一个 Reset 。这个 Reset
 过墙的时候，墙一看乐了，服务器也终止连接了，好吧，两边都是死老虎了，我就不监听这条连接了。而至于客户端，这个服务器过来的 Reset  非常好识别，忽略就是。随后，客户端开始正确的发送 &lt;span class="caps"&gt;ACK&lt;/span&gt;,
 至此，三次握手成功，真正的好戏开始，而墙则认为客户端和服务器都是死老虎，直接放过。所以，张生就这样透明的过了墙。   至于过墙以后所有的事情，《西厢记》里面都有记载，各位读者自行买书学习。 &lt;/p&gt;
&lt;p&gt; 现在的西厢计划客户端，即 “ 张生 ” 模块的防连接重置的原理就是这样，服务器端，即莺莺模块的实现也是类似的。防 DNS 那个，不懂 &lt;span class="caps"&gt;DNS&lt;/span&gt;
 协议，所以看不懂。我猜想，因为开发人员都是黑客，所以自然喜欢用最经得起折腾和高度定制的 Linux  开发。现在看西厢计划的实现，因为依赖于 Linux  内核模块 netfilter,
 在 Linux  上如鱼得水，但往其他平台的移植可能是个亟待解决的问题。我觉得，在其他平台上，可以通过 libpcap  和 libnet
 ，在用户态实现相同的功能，就是有点麻烦而已，有兴趣的懂网络的可以照西厢计划原理，在家自行做出此功能；当然，全中国人民都用 Linux  最好  :)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;span class="caps"&gt;PS&lt;/span&gt; 1:  据说是西厢计划一个作者画的原理图： &lt;a class="reference external" href="http://img.ly/DIi"&gt;http://img.ly/DIi&lt;/a&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;span class="caps"&gt;PS&lt;/span&gt; 2:  我对 &lt;span class="caps"&gt;TCP&lt;/span&gt;  的理解仅限于课本，如果上面的对技术的理解有错，请大家指出。 &lt;/div&gt;
&lt;div class="line"&gt;&lt;span class="caps"&gt;PS&lt;/span&gt; 3:  有些漏洞，可能是设计上本质缺陷，不是那么容易修复的。 &lt;/div&gt;
&lt;div class="line"&gt;&lt;span class="caps"&gt;PS&lt;/span&gt; 4:  除了最后一个图，本文没有其他相关链接，如需相关资料，自行 Google 。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Wed, 17 Mar 2010 09:40:00 +0900</pubDate><guid>tag:farseerfc.github.io,2010-03-17:zhs/zz-introducing-scholarzhang.html</guid><category>zz</category></item><item><title>写程序让CPU占用率保持正弦函数</title><link>//farseerfc.github.io/zhs/sine-cpu.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 导入自 &lt;a class="reference external" href="http://blog.renren.com/blog/230263946/298871889"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 据说是一道微软的面试题。如题，写程序，让 Windows 的任务管理器中的性能监视器呈现正弦曲线。 &lt;/p&gt;
&lt;img alt=" 正弦曲线 " class="align-center img-responsive" src="http://fm531.img.xiaonei.com/pic001/20080602/23/14/large_10019p67.jpg"/&gt;
&lt;img alt=" 正弦曲线 " class="align-center img-responsive" src="http://fm541.img.xiaonei.com/pic001/20080602/23/14/large_9935o67.jpg"/&gt;

&lt;p&gt; 潜心钻研良久，得代码：（ java ） &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;sincpu&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++){&lt;/span&gt;
            &lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
            &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;calcNextSleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sin&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sleep&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;sleepTime&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleepTime&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;yield&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleepTime&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;period&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(;;){&lt;/span&gt;
            &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sin&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;period&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 多核 CPU 上测试时要注意关掉一个 CPU ： &lt;/p&gt;
&lt;img alt=" 多核 CPU 上测试 " class="align-center img-responsive" src="http://fm411.img.xiaonei.com/pic001/20080602/23/14/large_9946k67.jpg"/&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Mon, 02 Jun 2008 23:27:00 +0900</pubDate><guid>tag:farseerfc.github.io,2008-06-02:zhs/sine-cpu.html</guid><category>java</category><category>microsoft</category></item><item><title>关于神创论的一些见解</title><link>//farseerfc.github.io/zhs/some-thought-on-creationism.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 导入自 &lt;a class="reference external" href="http://blog.renren.com/blog/230263946/292274803"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 看到陈骉同学很有感想的一篇神创论与命运日志，觉得近日很久没有看到这样的评论了。想说几句自己的观点。 &lt;/p&gt;
&lt;p&gt; 首先我认为，神创论与宿命论没有多少关联，甚至进化论者相较于神创论者更容易接受宿命论的观点。因为神创论主张意志的存在，人所具有的个体意志与神的意志，因此在神创论者的眼中事件的结果是可以通过意志来改变的，亦即如果我从物理楼 11 楼跳下，那么我就可以改变自己死亡时间的宿命。上帝的意志同样可以左右事件的结果，也就是所谓的宿命不复存在。而进化论者不承认意志独立于物质世界的存在，你我的思考、行为，都受到物理学法则诸如量子力学的约束，这就引出了北大物理系教授的那句 “ 宇宙中的一切都是可以计算的 ” ，亦即宿命论。如我我选择现在从物理楼上跳下，我这一行为并不是处于个人的独立意志，乃是想证明这一点，亦即我跳楼这一举动是有其背后的动机与原因的，就如同计算机的输入必然导致了输出，宿命的必然终结于此。 &lt;/p&gt;
&lt;p&gt; 其次，关于事件的复杂度所导致的随机化，在大量混沌随机中也存在着如统计学和随机分形学这样的规律，并不是否认宿命的充分理由。 &lt;/p&gt;
&lt;p&gt; 关于神创论的合理性问题。我认为是否相信神的存在只是一个 boolean 二值问题，它为 true 为 false 本身并不重要，重要的是确定它的取值之后得到的推论与结果。如果否认神的存在，如现代数学这样的完美又何以存在，进化论者的解释是事物最终会向着更好更高级的方向发展，产生现代数学乃至现代科学是发展的必然。而这种论调显然有悖于物理中以热力学第二定律为首的，预言事物会随时间推演愈发混乱的论断。更进一步，甚至整个人类、整个生物系统的存在都是有悖于热力学推论的现象，是某种理论只能以 “ 小概率事件 ” 解释的现象。 &lt;/p&gt;
&lt;p&gt; 神创论的核心观点之一，是神的唯一存在性，按照邹恒明的比喻，这就如同数学中集合中元素的的唯一性一般至关重要。数学乃至近代科学的发展，其起源在于这种对神性的探求，而不仅仅是好奇心就可以解释的。反观东方文化中数学的发展，开始时领先于西方科学千余每年，但是始终作为一种 craft-oriented 的实用主义学科。可以说没有了神的唯一性支持，人们就不能确信自己能找到这样一种完美高效的学科，只能在实用的基础上发展其基础算数。可以想象，没有神的完美与唯一性，数学必将发展成现代化学或者微软软件这样，庞大而充满特例，到处都是修补与查表，怎么会像现在的完美、简洁与和谐。 &lt;/p&gt;
&lt;p&gt; 神创论者并不是将难题推与 “ 神 ” 然后放任不管，他们相信神是最为理智的存在，创人时人同样得到了神的智慧和理智，也就是神可以用人的理智来理解。 &lt;/p&gt;
&lt;p&gt; 引用牛顿《自然哲学的数学原理》中终章的话 “ 太阳、恒星、行星的这个极精致的结构不可能存在，除非通过一个有理智的和有权能的存在的设计和主宰 …… 他不是作为宇宙的灵魂，而是作为一切的主宰而统治所有 ……”&lt;/p&gt;
&lt;p&gt; 以上 ……&lt;/p&gt;
&lt;p&gt;( 发现最近的哲理思维果然慢了不少，写作思绪也一片混乱 ^_^)&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Mon, 12 May 2008 11:16:00 +0900</pubDate><guid>tag:farseerfc.github.io,2008-05-12:zhs/some-thought-on-creationism.html</guid><category>creationism</category></item><item><title>由记忆棒误差故障引发的关于面向对象设计的九点思考</title><link>//farseerfc.github.io/zhs/9-thoughts-about-oop-from-wrongly-insert-memory-stick.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;p&gt; 故障描述 :
&lt;span class="caps"&gt;MMC&lt;/span&gt; Memory Stick Duo 记忆棒未经 Adapter 适配器，直接插入 SD Reader ，致使 MMC 卡入 SD Reader 中。 &lt;/p&gt;
&lt;p&gt; 栈展开：某日下午，无课。忙于数分作业，想查询用手机拍摄的板书照片。取出手机中的 MMC 。未经装配 Adapter ，直接插入 SD Reader 。 (A runtime exception was thrown.)
 尝试翻转笔记本机身，倒出 MMC ，未果。 (rethrow)
 尝试用手指甲取出，未果。 (rethrow)
 考虑到有 “ 推入反弹 ” 机制，尝试将 MMC 推入更深，反弹机制由于类型不匹配而失效，未果。 (rethrow)
(The exception spread across the border of the model.)
 电脑维修技师接手 (catch)
 技师未能发现问题所在，由我解说原委。 (Because the exception lose the information, &lt;span class="caps"&gt;RTTI&lt;/span&gt; was asked to recall the information)
 技师发现问题，尝试用镊子镊出 MMC ，未果。技师开解机箱 (expose the data structure)
 技师制作钩子，勾出 MMC(hooker link to the structure)  取出 MMC ，故障解除 &lt;/p&gt;
&lt;p&gt; 故障总结  1. 接收到没有完全了解、或没有适当工具解决的 exception 时，不要尝试用不成熟的技术解决，应尽快寻求能解决它的代码。否则，被反复 rethrow 的 exception ，尤其是通过模块边界的 exception ，有可能由 subclass 退化为 superclass ，并因此而丧失一些信息。尽量不要让 exception 丢失信息，必要时，通过 RTTI 机制寻回信息。 &lt;/p&gt;
&lt;p&gt;2. 超负荷运转，多线程执行，这种种复杂性都有可能导致错误，应避免。无论你有多么信任你的代码或能力。 &lt;/p&gt;
&lt;p&gt;3. 在设计 class 的 interface 时，相匹配的 interface 应该满足 is-a 的关系。因此，任何能插入 SD Reader 的 object ，即任何实现了 SD interface 的 object ，都应该 is-a &lt;span class="caps"&gt;SD&lt;/span&gt; card 。这次故障中， interface 接受了 MMC ，但 MMC 不是 SD 。即使这种情况下 throw an exception ，都不能使事态缓和。能提供 compile-time error 时，尽量让错误以 compile-time error 的形式展现，并在事先解决。类型匹配问题是应该能在事先解决的问题。 &lt;/p&gt;
&lt;p&gt;4.Design patterns 中的 Adapter pattern 应该只是迫不得已情况之下的解决方案。只有当你无权改变现状时，才能使用 Adapter 。如果能改变现状，应该改变设计以符合 interface 。 &lt;/p&gt;
&lt;p&gt;5. 因为上条，所有相似功能的对象应具有相同的 interface ，不同的 interface 是本次故障的根源所在。 &lt;/p&gt;
&lt;p&gt;6. 特殊情况下，破坏封装机制并 expose the data structure 是必要的，应该有方法支持这种做法。 C 的指针和 C# 的 Reflection 技术都以不同的方式支持这种做法。其他的一些语言机制，比如 serializing( 序列化 ) 或 streaming( 流化 ) ，也可以以某种方式间接支持这一做法。当然，机制还应避免这种做法被滥用。 &lt;/p&gt;
&lt;p&gt;7. 相反功能具有相同操作的设计，容易造成使用的混乱，应适当避免。比如 SD Reader 的推入反弹设计，即插入和弹出使用同一个向里推的操作的设计。同样的设计还包括， C++ 中的 setNewHandle 使用同一个函数，同时设置和返回 handle 。以及有些书中提倡的，使用同名函数重载的方式，实现 setter/getter 的设计。 &lt;/p&gt;
&lt;p&gt;8. 特殊工具 (hooker) 对于解决特定问题，通常比手工解决有效。不要嫌麻烦而不愿意构造特殊工具。 &lt;/p&gt;
&lt;p&gt;9. 栈语义，即 FILO 顺序，总在不知不觉中影响我们。违反了 FILO 顺序的操作极易造成混乱。本故障发生时正确的处理顺序为：装配 Adapter
     插入 SD Reader
         读取数据          停用设备      拔出 SD Reader
 拆解 Adapter  本次故障的原因就是违反了 FILO 顺序，违反了栈语义。 &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Thu, 20 Sep 2007 14:38:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-09-20:zhs/9-thoughts-about-oop-from-wrongly-insert-memory-stick.html</guid><category>oop</category></item><item><title>Program Development in Java Preface</title><link>//farseerfc.github.io/zhs/program-development-in-java-preface.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt; 程序开发原理 &lt;/h2&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;—— 抽象、规格与面向对象设计 &lt;/h3&gt;
&lt;p&gt;Barbara Liskov  、 John Guttag  著 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 杨嘉晨等译 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt; 关于翻译风格： &lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 多年来阅读计算机类的著作及译作，感觉总体的困难在于一大堆没有标准译名的技术术语。由于通行于工业界和学术界的还是英文原名和术语，我决定保留大量的英文术语。这样的翻译风格借鉴于台湾著名的译者和作者侯捷先生。对于译与不译的权衡，主要考虑阅读的流畅，以及读者的理解能力，或许难免带有一些主观色彩。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="preface"&gt;
&lt;h2&gt; 前言  Preface&lt;/h2&gt;
&lt;p&gt; 构建产品级质量的程序 —— 可以在很长一段时间内使用的程序 —— 众所周知是极其困难的。本书的目标就是改善程序员解决这项任务的效率。我希望读者在阅读本书之后成为一名好程序员。我相信本书的成功在于改善编程技巧，因为我的学生告诉我这已经发生在他们身上。 &lt;/p&gt;
&lt;p&gt; 怎么才算是一名好程序员？是产生整个程序产品的效率。关键是要在每一阶段减少浪费掉的努力。解决的方法包括：在开始编写代码之前就仔细考虑你的实现方案，通过未雨绸缪的方法来编写代码，使用严格的测试在早期发现错误，以及仔细注意模块化编程，这样当错误出现时，只需要改动极少数代码就可以修正整个程序。本书涉及所有这些领域的技术。 &lt;/p&gt;
&lt;p&gt; 模块化编程 (Modularity) 是编写好程序的关键。把程序分解成许多小模块，每一个模块通过良好定义的狭窄接口和别的模块交互作用 (interact) 。有了模块化，可以修正一部分程序中的错误而不考虑程序的其他部分，而且可以仅仅理解一部分程序而不必理解整个程序。没有模块化，程序是一大堆有着错综复杂的相互关系的部分的拼凑。很难去领悟和修改这样一个程序，同样也很难让它正常工作。 &lt;/p&gt;
&lt;p&gt; 因此本书的重点在于创建模块化的程序：怎样把程序组织成一系列精心挑选的模块。本书认为模块化就是抽象 (abstraction) 。每一个模块意味着一个抽象，比如说指引一系列文档中的关键字的目录，或者在文档中使用目录来查找匹配某个问题的文档的过程。着重强调面向对象编程思想 —— 在程序中使用数据抽象和对象的思想。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 这本书使用 Java 作为它的编程示例的语言。我们没有假定读者已经熟悉 Java 。尽管可能没什么价值，但是本书中的思想是语言无关的，并且可以在任何语言的编程中使用。 &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="how-can-the-book-be-used"&gt;
&lt;h3&gt; 怎样使用这本书？ How Can the Book Be Used&lt;/h3&gt;
&lt;p&gt; 本书《程序开发原理》有两种使用方法。其一是作为课本教材，讲述如何用面向对象的方法来设计和实现复杂系统；其二是编程专家使用，帮助他们改善编程技能，增进他们的关于模块化和 Object-Oriented( 面向对象 ) 设计的知识。 &lt;/p&gt;
&lt;p&gt; 作为教材使用时，本书一般作为第二或第三门程序设计课程。我们已经在 MIT 使用本书很多年，给大一大二的本科生教授第二门编程课。在这一阶段，学生们已经知道怎样编写小程序。课程在两方面利用这一点：让学生更仔细地思考小程序，以及教他们如何利用小程序作为组件构建大型程序。这本书也可以在专业（如软件工程）后期教学中使用。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 建立在本书基础上的课程适合于所有计算机科学专业。尽管许多学生可能永远不会成为真正的大型程序的设计师，他们可以在开发部门工作，在那儿他们负责设计和实现能与整个结构耦合的子系统。模块化设计的子系统是这种任务中心，这对那些从事大型程序设计任务的人来说也同样重要。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-is-this-book-about"&gt;
&lt;h3&gt; 这本书讲什么？ What Is This Book About&lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 通观全篇三分之二的书致力于讨论在构建独立的程序模块时产生的问题，剩下的部分讨论怎样运用这些模块构建大型程序。 &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="program-modules"&gt;
&lt;h4&gt; 程序模块 Program Modules&lt;/h4&gt;
&lt;p&gt; 这一部分的书集中讨论抽象机制 (abstraction mechanism) 。它讨论 procedure( 子程序 ) 和 exception( 异常 ) ，数据抽象，遍历 (iteration) 抽象，数据抽象系列 (family) 以及多态 (polymorphic) 抽象。 &lt;/p&gt;
&lt;p&gt; 在对抽象的讨论中，三个步骤是重要的。首先是决定被抽象的东西到底是什么：它提供给它的用户哪些行为。创造抽象是设计的关键，因此本书讨论如何在众多选择中挑选，以及怎样才能创造出好的抽象。 &lt;/p&gt;
&lt;p&gt; 第二步是通过为一个抽象制定一个规格 (specification) 来获取它的意义。如果没有一些描述，一个抽象就会含糊不清，而变得没有使用价值。 specification 则提供了需要的描述。本书定义了一种 specification 的格式，讨论了一份好的 specification 应有的属性，并且提供了许多示例。 &lt;/p&gt;
&lt;p&gt; 第三步是实现抽象。本书讨论怎样设计一份实现，以及在简洁性和执行性能之间怎样权衡利弊。书中强调封装 (encapsulation) 的重要性以及在一份实现中履行规格中定义的行为的重要性。书中同样提供一些技术 —— 尤其是不变式断言 (representation
invariant) 和抽象函数 (abstraction function)—— 来帮助读者理解代码和它的原因。不变式断言和抽象函数都实现到尽可能的程度，这对于除错和调试很有用。 &lt;/p&gt;
&lt;p&gt; 关于类型层次 (type
hierarchy) 的材料注重讨论使用它作为抽象的技术 —— 一种把相关联的一组数据抽象归入同一系列的技术。这里很重要的一点是，是否应当将一个类型作为另一个类型的子类。本书定义了替换原则 —— 通过比较子类和父类的 specification ，来决定是否建立子类关系的方法 &lt;a class="reference external" href="#_ftn1"&gt;[1]&lt;/a&gt; 。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 本书同样涉及除错和调试。书中讨论怎样得到足够数量的测试情况，来准备通过黑箱和白箱测试，它同样强调了复查 (regression) 测试的重要性。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="programming-in-the-large"&gt;
&lt;h4&gt; 编写大型程序 Programming in the Large&lt;/h4&gt;
&lt;p&gt; 本书的其后部分讲解怎样用模块化的方法设计和实现大型程序。它建立在前文有关 abstraction 和 specification 的材料的基础之上。 &lt;/p&gt;
&lt;p&gt; 编写大型程序涵盖四个主要议题。首先讲解需求分析 —— 怎样才能领悟程序中需要什么。本书讨论怎样实施需求分析，也讨论书写产生的需求规格的方式，通过使用一种描述程序的抽象阶段的数据模型。使用这种模型将产生一份更为正式的 specification ，同时它也使需求检查更加严格，这样可以更好的领悟需求。 &lt;/p&gt;
&lt;p&gt; 编写大型程序的第二项议题是程序设计，这通常是一个循序渐进的过程。设计过程围绕构建有用的抽象来组织，这些抽象作为整个程序之中理想的构建组建。这些抽象在设计时被仔细的编写规格，这样当程序实现时，那些实现抽象的模块可以独立地开发。这种设计使用设计笔记编写文档，包括描述整个程序结构的模块间依赖性的图示。 &lt;/p&gt;
&lt;p&gt; 第三项议题是实现和测试。本书讨论了前置设计分析对于实现的必要性，以及怎样进行设计复审。它同样讨论了设计和实现的顺序。这一部分比较了自顶而下与自底而上的组织方式，讨论如何使用驱动程序和占位程序 &lt;a class="reference external" href="#_ftn2"&gt;[2]&lt;/a&gt;(stub) ，并且强调了制定一个事先的顺序策略的必要性，以满足开发组织和客户的需求。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 本书以一章设计模式 (design pattern) 结束。一些模式在前面的章节介绍过，比如遍历抽象是算法的主要组建。最后的章节讨论前文中没有涉及到的模式。希望它作为这一教材的介绍。有兴趣的读者可以继续阅读其它书中更完善的讨论 &lt;a class="reference external" href="#_ftn3"&gt;[3]&lt;/a&gt; 。 &lt;/div&gt;
&lt;/div&gt;
&lt;hr class="docutils"/&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref1"&gt;[1]&lt;/a&gt;  译注：如果子类的 specification 包括了所有父类的 specification ，就是说父类的要求也是子类的要求，或者子类的要求更为严格，那么可以建立父子关系。而替换原则的说法是，对于具有父子关系的类，任何需要一个父类对象的地方，都可以替换为一个子类对象。 &lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref2"&gt;[2]&lt;/a&gt;  译注：在测试某一组建时，由于其余组建还未实现，这一组建与其余组建的接口衔接部分无法工作。此时可以针对这一组建编写其余组建的占位程序 (stub) ，预留出接口的衔接代码。占位代码通常不做任何有价值的事情，只报告组建的衔接部位工作正常。 &lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref3"&gt;[3]&lt;/a&gt;  译注：作者指的是设计模式的开山之作 —— 《 Design
Patterns—Elements of Reusable Object-Oriented
Software 》 , 作者为设计模式界著名的 “ 四人帮 ”GoF(Gang of Four) 。此书详尽讨论了三大类共 23 个广泛使用的设计模式的适用范围、依存关系、实现细节以及已有的应用领域等问题。书中以 C++ 和 Smalltalk 为示例语言，不过书中所涉及的模式适用于所有面向对象的语言。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Sun, 16 Sep 2007 13:26:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-09-16:zhs/program-development-in-java-preface.html</guid><category>Java</category></item><item><title>C++ Tricks 3.2 标号、goto，以及switch的实现</title><link>//farseerfc.github.io/zhs/c-tricks-3-2-label-goto-and-implementation-of-switch.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h2&gt;3.2  标号、 goto ，以及 switch 的实现 &lt;/h2&gt;
&lt;p&gt;goto 语句及标号 (label) 是最古老的 C 语言特性，也是最早被人们抛弃的语言特性之一。像汇编语言中的 jmp 指令一样， goto 语句可以跳转到同一函数体中任何标号位置： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{int i=0;&lt;/p&gt;
&lt;p&gt;Loop: //A label&lt;/p&gt;
&lt;p&gt;++i;&lt;/p&gt;
&lt;p&gt;if(i&amp;lt;10)goto Loop; //Jump to the label&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 在原始而和谐的早期 Fortran 和 Basic 时代，我们没有 if then else ，没有 for 和 while ，甚至没有函数的概念，一切控制结构都靠 goto( 带条件的或无条件的 ) 构件。软件工程师将这样的代码称作 “ 意大利面条 ” 代码。实践证明这样的代码极容易造成混乱。 &lt;/p&gt;
&lt;p&gt; 自从证明了结构化的程序可以做意大利面条做到的任何事情，人们就开始不遗余力地推广结构化设计思想，将 goto 像猛兽一般囚禁在牢笼，标号也因此消失。 &lt;/p&gt;
&lt;p&gt; 标号唯一散发余热的地方，是在 switch 中控制分支流程。 &lt;/p&gt;
&lt;p&gt; 很多人不甚了解 switch 存在的意义，认为它只是大型嵌套 if then else 结构的缩略形式，并且比 if 语句多了很多 “ 不合理 ” 的限制。如果你了解到 switch 在编译器内部的实现机制，就不难理解强加在 switch 之上的诸多限制，比如 case 后只能跟一个编译期整型常量，比如用 break 结束每一个 case 。首先看一个 switch 实例： &lt;/p&gt;
&lt;p&gt;switch (shape.getAngle())&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;case 3: cout&amp;lt;&amp;lt;”Triangle”;break;&lt;/p&gt;
&lt;p&gt;case 4: cout&amp;lt;&amp;lt;”Square”;break;&lt;/p&gt;
&lt;p&gt;case 0:case1: cout&amp;lt;&amp;lt;”Not a sharp!”;break;&lt;/p&gt;
&lt;p&gt;default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 任何程序员都可以写出与之对应的 if 结构： &lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i==3) cout&amp;lt;&amp;lt;”Triangle”;&lt;/p&gt;
&lt;p&gt;else if(i==4) cout&amp;lt;&amp;lt;”Square”;&lt;/p&gt;
&lt;p&gt;else if(i==0||i==1) cout&amp;lt;&amp;lt;”Not a sharp!”;&lt;/p&gt;
&lt;p&gt;else cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt; 看起来这两段代码在语义上是完全一样的，不是么？ &lt;/p&gt;
&lt;p&gt; 不！或许代码的执行结果完全一样，但是就执行效率而言， switch 版本的更快！ &lt;/p&gt;
&lt;p&gt; 要了解为什么 switch 的更快，我们需要知道编译器是怎样生成 switch 的实现代码的： &lt;/p&gt;
&lt;p&gt; 首先，保留 switch 之后由 {} 括起来的语具体，仅将其中 case 、 default 和 break 替换为真正的标号： &lt;/p&gt;
&lt;p&gt;switch (getAngle(shape))&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 随后，对于所有出现在 case 之后的常量，列出一张只有 goto 的跳转表，其顺序按 case 后的常量排列： &lt;/p&gt;
&lt;p&gt;goto _case_0;&lt;/p&gt;
&lt;p&gt;goto _case_1;&lt;/p&gt;
&lt;p&gt;goto _case_3;&lt;/p&gt;
&lt;p&gt;goto _case_4;&lt;/p&gt;
&lt;p&gt; 然后，计算 case 之后的常量与跳转表地址之间的关系，如有需要，在跳转表中插入空缺的项目： &lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default; // 因为没有 case 2 ，所以插入此项以条转到 default&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt; 假设一个 goto 语句占用 5 个字节，那么在本例中， goto 的地址 =case 后的常量 *5+100105&lt;/p&gt;
&lt;p&gt; 之后，生成跳转代码，在其余条件下跳转至 default ，在已知范围内按照公式跳转，全部的实现如下： &lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i&amp;lt;0||i&amp;gt;=5)goto _default;&lt;/p&gt;
&lt;p&gt;i=i*5+100105; // 按照得出的公式算出跳转地址 &lt;/p&gt;
&lt;p&gt;goto i; // 伪代码， C 中不允许跳转到整数，但是汇编允许 &lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default;&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 经过这样处理整个 switch 结构，使得无论 switch 后的变量为何值，都可以通过最多两次跳转到达目标代码。相比之下 if 版本的代码则采用线性的比较和跳转，在 case 语句很多的情况下效率极低。 &lt;/p&gt;
&lt;p&gt; 由此 , 我们也可以知道 , 为什么 case 后跟的一定是编译期整型常数，因为编译器需要根据这个值制作跳转表。我们可以明白为什么 case 与 case 之间应该用 break 分隔，因为编译器不改变 switch 语句体的结构， case 其本身只是一个具有语义的标号而已，要想跳出 switch ，就必须用 break 语句。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Sun, 16 Sep 2007 13:08:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-09-16:zhs/c-tricks-3-2-label-goto-and-implementation-of-switch.html</guid><category>C++</category></item><item><title>C++ Tricks 3.1 左值右值与常量性(lvalue，rvalue &amp; constant)</title><link>//farseerfc.github.io/zhs/c-tricks-3-1-lvalue-rvalue-constant.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h2&gt;3.1  左值右值与常量性 (lvalue ， rvalue &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; constant)&lt;/h2&gt;
&lt;p&gt; 首先要搞清楚的是，什么是左值，什么是右值。这里给出左值右值的定义： &lt;/p&gt;
&lt;p&gt;1 、左值是可以出现在等号 (=) 左边的值，右值是只能出现在等号右边的值。 &lt;/p&gt;
&lt;p&gt;2 、左值是可读可写的值，右值是只读的值。 &lt;/p&gt;
&lt;p&gt;3 、左值有地址，右值没有地址。 &lt;/p&gt;
&lt;p&gt; 根据左值右值的第二定义，值的左右性就是值的常量性 —— 常量是右值，非常量是左值。比如： &lt;/p&gt;
&lt;p&gt;1=1;//Error&lt;/p&gt;
&lt;p&gt; 这个复制操作在 C++ 中是语法错误， MSVC 给出的错误提示为 “error C2106: ‘=’ :
left operand must be l-value” ，就是说 ’=’ 的左操作数必须是一个左值，而字面常数 1 是一个右值。可见，严格的区分左值右值可以从语法分析的角度找出程序的逻辑错误。 &lt;/p&gt;
&lt;p&gt; 根据第二定义，一个左值也是一个右值，因为左值也可读，而一个右值不是一个左值，因为右值不可写。 &lt;/p&gt;
&lt;p&gt; 通常情况下，声明的变量是一个左值，除非你指定 const 将它变成一个右值： &lt;/p&gt;
&lt;p&gt;int lv=1;&lt;/p&gt;
&lt;p&gt;const int rv=lv;&lt;/p&gt;
&lt;p&gt; 由于右值的值在程序执行期间不能改变，所以必须用另一个右值初始化它。 &lt;/p&gt;
&lt;p&gt; 一个普通变量只能用右值初始化，如果你想传递左值，必须声明一个引用或一个指针： &lt;/p&gt;
&lt;p&gt;int &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; ref=lv;// 用引用传递左值 &lt;/p&gt;
&lt;p&gt;int * plv=&amp;amp;lv;// 传递指针以间接传递左值 &lt;/p&gt;
&lt;p&gt; 必须用左值初始化引用，然而，可以用右值初始化常量引用： &lt;/p&gt;
&lt;p&gt;int &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; r1=1; //Error!&lt;/p&gt;
&lt;p&gt;const int &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; r2=1; //&lt;span class="caps"&gt;OK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 这实际上相当于： &lt;/p&gt;
&lt;p&gt;int _r2=1;&lt;/p&gt;
&lt;p&gt;const int &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; r2=_r2;&lt;/p&gt;
&lt;p&gt; 这样的写法在函数体内没什么作用，但是在传递函数参数时，它可以避免潜在的 ( 传递左值时的 ) 复制操作，同时又可以接受右值。 &lt;/p&gt;
&lt;p&gt; 通常情况下，函数的参数和返回值都只传回右值，除非你明确的通过引用传递左值。 &lt;/p&gt;
&lt;p&gt; 明确了左值与右值的区别，有助于我们写函数时确定什么时候应该有 const ，什么时候不该有。比如，我们写了一个代表数学中复数的类 Complex ： &lt;/p&gt;
&lt;p&gt;class Complex;&lt;/p&gt;
&lt;p&gt; 然后，我们写针对 Complex 的运算符重载： operator+ 和 operator= 。问题在于，参数和返回值应该是什么类型，可选类型有四种： Complex 、 const Complex 、 Complex&amp;amp; 、 const Complex&amp;amp; 。 &lt;/p&gt;
&lt;p&gt; 对于 operator+ ，我们不会改变参数的值，所以可以通过 const
Complex&amp;amp; 传递参数。至于返回值类型，由于 int 类型的加法返回右值，所以根据 Do
as the ints do 的原则，返回值类型为 const Complex ： &lt;/p&gt;
&lt;p&gt;const Complex operator+(const Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt; 对于 operator= ，同样要思考这些问题。我们写入第一个参数，所以第一个参数为 Complex&amp;amp; ，我们只读取第二个参数，所以第二个参数为 const
Complex&amp;amp; 。至于返回值，还是 Do as the ints do 。 int 的赋值返回左值，不信你可以试一试： &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;(i=1)=2;&lt;/p&gt;
&lt;p&gt; 虽然比较傻，先将 i 赋为 1 ，再将其改为 2 ，但是这是被 C++ 语法支持的做法，我们就理应遵守。所以返回第一个参数的左值： &lt;/p&gt;
&lt;p&gt;Complex&amp;amp; operator=(Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt;const 是 C++ 引入的语言特性，也被 ANSI
C99 借鉴，在经典版本的 C 语言中是没有的。关于 const 的历史，有几点值得玩味。最初 Bjarne
Stroustrup 引入 const 时，可写性是和可读性分开的。那时使用关键字 readonly 和 writeonly 。这个特点被首先提交到 C 的 ANSI 标准化委员会 ( 当时还没有 C++ 标准化的计划 ) ，但是 ANSI C 标准只接受了 readonly 的概念，并将其命名为 const 。随后，有人发现在多线程同步的环境下，有些变量的值会在编译器的预料之外改变，为了防止过度优化破坏这些变量， C++ 又引入关键字 violate 。从语义特点来看， violate 是 const 的反义词，因为 const 表示不会变的量，而 violate 表示会不按照预期自行变化的量。从语法特点而言， violate 与 const 是极为相似的，适用于 const 的一切语法规则同样适用于 violate 。 &lt;/p&gt;
&lt;p&gt; 值的常量性可以被划分为两种：编译期常量和运行期常量。 C++ 语法并没有严格区分这两种常量，导致了少许混乱： &lt;/p&gt;
&lt;p&gt;const int i=5;const int * pi=&amp;amp;i;&lt;/p&gt;
&lt;p&gt;const_cast&amp;lt;int&amp;amp;&amp;gt;i=1;// 对于运行期常量，在需要时可以去除它的常量性 &lt;/p&gt;
&lt;p&gt;int a[i];// 对于编译期常量，可以用它来指定数组大小 &lt;/p&gt;
&lt;p&gt;cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;sizeof(a)/sizeof(a[0])&amp;lt;&amp;lt;*pi;&lt;/p&gt;
&lt;p&gt; 这种将编译期与运行期常量的特性混用的方法，势必导致语义的混乱。数组 a 的大小最终是 5 ，因为采用了 i 的编译期值，而不管 i 在运行期是否被改变了值。最后一句代码将（有可能）输出 551 ，第一个 i 的值作为一种优化在编译期绑定，第二个值标明了 a 的大小，第三个值通过指针显示地输出 i 的运行期真实值。 &lt;/p&gt;
&lt;p&gt; 在 C++ 的近亲 C# 的语法中，这两种常量被严格地区分开：编译期常量由 const 指定，只能是内建类型变量；运行期常量由 readonly 指定，可以是任何类型。永远不会改变的常量，如圆周率 pi 的值，应该用 const 声明；而其它有可能改变的常量，皆由 readonly 声明。 &lt;/p&gt;
&lt;p&gt;C++ 中的 const 的特点更倾向于 C# 中的 readonly ，虽然语法上允许使用 const 的编译期常量性，但正如上文所展示的，这容易造成混乱。为了得到 C# 中 const 的语义，在 C++ 中，我们不必回归恶魔 #define 的怀抱，可以使用所谓 “ 匿名 enum 技巧 ” 。当匿名声明一个 enum 类型时，其中的枚举值就是一个 int 类型的编译期常量，比如： &lt;/p&gt;
&lt;p&gt;enum{Size=5;};&lt;/p&gt;
&lt;p&gt;int a[Size];&lt;/p&gt;
&lt;p&gt; 这种使用匿名 enum 来声明编译期常量的做法，被广泛应用于 STL 、 boost 等模板库的实现代码中。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Sun, 16 Sep 2007 13:07:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-09-16:zhs/c-tricks-3-1-lvalue-rvalue-constant.html</guid><category>C++</category></item><item><title>C++ Tricks 2.2 I386平台的内存布局</title><link>//farseerfc.github.io/zhs/c-tricks-2-2-i386-memory-layout.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.2 I386 平台的内存布局 &lt;/h2&gt;
&lt;p&gt; 众所周知， I386 是 32 位体系结构。因此对于绝大多数 I386 平台的 C++ 编译器而言， sizeof(int)=sizeof(long)=sizeof(void*)=4 。当然 C++ 标准对此没有任何保证，我们也不应该试图编写依赖于此的代码。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;32 位指针的可寻址空间为 4GB 。为充分利用这么大的寻址空间，也是为了支持其它更先进的技术比如多任务技术或者动态链接库技术， WinNT 使用虚拟内存技术，给与每个应用程序全部 4GB 的内存空间。 4GB 的地址被一分为二，前 2GB 供应用程序自己使用，后 2GB 由系统内核分配和管理。这 2GB 的内存地址，通常被划分成 3 种内存区使用： &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;1  代码及静态数据区 &lt;/h3&gt;
&lt;p&gt; 由代码加载器从动态链接库镜像 ( 通常是 exe 或 dll 文件 ) 加载，通常定位到镜像文件中指定的基址开始的内存区。如果基址所在内存已被占用，动态连接器会将代码或数据重定向到其它可用地址。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 在 C++ 中，静态数据包括：名字空间 (namespace) 和全局 (global) 对象、函数的 static 对象、类的 static 数据成员。这些静态数据由编译器分配地址 ( 但可能被重定向 ) ，由静态连接器写入代码文件 ( 通常是 exe 或 dll) 的静态数据区段。所以标准说，这些静态数据在编译期就已经具有地址。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stack"&gt;
&lt;h3&gt;2  栈 (Stack)&lt;/h3&gt;
&lt;p&gt; 栈是最常用的动态数据存储区，所有函数的 non-static 对象和函数参数都在程序运行期在栈上分配内存。在数据结构中，术语 “ 栈 (Stack)” 意指先进后出 (&lt;span class="caps"&gt;FILO&lt;/span&gt; ， First
In Last Out) ，与 “ 队列 (Queue)” 所指的 FIFO 相对。相对于基于堆的对象分配技术，默认使用栈的对象分配有两点优势： &lt;/p&gt;
&lt;p&gt; 一、栈的 FILO 与人的思维方式相同 &lt;/p&gt;
&lt;p&gt; 现实生活中有许多事例都使用 FILO 的方式，比如人们必须先提起话筒再拨打号码，而后挂断电话之后再放下话筒。使用 FILO 的栈，可以保证事物的销毁顺序以其诞生顺序相反的顺序进行，不会产生在挂断电话之前就放下话筒的尴尬。 &lt;/p&gt;
&lt;p&gt; 二、栈的分配管理仅需要两个额外指针：栈顶 (esp) 和栈底 (ebp) 指针 &lt;/p&gt;
&lt;p&gt; 从实现的技术层面而言，栈的管理比其它动态分配技术要简单很多。 I386 平台上的动态栈管理，仅需要栈顶和栈底两个指针。这两个指针的存储显然不能放置于栈中，置于静态数据区又有损效率。 I386 平台为管理动态栈专门预留了两个通用寄存器变量 esp 与 ebp ，分别代表栈顶 (esp,Extended
Stack Pointer) 与栈底 (Extended Bottom Pointer) 指针。其中的 extended 代表它们是 32 位指针，以区分 16 位的 sp 和 bp 寄存器。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 栈是动态存储区的特点，表明它的内存占用将随着程序的运行而变化。 I386 平台上 WinNT 将应用程序的栈置于程序空间，向下增长。程序初始化时，由操作系统将 esp 指向系统分配的栈空间的顶部。当程序需要在栈上分配变量时，就将 esp 减去变量所需字节数，这被称作 “ 压栈 (Push)” ；随后又要销毁变量时，就将 esp 加上变量所需字节数，这被称作 “ 弹出 (Pop)” 。 esp 与 ebp 两者之间所夹的空间，就是当前函数正在使用的栈空间。由于栈向下增长， esp( 栈顶 ) 的值总是小于 ebp( 栈底 ) 的值，新分配的变量地址总是小于旧变量的地址。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="heap"&gt;
&lt;h3&gt;3  堆 (Heap) 和自由存储区 &lt;/h3&gt;
&lt;p&gt; 栈中的变量对于分配与释放的顺序有特定要求，这在一定程度上限制了栈的适用范围。面向对象 (&lt;span class="caps"&gt;OO&lt;/span&gt; ， Object Oriented) 的程序设计思想也要求能自由地控制变量的分配与销毁。由此，现代操作系统都提供了被称作 “ 堆 (Heap)” 的自由存储区，以允许由程序员控制的对象创建和销毁过程。 C 标准库函数 malloc 和 free 则是对操作系统提供的堆操作的封装。 C++ 提供的自由存储区运算符 new 和 delete 则通常是 malloc 和 free 的又一层封装。 &lt;/p&gt;
&lt;p&gt; 操作系统经由 malloc 和 free 控制对堆的访问。堆的存储管理技术各不相同，简单的使用双链表管理，复杂的可以比拟一个完整的文件系统。 &lt;/p&gt;
&lt;p&gt; 由于额外的管理需求，使用系统提供的通用分配器在堆上分配和销毁变量的代价，无论从空间角度还是效率角度而言，都比在栈上分配对象要高昂很多。对于 sizeof 上百的大型对象，这样的高昂代价还是可以接受的，但是对于 sizeof 只有个位数的小对象，这样的代价通常是一个数量级的差距。正因为这个原因， STL 不使用 new 和 delete ，转而使用分配子 (alllocor) 分配对象。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:30:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks-2-2-i386-memory-layout.html</guid><category>C++</category></item><item><title>C++ Tricks</title><link>//farseerfc.github.io/zhs/c-tricks.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ Tricks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;By  FarseerFc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 从今天起，我再将在 &lt;a class="reference external" href="http://firechildren.spaces.live.com/"&gt;Live
Space&lt;/a&gt; 和 &lt;a class="reference external" href="http://76635424.qzone.qq.com/"&gt;QQZone&lt;/a&gt; 同时发表一系列文章，暂定名为 “C++Tricks” 。 &lt;/p&gt;
&lt;p&gt; 本文旨在记录和阐述一些本人学习 C++ 时所得的心得、技巧。总体来看，本文涉及的内容是每一个 C++ 程序员都应该知道的，但是很少见诸 C++ 教材。希望对各位同仁学习 C++ 有所帮助。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 也可以通过 QQ 或 MSN 向我索要此文的 DOC 版或 PDF 版，会比网页上的更新的快一点。 &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lexical-problems"&gt;
&lt;h2&gt;1       词法问题 (Lexical Problems)&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!139.entry"&gt;1.1  条件运算符 (?:)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!140.entry"&gt;1.2  逗号运算符 (,) 、逻辑运算符 (&amp;amp;&amp;amp;,||) 与运算符重载的陷阱 &lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="x86"&gt;
&lt;h3&gt;2      X86 体系结构 &lt;/h3&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!146.entry"&gt;2.1 X86 概述 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!147.entry"&gt;2.2 I386 平台的内存布局 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!148.entry"&gt;2.3 I386 平台 C 函数内部的栈分配 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!149.entry"&gt;2.4 I386 平台 C 函数调用边界的栈分配 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!150.entry"&gt;2.5 I386 平台的边界对齐 (Align)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!151.entry"&gt;2.6 I386 平台 C 函数的可变参数表 (Variable Arguments)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!152.entry"&gt;2.7 I386 平台的其它函数调用模型 &lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="id6"&gt;
&lt;h5&gt;3  过程式编程 &lt;/h5&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!154.entry"&gt;3.1  左值右值与常量性 (lvalue ， rvalue &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; constant)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!155.entry"&gt;3.2  标号、 goto ，以及 switch 的实现 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:28:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks.html</guid><category>C++</category></item><item><title>C++ Tricks 2.3 I386平台C函数内部的栈分配</title><link>//farseerfc.github.io/zhs/c-tricks-2-3-i386-stack-allocation-in-c-functions.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.3 I386 平台 C 函数内部的栈分配 &lt;/h2&gt;
&lt;p&gt; 函数使用栈来保存局部变量，传递函数参数。进入函数时，函数在栈上为函数中的变量统一预留栈空间，将 esp 减去相应字节数。当函数执行流程途径变量声明语句时，如有需要就调用相应构造函数将变量初始化。当执行流程即将离开声明所在代码块时，以初始化的顺序的相反顺序逐一调用析构函数。当执行流程离开函数体时，将 esp 加上相应字节数，归还栈空间。 &lt;/p&gt;
&lt;p&gt; 为了访问函数变量，必须有方法定位每一个变量。变量相对于栈顶 esp 的位置在进入函数体时就已确定，但是由于 esp 会在函数执行期变动，所以将 esp 的值保存在 ebp 中，并事先将 ebp 的值压栈。随后，在函数体中通过 ebp 减去偏移量来访问变量。以一个最简单的函数为例： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int a=0; //a 的地址被分配为 ebp-4&lt;/p&gt;
&lt;p&gt;char c=1; //c 的地址被分配为 ebp-8&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 产生的汇编代码为： &lt;/p&gt;
&lt;p&gt;push ebp ; 将 ebp 压栈 &lt;/p&gt;
&lt;p&gt;mov ebp,esp ;ebp=esp  用栈底备份栈顶指针 &lt;/p&gt;
&lt;p&gt;sub esp,8 ;esp-=8 ，为 a 和 c 预留空间，包括边界对齐 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],0 ;a=0&lt;/p&gt;
&lt;p&gt;mov byte ptr[ebp-8],1 ;c=1&lt;/p&gt;
&lt;p&gt;add esp,8 ;esp+=8 ，归还 a 和 c 的空间 &lt;/p&gt;
&lt;p&gt;mov esp,ebp ;esp=ebp  从栈底恢复栈顶指针 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢复 ebp&lt;/p&gt;
&lt;p&gt;ret ; 返回 &lt;/p&gt;
&lt;p&gt; 相应的内存布局是这样： &lt;/p&gt;
&lt;p&gt;09992:c=1 &amp;lt;-esp&lt;/p&gt;
&lt;p&gt;09996:a=0&lt;/p&gt;
&lt;p&gt;10000: 旧 ebp &amp;lt;-ebp&lt;/p&gt;
&lt;p&gt;10004:……&lt;/p&gt;
&lt;p&gt; 注 : 汇编中的 pop 、 push 、 call 、 ret 语句是栈操作指令，其功能可以用普通指令替换 &lt;/p&gt;
&lt;p&gt;push ebp 相当于 :&lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;mov dword ptr[esp],ebp&lt;/p&gt;
&lt;p&gt;pop ebp 相当于： &lt;/p&gt;
&lt;p&gt;mov ebp,dword ptr[esp]&lt;/p&gt;
&lt;p&gt;sub esp,4&lt;/p&gt;
&lt;p&gt;call fun_address 相当于： &lt;/p&gt;
&lt;p&gt;push eip&lt;/p&gt;
&lt;p&gt;jmp fun_address&lt;/p&gt;
&lt;p&gt;ret 相当于 &lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt; 带参数的 ret&lt;/p&gt;
&lt;p&gt;ret 8 相当于 &lt;/p&gt;
&lt;p&gt;add esp,12&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt; 所有局部变量都在栈中由函数统一分配，形成了类似逆序数组的结构，可以通过指针逐一访问。这一特点具有很多有趣性质，比如，考虑如下函数，找出其中的错误及其造成的结果： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i,a[10];&lt;/p&gt;
&lt;p&gt;for(i=0;i&amp;lt;=10;++i)a[i]=0;/An error occurs here!&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 这个函数中包含的错误，即使是 C++ 新手也很容易发现，这是老生常谈的越界访问问题。但是这个错误造成的结果，是很多人没有想到的。这次的越界访问，并不会像很多新手预料的那样造成一个 “ 非法操作 ” 消息，也不会像很多老手估计的那样会默不作声，而是导致一个，呃，死循环！ &lt;/p&gt;
&lt;p&gt; 错误的本质显而易见，我们访问了 a[10] ，但是 a[10] 并不存在。 C++ 标准对于越界访问只是说 “ 未定义操作 ” 。我们知道， a[10] 是数组 a 所在位置之后的一个位置，但问题是，是谁在这个位置上。是 i!&lt;/p&gt;
&lt;p&gt; 根据前面的讨论， i 在数组 a 之前被声明，所以在 a 之前分配在栈上。但是， I386 上栈是向下增长的，所以， a 的地址低于 i 的地址。其结果是在循环的最后， a[i] 引用到了 i 自己！接下来的事情就不难预见了， a[i] ，也就是 i ，被重置为 0 ，然后继续循环的条件仍然成立 …… 这个循环会一直继续下去，直到在你的帐单上产生高额电费，直到耗光地球电能，直到太阳停止燃烧 …… 呵呵，或者直到聪明的你把程序 Kill 了 ……&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:28:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks-2-3-i386-stack-allocation-in-c-functions.html</guid><category>C++</category></item><item><title>C++ Tricks 2.4 I386平台C函数调用边界的栈分配</title><link>//farseerfc.github.io/zhs/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.4 I386 平台 C 函数调用边界的栈分配 &lt;/h2&gt;
&lt;p&gt; 当调用一个函数时，主调函数将参数以声明中相反的顺序压栈，然后将当前的代码执行指针 (eip) 压栈，然后跳转到被调函数的入口点。在被调函数中，通过将 ebp 加上一个偏移量来访问函数参数，以声明中的顺序 ( 即压栈的相反顺序 ) 来确定参数偏移量。被调函数返回时，弹出主调函数压在栈中的代码执行指针，跳回主调函数。再由主调函数恢复到调用前的栈。 &lt;/p&gt;
&lt;p&gt; 函数的返回值不同于函数参数，通过寄存器传递。如果返回值类型可以放入 32 位变量，比如 int 、 short 、 char 、指针等类型，通过 eax 寄存器传递。如果返回值类型是 64 位变量，如 _int64 ，同过 edx+eax 传递， edx 存储高 32 位， eax 存储低 32 位。如果返回值是浮点类型，如 float 和 double ，通过专用的浮点数寄存器栈的栈顶返回。如果返回值类型是用户自定义结构，或 C++ 类类型，通过修改函数签名，以引用型参数的形式传回。 &lt;/p&gt;
&lt;p&gt; 同样以最简单的函数为例： &lt;/p&gt;
&lt;p&gt;void f(){&lt;/p&gt;
&lt;p&gt;int i=g(1,2);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int g(int a,int b){&lt;/p&gt;
&lt;p&gt;int c=a+b ； &lt;/p&gt;
&lt;p&gt;return c;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 产生的汇编代码如下： &lt;/p&gt;
&lt;p&gt;f:&lt;/p&gt;
&lt;p&gt;push ebp ; 备份 ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ; 建立栈底 &lt;/p&gt;
&lt;p&gt;sub esp,4 ; 为 i 分配空间 &lt;/p&gt;
&lt;p&gt;mov eax,2 ; 准备参数 b 的值 2&lt;/p&gt;
&lt;p&gt;push eax ; 将 b 压栈 &lt;/p&gt;
&lt;p&gt;mov eax,1 ; 准备参数 a 的值 1&lt;/p&gt;
&lt;p&gt;push eax ; 将 a 压栈 &lt;/p&gt;
&lt;p&gt;call g ; 调用 g&lt;/p&gt;
&lt;p&gt;add esp,8 ; 将 a 和 b 一起弹出，恢复调用前的栈 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ; 将返回值保存进变量 i&lt;/p&gt;
&lt;p&gt;mov esp,ebp ; 恢复栈顶 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢复栈底 &lt;/p&gt;
&lt;p&gt;g:&lt;/p&gt;
&lt;p&gt;push ebp ; 备份 ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ; 建立栈底 &lt;/p&gt;
&lt;p&gt;sub esp,4 ; 为局部变量 c 在栈中分配内存 &lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp+8] ; 通过 ebp 间接读取参数 a 的值 &lt;/p&gt;
&lt;p&gt;mov ebx,dword ptr[ebp+12] ; 通过 ebp 间接读取参数 b 的值 &lt;/p&gt;
&lt;p&gt;add eax,ebx ; 将 a 和 b 的值相加，之和存在 eax 中 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ; 将和存入变量 c&lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp-4] ; 将 c 作为返回值，代码优化后会删除此句 &lt;/p&gt;
&lt;p&gt;add esp,4 ; 销毁 c 的内存 &lt;/p&gt;
&lt;p&gt;mov esp,ebp ; 恢复栈顶 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢复栈底 &lt;/p&gt;
&lt;p&gt;ret ; 返回函数 f&lt;/p&gt;
&lt;p&gt; 栈的内存布局如下： &lt;/p&gt;
&lt;p&gt;100076:c &amp;lt;- g 的 esp&lt;/p&gt;
&lt;p&gt;100080:f 的 ebp=100100 &amp;lt;- g 的 ebp&lt;/p&gt;
&lt;p&gt;100084:f 的 eip&lt;/p&gt;
&lt;p&gt;100088:a=1&lt;/p&gt;
&lt;p&gt;100092:b=2&lt;/p&gt;
&lt;p&gt;100096:i&lt;/p&gt;
&lt;p&gt;100100: 旧 ebp &amp;lt;-f 的 ebp&lt;/p&gt;
&lt;p&gt;100104:……&lt;/p&gt;
&lt;p&gt; 注意在函数 g 的汇编代码中，访问函数的局部变量和访问函数参数的区别。局部变量总是通过将 ebp 减去偏移量来访问，函数参数总是通过将 ebp 加上偏移量来访问。对于 32 位变量而言，第一个局部变量位于 ebp-4 ，第二个位于 ebp-8 ，以此类推， 32 位局部变量在栈中形成一个逆序数组；第一个函数参数位于 ebp+8 ，第二个位于 ebp+12 ，以此类推， 32 位函数参数在栈中形成一个正序数组。 &lt;/p&gt;
&lt;p&gt; 由于函数返回值通过寄存器返回，不需要空间分配等操作，所以返回值的代价很低。基于这个原因，旧的 C 语法约定，不写明返回值类型的函数，返回值类型为 int 。这一规则与现行的 C++ 语法相违背，因为 C++ 中，不写明返回值类型的函数返回值类型为 void ，表示不返回值。这种语法不兼容性是为了加强 C++ 的类型安全，但同时也带来了一些问题。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:28:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html</guid><category>C++</category></item><item><title>C++ Tricks 2.5 I386平台的边界对齐(Align)</title><link>//farseerfc.github.io/zhs/c-tricks-2-5-address-alignment.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h2&gt;2.5 I386 平台的边界对齐 (Align)&lt;/h2&gt;
&lt;p&gt; 首先提问，既然 I386 上 sizeof(int)==4 、 sizeof(char)==1 ，那么如下结构 (struct)A 的 sizeof 是多少？ &lt;/p&gt;
&lt;p&gt;struct A{int i;char c;};&lt;/p&gt;
&lt;p&gt; 答案是 sizeof(A)==8……1+5=8 ？ &lt;/p&gt;
&lt;p&gt; 呵呵，这就是 I386 上的边界对齐问题。我们知道， I386 上有整整 4GB 的地址空间，不过并不是每一个字节上都可以放置任何东西的。由于内存总线带宽等等的技术原因，很多体系结构都要求内存中的变量被放置于某一个边界的地址上。如果违反这个要求，重则导致停机出错，轻则减慢运行速度。对于 I386 平台而言，类型为 T 的变量必须放置在 sizeof(T) 的整数倍的地址上， char 可以随便放置， short 必须放在 2 的整数倍的地址上， int 必须放在 4 的整数倍的地址上， double 必须放在 8 的整数倍的地址上。如果违反边界对齐要求，从内存中读取数据必须进行两次，然后将独到的两半数据拼接起来，这会严重影响效率。 &lt;/p&gt;
&lt;p&gt; 由于边界对齐问题的要求，在计算 struct 的 sizeof 的时候，编译器必须算入额外的字节填充，以保证每一个变量都能自然对齐。比如如下声明的 struct:&lt;/p&gt;
&lt;p&gt;struct &lt;span class="caps"&gt;WASTE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 实际上相当于声明了这样一个结构： &lt;/p&gt;
&lt;p&gt;struct &lt;span class="caps"&gt;WASTE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;char _filling1 [3];// 三个字节填充，保证下一个 int 的对齐 &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2 ； &lt;/p&gt;
&lt;p&gt;char _filling2 [3];// 又三个字节填充 &lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 值得注意的是尾部的 3 个字节填充，这是为了可以在一个数组中声明 WASTE 变量，并且每一个都自然对齐。因为有了这些填充，所以 sizeof(&lt;span class="caps"&gt;WASTE&lt;/span&gt;)==12 。这是一种浪费，因为只要我们重新安排变量的声明，就可以减少 sizeof ： &lt;/p&gt;
&lt;p&gt;struct &lt;span class="caps"&gt;WASTE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c1,c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 像这样的安排， sizeof 就减少到 8 ，只有 2 个字节的额外填充。为了与汇编代码相兼容， C 语言语法规定，编译器无权擅自安排结构体内变量的布局顺序，必须从左向右逐一排列。所以，妥当安排成员顺序以避免内存空间的浪费，就成了我们程序员的责任之一。一般的，总是将结构体的成员按照其 sizeof 从大到小排列， double 在最前， char 在最后，这样总可以将结构的字节填充降至最小。 &lt;/p&gt;
&lt;p&gt;C++ 继承了 C 语言关于结构体布局的规定，所以以上的布局准则也适用于 C++ 的 class 的成员变量。 C++ 进一步扩展了布局规定，同一访问区段 (private 、 public 、 protected) 中的变量，编译器无权重新排列，不过编译器有权排列访问区段的前后顺序。基于这个规则， C++ 中有的程序员建议给每一个成员变量放在单独区段，在每一个成员声明之前都加上 private: 、 public: 、 protected: 标志，这可以最大限度的利用编译器的决策优势。 &lt;/p&gt;
&lt;p&gt; 在栈中按顺序分配的变量，其边界也受到对齐要求的限制。与在结构中不同的是，栈中的变量还必须保证其后续变量无论是何种类型都可以自由对齐，所以在栈中的变量通常都有平台相关的对齐最小值。在 MSVC 编译器上，这个最小值可以由宏 _INTSIZEOF(T) 查询： &lt;/p&gt;
&lt;p&gt;#define _INTSIZEOF(T) ( (sizeof(T) + sizeof(int) - 1) &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; ~(sizeof(int) -
1) )&lt;/p&gt;
&lt;p&gt;_INTSIZEOF(T) 会将 sizeof(T) 进位到 sizeof(int) 的整数倍。 &lt;/p&gt;
&lt;p&gt; 由于在栈中分配变量使用 _INTSIZEOF 而不是 sizeof ，在栈上连续分配多个小变量 (sizeof 小于 int 的变量 ) 会造成内存浪费，不如使用结构 (struct) 或数组。也就是说： &lt;/p&gt;
&lt;p&gt;char c1,c2,c3,c4;// 使用 16 字节 &lt;/p&gt;
&lt;p&gt;char c[4];// 使用 4 字节 &lt;/p&gt;
&lt;p&gt; 当然，使用数组的方法在访问数组变量 ( 比如 c[1]) 时有一次额外的指针运算和提领 (dereference) 操作，这会有执行效率的损失。这又是一种空间 ( 内存占用 )vs 时间 ( 执行效率 ) 的折中，需要程序员自己根据情况权衡利弊。 &lt;/p&gt;
&lt;p&gt;sizeof 的大小可能比我们预期的大，也可能比我们预期的小。对于空类： &lt;/p&gt;
&lt;p&gt;class Empty {};&lt;/p&gt;
&lt;p&gt; 在通常情况下， sizeof(Empty) 至少为 1 。这是因为 C++ 语法规定，对于任何实体类型的两个变量，都必须具有不同的地址。为了符合语法要求，编译器会给 Empty 加入 1 字节的填充。所以 sizeof() 的值不可能出现 0 的情况。可是对于以下的类声明： &lt;/p&gt;
&lt;p&gt;class A:public Empty{vitual ~A(){}};&lt;/p&gt;
&lt;p&gt;sizeof(A) 有可能是 6 ，也有可能是 5 ，也有可能是 4 ！必不可少的四个字节是一个指向虚函数表的指针。一个可能有的字节是 Empty 的大小，这是是因为编译器在特定情况下会将 Empty 视作一个 “ 空基类 ” ，从而实施 “ 空基类优化 ” ，省掉那毫无作用的一字节填充。另一个字节是 A 的一字节填充，因为从语法上讲， A 没有成员声明，理应有 1 字节填充，而从语义上讲，编译器给 A 的声明加入了一个指向虚函数表的指针，从而 A 就不再是一个 “ 空类 ” ，是否实施这个优化，要看编译器作者对语法措词的理解。也就是说， sizeof 也会出现 4+1+1=4 的情况。具体要看编译器有没有实施 “ 空基类优化 ” 和 “ 含虚函数表的空类优化 ” 。 &lt;/p&gt;
&lt;p&gt; 结构和类的空间中可能有填充的字节，这意味着填充字节中可能有数值，虽然这数值并不影响结构的逻辑状态，但是它也可能不知不觉中影响到你。比如说，你手头正好有一组依赖于底层硬件 ( 比如多处理器 ) 的函数，他们在操纵连续字节时比手动编码要快很多，而你想充分利用这种硬件优势： &lt;/p&gt;
&lt;p&gt;bool BitCompare(void* begin,void* end,void* another);&lt;/p&gt;
&lt;p&gt; 这个函数将区间 [begin,end) 之间的字节与 another 开始的字节相比较，如果有一位不同就返回 false ，否则返回 true 。 &lt;/p&gt;
&lt;p&gt; 比如你想将这个函数用于你自己的类的 operator== 中，这样可以利用硬件加快速度。不过你在动手前要充分考虑，你的 class 是否真的要比较每一位。如果在类的成员中存在编译器填充的字节数，那么应用以上的函数就是不正确的，因为填充的字节中可以有不同的值。为了保证你可以用 Bitwise
Compare ，你必须确保填充的字节中的值也是相同的。这不仅要求你在类的构造函数中初始化类的每一 bit 而不是每一个成员，也要求你在复制初始化和复制赋值函数中也同时保证 bitwise copy 语义，而不是编译器默认产生的 memberwise 语义。当然，你可能通过与 BitCompare 一同提供的 BitCopy 来完成这个艰巨的任务。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:28:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks-2-5-address-alignment.html</guid><category>C++</category></item><item><title>C++ Tricks 2.6 I386平台C函数的可变参数表(Variable Arguments)</title><link>//farseerfc.github.io/zhs/c-tricks-2-6-i386-variable-arguments.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h2&gt;2.6 I386 平台 C 函数的可变参数表 (Variable Arguments)&lt;/h2&gt;
&lt;p&gt; 基于前文 (2.4 节 ) 分析，我们可以不通过函数签名，直接通过指针运算，来得到函数的参数。由于参数的压栈和弹出操作都由主调函数进行，所以被调函数对于参数的真实数量不需要知晓。因此，函数签名中的变量声明不是必需的。为了支持这种参数使用形式， C 语言提供可变参数表。可变参数表的语法形式是在参数表末尾添加三个句点形成的省略号 “…” ： &lt;/p&gt;
&lt;p&gt;void g(int a,char* c,…);&lt;/p&gt;
&lt;p&gt; 省略号之前的逗号是可选的，并不影响词法语法分析。上面的函数 g 可以接受 2 个或 2 个以上的参数，前两个参数的类型固定，其后的参数类型未知，参数的个数也未知。为了知道参数个数，我们必须通过其他方法，比如通过第一个参数传递： &lt;/p&gt;
&lt;p&gt;g(3,”Hello”,2,4,5);// 调用 g 并传递 5 个参数，其中后 3 个为可变参数。 &lt;/p&gt;
&lt;p&gt; 在函数的实现代码中，可以通过 2.4 节叙述的，参数在栈中的排列顺序，来访问位于可变参数表的参数。比如 :&lt;/p&gt;
&lt;p&gt;void g(int a,char* c…){&lt;/p&gt;
&lt;p&gt;void *pc=&amp;amp;c;int* pi=static_cast&amp;lt;int*&amp;gt;(pc)+1;// 将 pi 指向首个可变参数 &lt;/p&gt;
&lt;p&gt;for(int i=0;i&amp;lt;a;i++)std::cout&amp;lt;&amp;lt;pi[i]&amp;lt;&amp;lt;” ” ； &lt;/p&gt;
&lt;p&gt;std::cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;std::endl;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 我们甚至可以让一个函数的所有参数都是可变参数，只要有办法获知参数的数量即可。比如，我们约定，在传递给 addAll 的参数都是 int ，并且最后一个以 0 结束： &lt;/p&gt;
&lt;p&gt;int addAll(…);&lt;/p&gt;
&lt;p&gt;int a=f(1,4,2,5,7,0);&lt;/p&gt;
&lt;p&gt; 那么 addAll 可以这样实现： &lt;/p&gt;
&lt;p&gt;int addAll(…){&lt;/p&gt;
&lt;p&gt;int sum=0;int *p=&amp;amp;sum; //p 指向第一个局部变量 &lt;/p&gt;
&lt;p&gt;p+=3; // 跳过 sum ， ebp ， eip ，现在 p 指向第一个参数 &lt;/p&gt;
&lt;p&gt;for(;*p;++p) // 如果 p 不指向 0 就继续循环 &lt;/p&gt;
&lt;p&gt;sum+=*p;&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 可变参数表的最广泛应用是 C 的标准库函数中的格式化输入输出： printf 和 scanf 。 &lt;/p&gt;
&lt;p&gt;void printf(char *c,…);&lt;/p&gt;
&lt;p&gt;void scanf(char *c,…);&lt;/p&gt;
&lt;p&gt; 两者都通过它的首个参数指出后续参数表中的参数类型和参数数量。 &lt;/p&gt;
&lt;p&gt; 如果可变参数表中的参数类型不一样，那么操纵可变参数表就需要复杂的指针运算，并且还要时刻注意边界对齐 (align) 问题，非常令人头痛。好在 C 标准库提供了用于操纵可变参数表的宏 (macro) 和结构 (struct) ，他们被定义在库文件 stdarg.h 中 :&lt;/p&gt;
&lt;p&gt;typedef struct {char *p;int offset;} va_list;&lt;/p&gt;
&lt;p&gt;#define va_start(valist,arg)&lt;/p&gt;
&lt;p&gt;#define va_arg(valist,type)&lt;/p&gt;
&lt;p&gt;#define va_end(valist)&lt;/p&gt;
&lt;p&gt; 其中结构 va_list 用于指示参数在栈中的位置，宏 va_start 接受一个 va_list 和函数的可变参数表之前的参数，通过第一个参数初始化 va_list 中的相应数据，因此要使用 stdarg.h 中的宏，你的可变参数表的函数必须至少有一个具名参数。 va_arg 返回下一个类型为 type 的参数， va_end 结束可变参数表的使用。还是以上文的 addAll 为例，这次写出它的使用标准宏的版本： &lt;/p&gt;
&lt;p&gt;int addAll(int i,…)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;va_list vl; // 定义一个 va_list 结构 &lt;/p&gt;
&lt;p&gt;va_start(vl,i); // 用省略号之前的参数初始化 vl&lt;/p&gt;
&lt;p&gt;if(i=0)return 0; // 如果第一个参数就是 0 ，返回 &lt;/p&gt;
&lt;p&gt;int sum=i; // 将第一个参数加入 sum&lt;/p&gt;
&lt;p&gt;for(;;){&lt;/p&gt;
&lt;p&gt;i=va_arg(vl,int); // 取得下一个参数，类型是 sum&lt;/p&gt;
&lt;p&gt;if(i==0)break; // 如果参数是 0 ，跳出循环 &lt;/p&gt;
&lt;p&gt;sum+=i;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;va_end(vl);&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 可以看出，如果参数类型一致，使用标准库要多些几行代码。不过如果参数类型不一致或者未知 (printf 的情况 ) ，使用标准库就要方便很多，因为我们很难猜出编译器处置边界对齐 (align) 等汇编代码的细节。使用标准库的代码是可以移植的，而使用上文所述的其它方法操纵可变参数表都是不可移植的，仅限于在 I386 平台上使用。 &lt;/p&gt;
&lt;p&gt; 纵使可变参数表有使用上的便利性，它的缺陷也有很多，不可移植性和平台依赖性只是其一，最大的问题在于它的类型不安全性。使用可变参数表就意味着编译器不对参数作任何类型检查，这在 C 中算是一言难尽的历史遗留问题，在 C++ 中就意味着恶魔 reinterpret_cast 被你唤醒。 C 的可变参数表是 C++ 代码错误频发的根源之一，以至于 C++ 标准将可变参数表列为即将被废除的 C 语言遗留特性。 C++ 语法中的许多新特性，比如重载函数、默认参数值、模板，都可以一定程度上替代可变参数表，并且比可变参数表更加安全。 &lt;/p&gt;
&lt;p&gt; 可变参数表在 C++ 中惟一值得嘉奖的贡献，是在模板元编程 (&lt;span class="caps"&gt;TMP&lt;/span&gt;) 的 SFINAE 技术中利用可变参数表制作最差匹配重载。根据 C++ 标准中有关函数重载决议的规则，具有可变参数表的函数总是最差匹配，编译器在被逼无奈走头无路时才会选择可变参数表。利用这一点，我们可以精心制作重载函数来提取类型信息。比如，要判断一个通过模板传递来的类型是不是 int ： &lt;/p&gt;
&lt;p&gt;long isIntImp(int);&lt;/p&gt;
&lt;p&gt;char isIntImp(…);&lt;/p&gt;
&lt;p&gt;template&amp;lt;typename T&amp;gt;&lt;/p&gt;
&lt;p&gt;struct isInt&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;enum{value=sizeof(isIntImp(T()))==sizeof(long);}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 然后，在一个具有模板参数 T 的函数中，我们就可以写 &lt;/p&gt;
&lt;p&gt;if(isInt&amp;lt;T&amp;gt;::value)//…&lt;/p&gt;
&lt;p&gt; 在这个 ( 不怎么精致的 ) 例子中，如果 T 是 int ，那么 isIntImp 的第一个重载版本就会被选中，返回值类型就是 long ，这样 value 就为 1 。否则，编译器只能选中第二个具有可变参数表的重载版本，返回值类型成为 char ，这样 value 就为 0 。把它说得再明白一些，上文的代码所表达的意思是：如果类型 T 是 int ，那它就是 int ，否则它就不是 int ，呵呵简单吧。这种通过重载决议规则来提取类型信息的技术，在模板元编程中被称作 SFINAE ，它和其它模板元编程技术被广泛运用于 STL 、 Boost 等模板库的开发实现之中。 &lt;/p&gt;
&lt;p&gt; 值得注意的是，在上文 SFINAE 的运用中， isIntImp 并没有出现定义而只提供了声明，因为我们并没有实际调用 isIntImp 函数，而只是让它参与重载决议并用 sizeof 判断其返回值类型。这是 C++ 的一个设计准则的完美体现：不需要的东西可以不出现。由于这一准则，我们避免了在 C++ 中调用具有可变参数表的函数这一危险举动，而仅仅利用了可变参数表在语法分析过程中的特殊地位，这种对于危险语言特性的巧妙利用是善意而无害的。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:28:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks-2-6-i386-variable-arguments.html</guid><category>C++</category></item><item><title>C++ Tricks 2.7 I386平台的其它函数调用模型</title><link>//farseerfc.github.io/zhs/c-tricks-2-7-i386-calling-conventions.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.7 I386 平台的其它函数调用模型 &lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 上文介绍的只是 I386 平台上 C 函数调用的标准模型，被称作 __cdecl 。事实上， Microsoft Visual C++ 编译器还支持其它一些函数调用模型，所有调用模型名称皆以双下划线开头，下面列出所有函数调用模型的异同： &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="cdecl"&gt;
&lt;h3&gt;1 __cdecl&lt;/h3&gt;
&lt;p&gt; 参数压栈顺序：逆序 ( 从右至左 )&lt;/p&gt;
&lt;p&gt; 参数堆栈恢复者：主调函数 (caller)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__cdecl 明确地指出函数使用 C 函数调用模型，这是默认的调用模型。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stdcall"&gt;
&lt;h3&gt;2 __stdcall&lt;/h3&gt;
&lt;p&gt; 参数压栈顺序：逆序 ( 从右至左 )&lt;/p&gt;
&lt;p&gt; 参数堆栈恢复者：被调函数 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__stdcall 是微软所谓的标准调用模型。可惜的是它与 __cdecl 不兼容。几乎所有的 Win32API 函数使用这种函数调用模型，希望在 DLL 之间，或者在程序和 WinNT 操作系统之间传递函数指针的函数也应该使用这种模型。与 __cdecl 模型的不同之处在于， __stdcall 模型下由被调函数恢复堆栈。主调函数在 call 语句之后，不需要再加上 add 语句。而被调函数的 ret 语句则被添加一个参数，代表函数参数堆栈的长度。因此，被调函数需要明确的知晓函数参数的数量和类型，所以在 __stdcall 模型下不支持可变参数表，所有参数必须写明。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="thiscall"&gt;
&lt;h3&gt;3 __thiscall&lt;/h3&gt;
&lt;p&gt; 参数压栈顺序：逆序 ( 从右至左 ) ， this 用 ecx 传递。 &lt;/p&gt;
&lt;p&gt; 参数堆栈恢复者：被调函数 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__thiscall 是 VC 编译器中类的非静态成员函数 (non-static member functon) 的默认调用模型。但是如果此成员函数有可变参数表， VC 编译器会使用 __cdecl 。和 __stdcall 一样， __thiscall 由被调函数恢复堆栈。比较独特的是 __thiscall 会通过 ecx 寄存器传递成员函数的 this 指针，而 __cdecl 下 this 指针是通过在参数表最前面增加一个函数参数来传递的。 __thiscall 是 VC 编译器对 this 指针的使用的一种优化，大大提高了面向对象程序的效率。在 VC2003 及之前的编译器上 __thiscall 不是一个关键字，不能被显式指定。但可以给成员函数显式指定 __cdecl 来避免使用 __thiscall 。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="fastcall"&gt;
&lt;h3&gt;4 __fastcall&lt;/h3&gt;
&lt;p&gt; 参数压栈顺序：逆序 ( 从右至左 ) ，前两个 32 位函数参数放入 ecx 和 edx 中 &lt;/p&gt;
&lt;p&gt; 参数堆栈恢复者：被调函数 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 快速函数调用模型，将前两个 32 位函数参数放入 ecx 和 edx 中，其余参数再逆序压栈。使用的是和 __thiscall 类似的优化技术，加快函数调用，适合运用在小型 inline 函数上。同样使用 __stdcall 形式的被调函数恢复堆栈，所以不支持可变参数表。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pascal"&gt;
&lt;h3&gt;5 __pascal&lt;/h3&gt;
&lt;p&gt; 参数压栈顺序：正序 ( 从左至右 )&lt;/p&gt;
&lt;p&gt; 参数堆栈恢复者：被调函数 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 过程式编程语言 Pascal 所使用的函数调用模型，由此得名。也是 16 位版本的 Windows 使用的 API 模型，过时的模型，现在已经废弃且禁止使用。你会看到有些书本仍会不时提到它，所以需要注意。 __pascal 是正序压栈，这与大部分 I386 函数模型都不相同。与 __stdcall 一样，由被调者恢复堆栈，不支持可变参数表。历史上曾有过的别名 PASCAL 、 pascal 、 _pascal( 单下划线 ) ，现在都改成了 __stdcall 的别名，与 __pascal( 双下划线 ) 不同。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;6  其它函数调用模型，以及模型别名。 &lt;/h3&gt;
&lt;p&gt;__syscall ：操作系统内部使用的函数调用模型，由用户模式向核心模式跳转时使用的模型。由于用户模式和核心模式使用不同的栈，所以没办法使用栈来传递参数，所有参数通过寄存器传递，这限制了参数的数量。用户模式编程中不允许使用。 &lt;/p&gt;
&lt;p&gt;__fortran ：数学运算语言 fortran 使用的函数模型，由此得名。在 C 中调用由 fortran 编译的函数时使用。 &lt;/p&gt;
&lt;p&gt;__clrcall ：微软 .Net 框架使用的函数模型，托管 (Managed)C++ 默认使用，也可以从非托管代码调用托管函数时使用。参数在托管栈上正序 ( 从左至右 ) 压栈，不使用普通栈。 &lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;CALLBACK&lt;/span&gt; 、 &lt;span class="caps"&gt;PASCAL&lt;/span&gt; 、 &lt;span class="caps"&gt;WINAPI&lt;/span&gt; 、 &lt;span class="caps"&gt;APIENTRY&lt;/span&gt; 、 &lt;span class="caps"&gt;APIPRIVATE&lt;/span&gt; ： I386 平台上是 __stdcall 的别名 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;span class="caps"&gt;WINAPIV&lt;/span&gt; ： I386 平台上是 __cdecl 的别名 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;7  函数调用模型的指定 &lt;/h3&gt;
&lt;p&gt; 函数调用模型的指定方式和 inline 关键字的指定方式相同，事实上， inline 可以被看作是 C++ 语言内建的一种函数调用模型。唯一不同的是，声明函数指针时，也要指明函数调用模型，而 inline 的指针是不能指明的，根本不存在指向 inline 函数的指针。比如： &lt;/p&gt;
&lt;p&gt;int &lt;span class="caps"&gt;CALLBACK&lt;/span&gt; GetVersion();&lt;/p&gt;
&lt;p&gt;int (&lt;span class="caps"&gt;CALLBACK&lt;/span&gt; * pf)()=GetVersion;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:28:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks-2-7-i386-calling-conventions.html</guid><category>C++</category></item><item><title>C++ Tricks 2.1 X86概述</title><link>//farseerfc.github.io/zhs/c-tricks-2-1-x86-architecture.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="x86"&gt;
&lt;h2&gt;2.1   X86 概述 &lt;/h2&gt;
&lt;p&gt; 所谓 X86 体系结构，是指以 Intel
8086 芯片为首的芯片所沿袭的 CPU 结构，一些文档中又被称作 IA32 体系结构。包括的芯片有但不限于 :Intel
8086 至  80486 ，奔腾 (Pentium) 系列处理器 1 至 4 ，赛扬系列处理器，酷睿系列处理器，以及 AMD 的相应型号产品。 X86 体系结构在早期属于 16 位处理器，自 80386 之后扩展为 32 位处理器，所以一些文档中又把 80386 之后的 32 位处理器体系称作 I386 。自 Pentium4 后期， AMD 的 Athlon64 开始， I386 被进一步扩充为 64 位处理器，含有 64 位寻址能力的 X86 体系结构被称作 X86-64 或 IA32-64 。总之，市售的个人电脑用 CPU ，除苹果的 Macintosh 之外，全部采用 X86 体系结构芯片。 &lt;/p&gt;
&lt;p&gt; 在 X86 早期， 16 位的寻址能力只支持 64KB(2^16=64K) 内存，这显然是不够的。 Intel 采用分段寻址的方法，用 4 位段位 +16 位偏移量，提供了总共 1MB(2^20=1M) 的寻址能力。所以在 X86 的 16 位编程中，有两种指针类型：长指针 (lp,long
pointer) 和短指针 (sp,short pointer) ，长指针 (20 位 ) 提供整个内存空间寻址能力，短指针 (16 位 ) 仅支持同一段中的寻址。在 “ 古代 ”DOS 及 Win3.x 编程过程中，两种类型的指针，以及总共 1MB 的内存大小，常常把程序员们折腾得焦头烂额。 &lt;/p&gt;
&lt;p&gt; 自 I386 之后， CPU 才开始提供 32 位的寻址能力。有了整整 4GB(2^32=4G) 的寻址空间，所有指针统一为长指针 (32 位 ) 。时至今日，我们仍可以看到微软文档中指针变量的 lp 前缀。由于内存管理的需要，分段机制被保留下来，但这一次不是因为地址空间太小，而是因为地址空间远大于实际内存容量，从而采用了虚拟内存机制。 &lt;/p&gt;
&lt;p&gt; 在从 16 位结构向 32 位结构转变的过程中，由于向下兼容的历史原因，曾一度长时间出现硬件 32 位 (I386) 、软件 16 位 (Win3.x) 的情况。同样也是为了兼容 16 位软件， Win9x 操作系统 (Win95 、 Win98 、 WinME) 保留了 16 位代码和 32 位代码。混合代码的设计使得 Win9x 及其混乱和不稳定。直到完全 32 位内核的操作系统 WinNT( 以及构建于其上的 Win2000 ， WinXP ， Win2003) 的出现， X86 平台上内存布局混乱的局面才得以改善。有了从 16 位至 32 位移植的经验和准备，现今的从 32 位到 64 位的操作系统移植显得平稳顺利很多。 WinXP 和 WinVista 系统都同时发布了 32 位版本和 64 位版本，并且其 x86-64 系统都实现了对 32 位软件的无缝衔接支持。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Mon, 27 Aug 2007 16:33:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-27:zhs/c-tricks-2-1-x86-architecture.html</guid><category>C++</category></item><item><title>C++ Tricks 1.2 逗号运算符(,)、逻辑运算符(&amp;&amp;,||)与运算符重载的陷阱</title><link>//farseerfc.github.io/zhs/c-tricks-1-2-trap-in-comma-logical-operator.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.2    逗号运算符 (,) 、逻辑运算符 (&amp;amp;&amp;amp;,||) 与运算符重载的陷阱 &lt;/h2&gt;
&lt;p&gt; 很多人甚至不知道逗号 (,) 也是个 C++ 运算符。与语法上要求出现的逗号 ( 比如分隔函数参数的逗号 ) 不同的是，出现在表达式中的逗号运算符在语义上表示多个表达式操作的连续执行，类似于分隔多语句的分号。比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt;(&lt;strong&gt;int&lt;/strong&gt;i=0,j=9;i&amp;lt;10;++i&lt;strong&gt;,&lt;/strong&gt;—j)std::cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;”+”&amp;lt;&amp;lt;j&amp;lt;&amp;lt;”=9\n”;&lt;/p&gt;
&lt;p&gt; 在这句语句中，出现了两个逗号，其中前者是语法上用来分隔声明的变量的，并非逗号运算符，而后者则是一个逗号运算符。根据 C++ 标准，逗号运算符的执行顺序为从左到右依次执行，返回最后一个子表达式的结果。由于只有最后一个表达式返回结果，所以对于一个语义正常的逗号表达式而言，前几个子表达式必须具有副作用。同时，从语言的定义中也可以看出，逗号表达式对求值的顺序有严格要求。 &lt;/p&gt;
&lt;p&gt; 对求值顺序有要求的，除了逗号表达式和条件表达式 ( 参见 1.1) ，在 C++ 中还有逻辑运算符 (&amp;amp;&amp;amp; 和 ||) 。逻辑运算相较于数学运算和位运算而言，有个显著的不同点：逻辑运算在计算到一半时，就有可能已经得到结果，这样继续运算另一半就不是必需的。对于 A&amp;amp;&amp;amp;B ，如果 A=false ，那么无论 B 为何值，整个的结果都是 false ；同样的 A||B ，如果 A=true ，那么不考虑 B ，结果一定是 true 。 &lt;/p&gt;
&lt;p&gt;C++ 标准规定，如果逻辑运算到一半 ( 算出 A) 时，就已经可以确定运算的结果，那么就不运算剩下的另一半 (B) 。这种执行语义被称作 “ 短路 ” 。在其它一些编程语言中，短路语义是可以选择的：在 Ada 里非短路的逻辑运算符为 and 和 or ，短路的逻辑运算符为 and_then 和 or_else 。但是在 C++ 中，逻辑运算符的短路语义是语法上强制的，我们没有非短路版本的运算符。如果确实需要非短路语义，我们总是可以通过增加一个 bool 中间变量加以解决。有时，短路对于保证正确执行是必须的，比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char&lt;/strong&gt;*p=getString();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(p&lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;*p)std::cout&amp;lt;&amp;lt;p;&lt;/p&gt;
&lt;p&gt; 这段代码在得到了一个字符串后，在字符串不为空时输出它。在 C++ 中判断一个字符串不为空需要两个步骤：判断指针是否为 0 ，以及指针不为 0 时判断指针指向的内容是否为 ’’ 。就像条件表达式中讨论到的 ( 参见 1.1) ，在 p 为空时提领 p 是个极其危险的操作。逻辑运算符的短路语义则避免了这种危险。 &lt;/p&gt;
&lt;p&gt; 以上对逗号运算符与逻辑运算符的讨论，仅限于 C++ 标准所定义的运算符语义。为什么这样说呢？这是因为在 C++ 中，运算符的语义是可以由程序员自行定义的，这种机制叫做运算符重载 (operator overload) 。运算符重载可以将人们熟悉的运算符表达式转换成函数调用，使编程灵活而直观，是个方便的语言特性。不过有时运算符重载也会使人困扰，那就是当运算符重载遇到求值顺序问题时。 &lt;/p&gt;
&lt;p&gt;C++ 中，并不是所有合法运算符都可以被合法地重载。条件运算符虽然对求值顺序有要求，但它并不在可重载运算符之列，所以运算符重载机制对它没有影响。问题在于，逗号运算符和逻辑运算符都可以被合法地重载： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class&lt;/strong&gt; BadThing{/* Some Bad and Stupid Thing*/};&lt;/p&gt;
&lt;p&gt;BadThing&amp;amp; &lt;strong&gt;operator&lt;/strong&gt;,(BadThing&amp;amp;, BadThing&amp;amp;);// 重载了逗号运算符 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bool&lt;/strong&gt; &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(BadThing&amp;amp;, BadThing&amp;amp;);// 重载了 &amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;BadThing b1,b2;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(b1&amp;amp;&amp;amp;b2)b1,b2;// 被替换成如下形式： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(b1,b2))&lt;strong&gt;operator&lt;/strong&gt;,(b1,b2);&lt;/p&gt;
&lt;p&gt; 可以看到，重载了运算符之后，对运算符的使用被替换为相应的函数调用形式。因此，旧有的运算符的执行顺序不再适用，取而代之的是函数参数的压栈顺序。 &lt;/p&gt;
&lt;p&gt; 根据 C++ 标准规定，任何参数必须在进入函数之前压栈，所以在进入 &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp; 之前， b1 、 b2 就会被求值，这里不再有短路规则，任何依赖于短路语义的不知不觉间操作 BadThing 的代码 ( 可能通过模板 ) 都会混乱。 &lt;/p&gt;
&lt;p&gt; 短路语义只是一个方面，更重要的在于压栈顺序。鉴于执行效率和旧代码兼容性等细节问题， C++ 标准在压栈顺序上给编译器的开发者留有很大自主性。标准的说辞是，编译器可能以任何它觉得方便的顺序将参数压栈，从左到右，从右到左，甚至从中间到两边，在这一点上我们不能安全地做任何假设。在上面的例子中，编译器生成的代码可能先计算 b1 再计算 b2 ，也可能是相反的顺序。再看看编译器的实际情况，在我试过的所有基于 X86 体系结构的编译器中，参数都是以逆向压栈，即从右到左，有悖于大多数人的阅读习惯和直觉 ( 别说你是来自伊斯兰的 ……) 。 &lt;/p&gt;
&lt;p&gt; 在 C 时代使用函数调用时，压栈顺序并不是什么大问题，毕竟大多数人会在函数调用的边界稍稍小心一些。但是到了 C++ 中，事情变得有些复杂，因为简单如 a+b 的使用，就有可能被运算符重载机制替换为函数调用。更何况有模板参与之后，我们写代码时不能确定对象的真实类型，也就无法预知一个运算符是否真的被重载过，唯一稳妥的方法是，假定任何有可能被重载的运算符的使用都是函数调用。 &lt;/p&gt;
&lt;blockquote&gt;
&amp;lt;p style="margin:0;"&amp;gt;&lt;/blockquote&gt;
&lt;p&gt; 回到上文的示例中，由于 , 和 &amp;amp;&amp;amp; 都被替换为函数调用，程序的执行顺序将成为压栈顺序，在 X86 上很有可能是从右到左，与标准定义的运算符的顺序正好相反。逗号运算符原本就含有 “ 先 … 后 …” 的语义，这种颠倒的执行顺序势必造成程序和程序员的混乱。以我的经验而言，含有 &lt;strong&gt;operator&lt;/strong&gt;, 的类，完全没有办法和 STL 或者 iostream 相互协作，反而会导致巨量的错误报告 ( 什么叫巨量的错误报告有概念么？如果没有，那说明你还没玩过范式编程 (&lt;span class="caps"&gt;GP&lt;/span&gt;,
Generic
Programming) 。去玩玩 GP 吧，看看你的编译器对巨量的定义。在我手头，针对 3.5KB 的代码文件倾泻出 3.8&lt;strong&gt;&lt;span class="caps"&gt;MB&lt;/span&gt;&lt;/strong&gt; 的错误信息的编译器不在少数 ……) 。有鉴于此，我的结论是，除非你有充足的依据支持你这么做 ( 比如你的粗暴上司的键盘上只剩下逗号能用 ) ，并且你清楚的了解这么做的后果的严重性 ( 比如至少要看过此文 ) ，否则我奉劝你，永远不要碰 &lt;strong&gt;operator&lt;/strong&gt;, 、 &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp; 以及 &lt;strong&gt;operator&lt;/strong&gt;|| ！ &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Wed, 22 Aug 2007 18:06:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-22:zhs/c-tricks-1-2-trap-in-comma-logical-operator.html</guid><category>C++</category></item><item><title>C++ Tricks 1.1 条件运算符(?:)</title><link>//farseerfc.github.io/zhs/c-tricks-1-1-conditional-operator.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.1    条件运算符 (?:)&lt;/h2&gt;
&lt;p&gt; 条件运算符 (?:) 是 C++ 中唯一的三目运算符 (trinary
operator) ，用于在表达式中作条件判断，通常可以替换 if 语句，与 Visual Basic 中的 iif 函数、 Excel 中的 if 函数有同样的作用。语法形式如下： &lt;/p&gt;
&lt;p&gt;&lt;em&gt;condition&lt;/em&gt; ? &lt;em&gt;true_value&lt;/em&gt; : &lt;em&gt;false_value&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 其中 &lt;em&gt;condition
* 条件是任何可以转换为 bool 类型的表达式，包括但不仅限于 **bool*&lt;/em&gt; 、 &lt;strong&gt;int&lt;/strong&gt; 、指针。与 &lt;strong&gt;if&lt;/strong&gt; 和 &lt;strong&gt;while&lt;/strong&gt; 的条件部分稍显不同的是，这里不能定义变量，否则会导致语法错误。 &lt;/p&gt;
&lt;p&gt; 另外，条件语句会切实地控制执行流程，而不仅仅是控制返回值。也就是说，两个返回值表达式中永远只有一个会被求值，在表达式的执行顺序很重要时，这点尤为值得注意。比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=pi&lt;strong&gt;?&lt;/strong&gt;*pi&lt;strong&gt;:&lt;/strong&gt;0;&lt;/p&gt;
&lt;p&gt; 这里，只有当 pi 的值不为 0 时，它才会被提领 (dereference) 。这种语义保证了程序的正确性，因为提领一个空指针将导致致命的运行期错误 ( 通常是非法操作的警告 ) 。同时，正因为条件运算符控制运算流程的特点，使得它不能用类似 iif 的普通函数来模拟： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; iif(&lt;strong&gt;int&lt;/strong&gt; con,&lt;strong&gt;int&lt;/strong&gt; t,&lt;strong&gt;int&lt;/strong&gt;f){&lt;strong&gt;if&lt;/strong&gt;(c)&lt;strong&gt;return&lt;/strong&gt; t;&lt;strong&gt;return&lt;/strong&gt; f;}// 试图模拟 ?:&lt;/p&gt;
&lt;p&gt;…//in some function&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=iif(pi,*pi,0);//Error!&lt;/p&gt;
&lt;p&gt; 这段代码会导致上文提到的致命运行期错误。 C/C++ 标准规定，参数在被传递给函数之前求值，因此无论 pi 为何值，都会被提领。又因为函数传回一个空指针的情况比较少见，所以这样的错误在调试时很难被发现，一旦发生又势必造成重大灾难。这样的代码在实践中应尽量避免。 &lt;/p&gt;
&lt;p&gt; 有时，条件运算符控制流程的特点会不知不觉影响我们的代码。在 C 时代，最大值 MAX 通常用宏实现： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#define&lt;/strong&gt;&lt;span class="caps"&gt;MAX&lt;/span&gt;(a,b) ((a)&amp;gt;(b)&lt;strong&gt;?&lt;/strong&gt;(a)&lt;strong&gt;:&lt;/strong&gt;(b))&lt;/p&gt;
&lt;p&gt; 需要用额外的括号将宏参数和宏本体保护起来，以免运算符优先级扰乱逻辑，这是宏丑陋的特点之一，这里暂且不提。矛盾在于，用具有副作用的表达式调用宏时，会出现问题： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=5,j=6;//…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=&lt;span class="caps"&gt;MAX&lt;/span&gt;(++i,++j);&lt;/p&gt;
&lt;p&gt; 代码的作者原意显然是想先将 i,j 分别递增，再将其中较大的一个赋给 a 。执行这段代码，当 i=5,j=6 时， a=8 ，知道为什么吗？通过宏展开，赋值语句成这样： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=(++i)&amp;gt;(++j)&lt;strong&gt;?&lt;/strong&gt;(++i)&lt;strong&gt;:&lt;/strong&gt;(++j);// 删除了多余括号 &lt;/p&gt;
&lt;p&gt; 在判断之前， i 、 j 被分别自增一次，然后舍弃 : 之前的部分， j 又被自增一次。执行之后， i=6,j=8 。 &lt;/p&gt;
&lt;p&gt;MAX 的更正确更安全的实现，是利用模板将类型参数化。 STL 标准算法中就有一个这样的工具级模版函数 std::max 。 &lt;/p&gt;
&lt;p&gt; 条件运算符是表达式而不是语句，这使得它可以出现在任何需要表达式的地方，这扩大了它的适用范围。在那些语法上只能出现表达式而不能出现语句的地方（比如变量初始化），条件运算符有着不可替代的作用。 &lt;/p&gt;
&lt;p&gt; 条件运算符优于 &lt;strong&gt;if&lt;/strong&gt; 语句的另一个场合是 “ 模板元编程 ”(&lt;span class="caps"&gt;TMP&lt;/span&gt;, Template
MetaProgramming) 。在 TMP 这个古怪奇异的编译期运算编程技术中，一切旧有的技术和法则被全线击破，我们所能仰仗的工具，只有模板特化 (Specialization) 、 &lt;strong&gt;typedef&lt;/strong&gt;s 、函数声明 ( 无法调用它们 ) 、以及编译期常量运算。已经有人很深入地论证过，仅有以上这些，就已经形成了一个 “ 图灵完善 ” 的计算机语言。我们可以用模板特化技术，来模拟条件分支，循环迭代等一系列复杂的语言结构。由于可以参与编译期常量运算，条件运算符在 TMP 世界中很自然地扮演起重要角色。 &lt;/p&gt;
&lt;p&gt; 比如，给与类型 T 的一个变量 t ，我们想声明一个缓冲区存放 t 和一个 int ，缓冲区的大小不小于 sizeof(T) 也不小于 sizeif(int) ，我们可以这样写： &lt;/p&gt;
&lt;p&gt;char buffer[sizeof(T)&amp;gt;sizeof(int)? sizeof(T): sizeof(int)];&lt;/p&gt;
&lt;p&gt; 我们不能用一个 if 语句替换这个运算： &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;if(sizeof(T)&amp;gt;sizeof(int))i=sizeof(T);&lt;/p&gt;
&lt;p&gt;else i=sizeof(int);&lt;/p&gt;
&lt;p&gt;char buffer[i];// 语法错误 !&lt;/p&gt;
&lt;p&gt; 原因在于数组声明中的下标必须是一个编译期常量，而不是一个运行期的值，条件表达式的运算可以在编译期进行， if 语句就只能在执行期执行。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Wed, 22 Aug 2007 18:05:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-22:zhs/c-tricks-1-1-conditional-operator.html</guid><category>C++</category></item><item><title>填补信仰、唤醒良知</title><link>//farseerfc.github.io/zhs/filling-believings-calling-conscience.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;p&gt; 填补信仰、唤醒良知 &lt;/p&gt;
&lt;p&gt; 我们听尽了呼吁与号召，对于良知，我不必谴责丧失它的国人，不必盛赞良知的美好。我只想讨论，丧失了良知的原因 —— 空缺的信仰。 &lt;/p&gt;
&lt;p&gt; 一、空缺信仰丧失良知 &lt;/p&gt;
&lt;p&gt; 现代的国人缺少信仰，以至于丧失良知。曾几何时，中华民族由良好的信仰凝聚而成。三皇五帝时，族民们以炎黄为信仰；春秋战国时，士大夫之族以周制礼乐为信仰；汉代以后，百姓延习孔孟之说、老聃之道，以儒家学说为信仰；自大唐起，以佛教为首的现代宗教纷纷传入中原，人民开始以它们作为信仰。 &lt;/p&gt;
&lt;p&gt; 直至鸦片战争、五四运动，西方文化入侵中华，国人开始抛弃国学，转而去研究科学；文化大革命，十年文化浩劫，人们批判旧的信仰，却没有合适的新的信仰前来填补。从此，国人的信仰出现空缺，国人的良知也被一块块蚕食殆尽。 &lt;/p&gt;
&lt;p&gt; 二、信仰、科学、迷信 &lt;/p&gt;
&lt;p&gt; 在许多国人的心目中，信仰就等于迷信。从小到大的教育告诉我们，信奉宗教是愚昧而又无知的表现，科学与信仰是矛盾的。是么？ &lt;/p&gt;
&lt;p&gt; 我们无法保证社会上的每一个人都接受过良好的教育，我们无法确信最前沿的科学素养能在民众中普及。在科普与教育力不从心的社会死角，在科学技术尚不能及的文化盲区，我们依旧需要信仰的规范与限制，我们的良知需要信仰！ &lt;/p&gt;
&lt;p&gt; 信仰不等于迷信。信仰本身无所谓谜与不迷，迷信是持有信仰的人误解了信仰，盲目遵从的结果。以为烧过香就可以免遭祸患，以为捐了钱就可以升入天堂，以为引火自焚就可以功德圆满，这便是迷信了。希特勒曾经的人类完善计划，依照遗传学的原理，将科学家与运动员强行结为夫妇孕育生命，希望得到最优秀的人类种族，这便是对科学这种信仰的迷信！ &lt;/p&gt;
&lt;p&gt; 由此可见，科学与信仰并不是矛盾的硬币的两面，从某种意义而言科学本身也是信仰的一种。虽然历史上宗教往往作为科学发展的阻碍，可信奉真理的信念一直是推动科学发展的动力。牛顿就曾说过，对自然规律的探询是为了更接近上帝。由此可见，信仰与真理，与良知毫无矛盾。 &lt;/p&gt;
&lt;p&gt; 三、信仰唤醒良知 &lt;/p&gt;
&lt;p&gt; 很少有人仔细思考过，良知的缺失是由信仰的缺失造成的。信仰是人思想的寄托与依靠，是人行动处世的准则。没有了信仰的人，思想行为就缺少了约束的标准，人就更容易因为一时不成熟的冲动，背叛良知、铸成错误。 &lt;/p&gt;
&lt;p&gt; 泰国人以佛教为信仰，泰国的寺庙每天都会有成千上万人顶礼膜拜。寺庙有一个人尽皆知的不成文规定：不得穿鞋进入。于是在寺庙之外，游客们可以看到千百双各式的鞋子有序的摆放在门口。国人每每看到此景，总会诧异地问：没有人会偷鞋么？得到的答案极为简单：庙前偷鞋会遭报应。由于拥有信仰，泰国人作了坏事会受到良知的谴责，泰国商人售出假货会彻夜难眠。二战期间，无数犹太难民被天主教会收留藏匿从而侥幸逃生，这同样是出于，天主教徒们被自己信奉的教义 “ 众生生来平等 ” ，所唤醒的良知。 &lt;/p&gt;
&lt;p&gt; 天下无贼的世界，不能仅靠科普说教来营造。如果脱离了信仰，纵使是教育也无法培养良知。我问过许多修化学的同学，学习化学的意义，结论竟是为了考试。如果没有对科学的信仰，我们可以牢记公式定理，却质疑它们是真理；如果没有对社会公德的信仰，我们可以熟背交通规则，却正大光明地闯红灯；如果没有对医疗道德的信仰，医生可以放任伤口发炎，从而留住病人继续治疗 ……&lt;/p&gt;
&lt;p&gt; 国人需要信仰的约束，需要填补信仰的空白，从而唤醒那深埋于每个国人内心深处的良知！ &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Mon, 07 Aug 2006 21:36:00 +0900</pubDate><guid>tag:farseerfc.github.io,2006-08-07:zhs/filling-believings-calling-conscience.html</guid></item></channel></rss>