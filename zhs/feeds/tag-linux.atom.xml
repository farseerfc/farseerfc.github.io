<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Farseerfc的小窝</title><link href="//farseerfc.me/zhs/" rel="alternate"></link><link href="//farseerfc.me/feeds/tag-linux.atom.xml" rel="self"></link><id>//farseerfc.me/zhs/</id><updated>2015-03-19T17:45:00+09:00</updated><entry><title>X 中的混成器与 Composite 扩展</title><link href="//farseerfc.me/zhs/compositor-in-X-and-compositext.html" rel="alternate"></link><updated>2015-03-19T17:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-03-19:zhs/compositor-in-X-and-compositext.html</id><summary type="html">
&lt;p&gt;在上篇文章 &lt;a class="reference external" href="//farseerfc.me/zhs/brief-history-of-compositors-in-desktop-os.html"&gt;「桌面系统的混成器简史」&lt;/a&gt;
中我介绍了其它桌面系统中的混成器的发展史和工作原理，
话题回到我们的正题 Linux 系统上，来说说目前 X 中混成器是如何工作的。
这篇文章将比上一篇深入更多技术细节，不想看太多细节的可以直接跳过看 &lt;a class="reference external" href="#id6"&gt;结论&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="x"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;原始的 X 的绘图模型&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先，没有混成器的时候 X 是这样画图的：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/e06d011e.png"/&gt;
&lt;p&gt;X 的应用程序没有统一的绘图 API 。GTK+ 在 3.0 之后统一用 &lt;a class="reference external" href="http://cairographics.org/"&gt;Cairo&lt;/a&gt; 绘图，
而 Cairo 则是基于 PDF 1.4 的绘图模型构建的，
GTK 的 2.0 和之前的版本中也有很大一部分的绘图是用 Cairo 进行，
其余则通过 xlib 或者 xcb 调用 X 核心协议提供的绘图原语绘图。
QT 的情况也是类似，基本上用 QPaint 子系统绘制成位图然后交给 X 的显示服务器。
显示服务器拿到这些绘制请求之后，再在屏幕上的相应位置绘制整个屏幕。
当然还有很多老旧的不用 GTK 或者 QT 的程序，他们则直接调用 X 核心协议提供的绘图原语。&lt;/p&gt;
&lt;p&gt;值得注意一点是 X 上除了没有统一的绘图模型，也没有统一的矢量图格式。
X 核心协议的绘图原语提供的是像素单位的绘图操作，没有类似 GDI+ 或者 Quartz
提供的 &lt;ruby&gt;&lt;rb&gt;设备无关&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Device Independence&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的「点」的抽象。所以只用 X
的绘图原语的话，我们可以把 (1,1) 这个像素点涂黑，但是不能把 (0.5, 0.5)
这个点涂黑，这一设计缺陷在
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix Hater's Handbook&lt;/a&gt;
中已经被吐槽过了。因为这个缺陷，所以直接用 X 绘图原语绘制的图像不能像
矢量图那样进行无损缩放。同样的缺陷导致 X 绘图原语绘制的字符不能做到
&lt;ruby&gt;&lt;rb&gt;子像素级&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;subpixel-level&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; &lt;ruby&gt;&lt;rb&gt;抗锯齿&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;anti-aliasing&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
（这解释了默认配置下的 xterm 和
&lt;a class="reference external" href="http://arch.acgtyrant.com/2015/01/05/I-do-not-recommend-urxvt-again-now/"&gt;urxvt 中的字体渲染为什么难看&lt;/a&gt;
）。相比之下 GDI 有对应的 WMF 矢量图格式， Quartz 有对应的 PDF 矢量图格式，
而 X 中没有这样的格式对应。因为没有统一的矢量图格式，所以无论是 Cairo 、QPaint
还是没有用这些绘图库但是同样在意字体和曲线渲染效果的程序（比如 Firefox 和
Chromium）都需要首先渲染到内部的 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/X_PixMap"&gt;XPixMap&lt;/a&gt;
位图格式，做好子像素渲染和矢量缩放，然后再把渲染好的位图转交给 X 图形服务器。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="composite"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;通过 Composite 扩展重定向窗口输出&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2004年发布的 X11R6.8 版本的 Xorg 引入了
&lt;a class="reference external" href="http://freedesktop.org/wiki/Software/CompositeExt/"&gt;Composite 扩展&lt;/a&gt;
。这个扩展背后的动机以及前因后果在一篇文章
&lt;a class="reference external" href="http://keithp.com/~keithp/talks/xarch_ols2004/xarch-ols2004-html/"&gt;The (Re)Architecture of the X Window System&lt;/a&gt;
中有详细的表述。Composite 扩展允许某个 X 程序做这几件事情：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;通过 &lt;code class="code"&gt;
RedirectSubwindows&lt;/code&gt;
 调用将一个窗口树中的所有窗口渲染重定向到
&lt;ruby&gt;&lt;rb&gt;内部存储&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;off-screen storage&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。重定向的时候可以指定让 X
自动更新窗口的内容到屏幕上或者由混成器手动更新。&lt;/li&gt;
&lt;li&gt;通过 &lt;code class="code"&gt;
NameWindowPixmap&lt;/code&gt;
 取得某个窗口的内部存储。&lt;/li&gt;
&lt;li&gt;通过 &lt;code class="code"&gt;
GetOverlayWindow&lt;/code&gt;
 获得一个特殊的用于绘图的窗口，
在这个窗口上绘制的图像将覆盖在屏幕的最上面。&lt;/li&gt;
&lt;li&gt;通过 &lt;code class="code"&gt;
CreateRegionFromBorderClip&lt;/code&gt;
 取得某个窗口的边界剪裁区域（不一定是矩形）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了 Composite 扩展，一个 X 程序就可以调用这些 API 实现混成器。
这里有篇 &lt;a class="reference external" href="http://www.talisman.org/~erlkonig/misc/x11-composite-tutorial/"&gt;教学解释如何使用 Composite 扩展&lt;/a&gt; 。开启了混成的 X 是这样绘图的：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/18f7774d.png"/&gt;
&lt;p&gt;整个 X 的混成器模型与 Mac OS X 的混成器模型相比，有如下几点显著的区别：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;混成的部分是交由外部的程序完成的，对混成的绘制方式和绘制普通窗口一样。
出于效率考虑，绝大多数 X 上的混成器额外使用了 XRender 扩展或者
OpenGL/EGL 来加速绘制贴图。不过即使如此，还是不能避免同样的位图（内容不一定完全一致，
比如 X 可以在窗口交给它的位图上加上边框然后再返还给混成器） &lt;em&gt;在不同的三个程序之间来回传递&lt;/em&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code class="code"&gt;
RedirectSubwindows&lt;/code&gt;
 调用针对的是一个窗口树，换句话说是一个窗口
及其全部子窗口，不同于 Mac OS X 中混成器会拿到全部窗口的输出。
这个特点其实并不算是限制，因为 X 中每个虚拟桌面都有一个根窗口，只要指定这个根窗口
就可以拿到整个虚拟桌面上的全部可见窗口输出了。
反而这个设计提供了一定的自由度，比如我们可以用这个调用实现一个截图程序，
拿到某个特定窗口的输出，而不用在意别的窗口。&lt;/li&gt;
&lt;li&gt;为了让窗口有输出，窗口必须显示在当前桌面上，不能处于最小化
状态或者显示在别的虚拟桌面，用 X 的术语说就是窗口必须处于 &lt;ruby&gt;&lt;rb&gt;被映射&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;mapped&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
的状态。因此直接用上述方法 &lt;em&gt;不能得到没有显示的窗口的输出&lt;/em&gt; ，比如不能对最小化的窗口
直接实现 Windows 7 中的 Aero Peak 之类的效果。这个限制可以想办法绕开，
比如在需要窗口输出的时候临时把窗口映射到桌面上，拿到输出之后再隐藏起来，
不过要实现这一点需要混成器和窗口管理器相互配合。&lt;/li&gt;
&lt;li&gt;不像 Mac OS X 的基于 OpenGL Surface 的绘图模型是 &lt;ruby&gt;&lt;rb&gt;设备无关&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;device independent&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
的，这里 X 的绘图模型是 &lt;ruby&gt;&lt;rb&gt;设备相关&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;device dependent&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的。
这既是优点也是缺点。从缺点方面而言，显示到 X 的位图输出因为设备相关性，
所以严格对应显示器的点阵，并不适合作为文档格式打印出来。当然无论是 Cairo
还是 QPaint 都提供了到 PostScript 或者 PDF 后端的输出，所以实用层面这个并不构成问题。
设备相关这一点的优点在于，绘制到 XPM 位图的时候，程序和绘图库是能拿到输出设备（显示器）
的特殊属性的，从而绘图库能考虑不同的色彩、分辨率、 DPI 或者
&lt;ruby&gt;&lt;rb&gt;子像素布局&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;subpixel layout&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 这些属性以提供最好的渲染效果。
Mac OS X 10.4 在设计的时候也曾考虑过提供无极缩放的支持，而这种支持到了 Mac OS X
10.5 中就缩水变成了 Retina 的固定 2 倍缩放。这种局面在 X
上没有发生正是因为 X 的绘图模型的这种设备相关性，而 Mac OS X 的混成器采用的
OpenGL Surface 则无视了这些设备相关的属性。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;输入事件的重定向，这可能做到么？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通过上述 Composite 扩展提供的 API ，混成器可以把窗口的 &lt;em&gt;输出&lt;/em&gt; 重定向到自己的窗口上。
但是仅仅重定向输出，整个 X 还不处于可用状态，因为 &lt;em&gt;没有重定向输入&lt;/em&gt; 。
考虑一下用户试图用鼠标点击某个按钮或者文本框，这时鼠标处于的位置是在 OverlayWindow
上绘制的位置，这个鼠标事件会交给 OverlayWindow ，而用户期待这个事件被发送给他看到的按钮上。&lt;/p&gt;
&lt;p&gt;需要重定向的事件主要有键盘和鼠标事件两大类（暂时先不考虑触摸屏之类的额外输入）。
由于 Composite 扩展并没有直接提供这方面的重定向 API ，这使得输入事件处理起来都比较麻烦，&lt;/p&gt;
&lt;p&gt;假设要重定向键盘事件，混成器需要效仿输入法框架（fcitx, ibus, scim）
那样处理一部分按键事件并把其余事件转给具有输入焦点的程序。
看看现有的输入法框架和诸多程序间的问题，我们就能知道这里的坑有多深。
于是 &lt;em&gt;大部分 X 的混成器都不处理键盘事件重定向&lt;/em&gt;
。再来看重定向鼠标事件，这边的坑比重定向键盘事件的坑更多，
因为不像重定向窗口输出那样只需要考虑 &lt;ruby&gt;&lt;rb&gt;顶层&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;top-level&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 窗口，
重定向鼠标输入的时候要考虑所有子窗口（它们有独立的事件队列），
以及要准确记录输入事件事件发生时的键盘组合键状态，还要正确实现 ICCCM/EWMH
中描述的转交窗口焦点的复杂规则，所有这些都已经在 X 中实现过的事情需要重新实现一遍。&lt;/p&gt;
&lt;p&gt;由于坑太多难以实现，所以所有 X 下的混成器的实现方式都是直接忽略这个繁重的任务，
&lt;em&gt;不重定向输入事件&lt;/em&gt; 而把它交给 X 处理。具体的实现方式就是通过
&lt;a class="reference external" href="http://freedesktop.org/wiki/Software/FixesExt/"&gt;XFixes&lt;/a&gt;
扩展提供的 &lt;code class="code"&gt;
SetWindowShapeRegion&lt;/code&gt;
 API 将 OverlayWindow 的 &lt;em&gt;输入区域&lt;/em&gt;
&lt;code class="code"&gt;
ShapeInput&lt;/code&gt;
 设为空区域，从而忽略对这个 OverlayWindow 的一切鼠标键盘事件。
这样一来对 OverlayWindow 的点击会透过 OverlayWindow 直接作用到底下的窗口上。&lt;/p&gt;
&lt;p&gt;因为选择了不重定向输入事件， X 下的混成器通常会处于以下两种状态：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;选择状态下可以缩放窗口的大小，扭曲窗口的形状，并且可以把窗口绘制在任意想要绘制的位置上
（并不是移动窗口的位置）， &lt;em&gt;但是不能让用户与窗口的内容交互&lt;/em&gt; 。&lt;/li&gt;
&lt;li&gt;正常状态下可以让用户与窗口的内容交互，但是
&lt;em&gt;绘制的窗口位置、大小和形状必须严格地和 X 记录的窗口的位置、大小和形状保持一致&lt;/em&gt;
。持续时间短暂的动画效果可以允许位置和形状稍有偏差，但是在动画的过程中如果用户点击了
变形缩放过的窗口，那么鼠标事件将发往错误的（ X 记录中的而非显示出的）窗口元素上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以发现这两种状态就直接对应了 Gnome 3 的普通状态和缩略图状态（点击 &lt;ruby&gt;&lt;rb&gt;活动&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Activity&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
或者戳画面左上角之后显示的状态），这也解释了为什么尽管 Gnome 3
的窗口有硕大的关闭按钮，但是在缩略图状态下 Gnome 3 仍然需要给窗口加上额外的关闭按钮：
&lt;em&gt;因为处于缩略状态下的窗口只是一张画而不能点&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;Composite 扩展的这些限制使得 X 下的混成器目前只能实现 Mac OS X 那样的 Exposé
效果，而不能实现 &lt;a class="reference external" href="//farseerfc.me/zhs/brief-history-of-compositors-in-desktop-os.html#project-looking-glass-3d"&gt;LG3D&lt;/a&gt; 那样直接在 3D 空间中操纵窗口内容。&lt;/p&gt;
&lt;p&gt;解决重定向问题曾经的一缕曙光是 &lt;ruby&gt;&lt;rb&gt;升阳公司&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Sun Microsystems&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 在开发 &lt;a class="reference external" href="//farseerfc.me/zhs/brief-history-of-compositors-in-desktop-os.html#project-looking-glass-3d"&gt;LG3D&lt;/a&gt; 的过程中同时提议过另一个 X
扩展叫做 Event Interception 或者简称 &lt;a class="reference external" href="http://freedesktop.org/wiki/Software/XEvIE/"&gt;XEvIE&lt;/a&gt; ，这个扩展的设计目的就是提供 API
让某个程序接收并操纵全部的键盘和鼠标事件。可惜这个扩展随着升阳公司本身的陨落而
处于无人维护的状态，这一点也在它的官方网页上说明了：&lt;/p&gt;
&lt;blockquote&gt;
It has been suggested that this extension should not be used
because it is broken and maintainerless.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;Composite 扩展的不足&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通过上面的介绍，我们就已经可以看到 Composite 扩展的不足之处了。
总结起来说，主要有两大不足：&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;绘图效率低。因为同样的位图从应用程序传到 Xorg ，再从 Xorg 传到混成器，
最后从混成器再绘制到屏幕上，绕了一个大弯。这就是为什么 Wayland 的开发者在他的slide
&lt;a class="reference external" href="http://people.freedesktop.org/~daniels/lca2013-wayland-x11.pdf"&gt;the real story behind Wayland and X&lt;/a&gt;
里这么说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;and what's the X server? really bad IPC&lt;/p&gt;
&lt;p&gt;那么 X 服务器到底做了什么呢？ 非常糟糕的进程间通讯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;没有重定向输入事件。如果我们要在 X 的混成器里做这个事情，
基本上我们要全部重写一遍 X 已经写好的窗口事件分发逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然同样要重写，为什么不直接重写一遍 X 呢，扔掉那些历史负担，扔掉那些无用的 API
，重新设计可扩展的 API ，做好快速安全的 IPC —— 嗯，重写 X 就是 Wayland 的目的。&lt;/p&gt;
&lt;p&gt;不过这么重写了的 Wayland 还是我们熟悉可爱的 X 么？它有哪些地方变样了？
这将是我下一篇文章的内容。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;附录：扩展阅读&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我自己没有写过窗口管理器，没有写过混成器，没有写过 Wayland
程序，以上说的都是我从互联网上看到的整理出来的内容。写下本文的过程中我参考了这些文章：&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://keithp.com/~keithp/talks/xarch_ols2004/xarch-ols2004-html/"&gt;The (Re)Architecture of the X Window System&lt;/a&gt; 这篇2004年写的文章描述了 Composite
扩展出现的动机和历史，介绍了绘图库的实现情况，涉及了上面所说的那些 X 扩展被用到的情况和可能。
同时这篇文章还展望了很多现在的 X 已然实现了的功能，比如 OpenGL 和 X 的结合方面我们有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/GLX"&gt;GLX&lt;/a&gt; 和 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/AIGLX"&gt;AIGLX&lt;/a&gt;
，比如内核的显卡支持方面我们有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Direct_Rendering_Infrastructure"&gt;DRI&lt;/a&gt; 和 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Mode_setting"&gt;KMS&lt;/a&gt; 。总之这是一篇描述 Linux
桌面未来的发展轨迹的非常有阅读价值的历史文献。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://wingolog.org/archives/2008/07/26/so-you-want-to-build-a-compositor"&gt;so you want to build a compositor&lt;/a&gt; 这是一篇 2008 年写的博文，介绍如何用 Clutter
实现一个最简单的混成器。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.talisman.org/~erlkonig/misc/x11-composite-tutorial/"&gt;Composite tutorial&lt;/a&gt; 这是另一篇介绍如何实现一个简单的混成器的博文，用 Qt 实现，但是同样很底层。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://projects.mini-dweeb.org/projects/unagi"&gt;unagi&lt;/a&gt; 这是一个可用的（但是已经长期没有开发的）类似 xcompmgr 的混成器。这个项目貌似
是一位研究生的硕士毕业设计，同时他公开了硕士学位的毕业论文
&lt;a class="reference external" href="http://projects.mini-dweeb.org/attachments/download/3/report.pdf"&gt;Master thesis: Writing an X compositing manager&lt;/a&gt;
其中也对实现一个简单的混成器做了详尽描述，包括介绍了相关的 X 扩展和调用。&lt;/p&gt;
&lt;/div&gt;
</summary><category term="linux"></category><category term="wayland"></category><category term="xorg"></category><category term="compositor"></category></entry><entry><title>archlinux 上用 chrome 实现 透明计算 远程登录</title><link href="//farseerfc.me/zhs/arch-chrome-remote-desktop.html" rel="alternate"></link><updated>2015-02-13T20:39:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-02-13:zhs/arch-chrome-remote-desktop.html</id><summary type="html">
&lt;p&gt;&lt;a class="reference external" href="http://news.sciencenet.cn/htmlnews/2015/1/311393.shtm"&gt;透明计算&lt;/a&gt;
具体是什么，因为他们没有公开技术细节所以我并不知道，只是看
&lt;a class="reference external" href="http://v.qq.com/page/h/v/q/h0145ebh1vq.html"&gt;公开出来的演示视频&lt;/a&gt;
，感觉似乎只要能从手机上远程登录系统桌面，就能算是透明计算了。
如果透明计算真是这个意思，那么我似乎已经用着这个技术很多年了嘛。&lt;/p&gt;
&lt;p&gt;Xorg 上常用的远程桌面工具有很多，基于 VNC 协议的、基于NX的和基于 RDP 协议的都能找到，
直接 ssh X forwarding 效果也不错。只是这些方案的一个 &lt;em&gt;不太易用&lt;/em&gt; 的地方在于，需要
通过 ip 访问到远程的电脑，所以在跨越 NAT 之类的情况下不太容易使用。&lt;/p&gt;
&lt;p&gt;于是今天介绍一个使用方便设置也简单的方法： 通过 chrome-remote-desktop 在 archlinux
上使用远程桌面。这个方案的优势在于，借助 Google 的云端服务器（内部貌似是XMPP协议下的握手）
方便地实现了 NAT 穿透，无论什么网络环境基本都能使用。当然，要支持远程登录，
位于远端的登录的计算机必须一直开着 Chrome Remote Desktop 的后台服务。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Chrome Remote Desktop 插件&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Chrome Remote Desktop 插件" class="img-responsive" src="{filename}/images/chrome-remote-desktop-plugin.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="chrome-remote-desktop"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;Chrome Remote Desktop 的客户端&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;虽然可能有很多人不知道，不过 Chrome 内包括远程桌面的功能很久了。只是这个功能的界面默认
没有提供界面，要使用它需要安装 Google 官方出品的
&lt;a class="reference external" href="https://chrome.google.com/webstore/detail/chrome-remote-desktop/gbchcmhmhahfdphkhkmpfmihenigjmpp"&gt;remote-desktop 插件&lt;/a&gt; 。
装好之后远程桌面的客户端就准备好，可以用来远程访问别的计算机桌面了（无论是 Windows/OS X
还是 Linux 都支持）。并且不光可以自己远程访问自己账户的桌面，还可以远程协助朋友的桌面。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="archlinux"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;Archlinux 上设置远程登录的服务器&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;有了客户端之后还要设置一下才能让桌面作为远程登录的服务器。Windows 和 OS X 上 Chrome
会自动下载需要的安装包，无脑下一步就能装好了。Linux上由于发行版众多，桌面配置各异，
所以需要一点手动配置。官方的设置步骤记载在 &lt;a class="reference external" href="https://support.google.com/chrome/answer/1649523"&gt;这里&lt;/a&gt;
其中给出了 debian 用的二进制包和 Ubuntu 12.10 上的设置方式，以下设置是参考官方步骤。&lt;/p&gt;
&lt;p&gt;首先要安装 chrome-remote-desktop 这个包，这个包实际上对应了 Windows/OS X 上用安装程序
安装的 Remote Desktop Host Controller。 archlinux 上开启了
&lt;a class="reference external" href="https://github.com/archlinuxcn/repo"&gt;[archlinuxcn]&lt;/a&gt;
仓库的话，可以直接安装打好的包。或者可以从
&lt;a class="reference external" href="https://aur.archlinux.org/packages/chrome-remote-desktop/"&gt;AUR&lt;/a&gt; 装。&lt;/p&gt;
&lt;pre&gt;&lt;span class="code-line"&gt;$ pacman -Ss chrome-remote-desktop&lt;br/&gt;&lt;span style="color:purple;font-weight:bold;"&gt;archlinuxcn/&lt;/span&gt;&lt;span style="font-weight:bold;"&gt;chrome-remote-desktop &lt;/span&gt;&lt;span style="color:green;font-weight:bold;"&gt;40.0.2214.44-1&lt;/span&gt;&lt;br/&gt;Allows you to securely access your computer over the Internet through Chrome.&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;装好之后从会说这么一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;groupadd：无效的组 ID “chrome-remote-desktop”&lt;/p&gt;
&lt;p&gt;Please create ~/.config/chrome-remote-desktop folder manually, if it doesn't exist, or else you can't use CRD.
The needed files are created by the Chrome app, inside the chrome-remote-desktop folder, after Enabling Remote Connections.
To {enable,start} the service use systemctl --user {enable,start} chrome-remote-desktop&lt;/p&gt;
&lt;p&gt;You may need to create a ~/.chrome-remote-desktop-session file with commands to start your session&lt;/p&gt;
&lt;p&gt;Go to &lt;a class="reference external" href="https://support.google.com/chrome/answer/1649523"&gt;https://support.google.com/chrome/answer/1649523&lt;/a&gt; for more information.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那句报错是 AUR 里打的包还没跟上上游 Google 的更改导致的错误，
首先我们需要把远程登录的用户添加入 chrome-remote-desktop 这个用户组里。
新版本的 chrome remote desktop 提供了一个命令做这个事情，所以执行以下命令就可以了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; /opt/google/chrome-remote-desktop/chrome-remote-desktop --add-user&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们需要手动创建 &lt;code class="code"&gt;
~/.config/chrome-remote-desktop&lt;/code&gt;
 这个文件夹，内容是空的
就好了，随后 chrome 会往这里面放 &lt;code class="code"&gt;
host#.json&lt;/code&gt;
 文件用于身份验证。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; mkdir ~/.config/chrome-remote-desktop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们要创建一个 shell 脚本 &lt;code class="code"&gt;
~/.chrome-remote-desktop-session&lt;/code&gt;
 ，这是远程
登录时的 .xinitrc ，内容么就是启动你想在远程登录时用的桌面环境。
这里可以指定一个和你正在登录的 WM/DE 不同的桌面，比如我启动 xfce4：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; cat ~/.chrome-remote-desktop-session&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;#&lt;/span&gt;!/bin/bash&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;startxfce4&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; chmod &lt;span class="m"&gt;755&lt;/span&gt; .chrome-remote-desktop-session&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来需要从 Chrome 的插件里启用远程桌面。打开 Chrome 的 Remote Desktop 插件，这时
应该可以看到一个「启用远程链接」的按钮。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="Chrome Remote Desktop 插件中「启用远程链接」的按钮" class="img-responsive" src="{filename}/images/chrome-remote-desktop-enable-button.png"/&gt;
&lt;p class="caption"&gt;Chrome Remote Desktop 插件中「启用远程链接」的按钮&lt;/p&gt;
&lt;/div&gt;
&lt;div class="alert alert-warning compound"&gt;
&lt;p&gt;在撰写本文的时候， Archlinux 官方源里的 chromium 的版本和 aur/google-chrome
的版本尚且还是 40.0.2214.111 ，而 Chrome Web Store 中提供的 Chrome Remote
Desktop 的插件的版本是 41.0.2272.41 。虽然通常并不要求两者版本一致，不过貌似最近
Chrome 内部的 Remoting 功能更改了 API 导致可能出问题。如果你找不到
「启用远程链接」的按钮，请尝试一下新版本的 Chrome 比如 google-chrome-dev 。
在这一步启用之后，老版本的 chrome 应该也就能使用远程桌面了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="alert alert-warning compound"&gt;
&lt;p&gt;在32位的 Linux 版本上，最近更新的 Chrome Remote Desktop 插件可能无法正确识别 Host
的版本，具体 &lt;a class="alert-link reference external" href="https://code.google.com/p/chromium/issues/detail?id=332930"&gt;参考这个 bug&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;点击「启用远程链接」，设定一个 PIN 密码（不需要很复杂，这里首先有 Google 帐号验证保证只有
你才能访问），然后就能看到这套电脑的 hostname 出现在「我的电脑」列表里。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="启用远程链接之后的样子" class="img-responsive" src="{filename}/images/chrome-remote-desktop-after-enabled.png"/&gt;
&lt;p class="caption"&gt;启用远程链接之后的样子&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;同时，启用了远程链接之后，可以在刚刚创建的 ~/.config/chrome-remote-desktop
文件夹中找到记录了验证信息的文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ls .config/chrome-remote-desktop&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;chrome-profile  host#8cfe7ecfd6bb17955c1ea22f77d0d800.json  pulseaudio#8cfe7ecfd6&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以启动对应的 systemd 用户服务了，如果想自动启动服务要记得 &lt;code class="code"&gt;
systemctl --user enable&lt;/code&gt;
 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; systemctl --user start chrome-remote-desktop.service&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果上面的设置一切正常，就可以看到 chrome-remote-desktop 启动了另外一个 Xorg 执行你
刚刚指定的桌面环境：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="htop 中看到的 chrome-remote-desktop 启动的另外一个 Xorg" class="img-responsive" src="{filename}/images/chrome-remote-desktop-htop.png"/&gt;
&lt;p class="caption"&gt;htop 中看到的 chrome-remote-desktop 启动的另外一个 Xorg&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;然后就可以试着通过 Remote Desktop 插件登录到这个新开的 Xorg 了：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="「远程」登录到新的 XFCE4" class="img-responsive" src="{filename}/images/chrome-remote-desktop-xfce4.png"/&gt;
&lt;p class="caption"&gt;「远程」登录到新的 XFCE4&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="linux-chrome-windows-os-x"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;Linux 版本的 Chrome远程桌面 和 Windows/ OS X 上的区别&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通过上面的设置步骤也可以看出，Linux版本的远程桌面会在后台开一个独立的 X 会话，而不能
复用现在已有的 X 会话。对远程登录的用法而言这还能接受，对远程协助的功能而言有点问题，
因为正在使用的人不能观察协助者做了什么，协助者也不能继续请求协助的人的操作。&lt;/p&gt;
&lt;p&gt;当然目前 Chrome 远程桌面的 Linux Host Controller 还只是 beta 版本，官方只测试支持
Ubuntu 12.04 和 12.10 （14.04之后似乎有
&lt;a class="reference external" href="https://code.google.com/p/chromium/issues/detail?id=366432"&gt;Bug&lt;/a&gt;
），所以不能要求太多。希望以后能改善吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bonus"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;Bonus： 手机远程登录&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
手机上的 Chrome 远程桌面 App&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="手机上的 Chrome 远程桌面 App" class="img-responsive" src="{filename}/images/chrome-remote-desktop-android.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过上面的设置就可以从任何一个 Chrome 远程桌面客户端登录刚刚设置的这台电脑了。
因为 Chrome 在三大桌面系统 Windows / OS X / Linux 上都有，所以应该能覆盖大多数桌面
系统了。&lt;/p&gt;
&lt;p&gt;除了桌面的 Chrome 之外还有一个客户端是 Android 上的
&lt;a class="reference external" href="https://play.google.com/store/apps/details?id=com.google.chromeremotedesktop"&gt;Chrome 远程桌面 App&lt;/a&gt; 经过上面的设置之后，从这个 App 也能看到并登录：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="手机远程登录" class="img-responsive" src="{filename}/images/chrome-remote-desktop-android-logined.png"/&gt;
&lt;p class="caption"&gt;手机远程登录&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;好啦，开始享受国家自然科学一等奖的透明计算技术吧！&lt;/p&gt;
&lt;/div&gt;
</summary><category term="linux"></category><category term="archlinux"></category><category term="arch"></category><category term="chrome"></category><category term="remote"></category><category term="desktop"></category></entry><entry><title>从非缓冲输入流到 Linux 控制台的历史</title><link href="//farseerfc.me/zhs/from-unbuffered-stdin-to-history-of-linux-tty.html" rel="alternate"></link><updated>2014-12-12T17:06:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2014-12-12:zhs/from-unbuffered-stdin-to-history-of-linux-tty.html</id><summary type="html">
&lt;p&gt;这篇也是源自于水源C板上板友的一个问题，涉及Linux上的控制台的实现方式和历史原因。因为内容比较长，所以在这里再排版一下发出来。
&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1418138991,file,M.1418138991.A.html"&gt;原帖在这里&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;可以设置不带缓冲的标准输入流吗？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;WaterElement(UnChanged) 于 2014年12月09日23:29:51 星期二 问到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请问对于标准输入流可以设置不带缓冲吗？比如以下程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;似乎还是需要在命令行输入后按回车才会让 &lt;code class="code"&gt;
fgets&lt;/code&gt;
 返回，不带缓冲究竟体现在哪里？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;这和缓存无关，是控制台的实现方式的问题。&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;再讲细节一点，这里有很多个程序和设备。以下按 linux 的情况讲：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;终端模拟器窗口（比如xterm）收到键盘事件&lt;/li&gt;
&lt;li&gt;终端模拟器(xterm)把键盘事件发给虚拟终端 pty1&lt;/li&gt;
&lt;li&gt;pty1 检查目前的输入状态，把键盘事件转换成 stdin 的输入，发给你的程序&lt;/li&gt;
&lt;li&gt;你的程序的 c 库从 stdin 读入一个输入，处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;标准库说的输入缓存是在 4 的这一步进行的。而行输入是在 3 的这一步被缓存起来的。&lt;/p&gt;
&lt;p&gt;终端pty有多种状态，一般控制台程序所在的状态叫「回显行缓存」状态，这个状态的意思是:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;所有普通字符的按键，会回显到屏幕上，同时记录在行缓存区里。&lt;/li&gt;
&lt;li&gt;处理退格( &lt;kbd class="kbd"&gt;
BackSpace&lt;/kbd&gt;
 )，删除( &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;
 )按键为删掉字符，左右按键移动光标。&lt;/li&gt;
&lt;li&gt;收到回车的时候把整个一行的内容发给stdin。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Cooked_mode"&gt;http://en.wikipedia.org/wiki/Cooked_mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时在Linux/Unix下可以发特殊控制符号给pty让它进入「raw」状态，这种状态下按键
不会被回显，显示什么内容都靠你程序自己控制。
如果你想得到每一个按键事件需要用raw状态，这需要自己控制回显自己处理缓冲，
简单点的方法是用 readline 这样的库（基本就是「回显行缓存」的高级扩展，支持了
Home/End，支持历史）或者 ncurses 这样的库（在raw状态下实现了一个简单的窗口/
事件处理框架）。&lt;/p&gt;
&lt;p&gt;参考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/POSIX_terminal_interface#History"&gt;http://en.wikipedia.org/wiki/POSIX_terminal_interface#History&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除此之外， &lt;kbd class="kbd"&gt;
Ctrl-C&lt;/kbd&gt;
 转换到 SIGINT ， &lt;kbd class="kbd"&gt;
Ctrl-D&lt;/kbd&gt;
 转换到 EOF 这种也是在 3 这一步做的。&lt;/p&gt;
&lt;p&gt;以及，有些终端模拟器提供的 &lt;kbd class="kbd"&gt;
Ctrl-Shift-C&lt;/kbd&gt;
 表示复制这种是在 2 这一步做的。&lt;/p&gt;
&lt;p&gt;以上是 Linux/unix 的方式。 Windows的情况大体类似，只是细节上有很多地方不一样：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;窗口事件的接收者是创建 cmd 窗口的 Win32 子系统。&lt;/li&gt;
&lt;li&gt;Win32子系统接收到事件之后，传递给位于 命令行子系统 的 cmd 程序&lt;/li&gt;
&lt;li&gt;cmd 程序再传递给你的程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Windows上同样有类似行缓存模式和raw模式的区别，只不过实现细节不太一样。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="strace"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;strace查看了下&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WaterElement(UnChanged) 于 2014年12月10日21:53:54 星期三 回复：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;感谢FC的详尽解答。&lt;/p&gt;
&lt;p&gt;用strace查看了下，设置标准输入没有缓存的话读每个字符都会调用一次 &lt;code class="code"&gt;
read&lt;/code&gt;
 系统调用，
比如输入abc：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;read(0, abc&lt;/span&gt;
&lt;span class="code-line"&gt;"a", 1)                         = 1&lt;/span&gt;
&lt;span class="code-line"&gt;read(0, "b", 1)                         = 1&lt;/span&gt;
&lt;span class="code-line"&gt;read(0, "c", 1)                         = 1&lt;/span&gt;
&lt;span class="code-line"&gt;read(0, "\n", 1)                        = 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有缓存的话就只调用一次了 &lt;code class="code"&gt;
read&lt;/code&gt;
 系统调用了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;read(0, abc&lt;/span&gt;
&lt;span class="code-line"&gt;"abc\n", 1024)                  = 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="raw-mode"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;如果想感受一下 raw mode&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;没错，这个是你的进程内C库做的缓存，tty属于字符设备所以是一个一个字符塞给你的
程序的。&lt;/p&gt;
&lt;p&gt;如果想感受一下 raw mode 可以试试下面这段程序（没有检测错误返回值）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include &amp;lt;termios.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ttyfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;/* reset tty - useful also for restoring the terminal when this process&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;   wishes to temporarily relinquish the tty&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* flush and reset */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;/* put terminal in raw mode - see termio(7I) for modes */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* copy original and then modify below */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* input modes - clear indicated ones giving: no break, no CR to NL,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;       no parity check, no strip char, no start/stop output (sic) control */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_iflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BRKINT&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICRNL&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;INPCK&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISTRIP&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IXON&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* output modes - clear giving: no post processing such as NL to CR+NL */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_oflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OPOST&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* control modes - set 8 bit chars */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cflag&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CS8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* local modes - clear giving: echoing off, canonical off (no erase with&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;       backspace, ^U,...),  no extended functions, no signal chars (^Z,^C) */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_lflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ECHO&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICANON&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IEXTEN&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISIG&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* control chars - set return condition: min number of bytes and timer */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after 5 bytes or .8 seconds&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;                                                after first byte seen      */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* immediate - anything       */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after two bytes, no timer  */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after a byte or .8 seconds */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* put terminal in raw mode after flushing */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;atexit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;终端上的字符编程&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;vander(大青蛙) 于 2014年12月12日08:52:20 星期五 问到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;学习了！&lt;/p&gt;
&lt;p&gt;进一步想请教一下fc大神。如果我在Linux上做终端上的字符编程，是否除了用ncurses库
之外，也可以不用该库而直接与终端打交道，就是你所说的直接在raw模式？
另外，终端类型vt100和linux的差别在哪里？为什么Kevin Boone的KBox配置手册里面说必
须把终端类型设成linux，而且要加上terminfo文件，才能让终端上的vim正常工作？term
info文件又是干什么的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;Linux控制台的历史&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;嗯理论上可以不用 ncurses 库直接在 raw 模式操纵终端。&lt;/p&gt;
&lt;p&gt;这里稍微聊一下terminfo/termcap的历史，详细的历史和吐槽参考
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater's Handbook&lt;/a&gt;
第6章 Terminal Insanity。&lt;/p&gt;
&lt;p&gt;首先一个真正意义上的终端就是一个输入设备（通常是键盘）加上一个输出设备（打印
机或者显示器）。很显然不同的终端的能力不同，比如如果输出设备是打印机的话，显
示出来的字符就不能删掉了（但是能覆盖），而且输出了一行之后就不能回到那一行了
。再比如显示器终端有的支持粗体和下划线，有的支持颜色，而有的什么都不支持。
早期Unix工作在电传打字机（TeleTYpe）终端上，后来Unix被port到越来越多的机器上
，然后越来越多类型的终端会被连到Unix上，很可能同一台Unix主机连了多个不同类型
的终端。由于是不同厂商提供的不同的终端，能力各有不同，自然控制他们工作的方式
也是不一样的。所有终端都支持回显行编辑模式，所以一般的面向行的程序还比较好写
，但是那时候要撰写支持所有终端的「全屏」程序就非常痛苦，这种情况就像现在浏览
器没有统一标准下写HTML要测试各种浏览器兼容性一样。
通常的做法是&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;使用最小功能子集&lt;/li&gt;
&lt;li&gt;假设终端是某个特殊设备，不管别的设备。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;水源的代码源头 Firebird2000 就是那样的一个程序，只支持固定大小的vt102终端。&lt;/p&gt;
&lt;p&gt;这时有一个划时代意义的程序出现了，就是 vi，试图要做到「全屏可视化编辑」。这在
现在看起来很简单，但是在当时基本是天方夜谭。
vi 的做法是提出一层抽象，记录它所需要的所有终端操作，然后有一个终端类型数据库
，把那些操作映射到终端类型的具体指令上。当然并不是所有操作在所有终端类型上都
支持，所以会有一堆 fallback，比如要「强调」某段文字，在彩色终端上可能
fallback 到红色，在黑白终端上可能 fallback 到粗体。&lt;/p&gt;
&lt;p&gt;vi 一出现大家都觉得好顶赞，然后想要写更多类似 vi 这样的全屏程序。然后 vi 的作
者就把终端抽象的这部分数据库放出来形成一个单独的项目，叫 termcap （Terminal
Capibility），对应的描述终端的数据库就是 termcap 格式。然后 termcap 只是一个
数据库（所以无状态）还不够方便易用，所以后来又有人用 termcap 实现了 curses 。&lt;/p&gt;
&lt;p&gt;再后来大家用 curses/termcap 的时候渐渐发现这个数据库有一点不足：它是为 vi 设
计的，所以只实现了 vi 需要的那部分终端能力。然后对它改进的努力就形成了新的
terminfo 数据库和 pcurses 和后来的 ncurses 。 然后 VIM 出现了自然也用
terminfo 实现这部分终端操作。&lt;/p&gt;
&lt;p&gt;然后么就是 X 出现了， xterm 出现了，大家都用显示器了，然后 xterm 为了兼容各种
老程序加入了各种老终端的模拟模式。不过因为最普及的终端是 vt100 所以 xterm 默
认是工作在兼容 vt100 的模式下。然后接下来各种新程序（偷懒不用*curses的那些）
都以 xterm/vt100 的方式写。&lt;/p&gt;
&lt;p&gt;嗯到此为止是 Unix 世界的黑历史。&lt;/p&gt;
&lt;p&gt;知道这段历史的话就可以明白为什么需要 TERM 变量配合 terminfo 数据库才能用一些
Unix 下的全屏程序了。类比一下的话这就是现代浏览器的 user-agent。&lt;/p&gt;
&lt;p&gt;然后话题回到 Linux 。 大家知道 Linux 早期代码不是一个 OS， 而是 Linus 大神想
在他的崭新蹭亮的 386-PC 上远程登录他学校的 Unix 主机，接收邮件和逛水源（咳咳
）。于是 Linux 最早的那部分代码并不是一个通用 OS 而只是一个 bootloader 加一个
终端模拟器。所以现在 Linux 内核里还留有他当年实现的终端模拟器的部分代码，而这
个终端模拟器的终端类型就是 linux 啦。然后他当时是为了逛水源嘛所以 linux 终端
基本上是 vt102 的一个接近完整子集。&lt;/p&gt;
&lt;p&gt;说到这里脉络大概应该清晰了， xterm终端类型基本模拟 vt100，linux终端类型基本模
拟 vt102。这两个的区别其实很细微，都是同一个厂商的两代产品嘛。有差别的地方差
不多就是 &lt;kbd class="kbd"&gt;
Home&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
End&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageUp&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageDown&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;

这些不在 ASCII 控制字符表里的按键的映射关系不同。&lt;/p&gt;
&lt;p&gt;嗯这也就解释了为什么在linux环境的图形界面的终端里 telnet 上水源的话，上面这些
按键会错乱…… 如果设置终端类型是 linux/vt102 的话就不会乱了。在 linux 的
TTY 里 telnet 也不会乱的样子。&lt;/p&gt;
&lt;p&gt;写到这里才发现貌似有点长…… 总之可以参考
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater's Handbook&lt;/a&gt;
里的相关历史评论和吐槽，那一段非常有意思。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="c"></category><category term="linux"></category><category term="stdio"></category><category term="tty"></category><category term="unix"></category><category term="ugh"></category><category term="ncurses"></category><category term="termcap"></category><category term="terminfo"></category></entry><entry><title>KDE5 Plasma 之跳动卖萌的活动按钮</title><link href="//farseerfc.me/zhs/jumping-kde5-plasma-activities-button.html" rel="alternate"></link><updated>2014-12-09T01:54:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2014-12-09:zhs/jumping-kde5-plasma-activities-button.html</id><summary type="html">
&lt;p&gt;今天尝试 KDE5 Plasma 的活动的时候无意间发现这个现象。
只要把活动按钮拖出桌面，它就会在桌面边缘来回跳动。
视频如下：&lt;/p&gt;

&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_SSbf97jGSpI"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/SSbf97jGSpI"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XODQ0NjM2MzQ4"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;embed align="middle" allowfullscreen="true" allowscriptaccess="always" class="embed-responsive-item" quality="high" src="http://player.youku.com/player.php/sid/XODQ0NjM2MzQ4/v.swf" type="application/x-shockwave-flash"&gt;&lt;/embed&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_SSbf97jGSpI"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XODQ0NjM2MzQ4"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;当然你可以把它再拖回来，所以这个问题还无伤大雅，只是卖萌。&lt;/p&gt;
&lt;p&gt;比比之前 Gnome3 那个跳动的界面真是好太多了：&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_TRQJdRHYwrw"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/TRQJdRHYwrw"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XNjc4MjQ5NjE2"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;embed align="middle" allowfullscreen="true" allowscriptaccess="always" class="embed-responsive-item" quality="high" src="http://player.youku.com/player.php/sid/XNjc4MjQ5NjE2/v.swf" type="application/x-shockwave-flash"&gt;&lt;/embed&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_TRQJdRHYwrw"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XNjc4MjQ5NjE2"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;顺便，今天还看到一个卖萌的 KDE5 Plasma 静音图标的翻译：&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;blockquote class="twitter-tweet" lang="zh-tw"&gt;&lt;p&gt;KDE5のミュート画面の中国语翻訳、「静音」のはずだが「镜音」になっている。Vocaloidファンのネタだか、単なる入力ミスだか分からない。 &lt;a href="http://t.co/ipyHjXMscR"&gt;pic.twitter.com/ipyHjXMscR&lt;/a&gt;&lt;/p&gt;— Jiachen YANG (@farseerfc) &lt;a href="https://twitter.com/farseerfc/status/541944351270518784"&gt;2014 12月 8日&lt;/a&gt;&lt;/blockquote&gt;</summary><category term="kde5"></category><category term="plasma"></category><category term="linux"></category><category term="gnome3"></category></entry><entry><title>“…if we do this work … ” --Bill Gates</title><link href="//farseerfc.me/zhs/if-we-do-this-work.html" rel="alternate"></link><updated>2011-03-14T20:34:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2011-03-14:zhs/if-we-do-this-work.html</id><summary type="html">&lt;p&gt;导入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/716517729"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From: Bill Gates&lt;/p&gt;
&lt;p&gt;’-- Sent: Sunday, January 24, 1999 8:41 AM&lt;/p&gt;
&lt;p&gt;Jeff Westorinon; Ben Fathi ;&lt;/p&gt;
&lt;p&gt;TO: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder&lt;/p&gt;
&lt;p&gt;Subject: ACPI extensions&lt;/p&gt;
&lt;p&gt;One thing I find myself wondering about is whether we shouldn’t try and
make the "ACPI" extensions somehow Windows specific.&lt;/p&gt;
&lt;p&gt;It seems unfortunate if we do this work and get our partners to do the
work and the result is that &lt;strong&gt;Linux works great without having to do the work&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maybe there is no way to avoid this problem but it does bother me.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Maybe we could define the APIs so that they work well with NT and not
the others even if they are open.&lt;/p&gt;
&lt;p&gt;Or maybe we could patent something relaled to this.&lt;/p&gt;
&lt;p&gt;From:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf"&gt;http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果这就是我至今在Xen4.0上得不到ACPI 3.0的完善支持的原因，那么我诅咒Bill Gates！&lt;/p&gt;
</summary><category term="microsoft"></category><category term="linux"></category><category term="acpi"></category></entry></feed>