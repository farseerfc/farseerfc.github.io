<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Farseerfc的小窝</title><link href="//farseerfc.me/zhs/" rel="alternate"></link><link href="//farseerfc.me/feeds/tag-zhihu.atom.xml" rel="self"></link><id>//farseerfc.me/zhs/</id><updated>2016-08-08T00:02:00+09:00</updated><entry><title>C语言中“.”与“-&gt;”有什么区别？</title><link href="//farseerfc.me/zhs/dot-and-arrow-in-c.html" rel="alternate"></link><published>2016-08-08T00:02:00+09:00</published><author><name>farseerfc</name></author><id>tag:farseerfc.me,2016-08-08:zhs/dot-and-arrow-in-c.html</id><summary type="html">&lt;p&gt;从 &lt;a class="reference external" href="https://www.zhihu.com/question/49164544/answer/114584541"&gt;知乎&lt;/a&gt; 转载&lt;/p&gt;
&lt;p&gt;转载几篇知乎上我自己的回答，因为不喜欢知乎的排版，所以在博客里重新排版一遍。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;原问题：C语言中“.”与“-&amp;gt;”有什么区别？&lt;/h2&gt;
&lt;p&gt;除了表达形式有些不同，功能可以说完全一样阿。那为何又要构造两个功能一样的运算符？ 效率有差异？可是现在编译器优化都那么强了，如果真是这样岂不是有些多此一举&lt;/p&gt;
&lt;hr class="docutils"/&gt;
&lt;p&gt;刚刚翻了下书，说早期的C实现无法用结构直接当作参数在函数间传递，只能用指向结构的指针在函数间进行传递！我想这应该也是最直观的原因吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;我的回答&lt;/h2&gt;
&lt;p&gt;首先 &lt;code class="code"&gt;
a-&amp;gt;b&lt;/code&gt;
 的含义是 &lt;code class="code"&gt;
(*a).b&lt;/code&gt;
 ，所以他们是不同的，不过的确 &lt;code class="code"&gt;
-&amp;gt;&lt;/code&gt;
 可以用 &lt;code class="code"&gt;
*&lt;/code&gt;
 和 &lt;code class="code"&gt;
.&lt;/code&gt;
 实现，不需要单独一个运算符。
嗯，我这是说现代的标准化的 C 语义上来说， &lt;code class="code"&gt;
-&amp;gt;&lt;/code&gt;
 可以用 &lt;code class="code"&gt;
*&lt;/code&gt;
 和 &lt;code class="code"&gt;
.&lt;/code&gt;
 的组合实现。&lt;/p&gt;
&lt;p&gt;早期的 C 有一段时间的语义和现代的 C 的语义不太一样。&lt;/p&gt;
&lt;p&gt;稍微有点汇编的基础的同学可能知道，在机器码和汇编的角度来看，不存在变量，不存在 struct 这种东西，只存在寄存器和一个叫做内存的大数组。&lt;/p&gt;
&lt;p&gt;所以变量，是 C 对内存地址的一个抽象，它代表了一个位置。举个例子，C 里面我们写：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实在汇编的角度来看更像是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 A 和 B 各是两个内存地址，是指针。&lt;/p&gt;
&lt;p&gt;好，以上是基本背景。&lt;/p&gt;
&lt;p&gt;基于这个背景我们讨论一下 struct 是什么，以及 struct 的成员是什么。
假设我们有&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从现代语义上讲 &lt;code class="code"&gt;
p&lt;/code&gt;
 就是一个结构体对象， &lt;code class="code"&gt;
x&lt;/code&gt;
 和 &lt;code class="code"&gt;
y&lt;/code&gt;
 各是其成员，嗯。&lt;/p&gt;
&lt;p&gt;从汇编的语义上讲， &lt;code class="code"&gt;
p`是一个不完整的地址，或者说，半个地址，再或者说，一个指向的东西是虚构出来的地址。而 :code:`x&lt;/code&gt;
 和 &lt;code class="code"&gt;
y&lt;/code&gt;
 各是在 Point 结构中的地址偏移量。也就是说，必须有 &lt;code class="code"&gt;
p&lt;/code&gt;
 和 &lt;code class="code"&gt;
x&lt;/code&gt;
 或者 &lt;code class="code"&gt;
p&lt;/code&gt;
 和 &lt;code class="code"&gt;
y&lt;/code&gt;
 同时出现，才形成一个完整的地址，单独的一个 &lt;code class="code"&gt;
p&lt;/code&gt;
 没有意义。&lt;/p&gt;
&lt;p&gt;早期的 C 就是在这样的模型上建立的。所以对早期的 C 而言， &lt;code class="code"&gt;
*pp&lt;/code&gt;
 没有意义，你取得了一个 struct ，而这个 struct 不能塞在任何一个寄存器里，编译器和 CPU 都无法表达这个东西。&lt;/p&gt;
&lt;p&gt;这时候只有 &lt;code class="code"&gt;
p.x&lt;/code&gt;
 和 &lt;code class="code"&gt;
p.y&lt;/code&gt;
 有意义，它们有真实的地址。&lt;/p&gt;
&lt;p&gt;早期的 C 就是这样一个看起来怪异的语义，而它更贴近机器的表达。
所以对早期的 C 而言，以下的代码是对的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而以下代码是错的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为作为这个赋值的目标地址表达式的一部分， &lt;code class="code"&gt;
*pp&lt;/code&gt;
 ，这个中间结果没法直译到机器码。&lt;/p&gt;
&lt;p&gt;所以对早期的 C 而言，对 pp 解引用的操作，必须和取成员的偏移的操作，这两者紧密结合起来变成一个单独的操作，其结果才有意义。&lt;/p&gt;
&lt;p&gt;所以早期的 C 就发明了 -&amp;gt; ，表示这两个操作紧密结合的操作。于是才能写：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;pp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嗯，这就是它存在的历史原因。
而这个历史原因现在已经不重要了，现代的符合标准的 C 编译器都知道 &lt;code class="code"&gt;
(*pp).x&lt;/code&gt;
 和 &lt;code class="code"&gt;
pp-&amp;gt;x&lt;/code&gt;
 是等价的了。&lt;/p&gt;
&lt;p&gt;说句题外话， C++ 里面还发明了 &lt;code class="code"&gt;
.*&lt;/code&gt;
 和 &lt;code class="code"&gt;
-&amp;gt;*&lt;/code&gt;
 这两个运算符（注意 &lt;code class="code"&gt;
-&amp;gt;*&lt;/code&gt;
 不是单独的 &lt;code class="code"&gt;
-&amp;gt;&lt;/code&gt;
 和 &lt;code class="code"&gt;
*&lt;/code&gt;
 并排放的意思），关于为什么要发明这两个运算符，而不能直接说 &lt;code class="code"&gt;
a -&amp;gt;* b&lt;/code&gt;
 的意思就是 &lt;code class="code"&gt;
a -&amp;gt;(*b)&lt;/code&gt;
 ，这个就作为课堂作业吧。&lt;/p&gt;
&lt;/div&gt;
</summary><category term="C"></category><category term="zhihu"></category></entry></feed>