<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Farseerfc的小窝 - tech</title><link href="//farseerfc.me/zhs/" rel="alternate"></link><link href="//farseerfc.me/feeds/tech.atom.xml" rel="self"></link><id>//farseerfc.me/zhs/</id><updated>2020-10-06T13:45:00+09:00</updated><entry><title>关于 swap 的一些补充</title><link href="//farseerfc.me/zhs/followup-about-swap.html" rel="alternate"></link><published>2020-10-06T13:45:00+09:00</published><updated>2020-10-06T13:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2020-10-06:/zhs/followup-about-swap.html</id><summary type="html">&lt;p&gt;上周翻译完 &lt;a class="reference external" href="//farseerfc.me/zhs/in-defence-of-swap.html"&gt;【译】替 swap 辩护：常见的误解&lt;/a&gt;
之后很多朋友们似乎还有些疑问和误解，于是写篇后续澄清一下。事先声明我不是内核开发者，
这里说的只是我的理解，
&lt;a class="reference external" href="https://www.kernel.org/doc/gorman/html/understand/understand005.html"&gt;基于内核文档中关于物理内存的描述&lt;/a&gt;
，新的内核代码的具体行为可能和我的理解有所出入，欢迎踊跃讨论。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="https://www.youtube.com/watch?v=7aONIVSXiJ8"&gt;Introduction to Memory Management in Linux&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/7aONIVSXiJ8"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;误解1: swap 是虚拟内存，虚拟内存肯定比物理内存慢嘛&lt;/h2&gt;
&lt;p&gt;这种误解进一步的结论通常是：「使用虚拟内存肯定会减慢系统运行时性能，如果物理内存足够为什么还要用虚拟的？」
这种误解是把虚拟内存和交换区的实现方式类比于「虚拟磁盘」或者「虚拟机」等同的方式，
也隐含「先用物理内存，用完了之后用虚拟内存」也即下面的「误解3」的理解。&lt;/p&gt;
&lt;p&gt;首先，交换区（swap） &lt;strong&gt;不是&lt;/strong&gt; 虚拟内存。操作系统中说「物理内存」还是「虚拟内存」的时候在指程序代码
寻址时使用的内存地址方式，使用物理地址空间时是在访问物理内存，使用虚拟地址空间时是在访问虚拟内存 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;上周翻译完 &lt;a class="reference external" href="//farseerfc.me/zhs/in-defence-of-swap.html"&gt;【译】替 swap 辩护：常见的误解&lt;/a&gt;
之后很多朋友们似乎还有些疑问和误解，于是写篇后续澄清一下。事先声明我不是内核开发者，
这里说的只是我的理解，
&lt;a class="reference external" href="https://www.kernel.org/doc/gorman/html/understand/understand005.html"&gt;基于内核文档中关于物理内存的描述&lt;/a&gt;
，新的内核代码的具体行为可能和我的理解有所出入，欢迎踊跃讨论。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="https://www.youtube.com/watch?v=7aONIVSXiJ8"&gt;Introduction to Memory Management in Linux&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/7aONIVSXiJ8"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;误解1: swap 是虚拟内存，虚拟内存肯定比物理内存慢嘛&lt;/h2&gt;
&lt;p&gt;这种误解进一步的结论通常是：「使用虚拟内存肯定会减慢系统运行时性能，如果物理内存足够为什么还要用虚拟的？」
这种误解是把虚拟内存和交换区的实现方式类比于「虚拟磁盘」或者「虚拟机」等同的方式，
也隐含「先用物理内存，用完了之后用虚拟内存」也即下面的「误解3」的理解。&lt;/p&gt;
&lt;p&gt;首先，交换区（swap） &lt;strong&gt;不是&lt;/strong&gt; 虚拟内存。操作系统中说「物理内存」还是「虚拟内存」的时候在指程序代码
寻址时使用的内存地址方式，使用物理地址空间时是在访问物理内存，使用虚拟地址空间时是在访问虚拟内存。
现代操作系统在大部分情况下都在使用虚拟地址空间寻址， &lt;strong&gt;包括&lt;/strong&gt; 在执行内核代码的时候。&lt;/p&gt;
&lt;p&gt;并且，交换区 &lt;strong&gt;不是&lt;/strong&gt; 实现虚拟内存的方式。操作系统使用内存管理单元（MMU，Memory Management
Unit）做虚拟内存地址到物理内存地址的地址翻译，现代架构下 MMU 通常是 CPU
的一部分，配有它专用的一小块存储区叫做地址转换旁路缓存（TLB，Translation Lookaside Buffer），
只有在 TLB 中没有相关地址翻译信息的时候 MMU 才会以缺页中断的形式调用操作系统内核帮忙。
除了 TLB 信息不足的时候，大部分情况下使用虚拟内存都是硬件直接实现的地址翻译，没有软件模拟开销。
实现虚拟内存不需要用到交换区，交换区只是操作系统实现虚拟内存后能提供的一个附加功能，
即便没有交换区，操作系统大部分时候也在用虚拟内存，包括在大部分内核代码中。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;误解2: 但是没有交换区的话，虚拟内存地址都有物理内存对应嘛&lt;/h2&gt;
&lt;p&gt;很多朋友也理解上述操作系统实现虚拟内存的方式，但是仍然会有疑问：「我知道虚拟内存和交换区的区别，
但是没有交换区的话，虚拟内存地址都有物理内存对应，不用交换区的话就不会遇到读虚拟内存需要读写磁盘
导致的卡顿了嘛」。&lt;/p&gt;
&lt;p&gt;这种理解也是错的，禁用交换区的时候，也会有一部分分配给程序的虚拟内存不对应物理内存，
比如使用 &lt;code class="code"&gt;
mmap&lt;/code&gt;
 调用实现内存映射文件的时候。实际上即便是使用 &lt;code class="code"&gt;
read/​write&lt;/code&gt;

读写文件， Linux 内核中（可能现代操作系统内核都）在底下是用和 &lt;code class="code"&gt;
mmap&lt;/code&gt;
 相同的机制建立文件
到虚拟地址空间的地址映射，然后实际读写到虚拟地址时靠缺页中断把文件内容载入页面缓存（page cache
）。内核加载可执行程序和动态链接库的方式也是通过内存映射文件。甚至可以进一步说，
用户空间的虚拟内存地址范围内，除了匿名页之外，其它虚拟地址都是文件后备（backed by file
），而匿名页通过交换区作为文件后备。上篇文章中提到的别的类型的内存，比如共享内存页面（shm
）是被一个内存中的虚拟文件系统后备的，这一点有些套娃先暂且不提。于是事实是无论有没有交换区，
缺页的时候总会有磁盘读写从慢速存储加载到物理内存，这进一步引出上篇文章中对于交换区和页面缓存这两者的讨论。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;误解3： 不是内存快用完的时候才会交换的么？&lt;/h2&gt;
&lt;p&gt;简短的答案可以说「是」，但是内核理解的「内存快用完」和你理解的很可能不同。
也可以说「不是」，就算按照内核理解的「内存快用完」的定义，内存快用完的时候内核的行为是去回收内存，
至于回收内存的时候内核会做什么有个复杂的启发式经验算法，实际上真的内存快满的时候根本来不及做
swap ，内核可能会尝试丢弃 page cache 甚至丢弃 vfs cache (dentry cache / inode cache)
这些不需要磁盘I/O就能更快获取可用内存的动作。&lt;/p&gt;
&lt;p&gt;深究这些内核机制之前，我在思考为什么很多朋友会问出这样的问题。可能大部分这么问的人，学过编程，
稍微学过基本的操作系统原理，在脑海里对内核分配页面留着这样一种印象（C伪代码）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;////////////////////  userspace space  ////////////////&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pages&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mmap&lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt;                                    &lt;span class="c1"&gt;// 从内核分配内存页&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;alloc_from_page&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                        &lt;span class="c1"&gt;// 从拿到的内存页细分&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="c1"&gt;////////////////////  kernel space  //////////////////&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;SYSCALL&lt;/span&gt; &lt;span class="n"&gt;do_mmap&lt;/span&gt;&lt;span class="p"&gt;(...){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;   &lt;span class="c1"&gt;//...&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;   &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;kmalloc_pages&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nr_page&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;kmalloc_pages&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;available_mem&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="c1"&gt;// 可用内存不够了！尝试搞点内存&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;page_frame_info&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;least_accessed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lru_pop_page_frame&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;     &lt;span class="c1"&gt;// 找出最少访问的页面&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;least_accessed&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pf_type&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;PAGE_CACHE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;drop_page_cache&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;least_accessed&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 丢弃文件缓存&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;SWAP&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="n"&gt;swap_out&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;least_accessed&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// &amp;lt;- 写磁盘，所以系统卡了！&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="c1"&gt;// ... 别的方式回收 least_accessed&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;append_free_page&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;free_page_list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;least_accessed&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;           &lt;span class="c1"&gt;// 回收到的页面加入可用列表&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;available_mem&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;least_accessed&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="c1"&gt;// 搞到内存了！返回给程序&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;available_mem&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;phy_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;take_from_free_list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;free_page_list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;assign_virtual_addr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phy_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种逻辑隐含三层 &lt;strong&gt;错误的&lt;/strong&gt; 假设：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;分配物理内存是发生在从内核分配内存的时候的，比如 &lt;code class="code"&gt;
malloc/​mmap&lt;/code&gt;
 的时候。&lt;/li&gt;
&lt;li&gt;内存回收是发生在进程请求内存分配的上下文里的，换句话说进程在等内核的内存回收返回内存，
不回收到内存，进程就得不到内存。&lt;/li&gt;
&lt;li&gt;交换出内存到 swap 是发生在内存回收的时候的，会阻塞内核的内存回收，进而阻塞程序的内存分配。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种把内核代码当作「具有特权的库函数调用」的看法，可能很易于理解，
甚至早期可能的确有操作系统的内核是这么实现的，但是很可惜现代操作系统都不是这么做的。
上面三层假设的错误之处在于：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;在程序请求内存的时候，比如 &lt;code class="code"&gt;
malloc/​mmap&lt;/code&gt;
 的时候，内核只做虚拟地址分配，
记录下某段虚拟地址空间对这个程序是可以合法访问的，但是不实际分配物理内存给程序。
在程序第一次访问到虚拟地址的时候，才会实际分配物理内存。这种叫 &lt;strong&gt;惰性分配（lazy allocation）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;在内核感受到内存分配压力之后，早在内核内存用尽之前，内核就会在后台慢慢扫描并回收内存页。
内存回收通常不发生在内存分配的时候，除非在内存非常短缺的情况下，后台内存回收来不及满足当前分配请求，
才会发生 &lt;strong&gt;直接回收(direct reclamation)&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;同样除了直接回收的情况，大部分正常情况下换出页面是内存管理子系统调用 DMA 在后台慢慢做的，
交换页面出去不会阻塞内核的内存回收，更不会阻塞程序做内存分配（malloc
）和使用内存(实际访问惰性分配的内存页)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是说，现代操作系统内核是高度并行化的设计，内存分配方方面面需要消耗计算资源或者 I/O
带宽的场景，都会尽量并行化，最大程度利用好计算机所有组件（CPU/MMU/DMA/IO）的吞吐率，
不到紧要关头需要直接回收的场合，就不会阻塞程序的正常执行流程。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;惰性分配有什么好处？&lt;/h2&gt;
&lt;p&gt;或许会有人问：「我让你分配内存，你给我分配了个虚拟的，到用的时候还要做很多事情才能给我，这不是骗人嘛」，
或者会有人担心惰性分配会对性能造成负面影响。&lt;/p&gt;
&lt;p&gt;这里实际情况是程序从分配虚拟内存的时候，「到用的时候」，这之间有段时间间隔，可以留给内核做准备
。程序可能一下子分配一大片内存地址，然后再在执行过程中解析数据慢慢往地址范围内写东西。
程序分配虚拟内存的速率可以是「突发」的，比如一个系统调用中分配 1GiB 大小，而实际写入数据的速率会被
CPU 执行速度等因素限制，不会短期内突然写入很多页面。
这个分配速率导致的时间差内内核可以完成很多后台工作，比如回收内存，
比如把回收到的别的进程用过的内存页面初始化为全0，这部分后台工作可以和程序的执行过程并行，
从而当程序实际用到内存的时候，需要的准备工作已经做完了，大部分场景下可以直接分配物理内存出来。&lt;/p&gt;
&lt;p&gt;如果程序要做实时响应，想避免因为惰性分配造成的性能不稳定，可以使用 &lt;code class="code"&gt;
mlock/​mlockall&lt;/code&gt;

将得到的虚拟内存锁定在物理内存中，锁的过程中内核会做物理内存分配。不过要区分「性能不稳定」和「低性能」，
预先分配内存可以避免实际使用内存时分配物理页面的额外开销，但是会拖慢整体吞吐率，所以要谨慎使用。&lt;/p&gt;
&lt;p&gt;很多程序分配了很大一片地址空间，但是实际并不会用完这些地址，直到程序执行结束这些虚拟地址也一直
处于没有对应物理地址的情况。惰性分配可以避免为这些情况浪费物理内存页面，使得很多程序可以无忧无虑地
随意分配内存地址而不用担心性能损失。这种分配方式也叫「超额分配（overcommit）」。飞机票有超售，
VPS 提供商划分虚拟机有超售，操作系统管理内存也同样有这种现象，合理使用超额分配能改善整体系统效率。&lt;/p&gt;
&lt;p&gt;内核要高效地做到惰性分配而不影响程序执行效率的前提之一，在于程序真的用到内存的时候，
内核能不做太多操作就立刻分配出来，也就是说内核需要时时刻刻在手上留有一部分空页，
满足程序执行时内存分配的需要。换句话说，内核需要早在物理内存用尽之前，就开始回收内存。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;那么内核什么时候会开始回收内存？&lt;/h2&gt;
&lt;p&gt;首先一些背景知识：物理内存地址空间并不是都平等，因为一些地址范围可以做
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Direct_memory_access"&gt;DMA&lt;/a&gt; 而另一些不能，以及
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Non-uniform_memory_access"&gt;NUMA&lt;/a&gt;
等硬件环境倾向于让 CPU 访问其所在 NUMA 节点内存范围。在 32bit
系统上内核的虚拟地址空间还有低端内存和高端内存的区分，他们会倾向于使用不同属性的物理内存，到
64bit 系统上已经没有了这种限制。&lt;/p&gt;
&lt;p&gt;硬件限制了内存分配的自由度，于是内核把物理内存空间分成多个 Zone
，每个 Zone 内各自管理可用内存， Zone 内的内存页之间是相互平等的。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
zone 内水位线&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/c995609e.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;一个 Zone 内的页面分配情况可以右图描绘。
除了已用内存页，剩下的就是空闲页（free pages），空闲页范围中有三个水位线（watermark
）评估当前内存压力情况，分别是高位（high）、低位（low）、最小位（min）。&lt;/p&gt;
&lt;p&gt;当内存分配使得空闲页水位低于低位线，内核会唤醒 &lt;code class="code"&gt;
kswapd&lt;/code&gt;
 后台线程， &lt;code class="code"&gt;
kswapd&lt;/code&gt;

负责扫描物理页面的使用情况并挑选一部分页面做回收，直到可用页面数量恢复到水位线高位（high）以上。
如果 &lt;code class="code"&gt;
kswapd&lt;/code&gt;
 回收内存的速度慢于程序执行实际分配内存的速度，
可用空闲页数量可能进一步下降，降至低于最小水位（min）之后，内核会让内存分配进入
&lt;strong&gt;直接回收(direct reclamation)&lt;/strong&gt; 模式，在直接回收模式下，程序分配某个物理页的请求（
第一次访问某个已分配虚拟页面的时候）会导致在进程上下文中阻塞式地调用内存回收代码。&lt;/p&gt;
&lt;p&gt;除了内核在后台回收内存，进程也可以主动释放内存，比如有程序退出的时候就会释放一大片内存页，
所以可用页面数量可能会升至水位线高位以上。有太多可用页面浪费资源对整体系统运行效率也不是好事，
所以系统会积极缓存文件读写，所有 page cache 都留在内存中，直到可用页面降至低水位以下触发
&lt;code class="code"&gt;
kswapd&lt;/code&gt;
 开始工作。&lt;/p&gt;
&lt;p&gt;设置最小水位线（min）的原因在于，内核中有些硬件也会突然请求大量内存，比如来自网卡接收到的数据包，
预留出最小水位线以下的内存给内核内部和硬件使用。&lt;/p&gt;
&lt;p&gt;设置高低两个控制 &lt;code class="code"&gt;
kswapd&lt;/code&gt;
 开关的水位线是基于控制理论。唤醒 &lt;code class="code"&gt;
kswapd&lt;/code&gt;

扫描内存页面本身有一定计算开销，于是每次唤醒它干活的话就让它多做一些活（ high - low
），避免频繁多次唤醒。&lt;/p&gt;
&lt;p&gt;因为有这些水位线，系统中根据程序请求内存的「速率」，整个系统的内存分配在宏观的一段时间内可能处于以下几种状态：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;strong&gt;不回收：&lt;/strong&gt; 系统中的程序申请内存速度很慢，或者程序主动释放内存的速度很快，
（比如程序执行时间很短，不怎么进行文件读写就马上退出，）此时可用页面数量可能一直处于低水位线以上，
内核不会主动回收内存，所有文件读写都会以页面缓存的形式留在物理内存中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后台回收：&lt;/strong&gt; 系统中的程序在缓慢申请内存，比如做文件读写，
比如分配并使用匿名页面。系统会时不时地唤醒 &lt;code class="code"&gt;
kswapd&lt;/code&gt;
 在后台做内存回收，
不会干扰到程序的执行效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直接回收：&lt;/strong&gt; 如果程序申请内存的速度快于 &lt;code class="code"&gt;
kswapd&lt;/code&gt;
 后台回收内存的速度，
空闲内存最终会跌破最小水位线，随后的内存申请会进入直接回收的代码路径，从而极大限制内存分配速度。
在直接分配和后台回收的同时作用下，空闲内存可能会时不时回到最小水位线以上，
但是如果程序继续申请内存，空闲内存量就会在最小水位线附近上下徘徊。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;杀进程回收：&lt;/strong&gt; 甚至直接分配和后台回收的同时作用也不足以拖慢程序分配内存的速度的时候，
最终空闲内存会完全用完，此时触发 OOM 杀手干活杀进程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;系统状态处于 &lt;strong&gt;1. 不回收&lt;/strong&gt;  的时候表明分配给系统的内存量过多，比如系统刚刚启动之类的时候。
理想上应该让系统长期处于 &lt;strong&gt;2. 后台回收&lt;/strong&gt; 的状态，此时最大化利用缓存的效率而又不会因为内存回收
减缓程序执行速度。如果系统引导后长期处于 &lt;strong&gt;1. 不回收&lt;/strong&gt; 的状态下，那么说明没有充分利用空闲内存做
文件缓存，有些 unix 服务比如 &lt;a class="reference external" href="https://wiki.archlinux.org/index.php/preload"&gt;preload&lt;/a&gt; 可用来提前填充文件缓存。&lt;/p&gt;
&lt;p&gt;如果系统频繁进入 &lt;strong&gt;3. 直接回收&lt;/strong&gt; 的状态，表明在这种工作负载下系统需要减慢一些内存分配速度，
让 &lt;code class="code"&gt;
kswapd&lt;/code&gt;
 有足够时间回收内存。就如前一篇翻译中 Chris
所述，频繁进入这种状态也不一定代表「内存不足」，可能表示内存分配处于非常高效的利用状态下，
系统充分利用慢速的磁盘带宽，为快速的内存缓存提供足够的可用空间。
&lt;strong&gt;直接回收&lt;/strong&gt; 是否对进程负载有负面影响要看具体负载的特性。
此时选择禁用 swap 并不能降低磁盘I/O，反而可能缩短 &lt;strong&gt;2. 后台回收&lt;/strong&gt; 状态能持续的时间，
导致更快进入 &lt;strong&gt;4. 杀进程回收&lt;/strong&gt; 的极端状态。&lt;/p&gt;
&lt;p&gt;当然如果系统长期处于 &lt;strong&gt;直接回收&lt;/strong&gt; 的状态的话，则说明内存总量不足，需要考虑增加物理内存，
或者减少系统负载了。如果系统进入 &lt;strong&gt;4. 杀进程回收&lt;/strong&gt; 的状态，不光用空间的进程会受影响，
并且还可能导致内核态的内存分配受影响，产生网络丢包之类的结果。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2&gt;微调内存管理水位线&lt;/h2&gt;
&lt;p&gt;可以看一下运行中的系统中每个 Zone 的水位线在哪儿。比如我手上这个 16GiB 的系统中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;$ cat /proc/zoneinfo&lt;/span&gt;
&lt;span class="code-line"&gt;Node &lt;span class="m"&gt;0&lt;/span&gt;, zone      DMA&lt;/span&gt;
&lt;span class="code-line"&gt;   pages free     &lt;span class="m"&gt;3459&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         min      &lt;span class="m"&gt;16&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         low      &lt;span class="m"&gt;20&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         high     &lt;span class="m"&gt;24&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         spanned  &lt;span class="m"&gt;4095&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         present  &lt;span class="m"&gt;3997&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         managed  &lt;span class="m"&gt;3975&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;Node &lt;span class="m"&gt;0&lt;/span&gt;, zone    DMA32&lt;/span&gt;
&lt;span class="code-line"&gt;   pages free     &lt;span class="m"&gt;225265&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         min      &lt;span class="m"&gt;3140&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         low      &lt;span class="m"&gt;3925&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         high     &lt;span class="m"&gt;4710&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         spanned  &lt;span class="m"&gt;1044480&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         present  &lt;span class="m"&gt;780044&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         managed  &lt;span class="m"&gt;763629&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;Node &lt;span class="m"&gt;0&lt;/span&gt;, zone   Normal&lt;/span&gt;
&lt;span class="code-line"&gt;   pages free     &lt;span class="m"&gt;300413&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         min      &lt;span class="m"&gt;13739&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         low      &lt;span class="m"&gt;17173&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         high     &lt;span class="m"&gt;20607&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         spanned  &lt;span class="m"&gt;3407872&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         present  &lt;span class="m"&gt;3407872&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         managed  &lt;span class="m"&gt;3328410&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为不是 NUMA 系统，所以只有一个 NUMA node，其中根据 DMA 类型共有 3 个 Zone 分别叫 DMA,
DMA32, Normal 。三个 Zone 的物理地址范围（spanned）加起来大概有
&lt;span class="math"&gt;\(4095+1044480+3407872\)&lt;/span&gt; 大约 17GiB 的地址空间，而实际可访问的地址范围（present
）加起来有 &lt;span class="math"&gt;\(3997+780044+3407872\)&lt;/span&gt; 大约 16GiB 的可访问物理内存。&lt;/p&gt;
&lt;p&gt;其中空闲页面有 &lt;span class="math"&gt;\(3459+762569+1460218\)&lt;/span&gt; 大约 8.5GiB ，三条水位线分别在：
&lt;span class="math"&gt;\(\texttt{high} = 24+4710+20607 = 98\texttt{MiB}\)&lt;/span&gt; ，
&lt;span class="math"&gt;\(\texttt{low} = 20+3925+17173 = 82\texttt{MiB}\)&lt;/span&gt; ，
&lt;span class="math"&gt;\(\texttt{min} = 16+3140+13739 = 65\texttt{MiB}\)&lt;/span&gt; 的位置。&lt;/p&gt;
&lt;p&gt;具体这些水位线的确定方式基于几个 sysctl 。首先 min 基于 &lt;code class="code"&gt;
vm.min_free_kbytes&lt;/code&gt;

默认是基于内核低端内存量的平方根算的值，并限制到最大 64MiB 再加点余量，比如我这台机器上
&lt;code class="code"&gt;
vm.min_free_kbytes = 67584&lt;/code&gt;
 ，于是 min 水位线在这个位置。
其它两个水位线基于这个计算，在 min 基础上增加总内存量的 &lt;code class="code"&gt;
vm.watermark_scale_factor /​ 10000&lt;/code&gt;

比例（在小内存的系统上还有额外考虑），默认 &lt;code class="code"&gt;
vm.watermark_scale_factor = 10&lt;/code&gt;

在大内存系统上意味着 low 比 min 高 0.1% ， high 比 low 高 0.1% 。&lt;/p&gt;
&lt;p&gt;可以手动设置这些值，以更早触发内存回收，比如将 &lt;code class="code"&gt;
vm.watermark_scale_factor&lt;/code&gt;
 设为 100:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sudo tee /proc/sys/vm/watermark_scale_factor&lt;/span&gt;
&lt;span class="code-line"&gt;$ cat /proc/zoneinfo&lt;/span&gt;
&lt;span class="code-line"&gt;Node &lt;span class="m"&gt;0&lt;/span&gt;, zone      DMA&lt;/span&gt;
&lt;span class="code-line"&gt;   pages free     &lt;span class="m"&gt;3459&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         min      &lt;span class="m"&gt;16&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         low      &lt;span class="m"&gt;55&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         high     &lt;span class="m"&gt;94&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         spanned  &lt;span class="m"&gt;4095&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         present  &lt;span class="m"&gt;3997&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         managed  &lt;span class="m"&gt;3975&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;   Node &lt;span class="m"&gt;0&lt;/span&gt;, zone    DMA32&lt;/span&gt;
&lt;span class="code-line"&gt;   pages free     &lt;span class="m"&gt;101987&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         min      &lt;span class="m"&gt;3149&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         low      &lt;span class="m"&gt;10785&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         high     &lt;span class="m"&gt;18421&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         spanned  &lt;span class="m"&gt;1044480&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         present  &lt;span class="m"&gt;780044&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         managed  &lt;span class="m"&gt;763629&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;   Node &lt;span class="m"&gt;0&lt;/span&gt;, zone   Normal&lt;/span&gt;
&lt;span class="code-line"&gt;   pages free     &lt;span class="m"&gt;61987&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         min      &lt;span class="m"&gt;13729&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         low      &lt;span class="m"&gt;47013&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         high     &lt;span class="m"&gt;80297&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         spanned  &lt;span class="m"&gt;3407872&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         present  &lt;span class="m"&gt;3407872&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;         managed  &lt;span class="m"&gt;3328410&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到的三条水位线分别在 &lt;span class="math"&gt;\(\texttt{min} = 16+3149+13729 = 66\texttt{MiB}\)&lt;/span&gt;
， &lt;span class="math"&gt;\(\texttt{low} = 55+10785+47013 = 226\texttt{MiB}\)&lt;/span&gt;
， &lt;span class="math"&gt;\(\texttt{high} = 94+18421+80297 = 386\texttt{MiB}\)&lt;/span&gt; ，
从而 low 和 high 分别比 min 提高 160MiB 也就是内存总量的 1% 左右。&lt;/p&gt;
&lt;p&gt;在 swap 放在 HDD 的系统中，因为换页出去的速度较慢，除了上篇文章说的降低
&lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 之外，还可以适当提高 &lt;code class="code"&gt;
vm.watermark_scale_factor&lt;/code&gt;

让内核更早开始回收内存，这虽然会稍微降低缓存命中率，但是另一方面可以在进入直接回收模式之前
有更多时间做后台换页，也将有助于改善系统整体流畅度。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h2&gt;只有 0.1% ，这不就是说内存快用完的时候么？&lt;/h2&gt;
&lt;p&gt;所以之前的「误解3」我说答案可以说「是」或者「不是」，但是无论回答是或不是，都代表了认为「swap
就是额外的慢速内存」的错误看法。当有人在强调「swap 是内存快用完的时候才交换」的时候，
隐含地，是在把系统总体的内存分配看作是一个静态的划分过程：打个比方这就像在说，我的系统里存储空间有快速
128GiB SSD 和慢速 HDD 的 1TiB ，同样内存有快速的 16GiB RAM 和慢速 16GiB 的 swap 。
这种静态划分的类比是错误的看待方式，因为系统回收内存进而做页面交换的方式是动态平衡的过程，
需要考虑到「时间」和「速率」而非单纯看「容量」。&lt;/p&gt;
&lt;p&gt;假设 swap 所在的存储设备可以支持 5MiB/s 的吞吐率（ HDD 上可能更慢， SSD
上可能更快，这里需要关注数量级），相比之下 DDR3 大概有 10GiB/s 的吞吐率，DDR4 大概有 20GiB/s
，无论多快的 SSD 也远达不到这样的吞吐（可能 Intel Optane 这样的
&lt;a class="reference external" href="https://lwn.net/Articles/717953/"&gt;DAX&lt;/a&gt; 设备会改变这里的状况）。从而把 swap
当作慢速内存的视角来看的话，加权平均的速率是非常悲观的，「 16G 的 DDR3 + 16G 的 swap 会有
&lt;span class="math"&gt;\(\frac{16 \times 10 \times 1024 + 16 \times 5}{16+16} = 5 \texttt{GiB/s}\)&lt;/span&gt;
的吞吐？所以开 swap 导致系统速度降了一半？」显然不能这样看待。&lt;/p&gt;
&lt;p&gt;动态的看待方式是， swap 设备能提供 5MiB/s 的吞吐，这意味着：如果我们能把未来 10
分钟内不会访问到的页面换出到 swap ，那么就相当于有
&lt;span class="math"&gt;\(10 \times 60 \texttt{s} \times 5 \texttt{MiB/s} = 3000 \texttt{MiB}\)&lt;/span&gt;
的额外内存，用来放那 10 分钟内可能会访问到的页面缓存。
10 分钟只是随口说的一段时间，可以换成 10 秒或者 10 小时，重要的是只要页面交换发生在后台，
不阻塞前台程序的执行，那么 swap 设备提供的额外吞吐率相当于一段时间内提供了更大的物理内存，
总是能提升页面缓存的命中，从而改善系统性能。&lt;/p&gt;
&lt;p&gt;当然系统内核不能预知「未来 10 分钟内需要的页面」，只能根据历史上访问内存的情况预估之后可能会访问的情况，
估算不准的情况下，比如最近10分钟内用过的页面缓存在之后10分钟内不再被使用的时候，
为了把最近这10分钟内访问过的页面留在物理内存中，可能会把之后10分钟内要用到的匿名页面换出到了交换设备上。
于是会有下面的情况：&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="swap-swap"&gt;
&lt;h2&gt;但是我开了 swap 之后，一旦复制大文件，系统就变卡，不开 swap 不会这样的&lt;/h2&gt;
&lt;p&gt;大概电脑用户都经历过这种现象，不限于 Linux 用户，包括 macOS 和 Windows 上也是。
在文件管理器中复制了几个大文件之后，切换到别的程序系统就极其卡顿，复制已经结束之后的一段时间也会如此。
复制的过程中系统交换区的使用率在上涨，复制结束后下降，显然 swap 在其中有重要因素，并且禁用
swap 或者调低 swappiness 之后就不会这样了。于是网上大量流传着解释这一现象，并进一步建议禁用
swap 或者调低 swappiness 的文章。我相信不少关心系统性能调优的人看过这篇「
&lt;a class="reference external" href="https://rudd-o.com/linux-and-free-software/tales-from-responsivenessland-why-linux-feels-slow-and-how-to-fix-that"&gt;Tales from responsivenessland: why Linux feels slow, and how to fix that&lt;/a&gt;
」或是它的转载、翻译，用中文搜索的话还能找到更多错误解释 swappiness 目的的文章，比如
&lt;a class="reference external" href="http://blog.itpub.net/29371470/viewspace-1250975"&gt;这篇将 swappiness 解释成是控制内存和交换区比例的参数&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;除去那些有技术上谬误的文章，这些网文中描述的现象是有道理的，不单纯是以讹传讹。
桌面环境中内存分配策略的不确定性和服务器环境中很不一样，复制、下载、解压大文件等导致一段时间内
大量占用页面缓存，以至于把操作结束后需要的页面撵出物理内存，无论是交换出去的方式还是以丢弃页面缓存的方式，
都会导致桌面响应性降低。&lt;/p&gt;
&lt;p&gt;不过就像前文 Chris 所述，这种现象其实并不能通过禁止 swap 的方式缓解：禁止 swap 或者调整
swappiness 让系统尽量避免 swap 只影响回收匿名页面的策略，不影响系统回收页面的时机，
也不能避免系统丢弃将要使用的页面缓存而导致的卡顿。&lt;/p&gt;
&lt;p&gt;以前在 Linux 上也没有什么好方法能避免这种现象。 macOS 转用 APFS 作为默认文件系统之后，
从文件管理器（Finder）复制文件默认启用 file clone 快速完成，这操作不实际复制文件数据，
一个隐含优势在不需要读入文件内容，从而不会导致大量页面缓存失效。 Linux 上同样可以用支持
reflink 的文件系统比如 btrfs 或者开了 reflink=1 的 xfs 达到类似的效果。
不过 reflink 也只能拯救复制文件的情况，不能改善解压文件、下载文件、计算文件校验等情况下，
一次性处理大文件对内存产生的压力。&lt;/p&gt;
&lt;p&gt;好在最近几年 Linux 有了 cgroup ，允许更细粒度地调整系统资源分配。进一步现在我们有了 cgroup
v2 ，前面 Chris 的文章也有提到 cgroup v2 的 &lt;code class="code"&gt;
memory.low&lt;/code&gt;
 可以某种程度上建议内存子系统
尽量避免回收某些 cgroup 进程的内存。&lt;/p&gt;
&lt;p&gt;于是有了 cgroup 之后，另一种思路是把复制文件等大量使用内存而之后又不需要保留页面缓存的程序单独放入
cgroup 内限制它的内存用量，用一点点复制文件时的性能损失换来整体系统的响应流畅度。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
关于 cgroup v1 和 v2&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;p&gt;稍微跑题说一下 cgroup v2 相对于 v1 带来的优势。这方面优势在
&lt;a class="reference external" href="https://www.youtube.com/watch?v=ikZ8_mRotT4"&gt;Chris Down 另一个关于 cgroup v2 演讲&lt;/a&gt;
中有提到。老 cgroup v1 按控制器区分 cgroup 层级，从而内存控制器所限制的东西和 IO
控制器所限制的东西是独立的。在内核角度来看，页面写回（page writeback）和交换（swap）正是
夹在内存控制器和IO控制器管理的边界上，从而用 v1 的 cgroup 难以同时管理。 v2
通过统一控制器层级解决了这方面限制。具体见下面 Chris Down 的演讲。&lt;/p&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/ikZ8_mRotT4"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="cgroup-v2"&gt;
&lt;h2&gt;用 cgroup v2 限制进程的内存分配&lt;/h2&gt;
&lt;p&gt;实际上有了 cgroup v2 之后，还有更多控制内存分配的方案。 &lt;a class="reference external" href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html#memory"&gt;cgroup v2 的内存控制器&lt;/a&gt;
可以对某个 cgroup 设置这些阈值：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;memory.min&lt;/strong&gt; : 最小内存限制。内存用量低于此值后系统不会回收内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;memory.low&lt;/strong&gt; : 低内存水位。内存用量低于此值后系统会尽量避免回收内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;memory.high&lt;/strong&gt; : 高内存水位。内存用量高于此值后系统会积极回收内存，并且会对内存分配节流（throttle）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;memory.max&lt;/strong&gt; : 最大内存限制。内存用量高于此值后系统会对内存分配请求返回 ENOMEM，或者在 cgroup 内触发 OOM 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见这些设定值可以当作 per-cgroup 的内存分配水位线，作用于某一部分进程而非整个系统。
针对交换区使用情况也可设置这些阈值：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;memory.swap.high&lt;/strong&gt; : 高交换区水位，交换区用量高于此值后会对交换区分配节流。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;memory.swap.max&lt;/strong&gt; : 最大交换区限制，交换区用量高于此值后不再会发生匿名页交换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到达这些 cgroup 设定阈值的时候，还可以设置内核回调的处理程序，从用户空间做一些程序相关的操作。&lt;/p&gt;
&lt;p&gt;Linux 有了 cgroup v2 之后，就可以通过对某些程序设置内存用量限制，避免他们产生的页面请求把别的
程序所需的页面挤出物理内存。使用 systemd 的系统中，首先需要
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Cgroups#Switching_to_cgroups_v2"&gt;启用 cgroup v2&lt;/a&gt;
，在内核引导参数中加上 &lt;code class="code"&gt;
systemd.unified_cgroup_hierarchy=1&lt;/code&gt;

。然后开启用户权限代理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# systemctl edit user@1000.service&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;[&lt;/span&gt;Service&lt;span class="o"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nv"&gt;Delegate&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;yes&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后可以定义用户会话的 slice （slice 是 systemd 术语，用来映射 cgroup ），比如创建一个叫
&lt;code class="code"&gt;
limit-mem&lt;/code&gt;
 的 slice ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;$ cat ~/.config/systemd/user/limit-mem.slice&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;[&lt;/span&gt;Slice&lt;span class="o"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nv"&gt;MemoryHigh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;3G&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nv"&gt;MemoryMax&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;4G&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nv"&gt;MemorySwapMax&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;2G&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后可以用 systemd-run 限制在某个 slice 中打开一个 shell：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;$ systemd-run --user --slice&lt;span class="o"&gt;=&lt;/span&gt;limit-mem.slice --shell&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者定义一个 shell alias 用来限制任意命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;type&lt;/span&gt; limit-mem&lt;/span&gt;
&lt;span class="code-line"&gt;limit-mem is an &lt;span class="nb"&gt;alias&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; /usr/bin/time systemd-run --user --pty --same-dir --wait --collect --slice&lt;span class="o"&gt;=&lt;/span&gt;limit-mem.slice&lt;/span&gt;
&lt;span class="code-line"&gt;$ limit-mem cp some-large-file dest/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际用法有很多，可以参考 systemd 文档
&lt;a class="reference external" href="http://www.jinbuguo.com/systemd/systemd.resource-control.html"&gt;man systemd.resource-control&lt;/a&gt;
， &lt;a class="reference external" href="/links.html#xuanwo"&gt;xuanwo&lt;/a&gt; 也 &lt;a class="reference external" href="https://xuanwo.io/2018/10/30/tips-of-systemd/"&gt;有篇博客介绍过 systemd 下资源限制&lt;/a&gt;
， &lt;a class="reference external" href="/links.html#lilydjwg"&gt;lilydjwg&lt;/a&gt; 也 &lt;a class="reference external" href="https://blog.lilydjwg.me/2019/3/2/use-cgroups-to-limit-memory-usage-for-specific-processes.214196.html"&gt;写过用 cgroup 限制进程内存的用法&lt;/a&gt;
和 &lt;a class="reference external" href="https://blog.lilydjwg.me/2020/5/11/priority-and-nice-value-in-linux.215304.html"&gt;用 cgroup 之后对 CPU 调度的影响&lt;/a&gt;
。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h2&gt;未来展望&lt;/h2&gt;
&lt;p&gt;最近新版的 gnome 和 KDE 已经开始为桌面环境下用户程序的进程创建 systemd scope 了，
可以通过 &lt;code class="code"&gt;
systemd-cgls&lt;/code&gt;
 观察到，每个通过桌面文件（.desktop）开启的用户空间程序
都有个独立的名字叫 &lt;code class="code"&gt;
app-APPNAME-HASH.scope&lt;/code&gt;
 之类的 systemd scope 。
有了这些 scope 之后，事实上用户程序的资源分配某种程度上已经相互独立，
不过默认的用户程序没有施加多少限制。&lt;/p&gt;
&lt;p&gt;今后可以展望，桌面环境可以提供用户友好的方式对这些桌面程序施加公平性的限制。
不光是内存分配的大小限制，包括 CPU 和 IO 占用方面也会更公平。
值得一提的是传统的 ext4/xfs/f2fs 之类的文件系统虽然支持
&lt;a class="reference external" href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html#writeback"&gt;cgroup writeback 节流&lt;/a&gt;
但是因为他们有额外的 journaling 写入，难以单独针对某些 cgroup 限制 IO
写入带宽（对文件系统元数据的写入难以统计到具体某组进程）。
而 btrfs 通过 CoW 避免了 journaling ，
&lt;a class="reference external" href="https://facebookmicrosites.github.io/btrfs/docs/btrfs-facebook.html#io-control-with-cgroup2"&gt;在这方面有更好的支持&lt;/a&gt;
。相信不远的将来，复制大文件之类常见普通操作不再需要手动调用加以限制，
就能避免单个程序占用太多资源影响别的程序。&lt;/p&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="tech"></category><category term="swap"></category><category term="mm"></category><category term="memory management"></category><category term="swappiness"></category><category term="kswapd"></category><category term="watermark"></category><category term="watermark_scale_factor"></category><category term="cgroup v2"></category></entry><entry><title>【译】替 swap 辩护：常见的误解</title><link href="//farseerfc.me/zhs/in-defence-of-swap.html" rel="alternate"></link><published>2020-09-30T13:45:00+09:00</published><updated>2020-09-30T13:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2020-09-30:/zhs/in-defence-of-swap.html</id><summary type="html">&lt;p&gt;这篇翻译自 Chris Down 的博文
&lt;a class="reference external" href="https://chrisdown.name/2018/01/02/in-defence-of-swap.html"&gt;In defence of swap: common misconceptions&lt;/a&gt;
。 &lt;a class="reference external" href="https://github.com/cdown/chrisdown.name/blob/master/LICENSE"&gt;原文的协议&lt;/a&gt;
是 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/4.0/"&gt;CC BY-SA 4.0&lt;/a&gt;
，本文翻译同样也使用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/4.0/"&gt;CC BY-SA 4.0&lt;/a&gt; 。其中加入了一些我自己的理解作为旁注，所有译注都在侧边栏中。&lt;/p&gt;
&lt;p&gt;翻译这篇文章是因为经常看到朋友们（包括有经验的程序员和 Linux 管理员）对 swap 和 swappiness
有诸多误解，而这篇文章正好澄清了这些误解，也讲清楚了 Linux 中这两者的本质。值得一提的是本文讨论的
swap 针对 Linux 内核，在别的系统包括 macOS/WinNT 或者 Unix 系统中的交换文件可能有不同一样的行为，
需要不同的调优方式。比如在 &lt;a class="reference external" href="https://www.freebsd.org/doc/handbook/bsdinstall-partitioning.html#configtuning-initial"&gt;FreeBSD …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;这篇翻译自 Chris Down 的博文
&lt;a class="reference external" href="https://chrisdown.name/2018/01/02/in-defence-of-swap.html"&gt;In defence of swap: common misconceptions&lt;/a&gt;
。 &lt;a class="reference external" href="https://github.com/cdown/chrisdown.name/blob/master/LICENSE"&gt;原文的协议&lt;/a&gt;
是 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/4.0/"&gt;CC BY-SA 4.0&lt;/a&gt;
，本文翻译同样也使用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/4.0/"&gt;CC BY-SA 4.0&lt;/a&gt; 。其中加入了一些我自己的理解作为旁注，所有译注都在侧边栏中。&lt;/p&gt;
&lt;p&gt;翻译这篇文章是因为经常看到朋友们（包括有经验的程序员和 Linux 管理员）对 swap 和 swappiness
有诸多误解，而这篇文章正好澄清了这些误解，也讲清楚了 Linux 中这两者的本质。值得一提的是本文讨论的
swap 针对 Linux 内核，在别的系统包括 macOS/WinNT 或者 Unix 系统中的交换文件可能有不同一样的行为，
需要不同的调优方式。比如在 &lt;a class="reference external" href="https://www.freebsd.org/doc/handbook/bsdinstall-partitioning.html#configtuning-initial"&gt;FreeBSD handbook&lt;/a&gt;
中明确建议了 swap 分区通常应该是两倍物理内存大小，这一点建议对 FreeBSD 系内核的内存管理可能非常合理，
而不一定适合 Linux 内核，FreeBSD 和 Linux 有不同的内存管理方式尤其是 swap 和 page cache 和
buffer cache 的处理方式有诸多不同。&lt;/p&gt;
&lt;p&gt;经常有朋友看到系统卡顿之后看系统内存使用状况观察到大量 swap 占用，于是觉得卡顿是来源于 swap
。就像文中所述，相关不蕴含因果，产生内存颠簸之后的确会造成大量 swap 占用，也会造成系统卡顿，
但是 swap 不是导致卡顿的原因，关掉 swap 或者调低 swappiness 并不能阻止卡顿，只会将 swap
造成的 I/O 转化为加载文件缓存造成的 I/O 。&lt;/p&gt;
&lt;p&gt;以下是原文翻译：&lt;/p&gt;

&lt;hr class="docutils"/&gt;
&lt;p&gt;这篇文章也有 &lt;a class="reference external" href="https://chrisdown.name/ja/2018/01/02/in-defence-of-swap.html"&gt;日文&lt;/a&gt;
和 &lt;a class="reference external" href="https://softdroid.net/v-zashchitu-svopa-rasprostranennye-zabluzhdeniya"&gt;俄文&lt;/a&gt;
翻译。&lt;/p&gt;
&lt;a aria-controls="a01b6caa" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#a01b6caa" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="a01b6caa"&gt;
&lt;p&gt;tl;dr:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Having swap is a reasonably important part of a well functioning system.
Without it, sane memory management becomes harder to achieve.&lt;/li&gt;
&lt;li&gt;Swap is not generally about getting emergency memory, it's about making
memory reclamation egalitarian and efficient. In fact, using it as
"emergency memory" is generally actively harmful.&lt;/li&gt;
&lt;li&gt;Disabling swap does not prevent disk I/O from becoming a problem
under memory contention, it simply shifts the disk I/O thrashing from
anonymous pages to file pages. Not only may this be less efficient,
as we have a smaller pool of pages to select from for reclaim, but it
may also contribute to getting into this high contention state in
the first place.&lt;/li&gt;
&lt;li&gt;The swapper on kernels before 4.0 has a lot of pitfalls,
and has contributed to a lot of people's negative perceptions about
swap due to its overeagerness to swap out pages. On kernels &amp;gt;4.0,
the situation is significantly better.&lt;/li&gt;
&lt;li&gt;On SSDs, swapping out anonymous pages and reclaiming file pages are
essentially equivalent in terms of performance/latency.
On older spinning disks, swap reads are slower due to random reads,
so a lower &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 setting makes sense there
(read on for more about &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
).&lt;/li&gt;
&lt;li&gt;Disabling swap doesn't prevent pathological behaviour at near-OOM,
although it's true that having swap may prolong it. Whether the
system global OOM killer is invoked with or without swap, or was invoked
sooner or later, the result is the same: you are left with a system in an
unpredictable state. Having no swap doesn't avoid this.&lt;/li&gt;
&lt;li&gt;You can achieve better swap behaviour under memory pressure and prevent
thrashing using &lt;code class="code"&gt;
memory.low&lt;/code&gt;
 and friends in cgroup v2.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;太长不看：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;对维持系统的正常功能而言，有 swap 是相对挺重要的一部分。没有它的话会更难做到合理的内存管理。&lt;/li&gt;
&lt;li&gt;swap 的目的通常并不是用作紧急内存，它的目的在于让内存回收能更平等和高效。
事实上把它当作「紧急内存」来用的想法通常是有害的。&lt;/li&gt;
&lt;li&gt;禁用 swap 在内存压力下并不能避免磁盘I/O造成的性能问题，这么做只是让磁盘I/O颠簸的范围从
匿名页面转化到文件页面。这不仅更低效，因为系统能回收的页面的选择范围更有限了，
而且这种做法还可能是加重了内存压力的原因之一。&lt;/li&gt;
&lt;li&gt;内核 4.0 版本之前的交换进程（swapper）有一些问题，导致很多人对 swap 有负面印象，
因为它太急于（overeagerness）把页面交换出去。在 4.0 之后的内核上这种情况已经改善了很多。&lt;/li&gt;
&lt;li&gt;在 SSD 上，交换出匿名页面的开销和回收文件页面的开销基本上在性能/延迟方面没有区别。
在老式的磁盘上，读取交换文件因为属于随机访问读取所以会更慢，于是设置较低的 &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;

可能比较合理（继续读下面关于 &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 的描述）。&lt;/li&gt;
&lt;li&gt;禁用 swap 并不能避免在接近 OOM 状态下最终表现出的症状，尽管的确有 swap
的情况下这种症状持续的时间可能会延长。在系统调用 OOM 杀手的时候无论有没有启用 swap
，或者更早/更晚开始调用 OOM 杀手，结果都是一样的：整个系统留在了一种不可预知的状态下。
有 swap 也不能避免这一点。&lt;/li&gt;
&lt;li&gt;可以用 cgroup v2 的 &lt;code class="code"&gt;
memory.low&lt;/code&gt;
 相关机制来改善内存压力下 swap 的行为并且
避免发生颠簸。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr class="docutils"/&gt;
&lt;a aria-controls="053c68ad" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#053c68ad" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="053c68ad"&gt;
As part of my work improving kernel memory management and cgroup v2,
I've been talking to a lot of engineers about attitudes towards memory
management, especially around application behaviour under pressure and
operating system heuristics used under the hood for memory management.&lt;/blockquote&gt;
&lt;p&gt;我的工作的一部分是改善内核中内存管理和 cgroup v2 相关，所以我和很多工程师讨论过看待内存管理的态度，
尤其是在压力下应用程序的行为和操作系统在底层内存管理中用的基于经验的启发式决策逻辑。&lt;/p&gt;
&lt;a aria-controls="8dedecec" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#8dedecec" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="8dedecec"&gt;
A repeated topic in these discussions has been swap.
Swap is a hotly contested and poorly understood topic,
even by those who have been working with Linux for many years.
Many see it as useless or actively harmful: a relic of a time where
memory was scarce, and disks were a necessary evil to provide much-needed
space for paging. This is a statement that I still see being batted
around with relative frequency in recent years, and I've had many
discussions with colleagues, friends, and industry peers to help them
understand why swap is still a useful concept on modern computers with
significantly more physical memory available than in the past.&lt;/blockquote&gt;
&lt;p&gt;在这种讨论中经常重复的话题是交换区（swap）。交换区的话题是非常有争议而且很少被理解的话题，甚至包括那些在
Linux 上工作过多年的人也是如此。很多人觉得它没什么用甚至是有害的：它是历史遗迹，从内存紧缺而
磁盘读写是必要之恶的时代遗留到现在，为计算机提供在当年很必要的页面交换功能作为内存空间。
最近几年我还经常能以一定频度看到这种论调，然后我和很多同事、朋友、业界同行们讨论过很多次，
帮他们理解为什么在现代计算机系统中交换区仍是有用的概念，即便现在的电脑中物理内存已经远多于过去。&lt;/p&gt;
&lt;a aria-controls="b1c86306" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#b1c86306" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="b1c86306"&gt;
There's also a lot of misunderstanding about the purpose of swap –
many people just see it as a kind of "slow extra memory" for use in emergencies,
but don't understand how it can contribute during normal load to the healthy
operation of an operating system as a whole.&lt;/blockquote&gt;
&lt;p&gt;围绕交换区的目的还有很多误解——很多人觉得它只是某种为了应对紧急情况的「慢速额外内存」，
但是没能理解在整个操作系统健康运作的时候它也能改善普通负载的性能。&lt;/p&gt;
&lt;a aria-controls="3603c7fa" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#3603c7fa" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="3603c7fa"&gt;
Many of us have heard most of the usual tropes about memory:
" &lt;a class="reference external" href="https://www.linuxatemyram.com/"&gt;Linux uses too much memory&lt;/a&gt; ",
" &lt;a class="reference external" href="https://superuser.com/a/111510"&gt;swap should be double your physical memory size&lt;/a&gt;
", and the like. While these are either trivial to dispel,
or discussion around them has become more nuanced in recent years,
the myth of "useless" swap is much more grounded in heuristics and
arcana rather than something that can be explained by simple analogy,
and requires somewhat more understanding of memory management to reason about.&lt;/blockquote&gt;
&lt;p&gt;我们很多人也听说过描述内存时所用的常见说法： 「 &lt;a class="reference external" href="https://www.linuxatemyram.com/"&gt;Linux 用了太多内存&lt;/a&gt;
」，「 &lt;a class="reference external" href="https://superuser.com/a/111510"&gt;swap 应该设为物理内存的两倍大小&lt;/a&gt; 」，或者类似的说法。
虽然这些误解要么很容易化解，或者关于他们的讨论在最近几年已经逐渐变得琐碎，但是关于「无用」交换区
的传言有更深的经验传承的根基，而不是一两个类比就能解释清楚的，并且要探讨这个先得对内存管理有
一些基础认知。&lt;/p&gt;
&lt;a aria-controls="ff09462c" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#ff09462c" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="ff09462c"&gt;
This post is mostly aimed at those who administrate Linux systems and
are interested in hearing the counterpoints to running with
undersized/no swap or running with vm.swappiness set to 0.&lt;/blockquote&gt;
&lt;p&gt;本文主要目标是针对那些管理 Linux 系统并且有兴趣理解「让系统运行于低/无交换区状态」或者「把
&lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 设为 0 」这些做法的反论。&lt;/p&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id23"&gt;背景&lt;/a&gt;&lt;/h2&gt;
&lt;a aria-controls="283c5b39" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#283c5b39" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="283c5b39"&gt;
It's hard to talk about why having swap and swapping out pages are good
things in normal operation without a shared understanding of some of
the basic underlying mechanisms at play in Linux memory management,
so let's make sure we're on the same page.&lt;/blockquote&gt;
&lt;p&gt;如果没有基本理解 Linux 内存管理的底层机制是如何运作的，就很难讨论为什么需要交换区以及交换出页面
对正常运行的系统为什么是件好事，所以我们先确保大家有讨论的基础。&lt;/p&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id24"&gt;内存的类型&lt;/a&gt;&lt;/h3&gt;
&lt;a aria-controls="b93d3e73" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#b93d3e73" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="b93d3e73"&gt;
There are many different types of memory in Linux, and each type has its
own properties. Understanding the nuances of these is key to understanding
why swap is important.&lt;/blockquote&gt;
&lt;p&gt;Linux 中内存分为好几种类型，每种都有各自的属性。想理解为什么交换区很重要的关键一点在于理解这些的细微区别。&lt;/p&gt;
&lt;a aria-controls="ea5c81cf" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#ea5c81cf" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="ea5c81cf"&gt;
For example, there are &lt;strong&gt;pages ("blocks" of memory, typically 4k)&lt;/strong&gt;
responsible for holding the code for each process being run on your computer.
There are also pages responsible for caching data and metadata related to
files accessed by those programs in order to speed up future access.
These are part of the &lt;strong&gt;page cache&lt;/strong&gt; , and I will refer to them as file memory.&lt;/blockquote&gt;
&lt;p&gt;比如说，有种 &lt;strong&gt;页面（「整块」的内存，通常 4K）&lt;/strong&gt; 是用来存放电脑里每个程序运行时各自的代码的。
也有页面用来保存这些程序所需要读取的文件数据和元数据的缓存，以便加速随后的文件读写。
这些内存页面构成 &lt;strong&gt;页面缓存（page cache）&lt;/strong&gt;，后文中我称他们为文件内存。&lt;/p&gt;
&lt;a aria-controls="a8e582f2" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#a8e582f2" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="a8e582f2"&gt;
There are also pages which are responsible for the memory allocations
made inside that code, for example, when new memory that has been allocated
with &lt;code class="code"&gt;
malloc&lt;/code&gt;
 is written to, or when using &lt;code class="code"&gt;
mmap&lt;/code&gt;
's
&lt;code class="code"&gt;
MAP_ANONYMOUS&lt;/code&gt;
 flag. These are "anonymous" pages –
so called because they are not backed by anything –
and I will refer to them as anon memory.&lt;/blockquote&gt;
&lt;p&gt;还有一些页面是在代码执行过程中做的内存分配得到的，比如说，当代码调用 &lt;code class="code"&gt;
malloc&lt;/code&gt;

能分配到新内存区，或者使用 &lt;code class="code"&gt;
mmap&lt;/code&gt;
 的 &lt;code class="code"&gt;
MAP_ANONYMOUS&lt;/code&gt;
 标志分配的内存。
这些是「匿名(anonymous)」页面——之所以这么称呼它们是因为他们没有任何东西作后备——
后文中我称他们为匿名内存。&lt;/p&gt;
&lt;a aria-controls="38d36a1d" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#38d36a1d" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="38d36a1d"&gt;
There are other types of memory too –
shared memory, slab memory, kernel stack memory, buffers, and the like –
but anonymous memory and file memory are the most well known and
easy to understand ones, so I will use these in my examples,
although they apply equally to these types too.&lt;/blockquote&gt;
&lt;p&gt;还有其它类型的内存——共享内存、slab内存、内核栈内存、文件缓冲区（buffers），这种的——
但是匿名内存和文件内存是最知名也最好理解的，所以后面的例子里我会用这两个说明，
虽然后面的说明也同样适用于别的这些内存类型。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id25"&gt;可回收/不可回收内存&lt;/a&gt;&lt;/h3&gt;
&lt;a aria-controls="896d577c" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#896d577c" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="896d577c"&gt;
One of the most fundamental questions when thinking about a particular type
of memory is whether it is able to be reclaimed or not.
"Reclaim" here means that the system can, without losing data,
purge pages of that type from physical memory.&lt;/blockquote&gt;
&lt;p&gt;考虑某种内存的类型时，一个非常基础的问题是这种内存是否能被回收。
「回收（Reclaim）」在这里是指系统可以，在不丢失数据的前提下，从物理内存中释放这种内存的页面。&lt;/p&gt;
&lt;a aria-controls="c8915ce3" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#c8915ce3" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="c8915ce3"&gt;
For some page types, this is typically fairly trivial. For example,
in the case of clean (unmodified) page cache memory,
we're simply caching something that we have on disk for performance,
so we can drop the page without having to do any special operations.&lt;/blockquote&gt;
&lt;p&gt;对一些内存类型而言，是否可回收通常可以直接判断。比如对于那些干净（未修改）的页面缓存内存，
我们只是为了性能在用它们缓存一些磁盘上现有的数据，所以我们可以直接扔掉这些页面，
不需要做什么特殊的操作。&lt;/p&gt;
&lt;a aria-controls="543b6f9b" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#543b6f9b" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="543b6f9b"&gt;
For some page types, this is possible, but not trivial. For example,
in the case of dirty (modified) page cache memory, we can't just drop the page,
because the disk doesn't have our modifications yet.
As such we either need to deny reclamation or first get our changes back to
disk before we can drop this memory.&lt;/blockquote&gt;
&lt;p&gt;对有些内存类型而言，回收是可能的，但是不是那么直接。比如对脏（修改过）的页面缓存内存，
我们不能直接扔掉这些页面，因为磁盘上还没有写入我们所做的修改。这种情况下，我们可以选择拒绝回收，
或者选择先等待我们的变更写入磁盘之后才能扔掉这些内存。&lt;/p&gt;
&lt;a aria-controls="5111480d" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#5111480d" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="5111480d"&gt;
For some page types, this is not possible. For example,
in the case of the anonymous pages mentioned previously,
they only exist in memory and in no other backing store,
so they have to be kept there.&lt;/blockquote&gt;
&lt;p&gt;对还有些内存类型而言，是不能回收的。比如前面提到的匿名页面，它们只存在于内存中，没有任何后备存储，
所以它们必须留在内存里。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id26"&gt;说到交换区的本质&lt;/a&gt;&lt;/h2&gt;
&lt;a aria-controls="99551744" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#99551744" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="99551744"&gt;
&lt;p&gt;If you look for descriptions of the purpose of swap on Linux,
you'll inevitably find many people talking about it as if it is merely
an extension of the physical RAM for use in emergencies. For example,
here is a random post I got as one of the top results from typing
"what is swap" in Google:&lt;/p&gt;
&lt;blockquote&gt;
Swap is essentially emergency memory; a space set aside for times
when your system temporarily needs more physical memory than you
have available in RAM. It's considered "bad" in the sense that
it's slow and inefficient, and if your system constantly needs
to use swap then it obviously doesn't have enough memory. […]
If you have enough RAM to handle all of your needs, and don't
expect to ever max it out, then you should be perfectly safe
running without a swap space.&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你去搜 Linux 上交换区的目的的描述，肯定会找到很多人说交换区只是在紧急时用来扩展物理内存的机制。
比如下面这段是我在 google 中输入「什么是 swap」 从前排结果中随机找到的一篇：&lt;/p&gt;
&lt;blockquote&gt;
交换区本质上是紧急内存；是为了应对你的系统临时所需内存多余你现有物理内存时，专门分出一块额外空间。
大家觉得交换区「不好」是因为它又慢又低效，并且如果你的系统一直需要使用交换区那说明它明显没有足够的内存。
［……］如果你有足够内存覆盖所有你需要的情况，而且你觉得肯定不会用满内存，那么完全可以不用交换区
安全地运行系统。&lt;/blockquote&gt;
&lt;a aria-controls="fe4c8bc1" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#fe4c8bc1" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="fe4c8bc1"&gt;
To be clear, I don't blame the poster of this comment at all for the content
of their post – this is accepted as "common knowledge" by a lot of
Linux sysadmins and is probably one of the most likely things that you will
hear from one if you ask them to talk about swap. It is unfortunately also,
however, a misunderstanding of the purpose and use of swap, especially on
modern systems.&lt;/blockquote&gt;
&lt;p&gt;事先说明，我不想因为这些文章的内容责怪这些文章的作者——这些内容被很多 Linux 系统管理员认为是「常识」，
并且很可能你问他们什么是交换区的时候他们会给你这样的回答。但是也很不幸的是，
这种认识是使用交换区的目的的一种普遍误解，尤其在现代系统上。&lt;/p&gt;
&lt;a aria-controls="77407587" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#77407587" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="77407587"&gt;
Above, I talked about reclamation for anonymous pages being "not possible",
as anonymous pages by their nature have no backing store to fall back to
when being purged from memory – as such, their reclamation would result in
complete data loss for those pages. What if we could create such a
store for these pages, though?&lt;/blockquote&gt;
&lt;p&gt;前文中我说过回收匿名页面的内存是「不可能的」，因为匿名内存的特点，把它们从内存中清除掉之后，
没有别的存储区域能作为他们的备份——因此，要回收它们会造成数据丢失。但是，如果我们为这种内存页面创建
一种后备存储呢？&lt;/p&gt;
&lt;a aria-controls="75be861f" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#75be861f" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="75be861f"&gt;
Well, this is precisely what swap is for. Swap is a storage area for these
seemingly "unreclaimable" pages that allows us to page them out to
a storage device on demand. This means that they can now be considered as
equally eligible for reclaim as their more trivially reclaimable friends,
like clean file pages, allowing more efficient use of available physical memory.&lt;/blockquote&gt;
&lt;p&gt;嗯，这正是交换区存在的意义。交换区是一块存储空间，用来让这些看起来「不可回收」的内存页面在需要的时候
可以交换到存储设备上。这意味着有了交换区之后，这些匿名页面也和别的那些可回收内存一样，
可以作为内存回收的候选，就像干净文件页面，从而允许更有效地使用物理内存。&lt;/p&gt;
&lt;a aria-controls="aa3951ca" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#aa3951ca" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="aa3951ca"&gt;
&lt;strong&gt;Swap is primarily a mechanism for equality of reclamation,&lt;/strong&gt;
&lt;strong&gt;not for emergency "extra memory". Swap is not what makes your application&lt;/strong&gt;
&lt;strong&gt;slow – entering overall memory contention is what makes your application slow.&lt;/strong&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;交换区主要是为了平等的回收机制，而不是为了紧急情况的「额外内存」。使用交换区不会让你的程序变慢——&lt;/strong&gt;
&lt;strong&gt;进入内存竞争的状态才是让程序变慢的元凶。&lt;/strong&gt;&lt;/p&gt;
&lt;a aria-controls="526740fe" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#526740fe" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="526740fe"&gt;
So in what situations under this "equality of reclamation"
scenario would we legitimately choose to reclaim anonymous pages?
Here are, abstractly, some not uncommon scenarios:&lt;/blockquote&gt;
&lt;p&gt;那么在这种「平等的可回收机遇」的情况下，让我们选择回收匿名页面的行为在何种场景中更合理呢？
抽象地说，比如在下述不算罕见的场景中：&lt;/p&gt;
&lt;a aria-controls="a12ad6df" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#a12ad6df" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="a12ad6df"&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;During initialisation, a long-running program may allocate and
use many pages. These pages may also be used as part of shutdown/cleanup,
but are not needed once the program is "started" (in an
application-specific sense). This is fairly common for daemons which
have significant dependencies to initialise.&lt;/li&gt;
&lt;li&gt;During the program's normal operation, we may allocate memory which is
only used rarely. It may make more sense for overall system performance
to require a &lt;strong&gt;major fault&lt;/strong&gt; to page these in from disk on demand,
instead using the memory for something else that's more important.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;程序初始化的时候，那些长期运行的程序可能要分配和使用很多页面。这些页面可能在最后的关闭/清理的
时候还需要使用，但是在程序「启动」之后（以具体的程序相关的方式）持续运行的时候不需要访问。
对后台服务程序来说，很多后台程序要初始化不少依赖库，这种情况很常见。&lt;/li&gt;
&lt;li&gt;在程序的正常运行过程中，我们可能分配一些很少使用的内存。对整体系统性能而言可能比起让这些内存页
一直留在内存中，只有在用到的时候才按需把它们用 &lt;strong&gt;缺页异常（major fault）&lt;/strong&gt; 换入内存，
可以空出更多内存留给更重要的东西。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="https://www.youtube.com/watch?v=ikZ8_mRotT4"&gt;cgroupv2: Linux's new unified control group hierarchy (QCON London 2017)&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/ikZ8_mRotT4"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id27"&gt;考察有无交换区时会发生什么&lt;/a&gt;&lt;/h2&gt;
&lt;a aria-controls="fc974b28" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#fc974b28" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="fc974b28"&gt;
Let's look at typical situations, and how they perform with and without
swap present. I talk about metrics around "memory contention" in my
&lt;a class="reference external" href="https://www.youtube.com/watch?v=ikZ8_mRotT4"&gt;talk on cgroup v2&lt;/a&gt; .&lt;/blockquote&gt;
&lt;p&gt;我们来看一些在常见场景中，有无交换区时分别会如何运行。
在我的 &lt;a class="reference external" href="https://www.youtube.com/watch?v=ikZ8_mRotT4"&gt;关于 cgroup v2 的演讲&lt;/a&gt;
中探讨过「内存竞争」的指标。&lt;/p&gt;
&lt;div class="section" id="id11"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id28"&gt;在无/低内存竞争的状态下&lt;/a&gt;&lt;/h3&gt;
&lt;a aria-controls="a577bbc2" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#a577bbc2" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="a577bbc2"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;With swap:&lt;/strong&gt; We can choose to swap out rarely-used anonymous memory that
may only be used during a small part of the process lifecycle,
allowing us to use this memory to improve cache hit rate,
or do other optimisations.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Without swap&lt;/strong&gt; We cannot swap out rarely-used anonymous memory,
as it's locked in memory. While this may not immediately
present as a problem, on some workloads this may represent
a non-trivial drop in performance due to stale,
anonymous pages taking space away from more important use.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;有交换区:&lt;/strong&gt; 我们可以选择换出那些只有在进程生存期内很小一部分时间会访问的匿名内存，
这允许我们空出更多内存空间用来提升缓存命中率，或者做别的优化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无交换区:&lt;/strong&gt; 我们不能换出那些很少使用的匿名内存，因为它们被锁在了内存中。虽然这通常不会直接表现出问题，
但是在一些工作条件下这可能造成卡顿导致不平凡的性能下降，因为匿名内存占着空间不能给
更重要的需求使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
译注：关于 &lt;strong&gt;内存热度&lt;/strong&gt; 和 &lt;strong&gt;内存颠簸（thrash）&lt;/strong&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;p&gt;讨论内核中内存管理的时候经常会说到内存页的 &lt;strong&gt;冷热&lt;/strong&gt; 程度。这里冷热是指历史上内存页被访问到的频度，
内存管理的经验在说，历史上在近期频繁访问的 &lt;strong&gt;热&lt;/strong&gt; 内存，在未来也可能被频繁访问，
从而应该留在物理内存里；反之历史上不那么频繁访问的 &lt;strong&gt;冷&lt;/strong&gt; 内存，在未来也可能很少被用到，
从而可以考虑交换到磁盘或者丢弃文件缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;颠簸（thrash）&lt;/strong&gt; 这个词在文中出现多次但是似乎没有详细介绍，实际计算机科学专业的课程中应该有讲过。
一段时间内，让程序继续运行所需的热内存总量被称作程序的工作集（workset），估算工作集大小，
换句话说判断进程分配的内存页中哪些属于 &lt;strong&gt;热&lt;/strong&gt; 内存哪些属于 &lt;strong&gt;冷&lt;/strong&gt; 内存，是内核中
内存管理的最重要的工作。当分配给程序的内存大于工作集的时候，程序可以不需要等待I/O全速运行；
而当分配给程序的内存不足以放下整个工作集的时候，意味着程序每执行一小段就需要等待换页或者等待
磁盘缓存读入所需内存页，产生这种情况的时候，从用户角度来看可以观察到程序肉眼可见的「卡顿」。
当系统中所有程序都内存不足的时候，整个系统都处于颠簸的状态下，响应速度直接降至磁盘I/O的带宽。
如本文所说，禁用交换区并不能防止颠簸，只是从等待换页变成了等待文件缓存，
给程序分配超过工作集大小的内存才能防止颠簸。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id29"&gt;在中/高内存竞争的状态下&lt;/a&gt;&lt;/h3&gt;
&lt;a aria-controls="266f0b15" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#266f0b15" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="266f0b15"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;With swap:&lt;/strong&gt; All memory types have an equal possibility of being reclaimed.
This means we have more chance of being able to reclaim pages
successfully – that is, we can reclaim pages that are not quickly
faulted back in again (thrashing).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Without swap&lt;/strong&gt; Anonymous pages are locked into memory as they have nowhere to go.
The chance of successful long-term page reclamation is lower,
as we have only some types of memory eligible to be reclaimed
at all. The risk of page thrashing is higher. The casual
reader might think that this would still be better as it might
avoid having to do disk I/O, but this isn't true –
we simply transfer the disk I/O of swapping to dropping
hot page caches and dropping code segments we need soon.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;有交换区:&lt;/strong&gt; 所有内存类型都有平等的被回收的可能性。这意味着我们回收页面有更高的成功率——
成功回收的意思是说被回收的那些页面不会在近期内被缺页异常换回内存中（颠簸）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无交换区:&lt;/strong&gt; 匿名内存因为无处可去所以被锁在内存中。长期内存回收的成功率变低了，因为我们成体上
能回收的页面总量少了。发生缺页颠簸的危险性更高了。缺乏经验的读者可能觉得这某时也是好事，
因为这能避免进行磁盘I/O，但是实际上不是如此——我们只是把交换页面造成的磁盘I/O变成了扔掉热缓存页
和扔掉代码段，这些页面很可能马上又要从文件中读回来。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id13"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id30"&gt;在临时内存占用高峰时&lt;/a&gt;&lt;/h3&gt;
&lt;a aria-controls="bf276ac9" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#bf276ac9" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="bf276ac9"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;With swap:&lt;/strong&gt; We're more resilient to temporary spikes, but in cases of
severe memory starvation, the period from memory thrashing beginning
to the OOM killer may be prolonged. We have more visibility into the
instigators of memory pressure and can act on them more reasonably,
and can perform a controlled intervention.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Without swap&lt;/strong&gt; The OOM killer is triggered more quickly as anonymous
pages are locked into memory and cannot be reclaimed. We're more likely to
thrash on memory, but the time between thrashing and OOMing is reduced.
Depending on your application, this may be better or worse. For example,
a queue-based application may desire this quick transfer from thrashing
to killing. That said, this is still too late to be really useful –
the OOM killer is only invoked at moments of severe starvation,
and relying on this method for such behaviour would be better replaced
with more opportunistic killing of processes as memory contention
is reached in the first place.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;有交换区:&lt;/strong&gt; 我们对内存使用激增的情况更有抵抗力，但是在严重的内存不足的情况下，
从开始发生内存颠簸到 OOM 杀手开始工作的时间会被延长。内存压力造成的问题更容易观察到，
从而可能更有效地应对，或者更有机会可控地干预。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无交换区:&lt;/strong&gt; 因为匿名内存被锁在内存中了不能被回收，所以 OOM 杀手会被更早触发。
发生内存颠簸的可能性更大，但是发生颠簸之后到 OOM 解决问题的时间间隔被缩短了。
基于你的程序，这可能更好或是更糟。比如说，基于队列的程序可能更希望这种从颠簸到杀进程的转换更快发生。
即便如此，发生 OOM 的时机通常还是太迟于是没什么帮助——只有在系统极度内存紧缺的情况下才会请出
OOM 杀手，如果想依赖这种行为模式，不如换成更早杀进程的方案，因为在这之前已经发生内存竞争了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id14"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id31"&gt;好吧，所以我需要系统交换区，但是我该怎么为每个程序微调它的行为？&lt;/a&gt;&lt;/h3&gt;
&lt;a aria-controls="7f9321c9" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#7f9321c9" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="7f9321c9"&gt;
You didn't think you'd get through this entire post without me plugging cgroup v2, did you? ;-)&lt;/blockquote&gt;
&lt;p&gt;你肯定想到了我写这篇文章一定会在哪儿插点 cgroup v2 的安利吧？ ;-)&lt;/p&gt;
&lt;a aria-controls="3fcbadba" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#3fcbadba" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="3fcbadba"&gt;
Obviously, it's hard for a generic heuristic algorithm to be right all the time,
so it's important for you to be able to give guidance to the kernel.
Historically the only tuning you could do was at the system level,
using &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 . This has two problems: &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;

is incredibly hard to reason about because it only feeds in as
a small part of a larger heuristic system, and it also is system-wide
instead of being granular to a smaller set of processes.&lt;/blockquote&gt;
&lt;p&gt;显然，要设计一种对所有情况都有效的启发算法会非常难，所以给内核提一些指引就很重要。
历史上我们只能在整个系统层面做这方面微调，通过 &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 。这有两方面问题：
&lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 的行为很难准确控制，因为它只是传递给一个更大的启发式算法中的一个小参数；
并且它是一个系统级别的设置，没法针对一小部分进程微调。&lt;/p&gt;
&lt;a aria-controls="dc0990d3" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#dc0990d3" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="dc0990d3"&gt;
You can also use &lt;code class="code"&gt;
mlock&lt;/code&gt;
 to lock pages into memory, but this requires
either modifying program code, fun with &lt;code class="code"&gt;
LD_PRELOAD&lt;/code&gt;
 , or doing
horrible things with a debugger at runtime.
In VM-based languages this also doesn't work very well, since you
generally have no control over allocation and end up having to
&lt;code class="code"&gt;
mlockall&lt;/code&gt;
 , which has no precision towards the pages
you actually care about.&lt;/blockquote&gt;
&lt;p&gt;你可以用 &lt;code class="code"&gt;
mlock&lt;/code&gt;
 把页面锁在内存里，但是这要么必须改程序代码，或者折腾
&lt;code class="code"&gt;
LD_PRELOAD&lt;/code&gt;
 ，或者在运行期用调试器做一些魔法操作。对基于虚拟机的语言来说这种方案也不能
很好工作，因为通常你没法控制内存分配，最后得用上 &lt;code class="code"&gt;
mlockall&lt;/code&gt;

，而这个没有办法精确指定你实际上想锁住的页面。&lt;/p&gt;
&lt;a aria-controls="ee392737" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#ee392737" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="ee392737"&gt;
cgroup v2 has a tunable per-cgroup in the form of &lt;code class="code"&gt;
memory.low&lt;/code&gt;

, which allows us to tell the kernel to prefer other applications for
reclaim below a certain threshold of memory used. This allows us to not
prevent the kernel from swapping out parts of our application,
but prefer to reclaim from other applications under memory contention.
Under normal conditions, the kernel's swap logic is generally pretty good,
and allowing it to swap out pages opportunistically generally increases
system performance. Swap thrash under heavy memory contention is not ideal,
but it's more a property of simply running out of memory entirely than
a problem with the swapper. In these situations, you typically want to
fail fast by self-killing non-critical processes when memory pressure
starts to build up.&lt;/blockquote&gt;
&lt;p&gt;cgroup v2 提供了一套可以每个 cgroup 微调的 &lt;code class="code"&gt;
memory.low&lt;/code&gt;

，允许我们告诉内核说当使用的内存低于一定阈值之后优先回收别的程序的内存。这可以让我们不强硬禁止内核
换出程序的一部分内存，但是当发生内存竞争的时候让内核优先回收别的程序的内存。在正常条件下，
内核的交换逻辑通常还是不错的，允许它有条件地换出一部分页面通常可以改善系统性能。在内存竞争的时候
发生交换颠簸虽然不理想，但是这更多地是单纯因为整体内存不够了，而不是因为交换进程（swapper）导致的问题。
在这种场景下，你通常希望在内存压力开始积攒的时候通过自杀一些非关键的进程的方式来快速退出（fail fast）。&lt;/p&gt;
&lt;a aria-controls="d789770a" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#d789770a" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="d789770a"&gt;
You can not simply rely on the OOM killer for this. The OOM killer is
only invoked in situations of dire failure when we've already entered
a state where the system is severely unhealthy and may well have been
so for a while. You need to opportunistically handle the situation yourself
before ever thinking about the OOM killer.&lt;/blockquote&gt;
&lt;p&gt;你不能依赖 OOM 杀手达成这个。 OOM 杀手只有在非常急迫的情况下才会出动，那时系统已经处于极度不健康的
状态了，而且很可能在这种状态下保持了一阵子了。需要在开始考虑 OOM 杀手之前，积极地自己处理这种情况。&lt;/p&gt;
&lt;a aria-controls="fe0515e4" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#fe0515e4" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="fe0515e4"&gt;
Determination of memory pressure is somewhat difficult using traditional
Linux memory counters, though. We have some things which seem somewhat related,
but are merely tangential – memory usage, page scans, etc – and from these
metrics alone it's very hard to tell an efficient memory configuration
from one that's trending towards memory contention. There is a group of us
at Facebook, spearheaded by &lt;a class="reference external" href="https://patchwork.kernel.org/project/LKML/list/?submitter=45"&gt;Johannes&lt;/a&gt;
, working on developing new metrics that expose memory pressure more easily
that should help with this in future. If you're interested in hearing more
about this,
&lt;a class="reference external" href="https://youtu.be/ikZ8_mRotT4?t=2145"&gt;I go into detail about one metric being considered in my talk on cgroup v2&lt;/a&gt;.&lt;/blockquote&gt;
&lt;p&gt;不过，用传统的 Linux 内存统计数据还是挺难判断内存压力的。我们有一些看起来相关的系统指标，但是都
只是支离破碎的——内存用量、页面扫描，这些——单纯从这些指标很难判断系统是处于高效的内存利用率还是
在滑向内存竞争状态。我们在 Facebook 有个团队，由
&lt;a class="reference external" href="https://patchwork.kernel.org/project/LKML/list/?submitter=45"&gt;Johannes&lt;/a&gt;
牵头，努力开发一些能评价内存压力的新指标，希望能在今后改善目前的现状。
如果你对这方面感兴趣， &lt;a class="reference external" href="https://youtu.be/ikZ8_mRotT4?t=2145"&gt;在我的 cgroup v2 的演讲中介绍到一个被提议的指标&lt;/a&gt;
。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id16"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id32"&gt;调优&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id17"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id33"&gt;那么，我需要多少交换空间？&lt;/a&gt;&lt;/h3&gt;
&lt;a aria-controls="5b5c883c" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#5b5c883c" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="5b5c883c"&gt;
In general, the minimum amount of swap space required for optimal
memory management depends on the number of anonymous pages pinned into
memory that are rarely reaccessed by an application, and the value of
reclaiming those anonymous pages. The latter is mostly a question of
which pages are no longer purged to make way for these infrequently
accessed anonymous pages.&lt;/blockquote&gt;
&lt;p&gt;通常而言，最优内存管理所需的最小交换空间取决于程序固定在内存中而又很少访问到的匿名页面的数量，
以及回收这些匿名页面换来的价值。后者大体上来说是问哪些页面不再会因为要保留这些很少访问的匿名页面而
被回收掉腾出空间。&lt;/p&gt;
&lt;a aria-controls="f070dec0" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#f070dec0" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="f070dec0"&gt;
If you have a bunch of disk space and a recent (4.0+) kernel,
more swap is almost always better than less. In older kernels &lt;code class="code"&gt;
kswapd&lt;/code&gt;
,
one of the kernel processes responsible for managing swap, was historically
very overeager to swap out memory aggressively the more swap you had.
In recent times, swapping behaviour when a large amount of swap space is
available has been significantly improved. If you're running kernel 4.0+,
having a larger swap on a modern kernel should not result in overzealous
swapping. As such, if you have the space, having a swap size of a few GB
keeps your options open on modern kernels.&lt;/blockquote&gt;
&lt;p&gt;如果你有足够大的磁盘空间和比较新的内核版本（4.0+），越大的交换空间基本上总是越好的。
更老的内核上 &lt;code class="code"&gt;
kswapd&lt;/code&gt;
 ， 内核中负责管理交换区的内核线程，在历史上倾向于有越多交换空间就
急于交换越多内存出去。在最近一段时间，可用交换空间很大的时候的交换行为已经改善了很多。
如果在运行 4.0+ 以后的内核，即便有很大的交换区在现代内核上也不会很激进地做交换。因此，
如果你有足够的容量，现代内核上有个几个 GB 的交换空间大小能让你有更多选择。&lt;/p&gt;
&lt;a aria-controls="d981b13d" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#d981b13d" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="d981b13d"&gt;
If you're more constrained with disk space, then the answer really
depends on the tradeoffs you have to make, and the nature of the environment.
Ideally you should have enough swap to make your system operate optimally
at normal and peak (memory) load. What I'd recommend is setting up a few
testing systems with 2-3GB of swap or more, and monitoring what happens
over the course of a week or so under varying (memory) load conditions.
As long as you haven't encountered severe memory starvation during that week
– in which case the test will not have been very useful – you will probably
end up with some number of MB of swap occupied. As such, it's probably worth
having at least that much swap available, in addition to a little buffer for
changing workloads. &lt;code class="code"&gt;
atop&lt;/code&gt;
 in logging mode can also show you which applications
are having their pages swapped out in the &lt;code class="code"&gt;
SWAPSZ&lt;/code&gt;
 column, so if you don't
already use it on your servers to log historic server state you probably
want to set it up on these test machines with logging mode as part of this
experiment. This also tells you when your application started swapping out
pages, which you can tie to log events or other key data.&lt;/blockquote&gt;
&lt;p&gt;如果你的磁盘空间有限，那么答案更多取决于你愿意做的取舍，以及运行的环境。理想上应该有足够的交换空间
能高效应对正常负载和高峰（内存）负载。我建议先用 2-3GB 或者更多的交换空间搭个测试环境，
然后监视在不同（内存）负载条件下持续一周左右的情况。只要在那一周里没有发生过严重的内存不足——
发生了的话说明测试结果没什么用——在测试结束的时候大概会留有多少 MB 交换区占用。
作为结果说明你至少应该有那么多可用的交换空间，再多加一些以应对负载变化。用日志模式跑 &lt;code class="code"&gt;
atop&lt;/code&gt;

可以在 &lt;code class="code"&gt;
SWAPSZ&lt;/code&gt;
 栏显示程序的页面被交换出去的情况，所以如果你还没用它记录服务器历史日志的话
，这次测试中可以试试在测试机上用它记录日志。这也会告诉你什么时候你的程序开始换出页面，你可以用这个
对照事件日志或者别的关键数据。&lt;/p&gt;
&lt;a aria-controls="c81cfdce" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#c81cfdce" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="c81cfdce"&gt;
Another thing worth considering is the nature of the swap medium.
Swap reads tend to be highly random, since we can't reliably predict
which pages will be refaulted and when. On an SSD this doesn't matter much,
but on spinning disks, random I/O is extremely expensive since it requires
physical movement to achieve. On the other hand, refaulting of file pages
is likely less random, since files related to the operation of a single
application at runtime tend to be less fragmented. This might mean that on
a spinning disk you may want to bias more towards reclaiming file pages
instead of swapping out anonymous pages, but again, you need to test and
evaluate how this balances out for your workload.&lt;/blockquote&gt;
&lt;p&gt;另一点值得考虑的是交换空间所在存储设备的媒介。读取交换区倾向于很随机，因为我们不能可靠预测什么时候
什么页面会被再次访问。在 SSD 上这不是什么问题，但是在传统磁盘上，随机 I/O 操作会很昂贵，
因为需要物理动作寻道。另一方面，重新加载文件缓存可能不那么随机，因为单一程序在运行期的文件读操作
一般不会太碎片化。这可能意味着在传统磁盘上你想更多地回收文件页面而不是换出匿名页面，但仍就，
你需要做测试评估在你的工作负载下如何取得平衡。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
译注：关于休眠到磁盘时的交换空间大小&lt;/div&gt;
&lt;div class="panel-body"&gt;
原文这里建议交换空间至少是物理内存大小，我觉得实际上不需要。休眠到磁盘的时候内核会写回并丢弃
所有有文件作后备的可回收页面，交换区只需要能放下那些没有文件后备的页面就可以了。
如果去掉文件缓存页面之后剩下的已用物理内存总量能完整放入交换区中，就可以正常休眠。
对于桌面浏览器这种内存大户，通常有很多缓存页可以在休眠的时候丢弃。&lt;/div&gt;
&lt;/div&gt;
&lt;a aria-controls="34173e8b" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#34173e8b" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="34173e8b"&gt;
For laptop/desktop users who want to hibernate to swap, this also needs to
be taken into account – in this case your swap file should be at least
your physical RAM size.&lt;/blockquote&gt;
&lt;p&gt;对笔记本/桌面用户如果想要休眠到交换区，这也需要考虑——这种情况下你的交换文件应该至少是物理内存大小。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="swappiness"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id34"&gt;我的 swappiness 应该如何设置？&lt;/a&gt;&lt;/h3&gt;
&lt;a aria-controls="02421253" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#02421253" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="02421253"&gt;
First, it's important to understand what &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 does.
&lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 is a sysctl that biases memory reclaim either towards
reclamation of anonymous pages, or towards file pages. It does this using two
different attributes: &lt;code class="code"&gt;
file_prio&lt;/code&gt;
 (our willingness to reclaim file pages)
and &lt;code class="code"&gt;
anon_prio&lt;/code&gt;
 (our willingness to reclaim anonymous pages).
&lt;code class="code"&gt;
vm.swappiness`plays into this, as it becomes the default value for
:code:`anon_prio&lt;/code&gt;
, and it also is subtracted from the default value of 200
for &lt;code class="code"&gt;
file_prio&lt;/code&gt;
, which means for a value of &lt;code class="code"&gt;
vm.swappiness = 50&lt;/code&gt;
,
the outcome is that &lt;code class="code"&gt;
anon_prio&lt;/code&gt;
 is 50, and &lt;code class="code"&gt;
file_prio&lt;/code&gt;
 is 150
(the exact numbers don't matter as much as their relative weight compared to the other).&lt;/blockquote&gt;
&lt;p&gt;首先很重要的一点是，要理解 &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 是做什么的。
&lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 是一个 sysctl 用来控制在内存回收的时候，是优先回收匿名页面，
还是优先回收文件页面。内存回收的时候用两个属性： &lt;code class="code"&gt;
file_prio&lt;/code&gt;
 （回收文件页面的倾向）
和 &lt;code class="code"&gt;
anon_prio&lt;/code&gt;
 （回收匿名页面的倾向）。 &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 控制这两个值，
因为它是 &lt;code class="code"&gt;
anon_prio&lt;/code&gt;
 的默认值，然后也是默认 200 减去它之后 &lt;code class="code"&gt;
file_prio&lt;/code&gt;
 的默认值。
意味着如果我们设置 &lt;code class="code"&gt;
vm.swappiness = 50&lt;/code&gt;
 那么结果是 &lt;code class="code"&gt;
anon_prio&lt;/code&gt;
 是 50，
&lt;code class="code"&gt;
file_prio&lt;/code&gt;
 是 150 （这里数值本身不是很重要，重要的是两者之间的权重比）。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
译注：关于 SSD 上的 swappiness&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;p&gt;原文这里说 SSD 上 swap 和 drop page cache 差不多开销所以 &lt;code class="code"&gt;
vm.swappiness = 100&lt;/code&gt;

。我觉得实际上要考虑 swap out 的时候会产生写入操作，而 drop page cache 可能不需要写入（
要看页面是否是脏页）。如果负载本身对I/O带宽比较敏感，稍微调低 swappiness 可能对性能更好，
内核的默认值 60 是个不错的默认值。以及桌面用户可能对性能不那么关心，反而更关心 SSD
的写入寿命，虽然说 SSD 写入寿命一般也足够桌面用户，不过调低 swappiness
可能也能减少一部分不必要的写入（因为写回脏页是必然会发生的，而写 swap 可以避免）。
当然太低的 swappiness 会对性能有负面影响（因为太多匿名页面留在物理内存里而降低了缓存命中率）
，这里的权衡也需要根据具体负载做测试。&lt;/p&gt;
&lt;p&gt;另外澄清一点误解， swap 分区还是 swap 文件对系统运行时的性能而言没有差别。或许有人会觉得
swap 文件要经过文件系统所以会有性能损失，在译文之前译者说过 Linux 的内存管理子系统基本上独立于文件系统。
实际上 Linux 上的 swapon 在设置 swap 文件作为交换空间的时候会读取一次文件系统元数据，
确定 swap 文件在磁盘上的地址范围，随后运行的过程中做交换就和文件系统无关了。关于 swap
空间是否连续的影响，因为 swap 读写基本是页面单位的随机读写，所以即便连续的 swap 空间（swap
分区）也并不能改善 swap 的性能。希疏文件的地址范围本身不连续，写入希疏文件的空洞需要
文件系统分配磁盘空间，所以在 Linux 上交换文件不能是希疏文件。只要不是希疏文件，
连续的文件内地址范围在磁盘上是否连续（是否有文件碎片）基本不影响能否 swapon 或者使用 swap 时的性能。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;a aria-controls="b2897dd9" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#b2897dd9" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="b2897dd9"&gt;
This means that, in general, &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
&lt;strong&gt;is simply a ratio of how&lt;/strong&gt;
&lt;strong&gt;costly reclaiming and refaulting anonymous memory is compared to file memory&lt;/strong&gt;
&lt;strong&gt;for your hardware and workload&lt;/strong&gt;. The lower the value, the more you tell the
kernel that infrequently accessed anonymous pages are expensive to swap out
and in on your hardware. The higher the value, the more you tell the kernel
that the cost of swapping anonymous pages and file pages is similar on your
hardware. The memory management subsystem will still try to mostly decide
whether it swaps file or anonymous pages based on how hot the memory is,
but swappiness tips the cost calculation either more towards swapping or
more towards dropping filesystem caches when it could go either way.
On SSDs these are basically as expensive as each other, so setting
&lt;code class="code"&gt;
vm.swappiness = 100&lt;/code&gt;
 (full equality) may work well.
On spinning disks, swapping may be significantly more expensive since
swapping in generally requires random reads, so you may want to
bias more towards a lower value.&lt;/blockquote&gt;
&lt;p&gt;这意味着，通常来说 &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
&lt;strong&gt;只是一个比例，用来衡量在你的硬件和工作负载下，&lt;/strong&gt;
&lt;strong&gt;回收和换回匿名内存还是文件内存哪种更昂贵&lt;/strong&gt; 。设定的值越低，你就是在告诉内核说换出那些不常访问的
匿名页面在你的硬件上开销越昂贵；设定的值越高，你就是在告诉内核说在你的硬件上交换匿名页和
文件缓存的开销越接近。内存管理子系统仍然还是会根据实际想要回收的内存的访问热度尝试自己决定具体是
交换出文件还是匿名页面，只不过 swappiness 会在两种回收方式皆可的时候，在计算开销权重的过程中左右
是该更多地做交换还是丢弃缓存。在 SSD 上这两种方式基本上是同等开销，所以设成
&lt;code class="code"&gt;
vm.swappiness = 100&lt;/code&gt;
 （同等比重）可能工作得不错。在传统磁盘上，交换页面可能会更昂贵，
因为通常需要随机读取，所以你可能想要设低一些。&lt;/p&gt;
&lt;a aria-controls="916d89d2" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#916d89d2" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="916d89d2"&gt;
The reality is that most people don't really have a feeling about which
their hardware demands, so it's non-trivial to tune this value based on
instinct alone – this is something that you need to test using different
values. You can also spend time evaluating the memory composition of your
system and core applications and their behaviour under mild memory reclamation.&lt;/blockquote&gt;
&lt;p&gt;现实是大部分人对他们的硬件需求没有什么感受，所以根据直觉调整这个值可能挺困难的 ——
你需要用不同的值做测试。你也可以花时间评估一下你的系统的内存分配情况和核心应用在大量回收内存的时候的行为表现。&lt;/p&gt;
&lt;a aria-controls="1716806c" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#1716806c" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="1716806c"&gt;
When talking about &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 , an extremely important change to
consider from recent(ish) times is
&lt;a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=fe35004fbf9eaf67482b074a2e032abb9c89b1dd"&gt;this change to vmscan by Satoru Moriya in 2012&lt;/a&gt;
, which changes the way that &lt;code class="code"&gt;
vm.swappiness = 0&lt;/code&gt;
 is handled
quite significantly.&lt;/blockquote&gt;
&lt;p&gt;讨论 &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;
 的时候，一个极为重要需要考虑的修改是（相对）近期在
&lt;a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=fe35004fbf9eaf67482b074a2e032abb9c89b1dd"&gt;2012 年左右 Satoru Moriya 对 vmscan 行为的修改&lt;/a&gt;
，它显著改变了代码对 &lt;code class="code"&gt;
vm.swappiness = 0&lt;/code&gt;
 这个值的处理方式。&lt;/p&gt;
&lt;a aria-controls="0d73ddd8" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#0d73ddd8" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="0d73ddd8"&gt;
Essentially, the patch makes it so that we are extremely biased against
scanning (and thus reclaiming) any anonymous pages at all with
&lt;code class="code"&gt;
vm.swappiness = 0&lt;/code&gt;
 , unless we are already encountering severe
memory contention. As mentioned previously in this post, that's generally
not what you want, since this prevents equality of reclamation prior to
extreme memory pressure occurring, which may actually lead to this
extreme memory pressure in the first place. &lt;code class="code"&gt;
vm.swappiness = 1&lt;/code&gt;

is the lowest you can go without invoking the special casing for
anonymous page scanning implemented in that patch.&lt;/blockquote&gt;
&lt;p&gt;基本上来说这个补丁让我们在 &lt;code class="code"&gt;
vm.swappiness = 0&lt;/code&gt;
 的时候会极度避免扫描（进而回收）匿名页面，
除非我们已经在经历严重的内存抢占。就如本文前面所属，这种行为基本上不会是你想要的，
因为这种行为会导致在发生内存抢占之前无法保证内存回收的公平性，这甚至可能是最初导致发生内存抢占的原因。
想要避免这个补丁中对扫描匿名页面的特殊行为的话， &lt;code class="code"&gt;
vm.swappiness = 1&lt;/code&gt;
 是你能设置的最低值。&lt;/p&gt;
&lt;a aria-controls="8283fab5" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#8283fab5" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="8283fab5"&gt;
The kernel default here is &lt;code class="code"&gt;
vm.swappiness = 60&lt;/code&gt;
. This value is
generally not too bad for most workloads, but it's hard to have a
general default that suits all workloads. As such, a valuable extension
to the tuning mentioned in the "how much swap do I need" section above
would be to test these systems with differing values for &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;

, and monitor your application and system metrics under heavy (memory) load.
Some time in the near future, once we have a decent implementation of
&lt;a class="reference external" href="https://youtu.be/ikZ8_mRotT4?t=2145"&gt;refault detection&lt;/a&gt; in the kernel,
you'll also be able to determine this somewhat workload-agnostically by
looking at cgroup v2's page refaulting metrics.&lt;/blockquote&gt;
&lt;p&gt;内核在这里设置的默认值是 &lt;code class="code"&gt;
vm.swappiness = 60&lt;/code&gt;
 。这个值对大部分工作负载来说都不会太坏，
但是很难有一个默认值能符合所有种类的工作负载。因此，对上面「 &lt;a class="reference internal" href="#id17"&gt;那么，我需要多少交换空间？&lt;/a&gt;
」那段讨论的一点重要扩展可以说，在测试系统中可以尝试使用不同的 &lt;code class="code"&gt;
vm.swappiness&lt;/code&gt;

，然后监视你的程序和系统在重（内存）负载下的性能指标。在未来某天，如果我们在内核中有了合理的
&lt;a class="reference external" href="https://youtu.be/ikZ8_mRotT4?t=2145"&gt;缺页检测&lt;/a&gt; ，你也将能通过 cgroup v2 的页面缺页
指标来以负载无关的方式决定这个。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="https://www.youtube.com/watch?v=beefUhRH5lU"&gt;SREcon19 Asia/Pacific - Linux Memory Management at Scale: Under the Hood&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/beefUhRH5lU"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id19"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id35"&gt;2019年07月更新：内核 4.20+ 中的内存压力指标&lt;/a&gt;&lt;/h3&gt;
&lt;a aria-controls="2cbb410f" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#2cbb410f" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="2cbb410f"&gt;
The refault metrics mentioned as in development earlier are now in the
kernel from 4.20 onwards and can be enabled with &lt;code class="code"&gt;
CONFIG_PSI=y&lt;/code&gt;

. See my talk at SREcon at around the 25:05 mark:&lt;/blockquote&gt;
&lt;p&gt;前文中提到的开发中的内存缺页检测指标已经进入 4.20+ 以上版本的内核，可以通过
&lt;code class="code"&gt;
CONFIG_PSI=y&lt;/code&gt;
 开启。详情参见我在 SREcon 大约 25:05 左右的讨论。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id20"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id36"&gt;结论&lt;/a&gt;&lt;/h2&gt;
&lt;a aria-controls="01142bf6" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#01142bf6" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;blockquote class="collapse" id="01142bf6"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Swap is a useful tool to allow equality of reclamation of memory pages,
but its purpose is frequently misunderstood, leading to its negative
perception across the industry. If you use swap in the spirit intended,
though – as a method of increasing equality of reclamation – you'll
find that it's a useful tool instead of a hindrance.&lt;/li&gt;
&lt;li&gt;Disabling swap does not prevent disk I/O from becoming a problem under
memory contention, it simply shifts the disk I/O thrashing from anonymous
pages to file pages. Not only may this be less efficient, as we have
a smaller pool of pages to select from for reclaim, but it may also
contribute to getting into this high contention state in the first place.&lt;/li&gt;
&lt;li&gt;Swap can make a system slower to OOM kill, since it provides another,
slower source of memory to thrash on in out of memory situations – the
OOM killer is only used by the kernel as a last resort, after things have
already become monumentally screwed. The solutions here depend on your system:&lt;ul&gt;
&lt;li&gt;You can opportunistically change the system workload depending on
cgroup-local or global memory pressure. This prevents getting into these
situations in the first place, but solid memory pressure metrics are
lacking throughout the history of Unix. Hopefully this should be
better soon with the addition of refault detection.&lt;/li&gt;
&lt;li&gt;You can bias reclaiming (and thus swapping) away from certain processes
per-cgroup using memory.low, allowing you to protect critical daemons
without disabling swap entirely.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;交换区是允许公平地回收内存的有用工具，但是它的目的经常被人误解，导致它在业内这种负面声誉。如果
你是按照原本的目的使用交换区的话——作为增加内存回收公平性的方式——你会发现它是很有效的工具而不是阻碍。&lt;/li&gt;
&lt;li&gt;禁用交换区并不能在内存竞争的时候防止磁盘I/O的问题，它只不过把匿名页面的磁盘I/O变成了文件页面的
磁盘I/O。这不仅更低效，因为我们回收内存的时候能选择的页面范围更小了，而且它可能是导致高度内存竞争
状态的元凶。&lt;/li&gt;
&lt;li&gt;有交换区会导致系统更慢地使用 OOM 杀手，因为在缺少内存的情况下它提供了另一种更慢的内存，
会持续地内存颠簸——内核调用 OOM 杀手只是最后手段，会晚于所有事情已经被搞得一团糟之后。
解决方案取决于你的系统：&lt;ul&gt;
&lt;li&gt;你可以预先更具每个 cgroup 的或者系统全局的内存压力改变系统负载。这能防止我们最初进入内存竞争
的状态，但是 Unix 的历史中一直缺乏可靠的内存压力检测方式。希望不久之后在有了
&lt;a class="reference external" href="https://youtu.be/ikZ8_mRotT4?t=2145"&gt;缺页检测&lt;/a&gt; 这样的性能指标之后能改善这一点。&lt;/li&gt;
&lt;li&gt;你可以使用 &lt;code class="code"&gt;
memory.low&lt;/code&gt;
 让内核不倾向于回收（进而交换）特定一些 cgroup 中的进程，
允许你在不禁用交换区的前提下保护关键后台服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr class="docutils"/&gt;
&lt;p&gt;感谢在撰写本文时 &lt;a class="reference external" href="https://github.com/rahulg"&gt;Rahul&lt;/a&gt; ，
&lt;a class="reference external" href="https://github.com/htejun"&gt;Tejun&lt;/a&gt; 和
&lt;a class="reference external" href="https://patchwork.kernel.org/project/LKML/list/?submitter=45"&gt;Johannes&lt;/a&gt;
提供的诸多建议和反馈。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="swap"></category><category term="mm"></category><category term="memory management"></category><category term="translate"></category><category term="swappiness"></category></entry><entry><title>系统中的大多数文件有多大？</title><link href="//farseerfc.me/zhs/file-size-histogram.html" rel="alternate"></link><published>2020-06-11T15:45:00+09:00</published><updated>2020-06-11T15:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2020-06-11:/zhs/file-size-histogram.html</id><summary type="html">
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;&lt;strong&gt;你觉得，你的系统中大多数文件大概有多大？&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这是一个很有意思的问题，你可以试着先猜一下。&lt;/p&gt;
&lt;p&gt;基于对系统中保存文件的了解，可能有这样的思考过程：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;我收藏了好多照片，每个有 2~5MiB 吧。&lt;/li&gt;
&lt;li&gt;我下载了好多漫画，每个 100KiB 左右，这些大概占了不少比例。&lt;/li&gt;
&lt;li&gt;我还收藏了不少动画电影电视剧，虽然这些文件总数量可能不多？&lt;/li&gt;
&lt;li&gt;我下载了 Linux 的源码，那里面每个 C 代码文件都几千行，每行 100 字宽，平均也得有 30KiB
吧，有几万个源码文件呢，占比应该挺大的……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问题中「大多数」其实是个挺不精确的称呼，换个精确点的问法：你觉得你的系统中 &lt;strong&gt;文件大小的中位数&lt;/strong&gt;
大概在什么范围内？或者说，文件系统中 &lt;strong&gt;文件大小的分布情况&lt;/strong&gt; 一般是怎样的曲线？&lt;/p&gt;
&lt;p&gt;这个问题其实还有多种别的问法，比如：一个常见的桌面或者服务器系统中，多大的文件算大文件，
多小的文件算小文件，什么范围内的大小算是普通呢？&lt;/p&gt;
&lt;p&gt;经历过基本的科学教育的人 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;&lt;strong&gt;你觉得，你的系统中大多数文件大概有多大？&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这是一个很有意思的问题，你可以试着先猜一下。&lt;/p&gt;
&lt;p&gt;基于对系统中保存文件的了解，可能有这样的思考过程：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;我收藏了好多照片，每个有 2~5MiB 吧。&lt;/li&gt;
&lt;li&gt;我下载了好多漫画，每个 100KiB 左右，这些大概占了不少比例。&lt;/li&gt;
&lt;li&gt;我还收藏了不少动画电影电视剧，虽然这些文件总数量可能不多？&lt;/li&gt;
&lt;li&gt;我下载了 Linux 的源码，那里面每个 C 代码文件都几千行，每行 100 字宽，平均也得有 30KiB
吧，有几万个源码文件呢，占比应该挺大的……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问题中「大多数」其实是个挺不精确的称呼，换个精确点的问法：你觉得你的系统中 &lt;strong&gt;文件大小的中位数&lt;/strong&gt;
大概在什么范围内？或者说，文件系统中 &lt;strong&gt;文件大小的分布情况&lt;/strong&gt; 一般是怎样的曲线？&lt;/p&gt;
&lt;p&gt;这个问题其实还有多种别的问法，比如：一个常见的桌面或者服务器系统中，多大的文件算大文件，
多小的文件算小文件，什么范围内的大小算是普通呢？&lt;/p&gt;
&lt;p&gt;经历过基本的科学教育的人，大概会做这样的基于科学假设的猜测：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;统计学上说，大量独立随机事件的累积概率满足正态分布（常态分布）曲线。假设我们把某个特定文件的大小增长
1字节看作是一次独立随机事件，那么文件大小在文件系统中应该是满足正态分布的？&lt;/li&gt;
&lt;li&gt;正态分布的前提下，平均数接近中位数，文件系统的已占用大小除以文件数量大概就是大部分文件的大小了吧。&lt;/li&gt;
&lt;li&gt;根据我现在文件系统的占用大小和文件数量，平均数大概是 500KiB 左右？&lt;/li&gt;
&lt;li&gt;虽然我还存了几个非常大，上 GiB 的文件，但是看起来似乎也有很多很多非常小的文件，
平均一下的话应该会把平均数拉大，大于中位数吧。那么中位数应该在 100KiB 这样的量级附近？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你说为什么要关心这个？因为我经常在网上看到这样的讨论：&lt;/p&gt;
&lt;p&gt;「我有个仓库盘要存很多下载到的漫画，每个漫画都是一个文件夹里面一堆 &lt;strong&gt;小 JPG&lt;/strong&gt; ，每个就几十 KiB
。网上看到的说法是 XFS 对 &lt;strong&gt;小文件&lt;/strong&gt; 的性能不那么好，我是不是该换 EXT4 ？我还想在 Windows
上能读写，是不是 ExFAT 这种简单的文件系统更合适一点？」&lt;/p&gt;
&lt;p&gt;「软件源的镜像服务器需要存的都是些 &lt;strong&gt;小文件&lt;/strong&gt; 吧，大多数软件包压缩后也就是几个 KiB 到几个
MiB 的量级，这种需求是不是适合用对 &lt;strong&gt;小文件&lt;/strong&gt; 优化比较好的文件系统？」&lt;/p&gt;
&lt;p&gt;「我的程序需要分析的数据是大量几百K的 &lt;strong&gt;小文件&lt;/strong&gt; ，该怎么存合适呢，直接用文件系统还是应该上数据库？
我还想多线程并发分析，是不是 SQL 数据库的并发能力强一些？又或者 MongoDB 的 GridFS
看起来似乎能结合文件系统和数据库的特点，选它应该还不错？」&lt;/p&gt;
&lt;p&gt;有没有觉得上面这些讨论和直觉有些出入？如果你的直觉告诉你，上面的讨论似乎很自然的话，
那说明你需要继续看下去了。&lt;/p&gt;
&lt;p&gt;好了写了这么多废话给大家思考时间，现在请回答一下我标题中那个问题，
&lt;strong&gt;你觉得，你的系统中大多数文件大概有多大？&lt;/strong&gt; ，接下来我要揭晓答案了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;统计实际系统中文件大小的学术研究&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="https://youtu.be/lTE26gkeVUs?t=452"&gt;A Study of Practical Deduplication&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/lTE26gkeVUs"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;最近看到一个挺早以前的研究报告，是 &lt;a class="reference external" href="https://www.usenix.org/legacy/events/fast11/"&gt;FAST'11&lt;/a&gt;
的最优秀论文奖，研究的课题叫 &lt;a class="reference external" href="https://www.usenix.org/legacy/event/fast11/tech/full_papers/Meyer.pdf"&gt;《A Study of Practical Deduplication》&lt;/a&gt;
。这个研究原本是想考察一下在桌面文件系统中「去重」（deduplication）的可行性和潜在收益，作为背景调查，
他们收集了一个挺大的调查样本，记录文件大小和校验和之类的。从论文摘要看，他们在微软公司内，
通过邮件的形式让微软员工在各自的工作机上执行他们的调查程序，大概在1个月左右的时间内收集到了 857
份调查结果。关于去重的研究结果这里我们这里先不深究，只看这个背景调查，他们对收集到的文件大小画了个图表：&lt;/p&gt;
&lt;img alt="file-histogram-4k.jpg" class="img-responsive" src="//farseerfc.me/zhs/images/file-histogram-4k.jpg"/&gt;
&lt;p&gt;他们结果显示最常见的文件大小是 &lt;strong&gt;4K&lt;/strong&gt; ！&lt;/p&gt;
&lt;p&gt;注意上图里的横轴座标，是按2的指数来给文件大小分类的。比如 128~256 字节的算一类， 4K~8K
字节的算一类，分类之后统计每一类里面文件的数量所占比例，也就是说横轴座标是指数增长的。
在指数增长的横轴座标上，画出的曲线才看起来像是正态分布的曲线，如果把横轴座标画成线性的话，
中位数会出现在非常靠近左侧小文件的地方。&lt;/p&gt;
&lt;p&gt;也就是说根据他们的统计，文件系统中大部分文件都是大概 2K 到 8K 这样的范围，最常见 4K 大小。
非常大的比如 8M 以上的文件只是极个别，位于图表右侧非常长的尾巴中。&lt;/p&gt;
&lt;p&gt;其实我对这个结果还不是很惊讶，因为我记得在 2000 年左右，当我家的电脑还在用 Windows 98 跑在
40G 的 FAT32 文件系统中的时候，读到过一篇介绍 NTFS 的「新」特性的文章。那篇文章讲到 FAT32
的簇大小随着分区大小增长，越来越大的簇大小对保存大量小文件极其浪费，而 NTFS 用固定的 4K
簇大小可避免这样的浪费，并且 1K MFT 记录甚至能「内联（inline）」存储非常小的文件。
为了证明大量小文件对文件系统是个现实存在的问题，那篇文章也提到了常见系统中的文件大小分布曲线，
提到了大部分文件都是 4K 大小这有点反直觉的结论。&lt;/p&gt;
&lt;p&gt;这次这个研究让我觉得吃惊的是，文件大小分布并没有随着硬盘大小的增加而增加，稳定在了 4K 这个数字上。
他们以前还进行过两次类似的统计，分别在 2000 年和 2004 年，图中的点线画出了历史上的统计分布，实线是
2009 年的最新统计。三年获得的统计结果的曲线基本吻合，这意味着随着存储容量增长，文件大小的分布几乎没有变化。&lt;/p&gt;
&lt;p&gt;正当我疑惑，这种文件大小不变的趋势，是否是因为微软公司内特定的操作系统和工作内容，
在别的系统上或者在更长的时间跨度上是否有类似的趋势呢？这时演讲的幻灯片翻了一页：&lt;/p&gt;
&lt;img alt="file-histogram-4k-since1981.jpg" class="img-responsive" src="//farseerfc.me/zhs/images/file-histogram-4k-since1981.jpg"/&gt;
&lt;p&gt;从早在 1981 年起，有研究表明文件系统中文件大小中位数就稳定在了 &lt;strong&gt;4K&lt;/strong&gt; ！&lt;/p&gt;
&lt;p&gt;在他们论文的参考文献中，能找到 &lt;a class="reference external" href="https://www.cs.cmu.edu/~satya/docdir/satya-sosp-1981.pdf"&gt;这个 1981 年的研究&lt;/a&gt;
。这篇早年的调查是在 DEC 的 PDP-10 机器上，使用 TOPS-10 操作系统。从现在的视点来看，被调查的
TOPS-10 的文件系统已经可以说非常初级了，没法支持很大的文件或者很多的文件，
然而即便如此常见文件大小也还是非常符合现代系统中得到的结果。&lt;/p&gt;
&lt;p&gt;微软的研究者们还回顾了计算机科学领域多年的相关研究，结论是常见文件大小这个值在 1981 到 2009
这近 30 年中都非常稳定。演讲的原文中这么评价：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;…… the median file size is 4k. It was 4k the other two years of the study.
We've actually gone back through the literature. It turns out it's 4k in every
study going back to the last 30 years. So this is great news. We can finally
compete with physicists: we have our own fundamental constant of the
universe, it's a medium file size ……&lt;/p&gt;
&lt;p&gt;文件大小中位数是 4K 。在前几年的两次研究中它也是 4K 。其实我们回顾了既往的学术研究，发现在过去30
年中每个研究都说它是 4K 这个值。这是个好消息，我们终于有了一个堪比物理学家的结论：我们有我们自己的
宇宙基本常数了，是文件大小中位数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个结论很有意思，文件大小中位数在计算机科学领域的稳定程度堪比宇宙基本常数： &lt;strong&gt;4K&lt;/strong&gt; ！&lt;/p&gt;
&lt;p&gt;很明显这是在调侃，文件大小这种变化很大的数字显然和文件系统内存储的内容直接相关，
存游戏的可能不同于存音乐的。但是这调侃的背后也有一定真实性：文件系统中保存的文件，
除了用户直接使用的那些视频、文档、代码，还有大量文件是程序内部创建使用的，比如浏览器的缓存和
cookie ，这类不被用户知晓的文件可能在数量上反而占据绝大多数。
于是从文件系统这边来看，大多数文件都是在 &lt;strong&gt;4K&lt;/strong&gt; 左右的数量级，更大的文件是少数。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;不信？你可以测一下自己的文件系统&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我也想测一下我的文件系统中文件大小的分布情况，于是稍微写了点代码测量和画图。如果你也想知道你的系统中
文件大小的分布，那么可以像我这样测。&lt;/p&gt;
&lt;p&gt;首先用 &lt;code class="code"&gt;
find&lt;/code&gt;
 命令统计一下每个文件的大小，输出到一个文件里：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;find /home -type f -printf &lt;span class="s2"&gt;"%s %p\n"&lt;/span&gt; &amp;gt; myhome.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述命令对 &lt;code class="code"&gt;
/​home&lt;/code&gt;
 中的所有普通文件而忽略文件夹和符号链接之类的（ &lt;code class="code"&gt;
-type f&lt;/code&gt;

），输出文件大小字节数和文件路径（ &lt;code class="code"&gt;
-printf "%s %p\n"&lt;/code&gt;
 ）。
如果文件名路径中有特殊符号可能之后比较难处理，那么可以 &lt;code class="code"&gt;
-printf "%s\n"&lt;/code&gt;

忽略路径。&lt;/p&gt;
&lt;p&gt;然后用 Python 的 Matplotlib 和 NumPy 对收集到的文件大小数据画个直方图（histogram）。
以下 &lt;a class="reference external" href="https://github.com/farseerfc/dotfiles/blob/master/zsh/.local/bin/filesizehistogram.py"&gt;filesizehistogram.py 脚本在这儿&lt;/a&gt;
能下载到。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/python3&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;plt&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;math&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;bisect&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;bisect_left&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;numfmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;marks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"KMGTP"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;marks&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="mf"&gt;1024.0&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;//=&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="si"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;.2f&lt;/span&gt;&lt;span class="si"&gt;}{&lt;/span&gt;&lt;span class="n"&gt;marks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="si"&gt;}{&lt;/span&gt;&lt;span class="n"&gt;marks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;prog&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"filesizehistogram"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;description&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;            can use "-" as input filename, indicate input is taken from stdin.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;            otherwise input file should be a result of "find -printf &lt;/span&gt;&lt;span class="se"&gt;\'&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt; %p&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s2"&gt;n&lt;/span&gt;&lt;span class="se"&gt;\'&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;            """&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'-o'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'--output'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"output filename, will recognize common extensions by matplot"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'input'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'+'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"input filenames"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;filenames&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s1"&gt;'-'&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="s1"&gt;'/dev/stdin'&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;' '&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;fn&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;filenames&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;mindatalog2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="c1"&gt;# cut from 32&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;maxdatalog2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ceil&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;log2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;())),&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# cut at 1G and above&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="c1"&gt;# bins [0, 1, 32, 64, 128, 256, ... , 1G, 2G] , last bin is open range&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;bins&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mindatalog2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxdatalog2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;median&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;median&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;mean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;bmedian&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bisect_left&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bins&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;median&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;bmean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bisect_left&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bins&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mean&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;hist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bin_edges&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;histogram&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;bins&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;fig&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ax&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;subplots&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;figsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hist&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="n"&gt;hist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_xticks&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hist&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;tickbar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"┊&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_xticklabels&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;tickbar&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="si"&gt;}{&lt;/span&gt;&lt;span class="n"&gt;numfmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bins&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;~&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;numfmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bins&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hist&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;                    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;numfmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bins&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hist&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;~"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;axvline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bmean&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'k'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;linestyle&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'dashed'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;linewidth&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;axvline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bmedian&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'r'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;linestyle&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'dashed'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;linewidth&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;min_ylim&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_ylim&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ylim&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;min_xlim&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_xlim&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlim&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bmean&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;   &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_ylim&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;'Mean: &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;numfmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bmedian&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_ylim&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;'Median: &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;numfmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;median&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'r'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_xlim&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_ylim&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;'Files: &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_xlim&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_ylim&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;'Total: &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;numfmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hist&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hist&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;hist&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="si"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;5&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# label on top of every bar, uplefted a little&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;savefig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就能 &lt;code class="code"&gt;
./​filesizehistogram.py myhome.txt&lt;/code&gt;
 这样画出一张图。以下是我一台机器上根目录
&lt;code class="code"&gt;
/​&lt;/code&gt;
 和家目录 &lt;code class="code"&gt;
/​home&lt;/code&gt;
 放在一起的结果：&lt;/p&gt;
&lt;img alt="myroot.png" class="img-responsive" src="//farseerfc.me/zhs/images/myroot.png"/&gt;
&lt;p&gt;图中我用点线标出了中位数（median）和平均数（mean）大小的位置，可见在我的文件系统中，
文件大小中位数在 2.24K ，平均数是 88.09K ，512~8K
范围内的文件数量加在一起超过了文件总数一半。文件数量最多的范围是 1K~2K
，大概因为我家里存了好多源代码。还有一个小突起在 64K~128K ，这堆主要是我收藏的漫画 JPG 文件。&lt;/p&gt;
&lt;p&gt;图的横座标和上面微软的研究类似，用2倍增长的bin统计文件数量。
不过稍微修改了一下，因为我想知道 0 大小文件的个数，还想把 1~32 和 1G~
以上这两个曲线底端的尾巴放在一起统计。图的纵座标是文件数。&lt;/p&gt;
&lt;p&gt;也可以用这个来画你感兴趣的文件夹的文件大小分布，比如用 linux 内核代码树画出来的图大概这样：&lt;/p&gt;
&lt;img alt="linux-filesize.png" class="img-responsive" src="//farseerfc.me/zhs/images/linux-filesize.png"/&gt;
&lt;p&gt;linux 代码树的文件大部分比我猜的 30K 要小呢，主要在 1K~16K ，中位数 3.28K
。而且意外得在代码树里有好几个 0 大小的文件，看了几个文件路径确认了一下，它们的确是 0
大小的头文件，并不是我的文件系统丢了文件内容。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;结论&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;有没有觉得「文件大小的中位数是 4K 」这个结论出乎意料呢？&lt;/p&gt;
&lt;p&gt;你在用的系统中文件大小的分布曲线又是什么样的呢？欢迎留言告诉我。（贴图可以用
&lt;a class="reference external" href="https://fars.ee/f"&gt;https://fars.ee/f&lt;/a&gt; 图床呀）&lt;/p&gt;
&lt;p&gt;知道了文件大小分布的规律，就会发现设计文件系统的时候，需要考虑两个极端情况：
既要照顾到文件系统中数量很少而大小超大的那些文件，又要考虑到这么多数量众多而大小只有数 K
的文件。也会发现，对于文件系统而言，超过 16K 的文件就绝不会被算作是「小文件」了，而文件系统设计中说的
「小文件优化」针对的通常是更小的文件大小。并且这一趋势并不会随着存储设备容量增加而改变，
不能妄图通过随着容量逐步增加文件分配「簇」大小的方式，来简化文件系统设计。&lt;/p&gt;
&lt;p&gt;那么众多文件系统实际是如何满足这些极端情况的呢？待我有空再细聊……&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="FS笔记"></category><category term="FS notes"></category><category term="file"></category><category term="size"></category><category term="histogram"></category></entry><entry><title>SSD 就是大U盘？聊聊闪存类存储的转换层</title><link href="//farseerfc.me/zhs/flash-storage-ftl-layer.html" rel="alternate"></link><published>2020-03-18T15:45:00+09:00</published><updated>2020-03-18T15:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2020-03-18:/zhs/flash-storage-ftl-layer.html</id><summary type="html">
&lt;p&gt;上篇 &lt;a class="reference external" href="//farseerfc.me/zhs/history-of-chs-addressing.html"&gt;「柱面-磁头-扇区寻址的一些旧事」&lt;/a&gt;
整理了一下我对磁盘类存储设备（包括软盘、硬盘，不包括光盘、磁带）的一些理解，
算是为以后讨论文件系统作铺垫；这篇整理一下我对闪存类存储设备的理解。&lt;/p&gt;
&lt;p&gt;这里想要讨论的闪存类存储是指 SSD 、SD卡、U盘、手机内置闪存等基于 NAND
又有闪存转换层的存储设备（下文简称闪存盘），但不包括裸 NAND 设备、3D Xpoint （Intel
Optane）等相近物理结构但是没有类似的闪存转换层的存储设备。
闪存类存储设备这几年发展迅猛，SD卡和U盘早就替代软盘成为数据交换的主流， SSD 大有替代硬盘的趋势。
因为发展迅速，所以其底层技术变革很快，不同于磁盘类存储技术有很多公开资料可以获取，
闪存类存储的技术细节通常是厂商们的秘密，互联网上能找到很多外围资料，
但是关于其如何运作的细节却很少提到。所以我想先整理一篇笔记，记下我搜集到的资料，加上我自己的理解。
本文大部分信息来源是 &lt;a class="reference external" href="https://lwn.net/Articles/428584/"&gt;Optimizing Linux with cheap flash drives&lt;/a&gt;
和 &lt;a class="reference external" href="https://accelazh.github.io/ssd/A-Summary-On-SSD-And-FTL"&gt;A Summary on …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">
&lt;p&gt;上篇 &lt;a class="reference external" href="//farseerfc.me/zhs/history-of-chs-addressing.html"&gt;「柱面-磁头-扇区寻址的一些旧事」&lt;/a&gt;
整理了一下我对磁盘类存储设备（包括软盘、硬盘，不包括光盘、磁带）的一些理解，
算是为以后讨论文件系统作铺垫；这篇整理一下我对闪存类存储设备的理解。&lt;/p&gt;
&lt;p&gt;这里想要讨论的闪存类存储是指 SSD 、SD卡、U盘、手机内置闪存等基于 NAND
又有闪存转换层的存储设备（下文简称闪存盘），但不包括裸 NAND 设备、3D Xpoint （Intel
Optane）等相近物理结构但是没有类似的闪存转换层的存储设备。
闪存类存储设备这几年发展迅猛，SD卡和U盘早就替代软盘成为数据交换的主流， SSD 大有替代硬盘的趋势。
因为发展迅速，所以其底层技术变革很快，不同于磁盘类存储技术有很多公开资料可以获取，
闪存类存储的技术细节通常是厂商们的秘密，互联网上能找到很多外围资料，
但是关于其如何运作的细节却很少提到。所以我想先整理一篇笔记，记下我搜集到的资料，加上我自己的理解。
本文大部分信息来源是 &lt;a class="reference external" href="https://lwn.net/Articles/428584/"&gt;Optimizing Linux with cheap flash drives&lt;/a&gt;
和 &lt;a class="reference external" href="https://accelazh.github.io/ssd/A-Summary-On-SSD-And-FTL"&gt;A Summary on SSD &amp;amp; FTL&lt;/a&gt;
，加上我的理解，文中一些配图也来自这两篇文章。&lt;/p&gt;
&lt;div class="section" id="nand-flash"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;1   NAND Flash 原理&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;比 NAND Flash 更早的 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/EEPROM"&gt;EEPROM&lt;/a&gt; 等存储技术
曾经用过 NOR Flash cell ，用于存储主板配置信息等少量数据已经存在 PC 中很久了。后来
NAND Flash 的微型化使得 NAND Flash 可以用于存储大量数据，急剧降低了存储成本，所以以 NAND
Flash 为基础的存储技术能得以替代硬盘等存储设备。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="https://openiotelceurope2016.sched.com/event/7rsF/tutorial-why-nand-flash-breaks-down-arnout-vandecappelle-essensiummind"&gt;Tutorial: Why NAND Flash Breaks Down&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/VajB8vCsZ3s"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里不想涉及太多 NAND Flash 硬件细节，有个演讲
&lt;a class="reference external" href="https://openiotelceurope2016.sched.com/event/7rsF/tutorial-why-nand-flash-breaks-down-arnout-vandecappelle-essensiummind"&gt;Tutorial: Why NAND Flash Breaks Down&lt;/a&gt;
和 &lt;a class="reference external" href="https://youtu.be/VajB8vCsZ3s"&gt;YouTube 视频&lt;/a&gt;
介绍了其原理，感兴趣的可以参考一下。只罗列一下视频中提到的一些 NAND Flash 的特点：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;NAND Flash 使用 floating gate 中束缚电子来保存二进制数据，对这些 Cell 有读取（Read）、
写入（Programming）、擦除（Erase）的操作。擦写次数叫 P/E cycle。&lt;/li&gt;
&lt;li&gt;电子的量导致的电势差可以区别 1 和 0 ，这是 Single Level Cell (SLC) 的存储方式。
或者可以用不同的电势差区分更多状态保存更多二进制位，从而有 Multi-Level Cell (MLC)，
TLC， QLC 等技术。可以对 MLC 的 Flash Cell 使用类似 SLC 的写入模式，物理区别只是参考电压，
只是 SLC 模式写入下容量减半。&lt;/li&gt;
&lt;li&gt;高密度设计下，一组 NAND Flash Cell 可以同时并发读写。所以有了读写页 2KiB/4KiB 这样的容量。
页面越大，存储密度越高，为了降低成本厂商都希望提高读写页的大小。&lt;/li&gt;
&lt;li&gt;为了避免添加额外导线，NAND Flash Cell 是使用基板上加负电压的方式擦除 floating gate
中的二进制位的，所以擦除操作没法通过地址线选择特定 Cell 或者读写页，于是整块擦除有块大小。&lt;/li&gt;
&lt;li&gt;写入操作对 SLC 单个 Cell 而言，就是把 1 置 0 ，而擦除操作则是把整块置 1 。SLC
可以通过地址线单独选择要写入的 Cell ，MLC 则把不同页的二进制放入一个 Cell ，放入时有顺序要求，
先写处于高位的页，再写低位的。所以 MLC 中不同页面地址的页面是交错在同一组 Cell 中的。&lt;/li&gt;
&lt;li&gt;SLC 其实并没有特别要求擦除块中的写入顺序，只是要求仅写一次（从 1 到 0）。
MLC 则有先写高位页再写低位页的要求。厂商规格中的要求更严格，擦除块中必须满足按页面编号顺序写入。&lt;/li&gt;
&lt;li&gt;写入和擦除操作是通过量子隧道效应把电子困在 floating gate 中的，所以是个概率事件。通过多次脉冲
可以缩小发生非预期概率事件的可能性，但是没法完全避免，所以需要 ECC 校验纠错。&lt;/li&gt;
&lt;li&gt;根据 ECC 强度通常有三种 ECC 算法，强度越强需要越多算力：&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://zh.wikipedia.org/zh-hans/%E6%B1%89%E6%98%8E%E7%A0%81"&gt;汉民码&lt;/a&gt;
可根据 n bit 探测 &lt;span class="math"&gt;\(2^n - n -1\)&lt;/span&gt; 中的 2 bit 错误，修正 1 bit 错误。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://zh.wikipedia.org/wiki/BCH%E7%A0%81"&gt;BCH码&lt;/a&gt; 可根据 &lt;span class="math"&gt;\(n*m\)&lt;/span&gt; bit
纠错 &lt;span class="math"&gt;\(2^n\)&lt;/span&gt; bit 中的 &lt;span class="math"&gt;\(m\)&lt;/span&gt; bit 错误。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://zh.wikipedia.org/wiki/%E4%BD%8E%E5%AF%86%E5%BA%A6%E5%A5%87%E5%81%B6%E6%AA%A2%E6%9F%A5%E7%A2%BC"&gt;LDPC&lt;/a&gt;
原理上类似扩展的汉民码，能做到使用更少校验位纠错更多错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因为 ECC 的存在，所以读写必须至少以 ECC 整块为单位，比如 256 字节或者整个页面。&lt;/li&gt;
&lt;li&gt;也因为 ECC 的存在， &lt;span class="math"&gt;\(ECC(\texttt{0xFF}) \ne \texttt{0xFF}\)&lt;/span&gt;
，空页（擦除后全1的页面）必须特殊处理。所以需要区分写了数据全 1 的页和空页。&lt;/li&gt;
&lt;li&gt;ECC校验多次失败的页面可以被标记为坏页，出厂时就可能有一些坏页，这些由转换层隐藏起来。&lt;/li&gt;
&lt;li&gt;断电后，也有小概率下束缚的电子逃逸出 floating gate ，时间越长越可能发生可以探测到的位反转。
所以基于 NAND Flash 的存储设备应该避免作为存档设备离线保存。&lt;/li&gt;
&lt;li&gt;电子逃逸的概率也和温度有关，温度越高越容易逃逸，所以高温使用下会有更高的校验错误率。&lt;/li&gt;
&lt;li&gt;读取时，因为用相对较高的电压屏蔽没有读取的地址线，有一定概率影响到没被读取的页面中存储的数据。
控制器可能考虑周期性地刷新这些写入后多次读取的页面，这可能和后文的静态擦写均衡一起做。&lt;/li&gt;
&lt;li&gt;正在写入或者擦除中突然断电的话下，写入中的一整页数据可能并不稳定，比如短期内能正常读取但是难以持续很长时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="https://openiotelceurope2016.sched.com/event/7rsF/tutorial-why-nand-flash-breaks-down-arnout-vandecappelle-essensiummind"&gt;MLC 擦写次数与错误率&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="ssd-pe-cycles.png" class="img-responsive" src="//farseerfc.me/zhs/images/ssd-pe-cycles.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上篇讲硬盘的笔记中提到过，硬盘物理存储也有越来越强的校验机制，不过相比之下 NAND Flash
出现临时性校验失败的可能性要高很多，需要控制器对校验出错误的情况有更强的容忍能力。
厂商们制作存储设备的时候，有一个需要达到的错误率目标（比如平均 &lt;span class="math"&gt;\(10^{14}\)&lt;/span&gt; bit
出现一次位反转），针对这个目标和实际物理错误率，相应地设计纠错强度。校验太强会浪费存储密度和算力，
从而提升成本，这里会根据市场细分找折衷点。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;2   封装结构&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;从外部来看，一个闪存盘可能有这样的结构：&lt;/p&gt;
&lt;object class="embed-responsive-item" data="//farseerfc.me/zhs/images/ssd-enclosure.svg" type="image/svg+xml"&gt;
ssd-enclosure.svg&lt;/object&gt;
&lt;p&gt;从上往下，我们买到的一个闪存盘可能一层层分级：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;整个闪存盘有个控制器，其中含有一部分 RAM 。然后是一组 NAND Flash 封装芯片（chip）。&lt;/li&gt;
&lt;li&gt;每个封装芯片可能还分多个 Device ，每个 Device 分多个 Die ，这中间有很多术语我无法跟上，大概和本文想讨论的事情关系不大。&lt;/li&gt;
&lt;li&gt;每个 Die 分多个平面（Plane），平面之间可以并行控制，每个平面相互独立。从而比如在一个平面内
做某个块的擦除操作的时候，别的平面可以继续读写而不受影响。&lt;/li&gt;
&lt;li&gt;每个平面分成多个段（Segment)，段是擦除操作的基本单位，一次擦除一整个段。&lt;/li&gt;
&lt;li&gt;每个段分成多个页面（Page），页面是读写操作的基本单位，一次可以读写一整页。&lt;/li&gt;
&lt;li&gt;页面内存有多个单元格（Cell），单元格是存储二进制位的基本单元，对应 SLC/MLC/TLC/QLC 这些，
每个单元格可以存储一个或多个二进制位。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上这些名字可能不同厂商不同文档的称法都各有不同，比如可能有的文档把擦除块叫 page 或者叫
eraseblock 。随着容量不断增大，厂商们又新造出很多抽象层次，比如 chip device die 这些，
不过这些可能和本文关系不大。如果看别的文档注意区别术语所指概念，本文中我想统一成以上术语。
重要的是有并行访问单元的平面（Plane）、擦除单元的段（Segment）、读写单元的页（Page）这些概念。
抽象地列举概念可能没有实感，顺便说一下这些概念的数量级：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;每个 SSD 可以有数个封装芯片。&lt;/li&gt;
&lt;li&gt;每个芯片有多个 Die 。&lt;/li&gt;
&lt;li&gt;每个 Die 有多个平面。&lt;/li&gt;
&lt;li&gt;每个平面有几千个段。比如 2048 个。&lt;/li&gt;
&lt;li&gt;每个段有数百个页到几千页，比如 128~4096 页，可能外加一些段内元数据。&lt;/li&gt;
&lt;li&gt;每个页面是 2KiB~8KiB 这样的容量，外加几百字节的元数据比如 ECC 校验码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;和硬盘相比，一个闪存页面大概对应一个到数个物理扇区大小，现代硬盘也逐渐普及 4KiB 物理扇区，
文件系统也基本普及 4KiB 或者更大的逻辑块（block）或者簇（cluster）大小，可以对应到一个闪存页面。
每次读写都可以通过地址映射直接对应到某个闪存页面，这方面没有硬盘那样的寻址开销。
闪存盘的一个页面通常配有比硬盘扇区更强的 ECC 校验码，因为 NAND
单元格丧失数据的可能性比磁介质高了很多。&lt;/p&gt;
&lt;p&gt;闪存有写入方式的限制，每次写入只能写在「空」的页面上，不能覆盖写入已有数据的页面。
要重复利用已经写过的页面，需要对页面所在段整个做擦除操作，每个段是大概 128KiB 到 8MiB
这样的数量级。每个擦除段需要统计校验失败率或者跟踪擦除次数，以进行擦写均衡（Wear Leveling）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="wear-leveling-flash-translation-layer"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;3   擦写均衡（Wear Leveling）和映射层（Flash Translation Layer）&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="https://lwn.net/Articles/428793/"&gt;Animation: wear leveling on SSD drives&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="ssd-segment.gif" class="img-responsive" src="//farseerfc.me/zhs/images/ssd-segment.gif"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;擦除段的容量大小是个折衷，更小的擦除段比如 128KiB 更适合随机读写，
因为每随机修改一部分数据时需要垃圾回收的粒度更小；而使用更大的擦除段可以减少元数据和地址映射的开销。
从擦除段的大小这里，已经开始有高端闪存和低端闪存的差异，比如商用 SSD 可能比 U 盘和 SD
卡使用更小的擦除段大小。&lt;/p&gt;
&lt;p&gt;闪存盘中维护一个逻辑段地址到物理段地址的映射层，叫闪存映射层（Flash Translation Layer
）。每次写一个段的时候都新分配一个空段，
写完后在映射表中记录其物理地址。映射表用来在读取时做地址转换，所以映射表需要保存在闪存盘控制器的
RAM 中，同时也需要记录在闪存内。具体记录方式要看闪存盘控制器的实现，可能是类似日志的方式记录的。&lt;/p&gt;
&lt;p&gt;「段地址映射表」的大小可以由段大小和存储设备容量推算出来。比如对一个 64GiB 的 SD
卡，如果使用 4MiB 的段大小，那么需要至少 16K 个表项。假设映射表中只记录 2B 的物理段地址，
那么需要 32KiB 的 RAM 存储段地址映射表。对一个 512GiB 的 SSD ，如果使用 128KiB 的段大小，
那么至少需要 4M 个表项。记录 4B 的物理段地址的话，需要 16MiB 的 RAM 存储地址映射，
或者需要动态加载的方案只缓存一部分到 RAM 里。控制器中的
RAM 比 NAND 要昂贵很多，这里可以看出成本差异。&lt;/p&gt;
&lt;p&gt;除了地址映射表，每个物理段还要根据擦除次数或者校验错误率之类的统计数据，做擦写均衡。有两种擦写均衡：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;动态擦写均衡（Dynamic Wear Leveling）：每次写入新段时选择擦除次数少的物理段。&lt;/li&gt;
&lt;li&gt;静态擦写均衡（Static Wear Leveling）：空闲时，偶尔将那些许久没有变化的逻辑段搬运到
多次擦除的物理段上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;低端闪存比如 SD 卡和 U 盘可能只有动态擦写均衡，更高端的 SSD 可能会做静态擦写均衡。
静态擦写均衡想要解决的问题是：盘中写入的数据可以根据写入频率分为冷热，
总有一些冷数据写入盘上就不怎么变化了，它们占用着的物理段有比较低的擦除计数。
只做动态擦写均衡的话，只有热数据的物理段被频繁擦写，加速磨损，
通过静态擦写均衡能将冷数据所在物理段释放出来，让整体擦写更平均。
但是静态擦写均衡搬运数据本身也会磨损有限的擦写次数，这需要优秀的算法来折衷。&lt;/p&gt;
&lt;p&gt;除了擦写均衡用的统计数据外， FTL 也要做坏块管理。闪存盘出厂时就有一定故障率，可能有一部分坏块。
随着消耗擦写周期、闲置时间、环境温度等因素影响，也会遇到一些无法再保证写入正确率的坏块。
NAND Flash 上因为量子隧道效应，偶尔会有临时的校验不一致，遇到这种情况，除了根据 ECC
校验恢复数据， FTL 也负责尝试对同一个物理段多次擦除和读写，考察它的可用性。排除了临时故障后，
如果校验不一致的情况仍然持续，那么需要标注它为坏块，避免今后再写入它。&lt;/p&gt;
&lt;p&gt;出厂时，闪存盘配有的物理段数量就高于标称的容量，除了出厂时的坏块之外，剩余的可用物理段可以用于
擦写均衡，这种行为称作 &lt;a class="reference external" href="https://zh.wikipedia.org/wiki/%E5%86%99%E5%85%A5%E6%94%BE%E5%A4%A7#%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4"&gt;Over Provisioning&lt;/a&gt;
。除了盘内预留的这些空间，用户也可以主动通过分区的方式或者文件系统 TRIM 的方式预留出更多可用空间，
允许 FTL 更灵活地均衡擦写。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id18"&gt;4   段内写入顺序与垃圾回收策略&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;段是闪存盘的擦写单元，考虑到段是 128KiB ~ 8MiB 这样的数量级，现实中要求每次连续写入一整段的话，
这样的块设备接口不像硬盘的接口，不方便普通文件系统使用。所以在段的抽象之下有了更小粒度的页面抽象，
页面对应到文件系统用的逻辑块大小，是 2KiB~8KiB 这样的数量级，每次以页面为单位读写。&lt;/p&gt;
&lt;p&gt;写入页面时有段内连续写入的限制，于是需要段内映射和垃圾回收算法，提供对外的随机写入接口。
写入操作时， FTL 控制器内部先「打开（open）」一个段，等写入完成，再执行垃圾回收「关闭(close)」一个段。
写入过程中处于打开状态的段需要一些额外资源（RAM等）跟踪段内的写入状况，所以闪存盘同时能「打开」
的段数量有限。并且根据不同的垃圾回收算法，需要的额外资源也不尽相同，在
&lt;a class="reference external" href="https://lwn.net/Articles/428584/"&gt;Optimizing Linux with cheap flash drives&lt;/a&gt; 一文中介绍几种可能的垃圾回收算法：&lt;/p&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;4.1   线性写入优化&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="https://lwn.net/Articles/428796/"&gt;Animations: linear-access optimized&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="ssd-linear.gif" class="img-responsive" src="//farseerfc.me/zhs/images/ssd-linear.gif"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;假设写入请求大部分都是连续写入，很少有地址跳转，那么可以使用线性优化算法。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Open：当第一次打开一个段，写入其中一页时，分配一个新段。如果要写入的页不在段的开头位置，那么搬运写入页面地址之前的所有页面到新段中。&lt;/li&gt;
&lt;li&gt;Write: 在 RAM 中跟踪记录当前写入位置，然后按顺序写下新的页面。&lt;/li&gt;
&lt;li&gt;Close: 最后搬运同段中随后地址上的页面，并关闭整段，调整段映射表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在段内写入了几页之后，又跳转到之前的位置，那需要在跳转时关闭当前段写入（并完整搬运剩下的页面），
然后重新打开这一段，搬运调转地址之前的页面，从跳转的页面位置开始写入。&lt;/p&gt;
&lt;p&gt;线性优化算法的好处在于：没有复杂的页面地址映射，段内的逻辑页面地址就是物理页面地址。
读一页的时候根据页面偏移和当前写入位置就能判断读新物理段还是老物理段。遇到突然断电之类的情况，
即使丢失最近写入的新物理段，老物理段的数据仍然还在，所以没必要保存 RAM 中的地址映射到闪存元数据中。&lt;/p&gt;
&lt;p&gt;线性优化算法的坏处是:每遇到一次乱序的写入，都要整段执行一次搬运，造成
&lt;a class="reference external" href="https://zh.wikipedia.org/zh-hans/%E5%86%99%E5%85%A5%E6%94%BE%E5%A4%A7"&gt;写入放大（Write Amplification）&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;一些文档中，将这种地址映射垃圾回收方式叫做「段映射（Segment Mapping）」，因为从 FTL
全局来看只维护了擦写段的地址映射关系。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id20"&gt;4.2   段内地址映射&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="https://lwn.net/Articles/428831/"&gt;Animations: block remapping&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="ssd-random.gif" class="img-responsive" src="//farseerfc.me/zhs/images/ssd-random.gif"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;对需要随机乱序写入的数据，可以使用段内地址映射。方式是额外在段外的别的闪存区域维护一张段内地址映射表，
像段地址一样，通过查表间接访问页面地址。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Open: 分配一块新的段，同时分配一个新的段内映射表。&lt;/li&gt;
&lt;li&gt;Write: 每写入一页，在段内映射表记录页面的在新段中的物理地址。&lt;/li&gt;
&lt;li&gt;Close: 复制老段中没有被覆盖写入的页到新段，并记录在段内映射表中，然后释放老段和老的段内映射表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说同时维护两块不同大小的闪存空间，一块是记录段数据的，一块是记录段内地址映射表的，
两块闪存空间有不同的写入粒度。可以在每个物理段内额外留出一些空间记录段内地址映射表，也可以在 FTL
全局维护一定数量的段内地址映射表。
每次读取段内的数据时，根据映射表的内容，做地址翻译。新段中页面的排列顺序将是写入的顺序，
而不是地址顺序。&lt;/p&gt;
&lt;p&gt;根据实现细节，段内地址映射可以允许覆盖写入老段中的页面，但是可能不允许覆盖写入新段（正在写入的段）
中已经写入的页面，遇到一次连续的写请求中有重复写入某一页面的时候，就需要关闭这一段的写入，然后重新打开。&lt;/p&gt;
&lt;p&gt;段内地址映射的优点是：支持随机写入，并且只要段处于打开状态，随机写入不会造成写入放大（Write Amplification）。&lt;/p&gt;
&lt;p&gt;缺点是：首先地址映射这层抽象有性能损失。其次遇到突然断电之类的情况，
下次上电后需要扫描所有正打开的段并完成段的关闭操作。&lt;/p&gt;
&lt;p&gt;和「段映射」术语一样，在一些文档中，将这种段内地址映射的方式叫做「页面映射（Page Mapping）」，因为从
FTL 全局来看跳过了擦写段这一层，直接映射了页面的地址映射。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id21"&gt;4.3   日志式写入&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="https://lwn.net/Articles/428831/"&gt;Animations: data logging&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="ssd-logging.gif" class="img-responsive" src="//farseerfc.me/zhs/images/ssd-logging.gif"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;除了大量随机写入和大量连续写入这两种极端情况，大部分文件系统的写入方式可能会是对某个地址空间
进行一段时间的随机写入，然后就长时间不再修改，这时适合日志式的写入方式。&lt;/p&gt;
&lt;p&gt;日志式的写入方式中写入一段采用三个物理段：老物理段，用于日志记录的新物理段，和垃圾回收后的段。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Open: 分配一块新的段。可能额外分配一个用于记录日志的段，或者将日志信息记录在数据段内。&lt;/li&gt;
&lt;li&gt;Write：每写入一页，同时记录页面地址到日志。&lt;/li&gt;
&lt;li&gt;Close：再分配一个新段执行垃圾回收。按日志中记录的地址顺序将数据段中（新写入）的页面或者老段中
没有被覆盖的页面复制到垃圾回收结束的新段中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;日志式写入在写入过程中像段内地址映射的方式一样，通过日志记录维护页面地址映射关系，
在写入结束执行垃圾回收之后，则像线性写入的方式一样不再需要维护页面映射。
可以说日志式写入某种程度上综合了前面两种写入方式的优点。&lt;/p&gt;
&lt;p&gt;日志式写入的优点：允许随机顺序写入，并且在执行垃圾回收之后，不再有间接访问的地址转换开销。&lt;/p&gt;
&lt;p&gt;日志式写入的缺点：触发垃圾回收的话，可能比段地址映射有更大的写入放大（Write Amplification）。&lt;/p&gt;
&lt;p&gt;在一些文档中，将这种日志式写入方式称作「混合映射（Hybrid Mapping）」，因为在段开启写入期间行为像页面映射，
在段关闭写入后行为像段映射。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id22"&gt;5   针对特定写入模式的优化&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上述三种地址映射和垃圾回收方式，各有不同的优缺点，根据数据块的写入模式可能需要挑选相应的策略。
并且「全局段地址映射表」、「段内页面地址映射表」、「写入页面地址日志」之类的元数据因为频繁修改，
FTL 也可能需要用不同的策略来记录这些元数据。这里面向不同使用场景的闪存设备可能有不同的 FTL
策略，并且 FTL 可能根据逻辑地址来选择哪种策略。&lt;/p&gt;
&lt;div class="section" id="id11"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id23"&gt;5.1   混合垃圾回收策略&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="https://lwn.net/Articles/428592/"&gt;Performance measurements on a class 10 SDHC card&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="ssd-extrememory-results.png" class="img-responsive" src="//farseerfc.me/zhs/images/ssd-extrememory-results.png"/&gt;
&lt;img alt="ssd-panasonic-plot.png" class="img-responsive" src="//farseerfc.me/zhs/images/ssd-panasonic-plot.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;用来记录照片、视频等的 SD 卡、microSD、U盘等设备可能根据数据的逻辑地址，为特定文件系统布局优化，
这里特定文件系统主要是指 FAT32 和 exFAT 这两个 FAT 系文件系统。 FAT 系文件系统的特点在于，
地址前端有一块空间被用来放置 &lt;a class="reference external" href="https://zh.wikipedia.org/wiki/FAT"&gt;文件分配表(File Allocation Table)&lt;/a&gt;
，可以根据文件系统簇大小和设备存储容量推算出 FAT 表占用大小，这块表内空间需要频繁随机读写。
对 FTL 自身的元数据，和 FAT 表的逻辑地址空间，需要使用「段内地址映射」来保证高效的随机读写，
而对随后的数据空间可使用「线性写入优化」的策略。&lt;/p&gt;
&lt;p&gt;右侧上图有张性能曲线，测量了一个 class 10 SDHC 卡上，不同读写块大小时，顺序读取、顺序写入、随机写入、
对 FAT 区域的写入之类的性能差异。下图是测量的读取延迟。可以看出 FAT
区域的随机写入和其余逻辑地址上有明显不同的性能表现。&lt;/p&gt;
&lt;p&gt;为容纳普通操作系统设计的 eMMC 和 SSD 难以预测文件系统的读写模式，可能需要使用更复杂的地址映射和垃圾回收策略。
比如一开始假定写入会是顺序写入，采用「线性优化」方式；当发生乱序写入时，转变成类似「日志式写入」
的方式记录写入地址并做地址映射；关闭段时，再根据积累的统计数据判断，可能将记录的日志与乱序的数据
合并（merge）成顺序的数据块，也可能保持页面映射转变成类似「段内地址映射」的策略。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id24"&gt;5.2   利用 NAND Flash 物理特性的优化&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;再考虑 NAND Flash 的物理特性，因为 MLC 要不断调整参考电压做写入， MLC 的写入比 SLC
慢一些，但是可以对 MLC Flash 使用 SLC 式的写入， FTL 控制器也可能利用这一点，让所有新的写入处于
SLC 模式，直到关闭整段做垃圾回收时把积攒的 SLC 日志段回收成 MLC 段用于长期保存。
一些网页将这种写入现象称作「SLC 缓存」甚至称之为作弊，需要理解这里并不是用单独的 SLC Flash
芯片做 writeback 缓存，更不是用大 RAM 做缓存，处于 SLC 模式的写入段也是持久存储的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id13"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id25"&gt;5.3   同时打开段数&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;上述地址映射和垃圾回收策略都有分别的打开（open）、写入（write）、关闭（close）时的操作，
闪存盘通常允许同时打开多个段，所以这三种操作不是顺序进行的，某一时刻可能同时有多个段处在打开的状态，
能接受写入。不过一个平面（Plane）通常只能进行一种操作（读、写、擦除），所以打开写入段时，
FTL 会尽量让写入分部在不同的平面上。还可能有更高层次的抽象比如 Device、 Chip 、 Die
等等，可能对应闪存盘内部的 RAID 层级。&lt;/p&gt;
&lt;p&gt;闪存盘能同时打开的段不光受平面之类的存储结构限制，还受控制器可用内存（RAM）限制之类的。
为 FAT 和顺序写入优化的 FTL ，可能除了 FAT 区域之外，只允许少量（2~8）个并发写入段，
超过了段数之后就会对已经打开的段触发关闭操作（close），执行垃圾回收调整地址映射，进而接受新的写入。
更高端的 SSD 的 FTL 如果采用日志式记录地址的话，同时打开的段数可能不再局限于可用内存限制，
连续的随机写入下按需动态加载段内地址映射到内存中，在空闲时或者剩余空间压力下才触发垃圾回收。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id14"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id26"&gt;5.4   预格式化&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;FTL 可能为某种文件系统的写入模式做优化，同时如果文件系统能得知 FTL 的一些具体参数（比如擦除段大小、
读写页大小、随机写入优化区域），那么可能更好地安排数据结构，和 FTL 相互配合。
F2FS 和 exFAT 这些文件系统都在最开头的文件系统描述中包含了一些区域，记录这些闪存介质的物理参数。
闪存盘出厂时，可能预先根据优化的文件系统做好格式化，并写入这些特定参数。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="trim-discard"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id27"&gt;5.5   TRIM 和 discard&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;另一种文件系统和 FTL 相互配合的机制是 TRIM 指令。TRIM 由文件系统发出，告诉底层闪存盘（
或者别的类型的 thin provisioning 块设备）哪些空间已经不再使用， FTL 接受 TRIM
指令之后可以避免一些数据搬运时的写入放大。关于 TRIM 指令在 Linux 内核中的实现，有篇
&lt;a class="reference external" href="https://lwn.net/Articles/417809/"&gt;The best way to throw blocks away&lt;/a&gt;
介绍可以参考。&lt;/p&gt;
&lt;p&gt;考虑到 FTL 的上述地址映射原理， TRIM 一块连续空间对 FTL 而言并不总是有帮助的。
如果被 TRIM 的地址位于正在以「段内地址映射」或「日志式映射」方式打开的写入段中，那么
TRIM 掉一些页面可能减少垃圾回收时搬运的页面数量。但是如果 TRIM 的地址发生在已经垃圾回收结束的段中，
此时如果 FTL 选择立刻对被 TRIM 的段执行垃圾回收，可能造成更多写入放大，
如果选择不回收只记录地址信息，记录这些地址信息也需要耗费一定的 Flash 写入。
所以 FTL 的具体实现中，可能只接受 TRIM 请求中，整段擦除段的 TRIM ，而忽略细小的写入页的 TRIM 。&lt;/p&gt;
&lt;p&gt;可见 FTL 对 TRIM 的实现是个黑盒操作，并且 TRIM 操作的耗时也非常难以预测，可能立刻返回，
也可能需要等待垃圾回收执行结束。&lt;/p&gt;
&lt;p&gt;对操作系统和文件系统实现而言，有两种方式利用 TRIM ：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;通过 discard 挂载选项，每当释放一些数据块时就执行 TRIM 告知底层块设备。&lt;/li&gt;
&lt;li&gt;通过 fstrim 等外部工具，收集连续的空块并定期发送 TRIM 给底层设备。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直觉来看可能 discard 能让底层设备更早得知 TRIM 区域的信息并更好利用，但是从实现角度来说，
discard 不光影响文件系统写入性能，还可能发送大量被设备忽略掉的小块 TRIM 区域。可能 fstrim
方式对连续大块的区间执行 TRIM 指令更有效。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="tl-dr-vs"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id28"&gt;6   TL;DR 低端 vs 高端&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;标题中的疑问「SSD就是大U盘？」相信看到这里已经有一些解答了。
即使 SSD 和U盘中可以采用类似的 NAND Flash 存储芯片，由于他们很可能采用不同的 FTL
策略，导致在读写性能和可靠性方面都有不同的表现。（何况他们可能采用不同品质的 Flash ）。&lt;/p&gt;
&lt;p&gt;如果不想细看全文，这里整理一张表，列出「高端」闪存盘和「低端」闪存盘可能采取的不同策略。
实际上大家买到的盘可能处于这些极端策略中的一些中间点，市场细分下并不是这么高低端分明。
比如有些标明着「为视频优化」之类宣传标语的「外置SSD」，对消费者来说可能会觉得为视频优化的话一定性能好，
但是理解了 FTL 的差异后就可以看出这种「优化」只针对线性写入，不一定适合放系统文件根目录的文件系统。&lt;/p&gt;
&lt;table border="0" class="docutils table borderless"&gt;
&lt;colgroup&gt;
&lt;col width="34%"/&gt;
&lt;col width="34%"/&gt;
&lt;col width="31%"/&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;参数&lt;/th&gt;
&lt;th class="head"&gt;低端&lt;/th&gt;
&lt;th class="head"&gt;高端&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;段大小&lt;/td&gt;
&lt;td&gt;8MiB&lt;/td&gt;
&lt;td&gt;128KiB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;段地址映射&lt;/td&gt;
&lt;td&gt;静态段映射&lt;/td&gt;
&lt;td&gt;日志式映射&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;随机写入范围&lt;/td&gt;
&lt;td&gt;FTL元数据与FAT表区域&lt;/td&gt;
&lt;td&gt;全盘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;同时打开段数&lt;/td&gt;
&lt;td&gt;4~8&lt;/td&gt;
&lt;td&gt;全盘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;物理段统计信息&lt;/td&gt;
&lt;td&gt;无（随机挑选空闲段）&lt;/td&gt;
&lt;td&gt;擦除次数、校验错误率等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;擦写均衡&lt;/td&gt;
&lt;td&gt;动态均衡（仅写入时分配新段考虑）&lt;/td&gt;
&lt;td&gt;静态均衡（空闲时考虑搬运）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;写入单元模式&lt;/td&gt;
&lt;td&gt;TLC&lt;/td&gt;
&lt;td&gt;长期存储 MLC， 模拟 SLC 日志&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;介绍完闪存类存储，下篇来讲讲文件系统的具体磁盘布局，考察一下常见文件系统如何使用 HDD/SSD
这些不同读写特性的设备。&lt;/p&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="tech"></category><category term="FS笔记"></category><category term="FS notes"></category><category term="FTL"></category><category term="SSD"></category><category term="USB stick"></category><category term="eMMC"></category><category term="MMC"></category><category term="SD Card"></category></entry><entry><title>柱面-磁头-扇区寻址的一些旧事</title><link href="//farseerfc.me/zhs/history-of-chs-addressing.html" rel="alternate"></link><published>2020-03-06T15:45:00+09:00</published><updated>2020-03-06T15:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2020-03-06:/zhs/history-of-chs-addressing.html</id><summary type="html">
&lt;p&gt;在 SSD 这种新兴存储设备普及之前，很长一段时间硬盘是个人计算机的主要存储设备。
更往前的磁带机不常见于个人计算机，软盘的地位很快被硬盘取代，到 SSD 出现为止像
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/MiniDisc"&gt;MiniDisc&lt;/a&gt; 、
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/DVD-RAM"&gt;DVD-RAM&lt;/a&gt;
等存储设备也从未能挑战过硬盘的地位。硬盘作为主要存储设备，自然也影响了文件系统的设计。&lt;/p&gt;
&lt;p&gt;这篇笔记稍微聊一聊硬盘这种存储设备的寻址方式对早期文件系统设计的一些影响，特别是
柱面-磁头-扇区寻址（Cylinder-head-sector addressing, 简称CHS寻址）的起源和发展。
大部分内容来自维基百科 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Cylinder-head-sector"&gt;Cylinder-head-sector 词条&lt;/a&gt;
这里只是记录笔记。现今的硬盘已经不再采用 CHS 寻址，其影响却还能在一些文件系统设计中看到影子。&lt;/p&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;柱面、磁头、扇区以及相关术语&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
磁盘示意图（来自维基百科 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Cylinder-head-sector"&gt;Cylinder-head-sector 词条&lt;/a&gt; ）&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;object class="embed-responsive-item" data="//farseerfc.me/zhs/images/chs-illustrate-trans.svg" type="image/svg+xml"&gt;
chs-illustrate-trans.svg&lt;/object&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如右图所示，一块硬盘(Hard Disk Drive, HDD)是一个圆柱体转轴上套着一些磁碟片(platter)，
然后有一条磁头臂(actuator arm)插入磁碟片间的位置 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
&lt;p&gt;在 SSD 这种新兴存储设备普及之前，很长一段时间硬盘是个人计算机的主要存储设备。
更往前的磁带机不常见于个人计算机，软盘的地位很快被硬盘取代，到 SSD 出现为止像
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/MiniDisc"&gt;MiniDisc&lt;/a&gt; 、
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/DVD-RAM"&gt;DVD-RAM&lt;/a&gt;
等存储设备也从未能挑战过硬盘的地位。硬盘作为主要存储设备，自然也影响了文件系统的设计。&lt;/p&gt;
&lt;p&gt;这篇笔记稍微聊一聊硬盘这种存储设备的寻址方式对早期文件系统设计的一些影响，特别是
柱面-磁头-扇区寻址（Cylinder-head-sector addressing, 简称CHS寻址）的起源和发展。
大部分内容来自维基百科 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Cylinder-head-sector"&gt;Cylinder-head-sector 词条&lt;/a&gt;
这里只是记录笔记。现今的硬盘已经不再采用 CHS 寻址，其影响却还能在一些文件系统设计中看到影子。&lt;/p&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;柱面、磁头、扇区以及相关术语&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
磁盘示意图（来自维基百科 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Cylinder-head-sector"&gt;Cylinder-head-sector 词条&lt;/a&gt; ）&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;object class="embed-responsive-item" data="//farseerfc.me/zhs/images/chs-illustrate-trans.svg" type="image/svg+xml"&gt;
chs-illustrate-trans.svg&lt;/object&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如右图所示，一块硬盘(Hard Disk Drive, HDD)是一个圆柱体转轴上套着一些磁碟片(platter)，
然后有一条磁头臂(actuator arm)插入磁碟片间的位置，加上一组控制芯片（controller）。
每个磁碟片有上下两面涂有磁性材质，磁头臂上有一组磁头（head），每个磁头对应磁盘的一个面，
所以比如一个 3 碟的硬盘会有 6 个磁头。&lt;/p&gt;
&lt;p&gt;每个磁碟片上定义了很多同心圆的磁头轨道，叫做磁道（track），磁道位于盘面上不同半径的位置，
通过旋转磁碟臂能让磁头移动到特定的半径上，从而让读写磁头在不同的磁道间跳转。
不同磁头上同磁道的同心圆共同组成一个柱面（cylinder），或者说移动磁碟臂能选定磁盘中的一个柱面。
磁道上按等角度切分成多个小段，叫做扇区（sector），每个扇区是读写数据时采用的最小单元。
早期在 IBM 大型机之类上使用的硬盘的扇区大小比较小，到 IBM PC
开始个人计算机用的硬盘扇区基本被统一到 512 字节。现代硬盘内部可能采用 Advanced Format
使用 4K 字节扇区。&lt;/p&gt;
&lt;p&gt;在早期软盘和硬盘的寻址方式被称作「柱面-磁头-扇区寻址」，简称 CHS 寻址，
是因为这三个参数是软件交给硬件定位到某个具体扇区单元时使用的参数。
首先柱面参数让磁头臂移动到某个半径上，寻址到某个柱面，然后激活某个磁头，然后随着盘面旋转，
磁头定位到某个扇区上。&lt;/p&gt;
&lt;p&gt;「柱面-磁头-扇区」这个寻址方式，听起来可能不太符合直觉，尤其是柱面的概念。直觉上，
可能更合理的寻址方式是「盘片-盘面-磁道-扇区」，而柱面在这里是同磁道不同盘片盘面构成的一个集合。
不过理解了磁盘的机械结构的话，柱面的概念就比较合理了，寻址时先驱动磁头臂旋转，
磁头臂上多个磁头一起飞到某个磁道上，从而运动磁头臂的动作定义了一个柱面。
柱面和磁头（CH）组合起来能定位到某个特定的磁道，画张图大概如下图所示：&lt;/p&gt;
&lt;object class="embed-responsive-item tikz" data="//farseerfc.me/uml/790bfd1c.svg" type="image/svg+xml"&gt;
tikz diagram&lt;/object&gt;
&lt;p&gt;上图中值得注意的是磁道的编号方式，我用相同的颜色画出了相同的磁道。因为按照 CHS
的顺序寻址，所以先定位柱面，然后选定磁头。磁盘上按半径从外向内定义柱面的编号，最外圈的磁道位于
0号柱面，由0号磁头开始。随着柱面编号增加，逐步从外圈定位到内圈。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="chs"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;物理 CHS 寻址&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以上术语中，柱面号和磁头号直接对应了硬盘上的物理组成部分，所以在物理 CHS
寻址方式下，通过扇区地址的写法能对应到扇区的具体物理位置。之所以这样描述扇区，
是因为早期的软盘和硬盘驱动器没有内置的控制芯片，可以完全由宿主系统执行驱动程序驱动。&lt;/p&gt;
&lt;p&gt;在 IBM PC 上，驱动软盘和硬盘的是 CPU 执行位于主板
&lt;a class="reference external" href="https://zh.wikipedia.org/wiki/BIOS"&gt;BIOS (Basic Input/Output System)&lt;/a&gt;
中的程序，具体来说操作系统（比如DOS）和应用程序调用 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/INT_13H"&gt;INT 13H&lt;/a&gt;
中断，通过 AH=02H/03H 选择读/写操作，BIOS 在中断表中注册的 13H 中断处理程序执行在 CPU
上完成读写请求。调用 INT 13H 读写扇区的时候，CPU 先通过 INT 13H AH=0CH
控制硬盘的磁头臂旋转到特定柱面上，然后选定具体磁头，让磁头保持在磁道上读数据，
通过忙轮训的方式等待要读写的扇区旋转到磁头下方，从而读到所需扇区的数据。在 DOS 之后的操作系统，
比如早期的 Windows 和 Linux 和 BSD 能以覆盖中断程序入口表的方式提供升级版本的这些操作替代
BIOS 的程序。&lt;/p&gt;
&lt;p&gt;以上过程中可以看出两点观察：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;CHS 寻址下，跨磁道的寻址（不同 CH 值），和磁道内的寻址（同 CH 不同 S
），是本质上不同的操作。跨磁道的寻址有移动磁头臂的动作，会比磁道内寻址花费更多时间。&lt;/li&gt;
&lt;li&gt;通过扇区号的磁道内寻址是个忙轮训操作，需要占用完整 CPU
周期。这也隐含扇区号在一个磁道内的物理排列不必是连续的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际上扇区号的物理排列的确不是连续的，每个物理扇区中除了用512字节记录扇区本身的数据，
还有扇区的开始记录和结束记录，写有扇区编号和扇区校验码。每读到一个扇区， CPU
可能需要做一些额外操作（比如计算比对校验、写入内存缓冲区、调整内存段页映射）
后才能继续读下一个扇区，如果物理排列上连续编号扇区，可能等 CPU
做完这些事情后磁头已经旋转到之后几个扇区上了。所以出厂时做磁盘低级格式化的时候，
会跳跃着给扇区编号，给 CPU 留足处理时间。比如下图：&lt;/p&gt;
&lt;object class="embed-responsive-item tikz" data="//farseerfc.me/uml/adb6edc3.svg" type="image/svg+xml"&gt;
tikz diagram&lt;/object&gt;
&lt;p&gt;上图中假设有3个柱面，每个柱面6个磁头，每个磁道内11个扇区，并且画出了三种不同的扇区编号跳转情况，
分别是磁道内的扇区跳转（+3），柱面内的磁头跳转（+5），以及柱面间跳转（+10）。
实际磁盘上的柱面数、扇区数要多很多，寻址时需要跳转的距离也可能更长，这里只是举例说明。
图中和实际情况相同的是，柱面号和磁头号从 0 开始编号，而扇区号从 1 开始编号，
所以做逻辑地址换算的时候要考虑编号差异。&lt;/p&gt;
&lt;p&gt;早期 IBM PC 的 BIOS 使用 24bit 的 CHS 地址，其中 10bit 柱面(C)、 8bit 磁头(H)、
6bit 扇区(S)。从而用物理 CHS 寻址方式的软盘和硬盘驱动器最多可以寻址 1024 个柱面，256 个磁头，
63 个扇区，其中扇区数因为从 1 开始编号所以少了 1 个可寻址范围。比如 3.5 吋高密度（HD）软盘有双面，
出厂时每面 80 磁道，每磁道 18 扇区，从而能算出 1,474,560 字节的容量。&lt;/p&gt;
&lt;p&gt;如此跳跃编号扇区之后，不是总能给磁道中所有扇区编号，可能在磁道的末尾位置留几个没有使用的扇区空间，
这些是磁道内的保留扇区，可以在发现坏扇区后使用这些隐藏扇区作为替代扇区。当然读写替代扇区的时候
因为扇区寻址不连续可能会有一定性能损失。&lt;/p&gt;
&lt;p&gt;因为物理 CHS 寻址下，磁盘由 CPU 执行驱动程序来驱动，所以以上扇区跳跃的长短实际是由 CPU
的速度等因素决定的，理论上 CPU 越快，跳跃间隔可以越短，从而磁盘读写速度也能加快。磁盘出厂时，
厂商并不知道使用磁盘的计算机会是怎样的性能，所以只能保守地根据最慢的 CPU 比如 IBM 初代 PC 搭配的
8086 的速度来决定跳跃间隔。所以在当年早期玩家们流传着这样一个操作：买到新硬盘，
或者升级了电脑配置之后，对硬盘做一次 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Disk_formatting#Low-level_formatting_(LLF)_of_hard_disks"&gt;低级格式化(Low level formating)&lt;/a&gt;
，聪明的低级格式化程序能智能安排扇区编号，提升硬盘读写速度，也能跳过已知坏道位置继续编号，
甚至可能将更多保留扇区暴露成可用扇区。这对现代有硬盘控制器的硬盘而言已经没有意义了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;逻辑 CHS 寻址&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;随着硬盘容量不断增加， BIOS 中用来 CHS 寻址的地址空间逐渐不够用了。早期 24bit 地址按 &lt;cite&gt;C H S&lt;/cite&gt;
的顺序分为 &lt;cite&gt;10 8 6&lt;/cite&gt; 的位数，用 8bit 来寻址磁头最多可以有 256 个磁头，而只有 10bit
来寻址柱面，就只能有 1024 个柱面。最初 IBM 这么划分是因为早期用于 IBM 大型机之类的硬盘可以有
厚厚一叠的盘片组，同样的寻址方式就直接用于了 IBM PC 。而 PC 用的硬盘迫于硬盘仓空间大小，
有厚度限制，硬盘中物理盘面可能只有四五个盘片，硬盘容量增加主要是增加盘片表面的数据密度而非增加盘片数量。&lt;/p&gt;
&lt;p&gt;于是逐渐地，硬盘厂商开始对 CHS 寻址的地址空间做一些手脚。比如最初的简单想法是重新定义 CH
，将一些磁头数挪用做柱面数。从而有了逻辑 CHS 寻址，其中 CH 是固定一组，通过简单换算从 CH
值找到物理的柱面和磁头数。结合 CH 而不映射 S 的优势在于，从操作系统和文件系统来看依然能根据逻辑
CHS 地址估算出地址跳转所需大概的时间，只是原本一次切换磁头的动作可能变成一次短距离的切换柱面。&lt;/p&gt;
&lt;p&gt;此时的操作系统和文件系统已经开始出现针对 CHS 寻址特点的优化方式，
尽量减少跨磁道的寻址能一定程度提升读写速度，跨磁道时的磁道间距离也会影响寻道时间，
文件系统可能会根据CHS地址来安排数据结构，优化这些寻址时间。&lt;/p&gt;
&lt;p&gt;即便使用没有针对 CHS 寻址方式优化过的操作系统和文件系统，比如局限在早期 Windows 和 FAT
系文件系统上，早期这些桌面系统用户们仍然能自己优化磁盘读写性能：通过分区。
分区是硬盘上连续的一段空间，早期由于 BIOS 和 bootloader 的一些技术限制，
每个分区必须对齐到柱面大小上。早期 PC 玩家们通过把一个大硬盘切分成多个小分区，
使用时尽量保持近期读写针对同一个分区，就可以减少寻址时的额外开销，改善读写速度。&lt;/p&gt;
&lt;p&gt;于是隐含地，CHS 寻址导致底层硬盘和上层操作系统之间有一层性能约定： &lt;strong&gt;连续读写保证最快的读写速度&lt;/strong&gt;
。硬盘实现 CHS 寻址时，调整扇区编号方式让连续的 CHS 地址有最快读写速度，文件系统也根据这个约定，
按照 CHS 地址的跳跃来估算读写速度耗时并针对性优化。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="zone-bit-recoding-zbr"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;区位记录（Zone bit recoding, ZBR）&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以上物理 CHS 寻址，其实依赖一个假设： &lt;strong&gt;每个磁道上有同样数量的扇区&lt;/strong&gt; 。早期硬盘上也的确遵循这个假设，
所以我们上面的图示里才能把一个盘面上的扇区展开成一张长方形的表格，因为每个磁道的扇区数是一样的。
实际上当时的硬盘都是恒定角速度（constant angular velocity, CAV）的方式读写，无论磁头在哪儿，
盘片都旋转保持恒定的转速，所以对磁头来说在单位时间内转过的角度影响读写二进制位的数量，
而磁头扫过的面积在这里没有影响。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
区位记录（来自维基百科 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Zone_bit_recording"&gt;Zone bit recording 词条&lt;/a&gt; ）&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;object class="embed-responsive-item" data="//farseerfc.me/zhs/images/DiskStructure.svg" type="image/svg+xml"&gt;
DiskStructure.svg&lt;/object&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;不过随着硬盘容量增加，盘面的数据密度也随之增加，单位面积中理论能容纳的二进制位数量有限。
理论上，如果保持相同密度的话，盘片外圈能比内圈容纳更多数据。因此硬盘厂商们开始在盘面上将磁道划分出
区块（zone），外圈区块中的磁道可以比内圈区块中的磁道多放入一些扇区。这种方式下生产出的硬盘叫
区位记录硬盘（Zone bit recoding, ZBR），相对的传统固定磁道中扇区数的硬盘就被叫做恒定角速度（CAV）
硬盘。&lt;/p&gt;
&lt;p&gt;如右图所示，区位记录在硬盘上将多个柱面组合成一个区块，区块内的磁道有相同数量的扇区，
而不同区块的磁道可以有不同数量的扇区，外圈区块比内圈区块有更多扇区。&lt;/p&gt;
&lt;p&gt;显然要支持 ZBR ，物理 CHS 寻址方式不再有效，于是 ZBR
硬盘将原本简单的地址换算电路升级为更复杂的磁盘控制器芯片，替代 CPU
来驱动硬盘，把来自文件系统的逻辑 CHS 地址通过换算转换到物理 CHS 地址，并且驱动磁头做跳转和寻址。
从而有了独立的控制芯片之后，硬盘读写扇区的速度不再受 CPU 速度影响。有了完整的逻辑-物理地址转换后，
逻辑扇区编号不再对应物理扇区编号，上述编号跳转和坏扇区处理之类的事情都由磁盘控制芯片代为完成。
从而 CHS 地址已经丧失了物理意义，只留下 &lt;strong&gt;连续读写保证最快的读写速度&lt;/strong&gt; 这样的性能约定。&lt;/p&gt;
&lt;p&gt;有了 ZBR 之后，硬盘读写速度也不再恒定，虽然仍然保持恒定转速，但是读写外圈磁道时单位时间扫过的扇区
多于读写内圈磁道时扫过的扇区。所以 ZBR 硬盘的低端地址比高端地址有更快的读写速度，
通过硬盘测速软件能观察到阶梯状的「掉速」现象。&lt;/p&gt;
&lt;p&gt;逻辑地址转换也会造成逻辑 CHS 寻址能访问到的扇区数少于物理 CHS 寻址的现象，
磁盘中扇区被重新编号后可能有一些扇区剩余，于是 ZBR 硬盘的出厂低级格式化可能会均分这些访问不到的扇区
给每个磁道作为保留扇区，留作坏扇区后备。&lt;/p&gt;
&lt;p&gt;另外有了独立磁盘控制器芯片之后，扇区内的校验算法也不再受制于 BIOS INT 13H 接口。
原本 BIOS 的 INT 13H 接口定义了每个扇区 512 字节，额外配有 4 字节校验， 32bit
的校验码对 4096bit 的数据来说，只能允许一些简单的校验算法，比如 32bit CRC ，或者比如
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Hamming_code"&gt;汉明码&lt;/a&gt; 对 4096bit 的数据需要 13bit
的校验。突破了校验算法限制后硬盘可以在物理扇区中放更多校验位，使用更复杂的
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Error_correction_code"&gt;ECC&lt;/a&gt; 算法，提供更强的容错性。
IDE/SATA 接口的硬盘由内部控制器负责计算和比对校验，而 SAS 接口的硬盘（主要用于服务器）可以读取
520/528 字节长度的扇区，包含额外校验位。&lt;/p&gt;
&lt;p&gt;通过 ZBR ，逻辑 CHS 寻址不再局限在具体每磁道扇区数等物理限制上，但是仍然局限在 CHS 总位数。
24bit 的 CHS 地址能寻址 &lt;span class="math"&gt;\(1024*256*63 = 16515072\)&lt;/span&gt; 个扇区，也就是 8064MiB 的空间。
于是早期很多操作系统有 7.8G 硬盘大小的限制。后来 ATA/IDE 标准提升了 CHS 寻址数量，从 24bit
到 28bit 到 32bit ，不过在系统引导早期仍然依赖 BIOS 最基本的 24bit CHS
寻址能力，于是那时候安装系统时要求引导程序装在前 8G 范围内也是这个原因。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="chs-lba"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;从 CHS 到 LBA&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;随着硬盘大小不断提升，无论是操作系统软件层，还是硬盘厂商硬件层，都逐渐意识到逻辑 CHS
寻址是两边相互欺骗对方的骗局：文件系统根据假的 CHS 地址的提示苦苦优化，而硬盘控制器又要把物理
CHS 模拟到假的 CHS 地址上以兼容 BIOS 和操作系统。和 CS 领域太多别的事情一样，
CHS 寻址过早地暴露出太多底层抽象细节，而上层软件又转而依赖于这些暴露出的细节进行优化，
底层细节的变动使得上层优化不再是有意义的优化。&lt;/p&gt;
&lt;p&gt;于是 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Parallel_ATA"&gt;ATA 标准&lt;/a&gt; 引入了
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Logical_block_addressing"&gt;逻辑块寻址（Logical Block Addressing, LBA）&lt;/a&gt;
来替代 CHS 寻址，解决其中的混乱。LBA 的思路其实就是逻辑 CHS 寻址的简单换算，因为
CHS 寻址下 S 从 1 开始计算，而 LBA 使用连续扇区编号，从 0 开始编号，所以换算公式如下：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
LBA 地址 = ( C \times 磁头数 + H ) \times 扇区数 + ( S - 1 )
\end{equation*}
&lt;/div&gt;
&lt;p&gt;使用 LBA 寻址，操作系统和文件系统直接寻址一个连续地址空间中的扇区号，
不应该关心柱面和磁头之类的物理参数，将这些物理细节交由磁盘控制器。
对操作系统和文件系统这些上层软件而言，LBA寻址的抽象仍然保证了 &lt;strong&gt;连续读写提供最快的读写速度&lt;/strong&gt;
，文件系统仍然会尝试根据 LBA 地址优化，尽量连续读写从而减少寻道时间。&lt;/p&gt;
&lt;p&gt;从 CHS 寻址切换到 LBA 寻址，需要硬盘和操作系统两方面的努力，所以很长一段时间，
硬盘同时支持两种寻址方式，在控制器内部做转换。最后需要放弃支持的是深植了 CHS 寻址的 BIOS
，使用 BIOS 引导的 MBR 引导程序还在用 CHS 寻址方式读取数据加载操作系统，直到大家都切换到 UEFI 。&lt;/p&gt;
&lt;p&gt;并且随着硬盘使用 LBA 寻址，导致上层软件很难预测底层硬件实际切换柱面切换磁头之类的时机，
潜在地导致一些性能不确定性。于是硬盘控制器在除了负责实际驱动物理磁盘之外，
还开始负责维护一块盘内缓冲区，实现盘内的 IO 队列。缓冲区的存在允许磁盘控制器同时接收更多来自上层软件
的读写请求，转换成实际物理布局参数，并根据磁盘物理布局来调整读写顺序，增加总体吞吐率。
比如 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tagged_Command_Queuing"&gt;ATA TCQ&lt;/a&gt; 和
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Native_Command_Queuing"&gt;SATANCQ&lt;/a&gt;
就是这样的盘内队列协议。&lt;/p&gt;
&lt;p&gt;当然有缓冲区和盘内队列的存在也使得突然断电之类的情况下更难保证数据一致性，于是 SCSI/SATA
标准开始约定特殊的请求，从操作系统能发送命令让底层设备清空自己的读写队列。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="shingled-magnetic-recording-smr"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;叠瓦磁记录（Shingled Magnetic Recording, SMR）&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;逐渐从历史讲到了现在，随着硬盘记录密度的不断增加，硬盘厂商们也在不断发明新技术尝试突破磁盘记录的物理极限。
因为有了在硬盘上独立的控制器，并且切换到了逻辑块地址（LBA）的寻址方式，
操作系统大部分时候不用再关心底层硬盘的物理技术革新，比如垂直写入技术（perpendicular magnetic
recording, PMR）将磁头记录方式从水平转换成垂直记录，增加了记录密度，但不影响寻址方式。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
叠瓦磁记录（来自 &lt;a class="reference external" href="https://ieeexplore.ieee.org/document/4782114"&gt;The Feasibility of Magnetic Recording at 10 Terabits Per Square Inch on Conventional Media&lt;/a&gt; ）&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="smr.png" class="img-responsive" src="//farseerfc.me/zhs/images/smr.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;不过技术革新中也有影响寻址方式的技术，比如
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Shingled_magnetic_recording"&gt;叠瓦磁记录技术（Shingled Magnetic Recording, SMR）&lt;/a&gt;
。 SMR 技术基于一个技术事实：物理上磁头的写入头（write head）需要比读取头(read head
)占用更大面积，如果按照写入头的物理极限放置磁记录，那么对于读取头会有很多空间浪费。从而
SMR 试图让相邻磁道的写入有部分重叠，从而增加记录密度。即便重叠了相邻磁道，读取磁道还是能随机定位，
而写入磁道会覆盖它后面叠加上的磁道，所以写入磁道必须严格按地址顺序写入。为了满足随机顺序写入的需要，
SMR 硬盘把连续的几个磁道组织成区块（zone），在一个区块内必须按顺序写入。
这里的区块可以和区位记录（ZBR）是同样的区块，也可以独立于 ZBR 做不同大小的区块分割。&lt;/p&gt;
&lt;p&gt;这种区块内连续写入的要求，很像是 SSD 这种基于闪存介质的记录方式， SMR 硬盘也同样像 SSD
一样在磁盘控制器内引入 &lt;a class="reference external" href="//farseerfc.me/zhs/btrfs-vs-zfs-difference-in-implementing-snapshots.html#id21"&gt;日志结构式的记录方式，采用类似的 GC 算法&lt;/a&gt;
，收到随机写入请求的时候，在区块间执行 GC 搬运数据块，对操作系统提供可以任意写入的抽象接口。&lt;/p&gt;
&lt;p&gt;当然这种类似闪存介质的 FTL 的抽象有对读写性能的直接影响。SMR 硬盘可以将这些细节完全隐藏起来（
Device Managed），或者完全暴露给宿主系统（Host Managed
），或者在读写时隐藏细节的同时在宿主想查询的时候提供接口查询（Host Aware）。和 SSD
一样，消费级的 SMR 硬盘通常选择隐藏细节只在被询问时暴露，完全暴露细节的设备通常只在企业服务器级别
的产品中看到。&lt;/p&gt;
&lt;p&gt;可以期待，随着 SMR 硬盘的逐渐普及，文件系统设计中也将更多考虑 SMR 的特性加以优化。这些优化可能参考
对 SSD 的优化（比如尽量连续写入），但是又不能完全照搬（比如 SSD 需要考虑写平衡而 SMR
硬盘不需要，比如 SSD 不用担心随机寻道时间而 SMR 硬盘需要）。这些对现在和未来文件系统的设计提供了更多挑战。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="kib"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;4KiB 扇区大小&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;不局限于硬盘，存储设备发展中另一个方向是增加扇区大小。如前所述，在应用于 PC
之前的硬盘设计也曾有过比 512 字节更小的扇区大小，而自从 PC 普及之后 512 字节扇区逐渐成为主流，
甚至到了挥之不去的地步。随着硬盘容量提升，直接寻址 512 字节的扇区显得不再那么高效，
文件系统内部也早已把多个扇区合并成一个逻辑簇（cluster）或者块（block），按簇或块的粒度管理。
在底层硬件同样也是按照 512 字节大小划分扇区，每个扇区都要独立计算校验，如果能增大扇区大小到比如
4KiB，将能更经济地安排扇区校验码，从而得到更多可用容量。可见 512 字节扇区大小这一设计，和
CHS 寻址一样，逐渐成为了操作系统和硬盘厂商彼此间互相努力维护的谎言。&lt;/p&gt;
&lt;p&gt;硬盘物理扇区提升为 4KiB 大小的设计，叫做「
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Advanced_Format"&gt;先进格式化（Advanced Format）&lt;/a&gt;
」，这样的硬盘叫做先进格式化硬盘（AFD）。在此基础上，硬盘控制器可以提供模拟 512 字节扇区的模拟层，
叫做 512e ，也可以直接提供 4K 大小的扇区给操作系统，叫做 4K native (4Kn)。
操作系统和文件系统要尽量避免依赖 512e 以提供最优性能，支持 4Kn 扇区寻址也是现在和未来
文件系统设计中一个重要挑战。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="dual-actuator"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;双磁头臂（Dual Actuator）&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
双磁头臂（来自 &lt;a class="reference external" href="http://www.digitalpreservation.gov/meetings/DSA2018/Day_1/5_TO_P2-2_Trantham_Disk_Trends.pdf"&gt;Seagate Storage Update - LOC Designing Storage Architecture for Digital Collections&lt;/a&gt; ）&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="DualActuator-Opposed.jpeg" class="img-responsive" src="//farseerfc.me/zhs/images/DualActuator-Opposed.jpeg"/&gt;
&lt;img alt="DualActuator-Split.jpeg" class="img-responsive" src="//farseerfc.me/zhs/images/DualActuator-Split.jpeg"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;除了提升容量，硬盘发展的另一个方向是提升读写速度。通过上述 CHS 寻址方式可见，
传统方式下提升硬盘读写速度有两种方式：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;提升磁记录密度&lt;/li&gt;
&lt;li&gt;提升（磁头臂和盘片）转速&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一种方式提升记录密度，在增加容量的同时也能提升硬盘读写速度，所以是长久以来硬盘厂商的主要方式。
第二种方式提升转速则很快就遇到了物理瓶颈，硬盘以前是 5400rpm 现在最高能到 15000rpm
附近，高速旋转的盘片就像一个螺旋桨一样，外圈线速度已经到了接近声速，很难再往上提升。
以及盘片转速影响连续读写速度，而磁头臂转速影响寻道速度，高速寻道对磁头臂旋转有极高精度要求。&lt;/p&gt;
&lt;p&gt;所以长久以来，衡量硬盘速度有两项指标：连续读写速度和每秒操作数(IOPS)，随着容量提升，
也在提升连续读写速度，但是很难提升 IOPS ，相对而言随机寻道所需的开销越来越昂贵。&lt;/p&gt;
&lt;p&gt;目前硬盘厂商们在尝试一种新的方式提升硬盘 IOPS ：增加一条磁头臂。一个硬盘驱动器内封入两组甚至多组
磁头臂，每个磁头臂能独立旋转，从而能独立寻址定位。这样的硬盘叫双/多磁头臂（Dual/Multi Actuator）硬盘。&lt;/p&gt;
&lt;p&gt;从操作系统角度来看，双磁头臂硬盘更像是一根连接线上接有等容量的两个独立驱动器，
可以在盘内控制器上组 RAID0 ，或者把两个磁头臂都暴露给操作系统，由操作系统组 RAID0
或更智能地使用独立寻址的能力。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tl-dr"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;结论（TL;DR）和预告&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;软件层面的优化与硬件层面的革新一直是一组矛盾。长久以来文件系统和硬盘设备在关于寻址方式的磨合中，
逐渐演化出一条真理，也是我文中一直在强调的： &lt;strong&gt;连续读写提供最快的读写速度&lt;/strong&gt;
。文件系统总是能根据底层设备暴露出的一些抽象泄漏，比如物理 CHS 布局，比如 512 字节扇区大小，
针对性做更多优化，但是随着底层设备的技术革新这些优化也随之成为泡影。&lt;/p&gt;
&lt;p&gt;从 SMR 技术中也能看出， 硬盘的读写接口也在逐渐向 SSD 的接口靠拢，从而文件系统的「优化」也在逐渐
向这种「倾向顺序写入」的方向优化。关于这些发展趋势待我有空再谈。&lt;/p&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="tech"></category><category term="FS笔记"></category><category term="FS notes"></category><category term="CHS"></category><category term="cylinder"></category><category term="head"></category><category term="sector"></category><category term="LBA"></category><category term="SMR"></category><category term="4Kn"></category></entry><entry><title>Btrfs vs ZFS 实现 snapshot 的差异</title><link href="//farseerfc.me/zhs/btrfs-vs-zfs-difference-in-implementing-snapshots.html" rel="alternate"></link><published>2020-02-19T15:45:00+09:00</published><updated>2020-02-19T15:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2020-02-19:/zhs/btrfs-vs-zfs-difference-in-implementing-snapshots.html</id><summary type="html">
&lt;!-- --&gt;
&lt;blockquote&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;zfs 这个东西倒是名不符实。叫 z storage stack 明显更符合。 叫 fs 但不做 fs 自然确实会和 btrfs 有很大出入。&lt;/div&gt;
&lt;div class="line"&gt;我反而以前还好奇为什么 btrfs 不弄 zvol ， 直到我意识到这东西真是一个 fs ，名符奇实。&lt;/div&gt;
&lt;div class="line"&gt;—— 某不愿透露姓名的 Ext2FSD 开发者&lt;/div&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;Btrfs 和 ZFS 都是开源的写时拷贝（Copy on Write, CoW）文件系统，都提供了相似的子卷管理和
快照(snapshot）的功能。网上有不少文章都评价 ZFS 实现 CoW FS 的创新之处，进而想说「 Btrfs
只是 Linux/GPL 阵营对 ZFS …&lt;/p&gt;</summary><content type="html">
&lt;!-- --&gt;
&lt;blockquote&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;zfs 这个东西倒是名不符实。叫 z storage stack 明显更符合。 叫 fs 但不做 fs 自然确实会和 btrfs 有很大出入。&lt;/div&gt;
&lt;div class="line"&gt;我反而以前还好奇为什么 btrfs 不弄 zvol ， 直到我意识到这东西真是一个 fs ，名符奇实。&lt;/div&gt;
&lt;div class="line"&gt;—— 某不愿透露姓名的 Ext2FSD 开发者&lt;/div&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;Btrfs 和 ZFS 都是开源的写时拷贝（Copy on Write, CoW）文件系统，都提供了相似的子卷管理和
快照(snapshot）的功能。网上有不少文章都评价 ZFS 实现 CoW FS 的创新之处，进而想说「 Btrfs
只是 Linux/GPL 阵营对 ZFS 的拙劣抄袭」。或许（在存储领域人尽皆知而在领域外）鲜有人知，在
ZFS 之前就有 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/NetApp"&gt;NetApp&lt;/a&gt; 的商业产品
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Write_Anywhere_File_Layout"&gt;WAFL (Write Anywhere File Layout)&lt;/a&gt;
实现了 CoW 语义的文件系统，并且集成了快照和卷管理之类的功能。描述 btrfs 原型设计的
&lt;a class="reference external" href="https://btrfs.wiki.kernel.org/images-btrfs/6/68/Btree_TOS.pdf"&gt;论文&lt;/a&gt;
和 &lt;a class="reference external" href="https://btrfs.wiki.kernel.org/images-btrfs/6/63/LinuxFS_Workshop.pdf"&gt;发表幻灯片&lt;/a&gt;
也明显提到 WAFL 比提到 ZFS 更多一些，应该说 WAFL 这样的企业级存储方案才是 ZFS 和 btrfs
共同的灵感来源，而无论是 ZFS 还是 btrfs 在其设计中都汲取了很多来自 WAFL 的经验教训。&lt;/p&gt;
&lt;p&gt;我一开始也带着「 Btrfs 和 ZFS
都提供了类似的功能，因此两者必然有类似的设计」这样的先入观念，尝试去使用这两个文件系统，
却经常撞上两者细节上的差异，导致使用时需要不尽相同的工作流，
或者看似相似的用法有不太一样的性能表现，又或者一边有的功能，比如 ZFS 的在线去重（in-band dedup）
， Btrfs 的 reflink ，在另一边没有的情况，进而需要不同细粒度的子卷划分方案。后来看到了
&lt;a class="reference external" href="https://lwn.net/Articles/342892/"&gt;LWN 的这篇 《A short history of btrfs》&lt;/a&gt;
让我意识到 btrfs 和 ZFS 虽然表面功能上看起来类似，但是实现细节上完全不一样，
所以需要不一样的用法，适用于不一样的使用场景。&lt;/p&gt;
&lt;p&gt;为了更好地理解这些差异，我四处搜罗这两个文件系统的实现细节，于是有了这篇笔记，
记录一下我查到的种种发现和自己的理解。&lt;del&gt;（或许会写成一个系列？还是先别乱挖坑不填。）&lt;/del&gt;
只是自己的笔记，所有参阅的资料文档都是二手资料，没有深挖过源码，还参杂了自己的理解，
于是难免有和事实相违的地方，如有写错，还请留言纠正。&lt;/p&gt;
&lt;div class="section" id="btrfs"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id34"&gt;1   Btrfs 的子卷和快照&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;关于写时拷贝（CoW）文件系统的优势，我们为什么要用 btrfs/zfs 这样的写时拷贝文件系统，
而不是传统的文件系统设计，或者写时拷贝文件系统在使用时有什么区别之类的，网上同样也能找到很多介绍
，这里不想再讨论。这里假设你用过 btrfs/zfs 至少一个的快照功能，知道它该怎么用，
并且想知道更多细节，判断怎么用那些功能才合理。&lt;/p&gt;
&lt;p&gt;先从两个文件系统中（表面上看起来）比较简单的 btrfs 的子卷（subvolume）和快照（snapshot）说起。
关于子卷和快照的常规用法、推荐布局之类的话题就不细说了，网上能找到很多不错的资料，比如
&lt;a class="reference external" href="https://btrfs.wiki.kernel.org/index.php/SysadminGuide#Subvolumes"&gt;btrfs wiki 的 SysadminGuide 页&lt;/a&gt;
和 Arch wiki 上 &lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Btrfs#Subvolumes"&gt;Btrfs#Subvolumes&lt;/a&gt; 页都有不错的参考价值。&lt;/p&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id35"&gt;1.1   子卷和快照的术语&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在 btrfs 中，存在于存储媒介中的只有「子卷」的概念，「快照」只是个创建「子卷」的方式，
换句话说在 btrfs 的术语里，子卷（subvolume）是个名词，而快照（snapshot）是个动词。
如果脱离了 btrfs 术语的上下文，或者不精确地称呼的时候，也经常有文档把 btrfs
的快照命令创建出的子卷叫做一个快照，所以当提到快照的时候，根据上下文判断这里是个动词还是名词，
把名词的快照当作用快照命令创建出的子卷就可以了。或者我们可以理解为，
&lt;strong&gt;互相共享一部分元数据（metadata）的子卷互为彼此的快照（名词）&lt;/strong&gt; ，
那么按照这个定义的话，在 btrfs 中创建快照（名词）的方式其实有两种：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;用 &lt;code class="code"&gt;
btrfs subvolume snapshot&lt;/code&gt;
 命令创建快照&lt;/li&gt;
&lt;li&gt;用 &lt;code class="code"&gt;
btrfs send&lt;/code&gt;
 命令并使用 &lt;code class="code"&gt;
-p&lt;/code&gt;
 参数发送快照，并在管道另一端接收&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;code class="code"&gt;
btrfs send&lt;/code&gt;
 命令的 &lt;code class="code"&gt;
-p&lt;/code&gt;
 与 &lt;code class="code"&gt;
-c&lt;/code&gt;
&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;p&gt;这里也顺便提一下 &lt;code class="code"&gt;
btrfs send&lt;/code&gt;
 命令的 &lt;code class="code"&gt;
-p&lt;/code&gt;
 参数和 &lt;code class="code"&gt;
-c&lt;/code&gt;
 参数的差异。
只看 &lt;a class="reference external" href="https://btrfs.wiki.kernel.org/index.php/Manpage/btrfs-send#DESCRIPTION"&gt;btrfs-send(8)&lt;/a&gt; 的描述的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;-p &amp;lt;parent&amp;gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;send an incremental stream from parent to subvol&lt;/div&gt;
&lt;div class="line"&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line"&gt;-c &amp;lt;clone-src&amp;gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;use this snapshot as a clone source for an incremental send (multiple allowed)&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;看起来这两个都可以用来生成两个快照之间的差分，只不过 -p 只能指定一个「parent」，
而 -c 能指定多个「clone source」。在
&lt;a class="reference external" href="https://unix.stackexchange.com/a/490857"&gt;unix stackexchange 上有人写明了这两个的异同&lt;/a&gt;
。使用 -p 的时候，产生的差分首先让接收端用 subvolume snapshot 命令对 parent 子卷创建一个快照，
然后发送指令将这个快照修改成目标子卷的样子，而使用 -c 的时候，首先在接收端用 subvolume create
创建一个空的子卷，随后发送指令在这个子卷中填充内容，其数据块尽量共享 clone source 已有的数据。
所以 &lt;code class="code"&gt;
btrfs send -p&lt;/code&gt;
 在接收端产生是有共享元数据的快照，而 &lt;code class="code"&gt;
btrfs send -c&lt;/code&gt;

在接收端产生的是仅仅共享数据而不共享元数据的子卷。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;定义中「互相共享一部分 &lt;strong&gt;元数据&lt;/strong&gt; 」比较重要，因为除了快照的方式之外， btrfs
的子卷间也可以通过 reflink 的形式共享数据块。我们可以对一整个子卷（甚至目录）执行
&lt;code class="code"&gt;
cp -r --reflink=always&lt;/code&gt;
 ，创建出一个副本，副本的文件内容通过 reflink
共享原本的数据，但不共享元数据，这样创建出的就不是快照。&lt;/p&gt;
&lt;p&gt;说了这么多，其实关键的只是 btrfs 在传统 Unix 文件系统的「目录/文件/inode」
这些东西之外只增加了一个「子卷」的新概念，而子卷间可以共享元数据或者数据，
用快照命令创建出的子卷就是共享一部分元数据。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id36"&gt;1.2   于是子卷在存储介质中是如何记录的呢？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;首先要说明， btrfs 中大部分长度可变的数据结构都是
&lt;a class="reference external" href="https://www.usenix.org/legacy/events/lsf07/tech/rodeh.pdf"&gt;CoW B-tree&lt;/a&gt;
，一种经过修改适合写时拷贝的B树结构，所以在
&lt;a class="reference external" href="https://btrfs.wiki.kernel.org/index.php/On-disk_Format"&gt;on-disk format&lt;/a&gt;
中提到了很多个树。这里的树不是指文件系统中目录结构树，而是写时拷贝B树（CoW B-tree，下文简称B树）
，如果不关心B树细节的话可以把 btrfs 所说的一棵树理解为关系数据库中的一个表，
和数据库的表一样 btrfs 的树的长度可变，然后表项内容根据一个 key 排序。&lt;/p&gt;
&lt;p&gt;B树结构由索引 key 、中间节点和叶子节点构成。每个 key
是一个 &lt;code class="code"&gt;
(uint64_t object_id, uint8_t item_type, uint64_t item_extra)&lt;/code&gt;

这样的三元组，三元组每一项的具体含义由 item_type 定义。 key
三元组构成了对象的概念，每个对象（object）在树中用一个或多个表项（item）描述，同 object_id
的表项共同描述一个对象。B树中的 key 只用来比较大小而不必连续，从而 object_id
也不必连续，只是按大小排序。有一些预留的 object_id 不能用作别的用途，他们的编号范围是
-255ULL 到 255ULL，也就是表中前 255 和最后 255 个编号预留。&lt;/p&gt;
&lt;p&gt;B树中间节点和叶子节点结构大概像是这个样子：&lt;/p&gt;
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;

&lt;!-- Generated by graphviz version 2.40.1 (20161225.0304)
 --&gt;
&lt;!-- Title: btree_nodes Pages: 1 --&gt;
&lt;svg class="svg-responsive" height="389pt" viewbox="0.00 0.00 529.00 389.00" width="529pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
&lt;g class="graph" id="graph0" transform="scale(1 1) rotate(0) translate(4 385)"&gt;
&lt;title&gt;btree_nodes&lt;/title&gt;
&lt;polygon fill="#ffffff" points="-4,4 -4,-385 525,-385 525,4 -4,4" stroke="transparent"&gt;&lt;/polygon&gt;
&lt;!-- btree_node --&gt;
&lt;g class="node" id="node1"&gt;
&lt;title&gt;btree_node&lt;/title&gt;
&lt;polygon fill="none" points="0,-242.5 0,-380.5 166,-380.5 166,-242.5 0,-242.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="83" y="-365.3"&gt;header TREE_NODE&lt;/text&gt;
&lt;polyline fill="none" points="0,-357.5 166,-357.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="83" y="-342.3"&gt;key0: address&lt;/text&gt;
&lt;polyline fill="none" points="0,-334.5 166,-334.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="83" y="-319.3"&gt;key10: address&lt;/text&gt;
&lt;polyline fill="none" points="0,-311.5 166,-311.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="83" y="-296.3"&gt;key20: address&lt;/text&gt;
&lt;polyline fill="none" points="0,-288.5 166,-288.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="83" y="-273.3"&gt;...&lt;/text&gt;
&lt;polyline fill="none" points="0,-265.5 166,-265.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="83" y="-250.3"&gt;free space&lt;/text&gt;
&lt;/g&gt;
&lt;!-- btree_leaf1 --&gt;
&lt;g class="node" id="node2"&gt;
&lt;title&gt;btree_leaf1&lt;/title&gt;
&lt;polygon fill="none" points="238,-.5 238,-322.5 403,-322.5 403,-.5 238,-.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-307.3"&gt;header LEAF_NODE&lt;/text&gt;
&lt;polyline fill="none" points="238,-299.5 403,-299.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-284.3"&gt;key0: offset, size&lt;/text&gt;
&lt;polyline fill="none" points="238,-276.5 403,-276.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-261.3"&gt;key1: offset, size&lt;/text&gt;
&lt;polyline fill="none" points="238,-253.5 403,-253.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-238.3"&gt;key2: offset, size&lt;/text&gt;
&lt;polyline fill="none" points="238,-230.5 403,-230.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-215.3"&gt;...&lt;/text&gt;
&lt;polyline fill="none" points="238,-207.5 403,-207.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-192.3"&gt;keyN offset, size&lt;/text&gt;
&lt;polyline fill="none" points="238,-184.5 403,-184.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-169.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="238,-161.5 403,-161.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-146.3"&gt;free space&lt;/text&gt;
&lt;polyline fill="none" points="238,-138.5 403,-138.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-123.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="238,-115.5 403,-115.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-100.3"&gt;dataN&lt;/text&gt;
&lt;polyline fill="none" points="238,-92.5 403,-92.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-77.3"&gt;...&lt;/text&gt;
&lt;polyline fill="none" points="238,-69.5 403,-69.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-54.3"&gt;data2&lt;/text&gt;
&lt;polyline fill="none" points="238,-46.5 403,-46.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-31.3"&gt;data1&lt;/text&gt;
&lt;polyline fill="none" points="238,-23.5 403,-23.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="320.5" y="-8.3"&gt;data0&lt;/text&gt;
&lt;/g&gt;
&lt;!-- btree_node&amp;#45;&amp;gt;btree_leaf1 --&gt;
&lt;g class="edge" id="edge1"&gt;
&lt;title&gt;btree_node:key00-&amp;gt;btree_leaf1:label&lt;/title&gt;
&lt;path d="M166.2568,-311.5C186.1234,-311.5 207.4684,-311.5 227.7961,-311.5" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="228,-315.0001 238,-311.5 228,-308.0001 228,-315.0001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- btree_leaf1&amp;#45;&amp;gt;btree_leaf1 --&gt;
&lt;g class="edge" id="edge2"&gt;
&lt;title&gt;btree_leaf1:e-&amp;gt;btree_leaf1:e&lt;/title&gt;
&lt;path d="M403.5,-288.5C442.3333,-297.5 521,-297.5 521,-150 521,-14.3115 454.4278,-3.4458 413.5345,-9.5821" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="412.6651,-6.1849 403.5,-11.5 413.9793,-13.0604 412.6651,-6.1849" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- btree_leaf1&amp;#45;&amp;gt;btree_leaf1 --&gt;
&lt;g class="edge" id="edge3"&gt;
&lt;title&gt;btree_leaf1:w-&amp;gt;btree_leaf1:w&lt;/title&gt;
&lt;path d="M237.5,-265.5C198.6667,-274.5 120,-274.5 120,-150 120,-35.4697 186.5722,-26.2984 227.4655,-32.5703" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="227.0189,-36.0485 237.5,-34.5 228.3409,-29.1745 227.0189,-36.0485" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- btree_leaf1&amp;#45;&amp;gt;btree_leaf1 --&gt;
&lt;g class="edge" id="edge4"&gt;
&lt;title&gt;btree_leaf1:e-&amp;gt;btree_leaf1:e&lt;/title&gt;
&lt;path d="M403.5,-242.5C442.3333,-251.5 521,-251.5 521,-150 521,-56.6279 454.4278,-49.1509 413.5345,-55.5585" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="412.6531,-52.1641 403.5,-57.5 413.9828,-59.0366 412.6531,-52.1641" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;/svg&gt;
&lt;p&gt;由此，每个中间节点保存一系列 key 到叶子节点的指针，而叶子节点内保存一系列 item ，每个 item
固定大小，并指向节点内某个可变大小位置的 data 。从而逻辑上一棵B树可以包含任何类型的
item ，每个 item 都可以有可变大小的附加数据。通过这样的B树结构，可以紧凑而灵活地表达很多数据类型。&lt;/p&gt;
&lt;p&gt;有这样的背景之后，比如在
&lt;a class="reference external" href="https://btrfs.wiki.kernel.org/index.php/SysadminGuide#Flat"&gt;SysadminGuide 这页的 Flat 布局&lt;/a&gt;
有个子卷布局的例子。&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
toplevel         (volume root directory, not to be mounted by default)
    +-- root       (subvolume root directory, to be mounted at /)
    +-- home       (subvolume root directory, to be mounted at /home)
    +-- var        (directory)
    |   \-- www    (subvolume root directory, to be mounted at /var/www)
    \-- postgres   (subvolume root directory, to be mounted at /var/lib/postgresql)
&lt;/pre&gt;
&lt;p&gt;用圆柱体表示子卷的话画成图大概是这个样子：&lt;/p&gt;
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;

&lt;!-- Generated by graphviz version 2.40.1 (20161225.0304)
 --&gt;
&lt;!-- Title: Flat_layout Pages: 1 --&gt;
&lt;svg class="svg-responsive" height="206pt" viewbox="0.00 0.00 287.00 206.00" width="287pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
&lt;g class="graph" id="graph0" transform="scale(1 1) rotate(0) translate(4 202)"&gt;
&lt;title&gt;Flat_layout&lt;/title&gt;
&lt;polygon fill="#ffffff" points="-4,4 -4,-202 283,-202 283,4 -4,4" stroke="transparent"&gt;&lt;/polygon&gt;
&lt;!-- toplevel --&gt;
&lt;g class="node" id="node1"&gt;
&lt;title&gt;toplevel&lt;/title&gt;
&lt;path d="M74,-113.7273C74,-115.5331 57.416,-117 37,-117 16.584,-117 0,-115.5331 0,-113.7273 0,-113.7273 0,-84.2727 0,-84.2727 0,-82.4669 16.584,-81 37,-81 57.416,-81 74,-82.4669 74,-84.2727 74,-84.2727 74,-113.7273 74,-113.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;path d="M74,-113.7273C74,-111.9214 57.416,-110.4545 37,-110.4545 16.584,-110.4545 0,-111.9214 0,-113.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="37" y="-95.3"&gt;toplevel&lt;/text&gt;
&lt;/g&gt;
&lt;!-- root --&gt;
&lt;g class="node" id="node2"&gt;
&lt;title&gt;root&lt;/title&gt;
&lt;path d="M176.5,-194.7273C176.5,-196.5331 164.3982,-198 149.5,-198 134.6018,-198 122.5,-196.5331 122.5,-194.7273 122.5,-194.7273 122.5,-165.2727 122.5,-165.2727 122.5,-163.4669 134.6018,-162 149.5,-162 164.3982,-162 176.5,-163.4669 176.5,-165.2727 176.5,-165.2727 176.5,-194.7273 176.5,-194.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;path d="M176.5,-194.7273C176.5,-192.9214 164.3982,-191.4545 149.5,-191.4545 134.6018,-191.4545 122.5,-192.9214 122.5,-194.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="149.5" y="-176.3"&gt;root&lt;/text&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;root --&gt;
&lt;g class="edge" id="edge1"&gt;
&lt;title&gt;toplevel-&amp;gt;root&lt;/title&gt;
&lt;path d="M60.5079,-116.7348C74.7361,-127.3823 93.2999,-141.1218 110,-153 111.8699,-154.33 113.7963,-155.6874 115.7451,-157.0508" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="114.115,-160.1795 124.3276,-163 118.1029,-154.4265 114.115,-160.1795" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- home --&gt;
&lt;g class="node" id="node3"&gt;
&lt;title&gt;home&lt;/title&gt;
&lt;path d="M177.5,-140.7273C177.5,-142.5331 164.95,-144 149.5,-144 134.05,-144 121.5,-142.5331 121.5,-140.7273 121.5,-140.7273 121.5,-111.2727 121.5,-111.2727 121.5,-109.4669 134.05,-108 149.5,-108 164.95,-108 177.5,-109.4669 177.5,-111.2727 177.5,-111.2727 177.5,-140.7273 177.5,-140.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;path d="M177.5,-140.7273C177.5,-138.9214 164.95,-137.4545 149.5,-137.4545 134.05,-137.4545 121.5,-138.9214 121.5,-140.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="149.5" y="-122.3"&gt;home&lt;/text&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;home --&gt;
&lt;g class="edge" id="edge2"&gt;
&lt;title&gt;toplevel-&amp;gt;home&lt;/title&gt;
&lt;path d="M74.1485,-107.9156C86.1488,-110.7957 99.4652,-113.9916 111.5245,-116.8859" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="110.7613,-120.302 121.302,-119.2325 112.395,-113.4953 110.7613,-120.302" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- var --&gt;
&lt;g class="node" id="node4"&gt;
&lt;title&gt;var&lt;/title&gt;
&lt;polygon fill="none" points="176.5,-90 173.5,-94 152.5,-94 149.5,-90 122.5,-90 122.5,-54 176.5,-54 176.5,-90" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="149.5" y="-68.3"&gt;var&lt;/text&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;var --&gt;
&lt;g class="edge" id="edge3"&gt;
&lt;title&gt;toplevel-&amp;gt;var&lt;/title&gt;
&lt;path d="M74.1485,-90.0844C86.4488,-87.1323 100.1319,-83.8484 112.4265,-80.8976" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="113.4596,-84.2492 122.3666,-78.512 111.8259,-77.4425 113.4596,-84.2492" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- postgres --&gt;
&lt;g class="node" id="node6"&gt;
&lt;title&gt;postgres&lt;/title&gt;
&lt;path d="M189,-32.7273C189,-34.5331 171.2955,-36 149.5,-36 127.7045,-36 110,-34.5331 110,-32.7273 110,-32.7273 110,-3.2727 110,-3.2727 110,-1.4669 127.7045,0 149.5,0 171.2955,0 189,-1.4669 189,-3.2727 189,-3.2727 189,-32.7273 189,-32.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;path d="M189,-32.7273C189,-30.9214 171.2955,-29.4545 149.5,-29.4545 127.7045,-29.4545 110,-30.9214 110,-32.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="149.5" y="-14.3"&gt;postgres&lt;/text&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;postgres --&gt;
&lt;g class="edge" id="edge5"&gt;
&lt;title&gt;toplevel-&amp;gt;postgres&lt;/title&gt;
&lt;path d="M60.5079,-81.2652C74.7361,-70.6177 93.2999,-56.8782 110,-45 111.5738,-43.8806 113.1875,-42.7418 114.821,-41.5965" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="116.8432,-44.4534 123.0588,-35.8733 112.8492,-38.7046 116.8432,-44.4534" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- www --&gt;
&lt;g class="node" id="node5"&gt;
&lt;title&gt;www&lt;/title&gt;
&lt;path d="M279,-86.7273C279,-88.5331 266.8982,-90 252,-90 237.1018,-90 225,-88.5331 225,-86.7273 225,-86.7273 225,-57.2727 225,-57.2727 225,-55.4669 237.1018,-54 252,-54 266.8982,-54 279,-55.4669 279,-57.2727 279,-57.2727 279,-86.7273 279,-86.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;path d="M279,-86.7273C279,-84.9214 266.8982,-83.4545 252,-83.4545 237.1018,-83.4545 225,-84.9214 225,-86.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="252" y="-68.3"&gt;www&lt;/text&gt;
&lt;/g&gt;
&lt;!-- var&amp;#45;&amp;gt;www --&gt;
&lt;g class="edge" id="edge4"&gt;
&lt;title&gt;var-&amp;gt;www&lt;/title&gt;
&lt;path d="M176.699,-72C188.2828,-72 201.9866,-72 214.5073,-72" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="214.6739,-75.5001 224.6739,-72 214.6739,-68.5001 214.6739,-75.5001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;/svg&gt;
&lt;p&gt;上图例子中的 Flat 布局在 btrfs 中大概是这样的数据结构，
其中实线箭头是B树一系列中间节点和叶子节点，逻辑上指向一棵B树，虚线箭头是根据
inode 号之类的编号的引用：&lt;/p&gt;
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;

&lt;!-- Generated by graphviz version 2.40.1 (20161225.0304)
 --&gt;
&lt;!-- Title: Flat_layout_on_disk Pages: 1 --&gt;
&lt;svg class="svg-responsive" height="499pt" viewbox="0.00 0.00 1130.00 499.00" width="1130pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
&lt;g class="graph" id="graph0" transform="scale(1 1) rotate(0) translate(4 495)"&gt;
&lt;title&gt;Flat_layout_on_disk&lt;/title&gt;
&lt;polygon fill="#ffffff" points="-4,4 -4,-495 1126,-495 1126,4 -4,4" stroke="transparent"&gt;&lt;/polygon&gt;
&lt;!-- superblock --&gt;
&lt;g class="node" id="node1"&gt;
&lt;title&gt;superblock&lt;/title&gt;
&lt;polygon fill="none" points="0,-315.5 0,-407.5 123,-407.5 123,-315.5 0,-315.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="61.5" y="-392.3"&gt;SUPERBLOCK&lt;/text&gt;
&lt;polyline fill="none" points="0,-384.5 123,-384.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="61.5" y="-369.3"&gt;...&lt;/text&gt;
&lt;polyline fill="none" points="0,-361.5 123,-361.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="61.5" y="-346.3"&gt;root_tree&lt;/text&gt;
&lt;polyline fill="none" points="0,-338.5 123,-338.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="61.5" y="-323.3"&gt;...&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree --&gt;
&lt;g class="node" id="node2"&gt;
&lt;title&gt;roottree&lt;/title&gt;
&lt;polygon fill="none" points="195,-62 195,-361 504,-361 504,-62 195,-62" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-345.8"&gt;ROOT_TREE&lt;/text&gt;
&lt;polyline fill="none" points="195,-338 504,-338 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-322.8"&gt;2: extent_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-315 504,-315 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-299.8"&gt;3: chunk_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-292 504,-292 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-276.8"&gt;4: dev_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-269 504,-269 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-253.8"&gt;5: fs_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-246 504,-246 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-230.8"&gt;6: root_dir "default" -&amp;gt; ROOT_ITEM 256&lt;/text&gt;
&lt;polyline fill="none" points="195,-223 504,-223 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-207.8"&gt;10: free_space_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-200 504,-200 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-184.8"&gt;256: fs_tree "root"&lt;/text&gt;
&lt;polyline fill="none" points="195,-177 504,-177 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-161.8"&gt;257: fs_tree "home"&lt;/text&gt;
&lt;polyline fill="none" points="195,-154 504,-154 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-138.8"&gt;258: fs_tree "www"&lt;/text&gt;
&lt;polyline fill="none" points="195,-131 504,-131 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-115.8"&gt;259: fs_tree "postgres"&lt;/text&gt;
&lt;polyline fill="none" points="195,-108 504,-108 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-92.8"&gt;-7: tree_log_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-85 504,-85 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-69.8"&gt;-5: orphan_root&lt;/text&gt;
&lt;/g&gt;
&lt;!-- superblock&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge1"&gt;
&lt;title&gt;superblock:sn_root-&amp;gt;roottree:label&lt;/title&gt;
&lt;path d="M123,-349.5C151.375,-349.5 160.8795,-349.5 184.9792,-349.5" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="185,-353.0001 195,-349.5 185,-346.0001 185,-353.0001" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge8"&gt;
&lt;title&gt;roottree:e-&amp;gt;roottree:e&lt;/title&gt;
&lt;path d="M504.5,-234.5C552,-243.5 648,-243.5 648,-211.5 648,-181.625 564.3267,-179.6411 514.5622,-186.8328" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="513.7934,-183.4124 504.5,-188.5 514.9376,-190.3183 513.7934,-183.4124" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel --&gt;
&lt;g class="node" id="node3"&gt;
&lt;title&gt;toplevel&lt;/title&gt;
&lt;polygon fill="none" points="576,-195.5 576,-425.5 923,-425.5 923,-195.5 576,-195.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-410.3"&gt;FS_TREE "toplevel"&lt;/text&gt;
&lt;polyline fill="none" points="576,-402.5 923,-402.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-387.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="576,-379.5 923,-379.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-364.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;polyline fill="none" points="576,-356.5 923,-356.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-341.3"&gt;256: dir_item: "root" -&amp;gt; ROOT_ITEM 256&lt;/text&gt;
&lt;polyline fill="none" points="576,-333.5 923,-333.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-318.3"&gt;256: dir_item: "home" -&amp;gt; ROOT_ITEM 257&lt;/text&gt;
&lt;polyline fill="none" points="576,-310.5 923,-310.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-295.3"&gt;256: dir_item: "var" -&amp;gt; INODE_ITEM 257&lt;/text&gt;
&lt;polyline fill="none" points="576,-287.5 923,-287.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-272.3"&gt;256: dir_item: "postgres" -&amp;gt; ROOT_ITEM 259&lt;/text&gt;
&lt;polyline fill="none" points="576,-264.5 923,-264.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-249.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="576,-241.5 923,-241.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-226.3"&gt;257: inode_item DIR&lt;/text&gt;
&lt;polyline fill="none" points="576,-218.5 923,-218.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-203.3"&gt;257: dir_item: "www" -&amp;gt; ROOT_ITEM 258&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;toplevel --&gt;
&lt;g class="edge" id="edge7"&gt;
&lt;title&gt;roottree:root_fs-&amp;gt;toplevel:label&lt;/title&gt;
&lt;path d="M504,-257.5C577.0172,-257.5 506.8191,-399.5423 565.8504,-413.4136" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="565.6843,-416.9157 576,-414.5 566.4293,-409.9555 565.6843,-416.9157" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- root --&gt;
&lt;g class="node" id="node4"&gt;
&lt;title&gt;root&lt;/title&gt;
&lt;polygon fill="none" points="667.5,-444.5 667.5,-490.5 831.5,-490.5 831.5,-444.5 667.5,-444.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-475.3"&gt;FS_TREE "root"&lt;/text&gt;
&lt;polyline fill="none" points="667.5,-467.5 831.5,-467.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-452.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;root --&gt;
&lt;g class="edge" id="edge9"&gt;
&lt;title&gt;roottree:root_sub_root-&amp;gt;root:label&lt;/title&gt;
&lt;path d="M504,-188.5C617.92,-188.5 502.6779,-347.3126 576,-434.5 602.8896,-466.4744 619.4489,-477.7394 657.3774,-479.3044" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="657.4342,-482.8061 667.5,-479.5 657.5695,-475.8074 657.4342,-482.8061" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- home --&gt;
&lt;g class="node" id="node5"&gt;
&lt;title&gt;home&lt;/title&gt;
&lt;polygon fill="none" points="667.5,-130.5 667.5,-176.5 831.5,-176.5 831.5,-130.5 667.5,-130.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-161.3"&gt;FS_TREE "home"&lt;/text&gt;
&lt;polyline fill="none" points="667.5,-153.5 831.5,-153.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-138.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;home --&gt;
&lt;g class="edge" id="edge10"&gt;
&lt;title&gt;roottree:root_sub_home-&amp;gt;home:label&lt;/title&gt;
&lt;path d="M504,-165.5C573.1185,-165.5 592.9293,-165.5 657.2326,-165.5" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="657.5,-169.0001 667.5,-165.5 657.5,-162.0001 657.5,-169.0001" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- www --&gt;
&lt;g class="node" id="node6"&gt;
&lt;title&gt;www&lt;/title&gt;
&lt;polygon fill="none" points="667.5,-65.5 667.5,-111.5 831.5,-111.5 831.5,-65.5 667.5,-65.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-96.3"&gt;FS_TREE "www"&lt;/text&gt;
&lt;polyline fill="none" points="667.5,-88.5 831.5,-88.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-73.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;www --&gt;
&lt;g class="edge" id="edge11"&gt;
&lt;title&gt;roottree:root_sub_www-&amp;gt;www:label&lt;/title&gt;
&lt;path d="M504,-142.5C537.4605,-142.5 543.6289,-128.9684 576,-120.5 612.8107,-110.8702 623.9964,-102.1347 657.4378,-100.7044" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="657.5732,-104.2024 667.5,-100.5 657.431,-97.2039 657.5732,-104.2024" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- postgres --&gt;
&lt;g class="node" id="node7"&gt;
&lt;title&gt;postgres&lt;/title&gt;
&lt;polygon fill="none" points="667,-.5 667,-46.5 832,-46.5 832,-.5 667,-.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-31.3"&gt;FS_TREE "postgres"&lt;/text&gt;
&lt;polyline fill="none" points="667,-23.5 832,-23.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-8.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;postgres --&gt;
&lt;g class="edge" id="edge12"&gt;
&lt;title&gt;roottree:root_sub_postgres-&amp;gt;postgres:label&lt;/title&gt;
&lt;path d="M504,-119.5C546.8146,-119.5 537.8681,-74.9691 576,-55.5 609.5346,-38.3781 622.9605,-35.847 656.4796,-35.5384" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="656.5135,-39.0384 666.5,-35.5 656.4866,-32.0384 656.5135,-39.0384" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge2"&gt;
&lt;title&gt;toplevel:toplevel_dir_root-&amp;gt;roottree:root_sub_root&lt;/title&gt;
&lt;path d="M576,-345.5C502.9828,-345.5 573.1809,-203.4577 514.1496,-189.5864" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="514.3157,-186.0843 504,-188.5 513.5707,-193.0445 514.3157,-186.0843" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge3"&gt;
&lt;title&gt;toplevel:toplevel_dir_home-&amp;gt;roottree:root_sub_home&lt;/title&gt;
&lt;path d="M576,-322.5C502.9828,-322.5 573.1809,-180.4577 514.1496,-166.5864" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="514.3157,-163.0843 504,-165.5 513.5707,-170.0445 514.3157,-163.0843" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge5"&gt;
&lt;title&gt;toplevel:toplevel_dir_postgres-&amp;gt;roottree:root_sub_postgres&lt;/title&gt;
&lt;path d="M576,-275.5C503.3669,-275.5 572.8531,-134.3624 514.0988,-120.5795" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="514.3154,-117.0828 504,-119.5 513.5713,-124.0431 514.3154,-117.0828" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge6"&gt;
&lt;title&gt;toplevel:toplevel_dir_www-&amp;gt;roottree:root_sub_www&lt;/title&gt;
&lt;path d="M576,-206.5C537.0321,-206.5 544.8212,-153.4834 514.2549,-143.957" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="514.3929,-140.4415 504,-142.5 513.4082,-147.3719 514.3929,-140.4415" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;toplevel --&gt;
&lt;g class="edge" id="edge4"&gt;
&lt;title&gt;toplevel:e-&amp;gt;toplevel:e&lt;/title&gt;
&lt;path d="M923.5,-298.5C989.3333,-307.5 1122,-307.5 1122,-264 1122,-222.624 1001.9728,-220.6037 933.5984,-228.25" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="932.9943,-224.798 923.5,-229.5 933.8542,-231.745 932.9943,-224.798" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;/svg&gt;
&lt;p&gt;上图中已经隐去了很多和本文无关的具体细节，所有这些细节都可以通过
&lt;a class="reference external" href="https://btrfs.wiki.kernel.org/index.php/Manpage/btrfs-inspect-internal"&gt;btrfs inspect-internal 的 dump-super 和 dump-tree&lt;/a&gt;
查看到。&lt;/p&gt;
&lt;p&gt;ROOT_TREE 中记录了到所有别的B树的指针，在一些文档中叫做 tree of tree roots 。「所有别的B树」
举例来说比如 2 号 extent_tree ，3 号 chunk_tree ， 4 号 dev_tree ，10 号 free_space_tree
，这些B树都是描述 btrfs 文件系统结构非常重要的组成部分，但是在本文关系不大，
今后有机会再讨论它们。在 ROOT_TREE 的 5 号对象有一个 fs_tree ，它描述了整个 btrfs pool
的顶级子卷，也就是图中叫 toplevel 的那个子卷（有些文档用定冠词称 the FS_TREE
的时候就是在说这个 5 号树，而不是别的子卷的 FS_TREE ）。除了顶级子卷之外，别的所有子卷的 object_id
在 256ULL 到 -256ULL 的范围之间，对子卷而言 ROOT_TREE 中的这些 object_id 也同时是它们的
子卷 id ，在内核挂载文件系统的时候可以用 subvolid 找到它们，别的一些对子卷的操作也可以直接用
subvolid 表示一个子卷。 ROOT_TREE 的 6 号对象描述的不是一棵树，而是一个名叫 default
的特殊目录，它指向 btrfs pool 的默认挂载子卷。最初 mkfs 的时候，这个目录指向 ROOT_ITEM 5
，也就是那个顶级子卷，之后可以通过命令 &lt;code class="code"&gt;
btrfs subvolume set-default&lt;/code&gt;

修改它指向别的子卷，这里它被改为指向 ROOT_ITEM 256 亦即那个名叫 "root" 的子卷。&lt;/p&gt;
&lt;p&gt;每一个子卷都有一棵自己的 FS_TREE （有的文档中叫 file tree），一个 FS_TREE 相当于传统 Unix
文件系统中的一整个 inode table ，只不过它除了包含 inode 信息之外还包含所有文件夹内容。在
FS_TREE 中， object_id 同时也是它所描述对象的 inode 号，所以 btrfs
的 &lt;strong&gt;子卷有互相独立的 inode 编号&lt;/strong&gt; ，不同子卷中的文件或目录可以拥有相同的 inode 。
或许有人不太清楚子卷间 inode 编号独立意味着什么，简单地说，这意味着你不能跨子卷创建
hard link ，不能跨子卷 mv 移动文件而不产生复制操作。不过因为 reflink 和 inode 无关，
可以跨子卷创建 reflink ，也可以用 reflink + rm 的方式快速「移动」文件（这里移动加引号是因为
inode 变了，传统上不算移动）。&lt;/p&gt;
&lt;p&gt;FS_TREE 中一个目录用一个 inode_item 和多个 dir_item 描述， inode_item 是目录自己的 inode
，那些 dir_item 是目录的内容。 dir_item 可以指向别的 inode_item 来描述普通文件和子目录，
也可以指向 root_item 来描述这个目录指向一个子卷。有人或许疑惑，子卷就没有自己的 inode
么？其实如果看 &lt;a class="reference external" href="https://btrfs.wiki.kernel.org/index.php/Data_Structures#btrfs_root_item"&gt;数据结构定义&lt;/a&gt;
的话 &lt;code class="code"&gt;
struct btrfs_root_item&lt;/code&gt;
 结构在最开头的地方包含了一个
&lt;code class="code"&gt;
struct btrfs_inode_item&lt;/code&gt;
 所以 root_item 也同时作为子卷的 inode
，不过用户通常看不到这个子卷的 inode ，因为子卷在被（手动或自动地）挂载到目录上之后，
用户会看到的是子卷的根目录的 inode 。&lt;/p&gt;
&lt;p&gt;比如上图 FS_TREE toplevel 中，有两个对象，第一个 256 是（子卷的）根目录，第二个 257
是 "var" 目录，256 有4个子目录，其中 "root" "home" "postgres" 这三个指向了 ROOT_TREE
中的对应子卷，而 "var" 指向了 inode 257 。然后 257 有一个子目录叫 "www" 它指向了
ROOT_TREE 中 object_id 为 258 的子卷。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id37"&gt;1.3   那么快照又是如何记录的呢？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;以上是子卷、目录、 inode 在 btrfs 中的记录方式，你可能想知道，如何记录一个快照呢？
特别是，如果对一个包含子卷的子卷创建了快照，会得到什么结果呢？如果我们在上面的布局基础上执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;btrfs subvolume snapshot toplevel toplevel/toplevel@s1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么产生的数据结构大概如下所示：&lt;/p&gt;
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;

&lt;!-- Generated by graphviz version 2.40.1 (20161225.0304)
 --&gt;
&lt;!-- Title: Flat_layout_on_disk Pages: 1 --&gt;
&lt;svg class="svg-responsive" height="781pt" viewbox="0.00 0.00 1162.00 781.00" width="1162pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
&lt;g class="graph" id="graph0" transform="scale(1 1) rotate(0) translate(4 777)"&gt;
&lt;title&gt;Flat_layout_on_disk&lt;/title&gt;
&lt;polygon fill="#ffffff" points="-4,4 -4,-777 1158,-777 1158,4 -4,4" stroke="transparent"&gt;&lt;/polygon&gt;
&lt;!-- superblock --&gt;
&lt;g class="node" id="node1"&gt;
&lt;title&gt;superblock&lt;/title&gt;
&lt;polygon fill="none" points="0,-680.5 0,-772.5 123,-772.5 123,-680.5 0,-680.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="61.5" y="-757.3"&gt;SUPERBLOCK&lt;/text&gt;
&lt;polyline fill="none" points="0,-749.5 123,-749.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="61.5" y="-734.3"&gt;...&lt;/text&gt;
&lt;polyline fill="none" points="0,-726.5 123,-726.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="61.5" y="-711.3"&gt;root_tree&lt;/text&gt;
&lt;polyline fill="none" points="0,-703.5 123,-703.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="61.5" y="-688.3"&gt;...&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree --&gt;
&lt;g class="node" id="node2"&gt;
&lt;title&gt;roottree&lt;/title&gt;
&lt;polygon fill="none" points="195,-403.5 195,-725.5 504,-725.5 504,-403.5 195,-403.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-710.3"&gt;ROOT_TREE&lt;/text&gt;
&lt;polyline fill="none" points="195,-702.5 504,-702.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-687.3"&gt;2: extent_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-679.5 504,-679.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-664.3"&gt;3: chunk_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-656.5 504,-656.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-641.3"&gt;4: dev_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-633.5 504,-633.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-618.3"&gt;5: fs_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-610.5 504,-610.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-595.3"&gt;6: root_dir "default" -&amp;gt; ROOT_ITEM 256&lt;/text&gt;
&lt;polyline fill="none" points="195,-587.5 504,-587.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-572.3"&gt;10: free_space_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-564.5 504,-564.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-549.3"&gt;256: fs_tree "root"&lt;/text&gt;
&lt;polyline fill="none" points="195,-541.5 504,-541.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-526.3"&gt;257: fs_tree "home"&lt;/text&gt;
&lt;polyline fill="none" points="195,-518.5 504,-518.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-503.3"&gt;258: fs_tree "www"&lt;/text&gt;
&lt;polyline fill="none" points="195,-495.5 504,-495.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-480.3"&gt;259: fs_tree "postgres"&lt;/text&gt;
&lt;polyline fill="none" points="195,-472.5 504,-472.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-457.3"&gt;260: fs_tree "toplevel@s1"&lt;/text&gt;
&lt;polyline fill="none" points="195,-449.5 504,-449.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-434.3"&gt;-7: tree_log_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-426.5 504,-426.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-411.3"&gt;-5: orphan_root&lt;/text&gt;
&lt;/g&gt;
&lt;!-- superblock&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge1"&gt;
&lt;title&gt;superblock:sn_root-&amp;gt;roottree:label&lt;/title&gt;
&lt;path d="M123,-714.5C151.375,-714.5 160.8795,-714.5 184.9792,-714.5" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="185,-718.0001 195,-714.5 185,-711.0001 185,-718.0001" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge10"&gt;
&lt;title&gt;roottree:e-&amp;gt;roottree:e&lt;/title&gt;
&lt;path d="M504.5,-599.5C552,-608.5 648,-608.5 648,-576 648,-545.6582 564.3267,-543.6433 514.5622,-550.833" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="513.7934,-547.4125 504.5,-552.5 514.9376,-554.3184 513.7934,-547.4125" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel --&gt;
&lt;g class="node" id="node3"&gt;
&lt;title&gt;toplevel&lt;/title&gt;
&lt;polygon fill="none" points="576,-380 576,-633 948,-633 948,-380 576,-380" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-617.8"&gt;FS_TREE "toplevel"&lt;/text&gt;
&lt;polyline fill="none" points="576,-610 948,-610 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-594.8"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="576,-587 948,-587 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-571.8"&gt;256: inode_item DIR&lt;/text&gt;
&lt;polyline fill="none" points="576,-564 948,-564 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-548.8"&gt;256: dir_item: "root" -&amp;gt; ROOT_ITEM 256&lt;/text&gt;
&lt;polyline fill="none" points="576,-541 948,-541 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-525.8"&gt;256: dir_item: "home" -&amp;gt; ROOT_ITEM 257&lt;/text&gt;
&lt;polyline fill="none" points="576,-518 948,-518 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-502.8"&gt;256: dir_item: "var" -&amp;gt; INODE_ITEM 257&lt;/text&gt;
&lt;polyline fill="none" points="576,-495 948,-495 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-479.8"&gt;256: dir_item: "postgres" -&amp;gt; ROOT_ITEM 259&lt;/text&gt;
&lt;polyline fill="none" points="576,-472 948,-472 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-456.8"&gt;256: dir_item: "toplevel@s1" -&amp;gt; ROOT_ITEM 260&lt;/text&gt;
&lt;polyline fill="none" points="576,-449 948,-449 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-433.8"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="576,-426 948,-426 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-410.8"&gt;257: inode_item DIR&lt;/text&gt;
&lt;polyline fill="none" points="576,-403 948,-403 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-387.8"&gt;257: dir_item: "www" -&amp;gt; ROOT_ITEM 258&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;toplevel --&gt;
&lt;g class="edge" id="edge8"&gt;
&lt;title&gt;roottree:root_fs-&amp;gt;toplevel:label&lt;/title&gt;
&lt;path d="M504,-622.5C532.3777,-622.5 541.8777,-621.7137 565.9785,-621.5356" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="566.0125,-625.0356 576,-621.5 565.9876,-618.0356 566.0125,-625.0356" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevels1 --&gt;
&lt;g class="node" id="node4"&gt;
&lt;title&gt;toplevels1&lt;/title&gt;
&lt;polygon fill="none" points="588.5,-.5 588.5,-230.5 935.5,-230.5 935.5,-.5 588.5,-.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-215.3"&gt;FS_TREE "toplevel@s1"&lt;/text&gt;
&lt;polyline fill="none" points="588.5,-207.5 935.5,-207.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-192.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="588.5,-184.5 935.5,-184.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-169.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;polyline fill="none" points="588.5,-161.5 935.5,-161.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-146.3"&gt;256: dir_item: "root" -&amp;gt; ROOT_ITEM 256&lt;/text&gt;
&lt;polyline fill="none" points="588.5,-138.5 935.5,-138.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-123.3"&gt;256: dir_item: "home" -&amp;gt; ROOT_ITEM 257&lt;/text&gt;
&lt;polyline fill="none" points="588.5,-115.5 935.5,-115.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-100.3"&gt;256: dir_item: "var" -&amp;gt; INODE_ITEM 257&lt;/text&gt;
&lt;polyline fill="none" points="588.5,-92.5 935.5,-92.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-77.3"&gt;256: dir_item: "postgres" -&amp;gt; ROOT_ITEM 259&lt;/text&gt;
&lt;polyline fill="none" points="588.5,-69.5 935.5,-69.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-54.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="588.5,-46.5 935.5,-46.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-31.3"&gt;257: inode_item DIR&lt;/text&gt;
&lt;polyline fill="none" points="588.5,-23.5 935.5,-23.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-8.3"&gt;257: dir_item: "www" -&amp;gt; ROOT_ITEM 258&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;toplevels1 --&gt;
&lt;g class="edge" id="edge9"&gt;
&lt;title&gt;roottree:root_sub_s1-&amp;gt;toplevels1:label&lt;/title&gt;
&lt;path d="M504,-460.5C613.7754,-460.5 483.5108,-234.7829 577.8149,-220.2347" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="578.2778,-223.7105 588,-219.5 577.7741,-216.7287 578.2778,-223.7105" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- root --&gt;
&lt;g class="node" id="node5"&gt;
&lt;title&gt;root&lt;/title&gt;
&lt;polygon fill="none" points="680,-717.5 680,-763.5 844,-763.5 844,-717.5 680,-717.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-748.3"&gt;FS_TREE "root"&lt;/text&gt;
&lt;polyline fill="none" points="680,-740.5 844,-740.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-725.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;root --&gt;
&lt;g class="edge" id="edge11"&gt;
&lt;title&gt;roottree:root_sub_root-&amp;gt;root:label&lt;/title&gt;
&lt;path d="M504,-552.5C580.3617,-552.5 521.1427,-655.3795 576,-708.5 609.5199,-740.9586 627.2238,-751.0945 669.8767,-752.3594" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="669.9523,-755.8607 680,-752.5 670.0496,-748.8614 669.9523,-755.8607" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- home --&gt;
&lt;g class="node" id="node6"&gt;
&lt;title&gt;home&lt;/title&gt;
&lt;polygon fill="none" points="680,-652.5 680,-698.5 844,-698.5 844,-652.5 680,-652.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-683.3"&gt;FS_TREE "home"&lt;/text&gt;
&lt;polyline fill="none" points="680,-675.5 844,-675.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-660.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;home --&gt;
&lt;g class="edge" id="edge12"&gt;
&lt;title&gt;roottree:root_sub_home-&amp;gt;home:label&lt;/title&gt;
&lt;path d="M504,-529.5C563.5506,-529.5 530.6816,-603.867 576,-642.5 611.6322,-672.8757 627.3697,-685.6659 669.8761,-687.3144" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="669.9375,-690.816 680,-687.5 670.0659,-683.8172 669.9375,-690.816" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- www --&gt;
&lt;g class="node" id="node7"&gt;
&lt;title&gt;www&lt;/title&gt;
&lt;polygon fill="none" points="680,-314.5 680,-360.5 844,-360.5 844,-314.5 680,-314.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-345.3"&gt;FS_TREE "www"&lt;/text&gt;
&lt;polyline fill="none" points="680,-337.5 844,-337.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-322.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;www --&gt;
&lt;g class="edge" id="edge13"&gt;
&lt;title&gt;roottree:root_sub_www-&amp;gt;www:label&lt;/title&gt;
&lt;path d="M504,-506.5C572.3925,-506.5 521.2069,-411.4298 576,-370.5 610.9748,-344.3743 629.9117,-348.6235 669.9457,-349.3981" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="669.965,-352.8984 680,-349.5 670.036,-345.8988 669.965,-352.8984" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- postgres --&gt;
&lt;g class="node" id="node8"&gt;
&lt;title&gt;postgres&lt;/title&gt;
&lt;polygon fill="none" points="679.5,-249.5 679.5,-295.5 844.5,-295.5 844.5,-249.5 679.5,-249.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-280.3"&gt;FS_TREE "postgres"&lt;/text&gt;
&lt;polyline fill="none" points="679.5,-272.5 844.5,-272.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="762" y="-257.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;postgres --&gt;
&lt;g class="edge" id="edge14"&gt;
&lt;title&gt;roottree:root_sub_postgres-&amp;gt;postgres:label&lt;/title&gt;
&lt;path d="M504,-483.5C589.7501,-483.5 509.8697,-359.0882 576,-304.5 609.2237,-277.075 629.1685,-283.2528 668.7818,-284.3531" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="668.9507,-287.8558 679,-284.5 669.0514,-280.8565 668.9507,-287.8558" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge2"&gt;
&lt;title&gt;toplevel:toplevel_dir_root-&amp;gt;roottree:root_sub_root&lt;/title&gt;
&lt;path d="M576,-552.5C547.625,-552.5 538.1205,-552.5 514.0208,-552.5" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="514,-549.0001 504,-552.5 514,-556.0001 514,-549.0001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge3"&gt;
&lt;title&gt;toplevel:toplevel_dir_home-&amp;gt;roottree:root_sub_home&lt;/title&gt;
&lt;path d="M576,-529.5C547.625,-529.5 538.1205,-529.5 514.0208,-529.5" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="514,-526.0001 504,-529.5 514,-533.0001 514,-526.0001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge5"&gt;
&lt;title&gt;toplevel:toplevel_dir_postgres-&amp;gt;roottree:root_sub_postgres&lt;/title&gt;
&lt;path d="M576,-483.5C547.625,-483.5 538.1205,-483.5 514.0208,-483.5" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="514,-480.0001 504,-483.5 514,-487.0001 514,-480.0001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge6"&gt;
&lt;title&gt;toplevel:toplevel_dir_toplevels1-&amp;gt;roottree:root_sub_s1&lt;/title&gt;
&lt;path d="M576,-460.5C547.625,-460.5 538.1205,-460.5 514.0208,-460.5" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="514,-457.0001 504,-460.5 514,-464.0001 514,-457.0001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge7"&gt;
&lt;title&gt;toplevel:toplevel_dir_www-&amp;gt;roottree:root_sub_www&lt;/title&gt;
&lt;path d="M576,-391.5C519.4668,-391.5 558.652,-492.5742 514.0836,-505.2085" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="513.4743,-501.7579 504,-506.5 514.3637,-508.7011 513.4743,-501.7579" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;toplevel --&gt;
&lt;g class="edge" id="edge4"&gt;
&lt;title&gt;toplevel:e-&amp;gt;toplevel:e&lt;/title&gt;
&lt;path d="M948,-506.5C1016.6667,-515.5 1154,-515.5 1154,-460.5 1154,-408.0781 1029.2399,-405.6208 958.0877,-413.2984" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="none" points="957.5158,-409.8417 948,-414.5 958.3438,-416.7926 957.5158,-409.8417" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;/svg&gt;
&lt;p&gt;在 ROOT_TREE 中增加了 260 号子卷，其内容复制自 toplevel 子卷，然后 FS_TREE toplevel
的 256 号 inode 也就是根目录中增加一个 dir_item 名叫 &lt;cite&gt;toplevel@s1&lt;/cite&gt; 它指向 ROOT_ITEM
的 260 号子卷。这里看似是完整复制了整个 FS_TREE 的内容，这是因为 CoW b-tree
当只有一个叶子节点时就复制整个叶子节点。如果子卷内容再多一些，除了叶子之外还有中间节点，
那么只有被修改的叶子和其上的中间节点需要复制。从而创建快照的开销基本上是
O( level of FS_TREE )，而B树的高度一般都能维持在很低的程度，所以快照创建速度近乎是常数开销。&lt;/p&gt;
&lt;p&gt;从子卷和快照的这种实现方式，可以看出： &lt;strong&gt;虽然子卷可以嵌套子卷，但是对含有嵌套子卷的子卷做快照的语义有些特别&lt;/strong&gt;
。上图中我没有画 &lt;cite&gt;toplevel@s1&lt;/cite&gt; 下的各个子卷到对应 ROOT_ITEM 之间的虚线箭头，
是因为这时候如果你尝试直接跳过 &lt;cite&gt;toplevel&lt;/cite&gt; 挂载 &lt;cite&gt;toplevel@s1&lt;/cite&gt; 到挂载点，
会发现那些子卷没有被自动挂载，更奇怪的是那些子卷的目录项也不是个普通目录，
尝试往它们中放东西会得到无权访问的错误，对它们能做的唯一事情是手动将别的子卷挂载在上面。
推测原因在于这些子目录并不是真的目录，没有对应的目录的 inode ，试图查看它们的 inode
号会得到 2 号，而这是个保留号不应该出现在 btrfs 的 inode 号中。
每个子卷创建时会记录包含它的上级子卷，用 &lt;code class="code"&gt;
btrfs subvolume list&lt;/code&gt;
 可以看到每个子卷的
top level subvolid ，猜测当挂载 A 而 A 中嵌套的 B 子卷记录的上级子卷不是 A 的时候，
会出现上述奇怪行为。嵌套子卷的快照还有一些别的奇怪行为，大家可以自己探索探索。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
建议用平坦的子卷布局&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;p&gt;因为上述嵌套子卷在做快照时的特殊行为，
我个人建议是 &lt;strong&gt;保持平坦的子卷布局&lt;/strong&gt; ，也就是说：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;只让顶层子卷包含其它子卷，除了顶层子卷之外的子卷只做手工挂载，不放嵌套子卷&lt;/li&gt;
&lt;li&gt;只在顶层子卷对其它子卷做快照，不快照顶层子卷&lt;/li&gt;
&lt;li&gt;虽然可以在顶层子卷放子卷之外的东西（文件或目录），不过因为想避免对顶层子卷做快照，
所以避免在顶层子卷放普通文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;btrfs 的子卷可以设置「可写」或者「只读」，在创建一个快照的时候也可以通过 &lt;code class="code"&gt;
-r&lt;/code&gt;

参数创建出一个只读快照。通常只读快照可能比可写的快照更有用，因为 &lt;code class="code"&gt;
btrfs send&lt;/code&gt;

命令只接受只读快照作为参考点。子卷可以有两种方式切换它是否只读的属性，可以通过
&lt;code class="code"&gt;
btrfs property set &amp;lt;subvol&amp;gt; ro&lt;/code&gt;
 直接修改是否只读，也可以对只读子卷用
&lt;code class="code"&gt;
btrfs subvolume snapshot&lt;/code&gt;
 创建出可写子卷，或者反过来对可写子卷创建出只读子卷。&lt;/p&gt;
&lt;p&gt;只读快照也有些特殊的限制，在 &lt;a class="reference external" href="https://btrfs.wiki.kernel.org/index.php/SysadminGuide#Special_Cases"&gt;SysadminGuide#Special_Cases&lt;/a&gt;
就提到一例，你不能把只读快照用 mv 移出包含它的目录，虽然你能用 mv 给它改名或者移动包含它的目录
到别的地方。 btrfs wiki 上给出这个限制的原因是子卷中记录了它的上级，
所以要移动它到别的上级需要修改这个子卷，从而只读子卷没法移动到别的上级（
不过我还没搞清楚子卷在哪儿记录了它的上级，记录的是上级目录还是上级子卷）。不过这个限制可以通过
对只读快照在目标位置创建一个新的只读快照，然后删掉原位置的只读快照来解决。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="zfs"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id38"&gt;2   ZFS 的文件系统、快照、克隆及其它&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Btrfs 给传统文件系统只增加了子卷的概念，相比之下 ZFS 中类似子卷的概念有好几个，据我所知有这些：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;数据集（dataset）&lt;/li&gt;
&lt;li&gt;文件系统（filesystem）&lt;/li&gt;
&lt;li&gt;快照（snapshot）&lt;/li&gt;
&lt;li&gt;克隆（clone）&lt;/li&gt;
&lt;li&gt;书签（bookmark）：从 ZFS on Linux v0.6.4 开始&lt;/li&gt;
&lt;li&gt;检查点（checkpoint）：从 ZFS on Linux v0.8.0 开始&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;梳理一下这些概念之间的关系也是最初想写下这篇笔记的初衷。先画个简图，随后逐一讲讲这些概念：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/f0cd8a5f.png"/&gt;
&lt;p&gt;上图中，假设我们有一个 pool ，其中有 3 个文件系统叫 fs1~fs3 和一个 zvol 叫 zv1
，然后文件系统 fs1 有两个快照 s1 和 s2 ，和两个书签 b1 和 b2。pool 整体有两个检查点 cp1 和
cp2 。这个简图将作为例子在后面介绍这些概念。&lt;/p&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id39"&gt;2.1   ZFS 设计中和快照相关的一些术语和概念&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="id9"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id40"&gt;数据集&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;ZFS 中把文件系统、快照、克隆、zvol 等概念统称为数据集（dataset）。
一些文档和介绍中把文件系统叫做数据集，大概因为在 ZFS 中，文件系统是最先创建并且最有用的数据集。&lt;/p&gt;
&lt;p&gt;在 ZFS 的术语中，把底层管理和释放存储设备空间的叫做 ZFS 存储池（pool），
简称 zpool ，其上可以容纳多个数据集，这些数据集用类似文件夹路径的语法
&lt;code class="code"&gt;
pool_name/​dataset_path@snapshot_name&lt;/code&gt;
 这样来称呼。
存储池中的数据集一同共享可用的存储空间，每个数据集单独跟踪自己所消耗掉的存储空间。&lt;/p&gt;
&lt;p&gt;数据集之间有类似文件夹的层级父子关系，这一点有用的地方在于可以在父级数据集上设定一些 ZFS 参数，
这些参数可以被子级数据集继承，从而通过层级关系可以方便地微调 ZFS 参数。在 btrfs
中目前还没有类似的属性继承的功能。&lt;/p&gt;
&lt;p&gt;zvol 的概念和本文关系不大，可以参考我上一篇 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#ZVOL"&gt;ZFS 子系统笔记中 ZVOL 的说明&lt;/a&gt;
。用 zvol 能把 ZFS 当作一个传统的卷管理器，绕开 ZFS
的 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#ZPL"&gt;ZPL（ZFS Posix filesystem Layer）&lt;/a&gt;
层。在 Btrfs 中可以用 loopback 块设备某种程度上模拟 zvol 的功能。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id41"&gt;文件系统&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;创建了 ZFS 存储池后，首先要在其中创建文件系统（filesystem），才能在文件系统中存储文件。
容易看出 ZFS 文件系统的概念直接对应 btrfs 中的子卷。文件系统（filesystem）这个术语，
从命名方式来看或许是想要和（像 Solaris 的 SVM 或者 Linux 的 LVM 这样的）传统的卷管理器
与其上创建的多个文件系统（Solaris UFS 或者 Linux ext）这样的上下层级做类比。
从 btrfs 的子卷在内部结构中叫作 FS_TREE 这一点可以看出，至少在 btrfs
早期设计中大概也是把子卷称为 filesystem 做过类似的类比的。
和传统的卷管理器与传统文件系统的上下层级不同的是， ZFS 和 btrfs 中由存储池跟踪和管理可用空间，
做统一的数据块分配和释放，没有分配的数据块算作整个存储池中所有 ZFS 文件系统或者 btrfs
子卷的可用空间。&lt;/p&gt;
&lt;p&gt;与 btrfs 的子卷不同的是， ZFS 的文件系统之间是完全隔离的，（除了后文会讲的 dedup
方式之外）不可以共享任何数据或者元数据。一个文件系统还包含了隶属于其中的快照（snapshot）、
克隆（clone）和书签（bookmark）。在 btrfs 中一个子卷和对其创建的快照之间虽然有父子关系，
但是在 ROOT_TREE 的记录中属于平级的关系。&lt;/p&gt;
&lt;p&gt;上面简图中 pool 里面包含 3 个文件系统，分别是 fs1~3 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id42"&gt;快照&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;ZFS 的快照对应 btrfs 的只读快照，是标记数据集在某一历史时刻上的只读状态。
和 btrfs 的只读快照一样， ZFS 的快照也兼作 send/receive 时的参考点。
快照隶属于一个数据集，这说明 ZFS 的文件系统或者 zvol 都可以创建快照。&lt;/p&gt;
&lt;p&gt;ZFS 中快照是排列在一个时间线上的，因为都是只读快照，它们是数据集在历史上的不同时间点。
这里说的时间不是系统时钟的时间，而是 ZFS 中事务组（TXG, transaction group）的一个序号。
整个 ZFS pool 的每次写入会被合并到一个事务组，对事务组分配一个严格递增的序列号，
提交一个事务组具有类似数据库中事务的语义：要么整个事务组都被完整提交，要么整个 pool
处于上一个事务组的状态，即使中间发生突然断电之类的意外也不会破坏事务语义。
因此 ZFS 快照就是数据集处于某一个事务组时的状态。&lt;/p&gt;
&lt;p&gt;如果不满于对数据集进行的修改，想把整个数据集恢复到之前的状态，那么可以回滚（rollback
）数据集到一个快照。回滚操作会撤销掉对数据集的所有更改，并且默认参数下只能回滚到最近的一个快照。
如果想回滚到更早的快照，可以先删掉最近的几个，或者可以使用 &lt;code class="code"&gt;
zfs rollback -r&lt;/code&gt;

参数删除中间的快照并回滚。&lt;/p&gt;
&lt;p&gt;除了回滚操作，还可以直接只读访问到快照中的文件。 ZFS 的文件系统中有个隐藏文件夹叫 ".zfs"
，所以如果只想回滚一部分文件，可以从 ".zfs/snapshots/SNAPSHOT-NAME" 中把需要的文件复制出来。&lt;/p&gt;
&lt;p&gt;比如上面简图中 fs1 就有 &lt;code class="code"&gt;
pool/​fs1@s1&lt;/code&gt;
 和 &lt;code class="code"&gt;
pool/​fs1@s2&lt;/code&gt;
 这两个快照，
那么可以在 fs1 挂载点下 &lt;code class="code"&gt;
.zfs/​snapshots/​s1&lt;/code&gt;
 的路径直接访问到 s1 中的内容。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id43"&gt;克隆&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;ZFS 的克隆（clone）有点像 btrfs 的可写快照。因为 ZFS 的快照是只读的，如果想对快照做写入，那需要先用
&lt;code class="code"&gt;
zfs clone&lt;/code&gt;
 从快照中建出一个克隆，创建出的克隆和快照共享元数据和数据，
然后对克隆的写入不影响数据集原本的写入点。
创建了克隆之后，作为克隆参考点的快照会成为克隆的依赖，克隆存在期间无法删除掉作为其依赖的快照。&lt;/p&gt;
&lt;p&gt;一个数据集可以有多个克隆，这些克隆都独立于数据集当前的写入点。使用 &lt;code class="code"&gt;
zfs promote&lt;/code&gt;

命令可以把一个克隆「升级」成为数据集的当前写入点，从而数据集原本的写入点会调转依赖关系，
成为这个新写入点的一个克隆，被升级的克隆原本依赖的快照和之前的快照会成为新数据集写入点的快照。&lt;/p&gt;
&lt;p&gt;比如上面简图中 fs1 有 c1 的克隆，它依赖于 s2 这个快照，从而 c1 存在的时候就不能删除掉 s2 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id13"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id44"&gt;书签&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这是 ZFS 一个比较新的特性，ZFS on Linux 分支从 v0.6.4 开始支持创建书签的功能。&lt;/p&gt;
&lt;p&gt;书签（bookmark）特性存在的理由是基于这样的事实：原本 ZFS 在 send 两个快照间的差异的时候，比如 send S1 和
S2 之间的差异，在发送端实际上只需要 S1 中记录的时间戳（TXG id），而不需要 S1 快照的数据，
就可以计算出 S1 到 S2 的差异。在接收端则需要 S1 的完整数据，在其上根据接收到的数据流创建 S2 。
因此在发送端，可以把快照 S1 转变成书签，只留下时间戳元数据而不保留任何目录结构或者文件内容。
书签只能作为增量 send 时的参考点，并且在接收端需要有对应的快照，这种方式可以在发送端节省很多存储。&lt;/p&gt;
&lt;p&gt;通常的使用场景是，比如你有一个笔记本电脑，上面有 ZFS 存储的数据，然后使用一个服务器上 ZFS
作为接收端，定期对笔记本上的 ZFS 做快照然后 send 给服务器。在没有书签功能的时候，
笔记本上至少得保留一个和服务器上相同的快照，作为 send 的增量参考点，
而这个快照的内容已经在服务器上，所以笔记本中存有相同的快照只是在浪费存储空间。
有了书签功能之后，每次将定期的新快照发送到服务器之后，就可以把这个快照转化成书签，节省存储开销。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id14"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id45"&gt;检查点&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这也是 ZFS 的新特性， ZFS on Linux 分支从 v0.8.0 开始支持创建检查点。&lt;/p&gt;
&lt;p&gt;简而言之，检查点（checkpoint）可以看作是整个存储池级别的快照，使用检查点能快速将整个存储池都恢复到上一个状态。
这边有篇文章介绍 &lt;a class="reference external" href="https://sdimitro.github.io/post/zpool-checkpoint/"&gt;ZFS checkpoint 功能的背景、用法和限制&lt;/a&gt;
，可以看出当存储池中有检查点的时候很多存储池的功能会受影响（比如不能删除 vdev 、不能处于
degraded 状态、不能 scrub 到当前存储池中已经释放而在检查点还在引用的数据块），
于是检查点功能设计上更多是给系统管理员准备的用于调整整个 ZFS pool 时的后悔药，
调整结束后日用状态下应该删除掉所有检查点。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="zfs-btrfs"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id46"&gt;2.2   ZFS 的概念与 btrfs 概念的对比&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;先说书签和检查点，因为这是两个 btrfs 目前完全没有的功能。&lt;/p&gt;
&lt;p&gt;书签功能完全围绕 ZFS send 的工作原理，而 ZFS send 位于
&lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#DSL"&gt;ZFS 设计中的 DSL&lt;/a&gt;
层面，甚至不关心它 send 的快照的数据是来自文件系统还是 zvol
。在发送端它只是从目标快照递归取数据块，判断 TXG
是否老于参照点的快照，然后把新的数据块全部发往 send stream ；在接收端也只是完整地接收数据块，
不加以处理，。与之不同的是 btrfs 的 send 的工作原理是工作在文件系统的只读子卷层面，
发送端在内核代码中根据目标快照的 b 树和参照点快照的 generation 生成一个 diff
（可以通过 &lt;code class="code"&gt;
btrfs subvolume find-new&lt;/code&gt;
 直接拿到这个 diff ），然后在用户态代码中根据
diff 和参照点、目标快照的两个只读子卷的数据产生一连串修改文件系统的指令，
指令包括创建文件、删除文件、让文件引用数据块（保持 reflink ）等操作；在接收端则完全工作在用户态下，
根据接收到的指令重建目标快照。可见 btrfs send 需要在发送端读取参照点快照的数据（比如找到
reflink 引用），从而 btrfs 没法（或者很难）实现书签功能。&lt;/p&gt;
&lt;p&gt;检查点也是 btrfs 目前没有的功能。 btrfs 目前不能对顶层子卷做递归的 snapshot ，btrfs
的子卷也没有类似 ZFS 数据集的层级关系和可继承属性，从而没法实现类似检查点的功能。&lt;/p&gt;
&lt;p&gt;除了书签和检查点之外，剩下的概念可以在 ZFS 和 btrfs 之间有如下映射关系：&lt;/p&gt;
&lt;table border="0" class="docutils table field-list" frame="void" rules="none"&gt;
&lt;col class="field-name"/&gt;
&lt;col class="field-body"/&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;ZFS 文件系统:&lt;/th&gt;&lt;td class="field-body"&gt;btrfs 子卷&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;ZFS 快照:&lt;/th&gt;&lt;td class="field-body"&gt;btrfs 只读快照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;ZFS 克隆:&lt;/th&gt;&lt;td class="field-body"&gt;btrfs 可写快照&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对 ZFS 数据集的操作，大部分也可以找到对应的对 btrfs 子卷的操作。&lt;/p&gt;
&lt;table border="0" class="docutils table field-list" frame="void" rules="none"&gt;
&lt;col class="field-name"/&gt;
&lt;col class="field-body"/&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;zfs list:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;code class="code"&gt;
btrfs subvolume list&lt;/code&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;zfs create:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;code class="code"&gt;
btrfs subvolume create&lt;/code&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;zfs destroy:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;code class="code"&gt;
btrfs subvolume delete&lt;/code&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;zfs rename:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;code class="code"&gt;
mv&lt;/code&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;zfs snapshot:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;code class="code"&gt;
btrfs subvolume snapshot -r&lt;/code&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;zfs rollback:&lt;/th&gt;&lt;td class="field-body"&gt;这个在 btrfs 需要对只读快照创建出可写的快照（用 snapshot 命令，或者直接修改读写属性），然后改名或者调整挂载点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;zfs diff:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;code class="code"&gt;
btrfs subvolume find-new&lt;/code&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;zfs clone:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;code class="code"&gt;
btrfs subvolume snapshot&lt;/code&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;zfs promote:&lt;/th&gt;&lt;td class="field-body"&gt;和 rollback 类似，可以直接调整 btrfs 子卷的挂载点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可见虽然功能上类似，但是至少从管理员管理的角度而言， zfs 对文件系统、快照、克隆的划分更为清晰，
对他们能做的操作也更为明确。这也是很多从 ZFS 迁移到 btrfs ，或者反过来从 btrfs 换用 zfs
时，一些人困惑的起源（甚至有人据此说 ZFS 比 btrfs 好在 cli 设计上）。&lt;/p&gt;
&lt;p&gt;不过 btrfs 子卷的设计也使它在系统管理上有了更大的灵活性。比如在 btrfs
中删除一个子卷不会受制于别的子卷是否存在，而在 zfs 中要删除一个快照必须先保证先摧毁掉依赖它的克隆。
再比如 btrfs 的可写子卷没有主次之分，而 zfs 中一个文件系统和其克隆之间有明显的区别，所以需要
promote 命令调整差异。还有比如 ZFS 的文件系统只能回滚到最近一次的快照，
要回滚到更久之前的快照需要删掉中间的快照，并且回滚之后原本的文件系统数据和快照数据就被丢弃了；
而 btrfs 中因为回滚操作相当于调整子卷的挂载，所以不需要删掉快照，
并且回滚之后原本的子卷和快照还可以继续保留。&lt;/p&gt;
&lt;p&gt;加上 btrfs 有 reflink ，这给了 btrfs 在使用中更大的灵活性，可以有一些 zfs 很难做到的用法。
比如想从快照中打捞出一些虚拟机镜像的历史副本，而不想回滚整个快照的时候，在
btrfs 中可以直接 &lt;code class="code"&gt;
cp --reflink=always&lt;/code&gt;
 将镜像从快照中复制出来，此时的复制将和快照共享数据块；
而在 zfs 中只能用普通 cp 复制，会浪费很多存储空间。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id15"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id47"&gt;2.3   ZFS 中是如何存储这些数据集的呢&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;要讲到存储细节，首先需要 了解一下 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html"&gt;ZFS 的分层设计&lt;/a&gt;
。不像 btrfs 基于现代 Linux 内核，有许多现有文件系统已经实现好的基础设施可以利用，
并且大体上只用到一种核心数据结构（CoW的B树）； ZFS 则脱胎于 Solaris 的野心勃勃，
设计时就分成很多不同的子系统，逐步提升抽象层次，
并且每个子系统都发明了许多特定需求下的数据结构来描述存储的信息。 在这里和本文内容密切相关的是
&lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#zpl"&gt;ZPL&lt;/a&gt; 、 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#DSL"&gt;DSL&lt;/a&gt; 、 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#dmu"&gt;DMU&lt;/a&gt; 这些 ZFS 子系统。&lt;/p&gt;
&lt;p&gt;Sun 曾经写过一篇 ZFS 的 &lt;a class="reference external" href="http://www.giis.co.in/Zfs_ondiskformat.pdf"&gt;On disk format&lt;/a&gt;
对理解 ZFS 如何存储在磁盘上很有帮助，虽然这篇文档是针对 Sun 还在的时候 Solaris 的 ZFS
，现在 ZFS 的内部已经变化挺大，不过对于理解本文想讲的快照的实现方式还具有参考意义。这里借助这篇
ZFS On Disk Format 中的一些图示来解释 ZFS 在磁盘上的存储方式。&lt;/p&gt;
&lt;div class="section" id="id18"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id48"&gt;ZFS 的块指针&lt;/a&gt;&lt;/h4&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="//farseerfc.me/zhs/images/zfs-block-pointer.svg"&gt;ZFS 中用的 128 字节块指针&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;object class="embed-responsive-item" data="//farseerfc.me/zhs/images/zfs-block-pointer.svg" type="image/svg+xml"&gt;
zfs-block-pointer.svg&lt;/object&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;要理解 ZFS 的磁盘结构首先想介绍一下 ZFS 中的块指针（block pointer, &lt;code class="code"&gt;
blkptr_t&lt;/code&gt;

），结构如右图所示。 ZFS 的块指针用在 ZFS 的许多数据结构之中，当需要从一个地方指向任意另一个地址的时候都会
插入这样的一个块指针结构。大多数文件系统中也有类似的指针结构，比如 btrfs
中有个8字节大小的逻辑地址（logical address），一般也就是个 4字节 到 16字节
大小的整数写着扇区号、块号或者字节偏移，在 ZFS 中的块指针则是一个巨大的128字节（不是
128bit !）的结构体。&lt;/p&gt;
&lt;p&gt;128字节块指针的开头是3个数据虚拟地址（DVA, Data Virtual Address），每个 DVA 是 128bit
，其中记录这块数据在什么设备（vdev）的什么偏移（offset）上占用多大（asize)，有 3个
DVA 槽是用来存储最多3个不同位置的副本。然后块指针还记录了这个块用什么校验算法（ cksum
）和什么压缩算法（comp），压缩前后的大小（PSIZE/LSIZE），以及256bit的校验和（checksum）。&lt;/p&gt;
&lt;p&gt;当需要间接块（indirect block）时，块指针中记录了间接块的层数（lvl），和下层块指针的数量（fill）。
一个间接块就是一个数据块中包含一个块指针的数组，当引用的对象很大需要很多块时，间接块构成一棵树状结构。&lt;/p&gt;
&lt;p&gt;块指针中还有和本文关系很大的一个值 birth txg ，记录这个块指针诞生时的整个 pool 的 TXG id
。一次 TXG 提交中写入的数据块都会有相同的 birth txg ，这个相当于 btrfs 中 generation 的概念。
实际上现在的 ZFS 块指针似乎记录了两个 birth txg ，分别在图中的9行和a行的位置，
&lt;a class="reference external" href="https://utcc.utoronto.ca/~cks/space/blog/solaris/ZFSBlockPointers"&gt;一个 physical 一个 logical ，用于 dedup 和 device removal&lt;/a&gt;
。值得注意的是块指针里只有 birth txg ，没有引用计数或者别的机制做引用，这对后面要讲的东西很关键。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id19"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id49"&gt;DSL 的元对象集&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;理解块指针和 ZFS 的子系统层级之后，就可以来看看 ZFS 存储在磁盘上的具体结构了。
因为涉及的数据结构种类比较多，所以先来画一张逻辑上的简图，其中箭头只是某种引用关系不代表块指针，
方框也不是结构体细节：&lt;/p&gt;
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;

&lt;!-- Generated by graphviz version 2.40.1 (20161225.0304)
 --&gt;
&lt;!-- Title: zfs_layout_simple Pages: 1 --&gt;
&lt;svg class="svg-responsive" height="262pt" viewbox="0.00 0.00 1128.00 262.00" width="1128pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
&lt;g class="graph" id="graph0" transform="scale(1 1) rotate(0) translate(4 258)"&gt;
&lt;title&gt;zfs_layout_simple&lt;/title&gt;
&lt;polygon fill="#ffffff" points="-4,4 -4,-258 1124,-258 1124,4 -4,4" stroke="transparent"&gt;&lt;/polygon&gt;
&lt;!-- uberblock --&gt;
&lt;g class="node" id="node1"&gt;
&lt;title&gt;uberblock&lt;/title&gt;
&lt;polygon fill="none" points="0,-184.5 0,-253.5 114,-253.5 114,-184.5 0,-184.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="57" y="-238.3"&gt;UBERBLOCK&lt;/text&gt;
&lt;polyline fill="none" points="0,-230.5 114,-230.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="57" y="-215.3"&gt;...&lt;/text&gt;
&lt;polyline fill="none" points="0,-207.5 114,-207.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="57" y="-192.3"&gt;mos_blkptr&lt;/text&gt;
&lt;/g&gt;
&lt;!-- mos --&gt;
&lt;g class="node" id="node2"&gt;
&lt;title&gt;mos&lt;/title&gt;
&lt;polygon fill="none" points="186,-115 186,-207 320,-207 320,-115 186,-115" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="253" y="-191.8"&gt;Meta Object Set&lt;/text&gt;
&lt;polyline fill="none" points="186,-184 320,-184 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="253" y="-168.8"&gt;root dataset&lt;/text&gt;
&lt;polyline fill="none" points="186,-161 320,-161 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="253" y="-145.8"&gt;config&lt;/text&gt;
&lt;polyline fill="none" points="186,-138 320,-138 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="253" y="-122.8"&gt;...&lt;/text&gt;
&lt;/g&gt;
&lt;!-- uberblock&amp;#45;&amp;gt;mos --&gt;
&lt;g class="edge" id="edge1"&gt;
&lt;title&gt;uberblock:ub_rootbp-&amp;gt;mos:mos_label&lt;/title&gt;
&lt;path d="M114,-196C142.375,-196 151.8795,-196 175.9792,-196" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="176,-199.5001 186,-196 176,-192.5001 176,-199.5001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- root_dataset --&gt;
&lt;g class="node" id="node3"&gt;
&lt;title&gt;root_dataset&lt;/title&gt;
&lt;polygon fill="none" points="392,-92 392,-184 541,-184 541,-92 392,-92" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="466.5" y="-168.8"&gt;ROOT dataset&lt;/text&gt;
&lt;polyline fill="none" points="392,-161 541,-161 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="466.5" y="-145.8"&gt;dataset1 directory&lt;/text&gt;
&lt;polyline fill="none" points="392,-138 541,-138 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="466.5" y="-122.8"&gt;dataset2 directory&lt;/text&gt;
&lt;polyline fill="none" points="392,-115 541,-115 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="466.5" y="-99.8"&gt;...&lt;/text&gt;
&lt;/g&gt;
&lt;!-- mos&amp;#45;&amp;gt;root_dataset --&gt;
&lt;g class="edge" id="edge2"&gt;
&lt;title&gt;mos:mos_root_dataset-&amp;gt;root_dataset:rd_label&lt;/title&gt;
&lt;path d="M320,-173C348.375,-173 357.8795,-173 381.9792,-173" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="382,-176.5001 392,-173 382,-169.5001 382,-176.5001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ds1_directory --&gt;
&lt;g class="node" id="node4"&gt;
&lt;title&gt;ds1_directory&lt;/title&gt;
&lt;polygon fill="none" points="613,-.5 613,-161.5 805,-161.5 805,-.5 613,-.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="709" y="-146.3"&gt;DSL Directory&lt;/text&gt;
&lt;polyline fill="none" points="613,-138.5 805,-138.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="709" y="-123.3"&gt;ds1 property ZAP object&lt;/text&gt;
&lt;polyline fill="none" points="613,-115.5 805,-115.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="709" y="-100.3"&gt;ds1 child ZAP object&lt;/text&gt;
&lt;polyline fill="none" points="613,-92.5 805,-92.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="709" y="-77.3"&gt;ds1 dataset (active)&lt;/text&gt;
&lt;polyline fill="none" points="613,-69.5 805,-69.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="709" y="-54.3"&gt;ds1 snapshot1&lt;/text&gt;
&lt;polyline fill="none" points="613,-46.5 805,-46.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="709" y="-31.3"&gt;ds1 snapshot2&lt;/text&gt;
&lt;polyline fill="none" points="613,-23.5 805,-23.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="709" y="-8.3"&gt;...&lt;/text&gt;
&lt;/g&gt;
&lt;!-- root_dataset&amp;#45;&amp;gt;ds1_directory --&gt;
&lt;g class="edge" id="edge3"&gt;
&lt;title&gt;root_dataset:rd_ds1-&amp;gt;ds1_directory:ds1_label&lt;/title&gt;
&lt;path d="M541,-150C569.375,-150 578.8795,-150 602.9792,-150" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="603,-153.5001 613,-150 603,-146.5001 603,-153.5001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ds1_dataset --&gt;
&lt;g class="node" id="node5"&gt;
&lt;title&gt;ds1_dataset&lt;/title&gt;
&lt;polygon fill="none" points="916,-67 916,-113 1081,-113 1081,-67 916,-67" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="998.5" y="-97.8"&gt;ds1 DMU Object Set&lt;/text&gt;
&lt;polyline fill="none" points="916,-90 1081,-90 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="998.5" y="-74.8"&gt;...&lt;/text&gt;
&lt;/g&gt;
&lt;!-- ds1_directory&amp;#45;&amp;gt;ds1_dataset --&gt;
&lt;g class="edge" id="edge4"&gt;
&lt;title&gt;ds1_directory:ds1_dataset-&amp;gt;ds1_dataset:ds1_ds_label&lt;/title&gt;
&lt;path d="M805,-81C851.3776,-81 863.7833,-99.0745 905.2509,-101.6868" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="905.3977,-105.1929 915.5,-102 905.6116,-98.1961 905.3977,-105.1929" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ds1_snapshot1 --&gt;
&lt;g class="node" id="node6"&gt;
&lt;title&gt;ds1_snapshot1&lt;/title&gt;
&lt;polygon fill="none" points="877,-2 877,-48 1120,-48 1120,-2 877,-2" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="998.5" y="-32.8"&gt;ds1 snapshot1 DMU Object Set&lt;/text&gt;
&lt;polyline fill="none" points="877,-25 1120,-25 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="998.5" y="-9.8"&gt;...&lt;/text&gt;
&lt;/g&gt;
&lt;!-- ds1_directory&amp;#45;&amp;gt;ds1_snapshot1 --&gt;
&lt;g class="edge" id="edge5"&gt;
&lt;title&gt;ds1_directory:ds1_s1-&amp;gt;ds1_snapshot1:ds1_s1_label&lt;/title&gt;
&lt;path d="M805,-58C834.6875,-58 842.165,-41.3425 866.9941,-37.6987" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="867.2681,-41.1882 877,-37 866.7804,-34.2052 867.2681,-41.1882" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;/svg&gt;
&lt;p&gt;如上简图所示，首先 ZFS pool 级别有个 uberblock ，具体每个 vdev 如何存储和找到这个 uberblock
今后有空再聊，这里认为整个 zpool 有唯一的一个 uberblock 。从 uberblock
有个指针指向元对象集（MOS, Meta Object Set），它是个 DMU 的对象集，它包含整个 pool
的一些配置信息，和根数据集（root dataset）。根数据集再包含整个 pool
中保存的所有顶层数据集，每个数据集有一个 DSL Directory 结构。然后从每个数据集的
DSL Directory 可以找到一系列子数据集和一系列快照等结构。最后每个数据集有个 active
的 DMU 对象集，这是整个文件系统的当前写入点，每个快照也指向一个各自的 DMU 对象集。&lt;/p&gt;
&lt;p&gt;DSL 层的每个数据集的逻辑结构也可以用下面的图表达（来自 ZFS On Disk Format ）：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;object class="embed-responsive-item" data="//farseerfc.me/zhs/images/zfs-dsl-infrastructure.svg" type="image/svg+xml"&gt;
zfs-dsl-infrastructure.svg&lt;/object&gt;
&lt;p class="caption"&gt;ZFS On Disk Format 中 4.1 节的 DSL infrastructure&lt;/p&gt;
&lt;/div&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="reference external" href="//farseerfc.me/zhs/images/zfs-metaobjectset.svg"&gt;ZFS On Disk Format 中 4.2 节的 Meta Object Set&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;object class="embed-responsive-item" data="//farseerfc.me/zhs/images/zfs-metaobjectset.svg" type="image/svg+xml"&gt;
zfs-metaobjectset.svg&lt;/object&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;需要记得 ZFS 中没有类似 btrfs 的 CoW b-tree 这样的统一数据结构，所以上面的这些设施是用各种不同的数据结构表达的。
尤其每个 Directory 的结构可以包含一个 ZAP 的键值对存储，和一个 DMU 对象。
可以理解为， DSL 用 DMU 对象集（Objectset）表示一个整数（uinit64_t 的 dnode 编号）到 DMU
对象的映射，然后用 ZAP 对象表示一个名字到整数的映射，然后又有很多额外的存储于 DMU 对象中的 DSL
结构体。如果我们画出不同的指针和不同的结构体，那么会得到一个稍显复杂的图，见右边「ZFS
On Disk Format 中 4.2 节的 Meta Object Set」，图中还只画到了 root_dataset 为止。&lt;/p&gt;
&lt;p&gt;看到这里，大概可以理解在 ZFS 中创建一个 ZFS 快照的操作其实很简单：找到数据集的 DSL Directory
中当前 active 的 DMU 对象集指针，创建一个表示 snapshot 的 DSL dataset 结构，指向那个
DMU 对象集，然后快照就建好了。因为今后对 active 的写入会写时复制对应的 DMU 对象集，所以
snapshot 指向的 DMU 对象集不会变化。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id20"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id50"&gt;3   创建快照这么简单么？那么删除快照呢？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;按上面的存储格式细节来看， btrfs 和 zfs 中创建快照似乎都挺简单的，利用写时拷贝，创建快照本身没什么复杂操作。&lt;/p&gt;
&lt;p&gt;如果你也听到过别人介绍 CoW 文件系统时这么讲，是不是会觉得似乎哪儿少了点什么。创建快照是挺简单的，
&lt;strong&gt;直到你开始考虑如何删除快照&lt;/strong&gt; ……&lt;/p&gt;
&lt;p&gt;或者不局限在删除单个快照上， CoW 文件系统因为写时拷贝，每修改一个文件内容或者修改一个文件系统结构，
都是分配新数据块，然后考虑是否要删除这个数据替换的老数据块，此时如何决定老数据块能不能删呢？
删除快照的时候也是同样，快照是和别的文件系统有共享一部分数据和元数据的，
所以显然不能把快照引用到的数据块都直接删掉，要考察快照引用的数据块是否还在别的地方被引用着，
只能删除那些没有被引用的数据。&lt;/p&gt;
&lt;p&gt;深究「如何删快照」这个问题，就能看出 WAFL 、 btrfs 、 ZFS 甚至别的 log-structured
文件系统间的关键区别，从而也能看到另一个问题的答案：
&lt;strong&gt;为什么 btrfs 只需要子卷的抽象，而 zfs 搞出了这么多抽象概念？&lt;/strong&gt;
带着这两个疑问，我们来研究一下这些文件系统的块删除算法。&lt;/p&gt;
&lt;div class="section" id="id21"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id51"&gt;3.1   日志结构文件系统中用的垃圾回收算法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;讲 btrfs 和 zfs 用到的删除算法之前，先讲一下日志结构（log-structured）文件系统中的垃圾回收（
GC, Garbage Collection）算法。对熟悉编程的人来说，讲到空间释放算法，大概首先会想到 GC
，因为这里要解决的问题乍看起来很像编程语言的内存管理中 GC
想要解决的问题：有很多指针相互指向很多数据结构，找其中没有被引用的垃圾然后释放掉。&lt;/p&gt;
&lt;p&gt;首先要澄清一下 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Log-structured_file_system"&gt;日志结构文件系统（log-structured file system）&lt;/a&gt;
的定义，因为有很多文件系统用日志，而用了日志的不一定是日志结构文件系统。
在维基百科上有个页面介绍 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Log-structured_file_system"&gt;日志结构文件系统&lt;/a&gt;
，还有个 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/List_of_log-structured_file_systems"&gt;列表列出了一些日志结构文件系统&lt;/a&gt;
。通常说，整个文件系统的存储结构都组织成一个大日志的样子，就说这个文件系统是日志结构的，
这包括很多早期学术研究的文件系统，以及目前 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Log-structured_File_System_(BSD)"&gt;NetBSD 的 LFS&lt;/a&gt;
、Linux 的 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/NILFS"&gt;NILFS&lt;/a&gt;
，用在光盘介质上的 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Universal_Disk_Format"&gt;UDF&lt;/a&gt;
，还有一些专门为闪存优化的 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/JFFS"&gt;JFFS&lt;/a&gt; 、
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/YAFFS"&gt;YAFFS&lt;/a&gt; 以及
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/F2FS"&gt;F2FS&lt;/a&gt;
。日志结构文件系统不包括那些用额外日志保证文件系统一致性，但文件系统结构不在日志中的 ext4 、 xfs
、 ntfs 、 hfs+ 。&lt;/p&gt;
&lt;p&gt;简单来说，日志结构文件系统就是把存储设备当作一个大日志，每次写入数据时都添加在日志末尾，
然后用写时复制重新写入元数据，最后提交整个文件系统结构。因为这里用了写时复制，原本的数据块都还留着，
所以可以很容易实现快照之类的功能。从这个特征上来说，写时拷贝文件系统（CoW
FS）像 btrfs/zfs 这些在一些人眼中也符合日志结构文件系统的特征，
所以也有人说写时拷贝文件系统算是日志结构文件系统的一个子类。不过日志结构文件系统的另一大特征是利用
GC 回收空间，这里是本文要讲的区别，所以在我看来不用 GC 的 btrfs 和 zfs 不算是日志结构文件系统。&lt;/p&gt;
&lt;p&gt;举个例子，比如下图是一个日志结构文件系统的磁盘占用，其中绿色是数据，蓝色是元数据（比如目录结构和
inode），红色是文件系统级关键数据（比如最后的日志提交点），一开始可能是这样，有9个数据块，
2个元数据块，1个系统块：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/c8f452c3.png"/&gt;
&lt;p&gt;现在要覆盖 2 和 3 的内容，新写入 n2 和 n3 ，再删除 4 号的内容 ，然后修改 10 里面的 inode 变成 n10
引用这些新数据，然后写入一个新提交 n12 ，用黄色表示不再被引用的垃圾，提交完大概是这样：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/a0eb592f.png"/&gt;
&lt;p&gt;日志结构文件系统需要 GC 比较容易理解，写日志嘛，总得有一个「添加到末尾」的写入点，比如上面图中的
n12 就是当前的写入点。空盘上连续往后写而不 GC 总会遇到空间末尾，这时候就要覆盖写空间开头，
就很难判断「末尾」在什么地方，而下一次写入需要在哪里了。
这时文件系统也不知道需要回收哪些块（图中的 o2 o3 o4 o10 和 o12），因为这些块可能被别的地方还继续
引用着，需要等到 GC 时扫描元数据来判断。&lt;/p&gt;
&lt;p&gt;和内存管理时的 GC 不同的一点在于，文件系统的 GC 肯定不能停下整个世界跑 GC
，也不能把整个地址空间对半分然后 Mark-and-Sweep
，这些在内存中还尚可的简单策略直接放到文件系统中绝对是性能灾难。所以文件系统的 GC
需要并行的后台 GC ，并且需要更细粒度的分块机制能在 Mark-and-Sweep
的时候保持别的地方可以继续写入数据而维持文件系统的正常职能。&lt;/p&gt;
&lt;p&gt;通常文件系统的 GC 是这样，先把整个盘分成几个段（segment）或者区域(zone)，术语不同不过表达的概念类似，
然后 GC 时挑一个老段，扫描文件系统元数据找出要释放的段中还被引用的数据块，搬运到日志末尾，最后整个释放一段。
搬运数据块时，也要调整文件系统别的地方对被搬运的数据块的引用。&lt;/p&gt;
&lt;p&gt;物理磁盘上一般有扇区的概念，通常是 512B 或者 4KiB 的大小，在文件系统中一般把连续几个物理块作为一个数据块，
大概是 4KiB 到 1MiB 的数量级，然后日志结构文件系统中一个段(segment)通常是连续的很多块，数量级来看大约是
4MiB 到 64MiB 这样的数量级。相比之下 ufs/ext4/btrfs/zfs 的分配器通常还有 block group 的概念，
大概是 128MiB 到 1GiB 的大小。可见日志结构文件系统的段，是位于数据块和其它文件系统 block group
中间的一个单位。段大小太小的话，会显著增加空间管理需要的额外时间空间开销，而段大小太大的话，
又不利于利用整个可用空间，这里的抉择有个平衡点。&lt;/p&gt;
&lt;p&gt;继续上面的例子，假设上面文件系统的图示中每一列的4块是一个段，想要回收最开头那个段，
那么需要搬运还在用的 1 到空闲空间，顺带修改引用它的 n10 ，最后提交 n12 ：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/ba5b5955.png"/&gt;
&lt;p&gt;要扫描并释放一整段，需要扫描整个文件系统中别的元数据（图中的 n12 和 n10 和
11）来确定有没有引用到目标段中的地址，可见释放一个段是一个 &lt;span class="math"&gt;\(O(N)\)&lt;/span&gt; 的操作，其中 N
是元数据段的数量，按文件系统的大小增长，
于是删除快照之类可能要连续释放很多段的操作在日志文件系统中是个 &lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt; 甚至更昂贵的操作。
在文件系统相对比较小而系统内存相对比较大的时候，比如手机上或者PC读写SD卡，大部分元数据块（
其中包含块指针）都能放入内存缓存起来的话，这个扫描操作的开销还是可以接受的。
但是对大型存储系统显然扫描并释放空间就不合适了。&lt;/p&gt;
&lt;p&gt;段的抽象用在闪存类存储设备上的一点优势在于，闪存通常也有擦除块的概念，比写入块的大小要大，
是连续的多个写入块构成，从而日志结构的文件系统中一个段可以直接对应到闪存的一个擦除块上。
所以闪存设备诸如U盘或者 SSD 通常在底层固件中用日志结构文件系统模拟一个块设备，来做写入平衡。
大家所说的 SSD 上固件做的 GC ，大概也就是这样一种操作。&lt;/p&gt;
&lt;p&gt;基于段的 GC 还有一个显著缺陷，需要扫描元数据，复制搬运仍然被引用到的块，这不光会增加设备写入，
还需要调整现有数据结构中的指针，调整指针需要更多写入，同时又释放更多数据块，
F2FS 等一些文件系统设计中把这个问题叫 Wandering Tree Problem ，在 F2FS
设计中是通过近乎「作弊」的 &lt;a class="reference external" href="https://www.kernel.org/doc/html/latest/filesystems/f2fs.html#id1"&gt;NAT 转换表&lt;/a&gt;
放在存储设备期待的 FAT 所在位置，不仅能让需要扫描的元数据更集中，还能减少这种指针调整导致的写入。&lt;/p&gt;
&lt;p&gt;不过基于段的 GC 也有一些好处，它不需要复杂的文件系统设计，不需要特殊构造的指针，
就能很方便地支持大量快照。一些日志结构文件系统比如 NILFS 用这一点支持了「连续快照（continuous
snapshots）」，每次文件系统提交都是自动创建一个快照，用户可以手动标记需要保留哪些快照，
GC 算法则排除掉用户手动标记的快照之后，根据快照创建的时间，先从最老的未标记快照开始回收。
即便如此， GC 的开销（CPU时间和磁盘读写带宽）仍然是 NILFS
最为被人诟病的地方，是它难以被广泛采用的原因。 为了加快 NILFS 这类日志文件系统的 GC
性能让他们能更适合于普通使用场景，也有许多学术研究致力于探索和优化 GC
，使用更先进的数据结构和算法跟踪数据块来调整 GC 策略，比如这里有一篇
&lt;a class="reference external" href="https://www.complang.tuwien.ac.at/Diplomarbeiten/rohner18.pdf"&gt;State-of-the-art Garbage Collection Policies for NILFS2&lt;/a&gt;
。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="wafl"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id52"&gt;3.2   WAFL 早期使用的可用空间位图数组&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;从日志结构文件系统使用 GC 的困境中可以看出，文件系统级别实际更合适的，
可能不是在运行期依赖扫描元数据来计算空间利用率的 GC
，而是在创建快照时或者写入数据时就预先记录下快照的空间利用情况，
从而可以细粒度地跟踪空间和回收空间，这也是 WAFL 早期实现快照的设计思路。&lt;/p&gt;
&lt;p&gt;WAFL 早期记录快照占用数据块的思路从表面上来看也很「暴力」，传统文件系统一般有个叫做「位图（bitmap
）」的数据结构，用一个二进制位记录一个数据块是否占用，靠扫描位图来寻找可用空间和已用空间。 WAFL
的设计早期中考虑既然需要支持快照，那就把记录数据块占用情况的位图，变成快照的数组。
于是整个文件系统有个 256 大小的快照利用率数组，数组中每个快照记录自己占用的数据块位图，
文件系统中最多能容纳 255 个快照。&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/5dfeb8e2.png"/&gt;
&lt;p&gt;上面每个单元格都是一个二进制位，表示某个快照有没有引用某个数据块。有这样一个位图的数组之后，
就可以直接扫描位图判断出某个数据块是否已经占用，可以找出尚未被占用的数据块用作空间分配，
也可以方便地计算每个快照引用的空间大小或者独占的空间大小，估算删除快照后可以释放的空间。&lt;/p&gt;
&lt;p&gt;需要注意的是，文件系统中可以有非常多的块，从而位图数组比位图需要更多的元数据来表达。
比如估算一下传统文件系统中一块可以是 4KiB 大小，那么跟踪空间利用的位图需要 1bit/4KiB
， 1TiB 的盘就需要 32MiB 的元数据来存放位图；
而 WAFL 这种位图数组即便限制了快照数量只能有255个，仍需要 256bit/4KiB 的空间开销，
1TiB 的盘需要的元数据开销陡增到 8GiB ，这些还只是单纯记录空间利用率的位图数组，不包括别的元数据。&lt;/p&gt;
&lt;p&gt;使用这么多元数据表示快照之后，创建快照的开销也相应地增加了，需要复制整个位图来创建一个新的快照，
按上面的估算 1TiB 的盘可能需要复制 32MiB 的位图，这不再是一瞬能完成的事情，
期间可能需要停下所有对文件系统的写入等待复制完成。
位图数组在存储设备上的记录方式也很有讲究，当删除快照时希望能快速读写上图中的一整行位图，
于是可能希望每一行位图的存储方式在磁盘上都尽量连续，
而在普通的写入操作需要分配新块时，想要按列的方式扫描位图数组，找到没有被快照占用的块，
从而上图中按列的存储表达也希望在磁盘上尽量连续。
WAFL 的设计工程师们在位图数组的思路下，实现了高效的数据结构让上述两种维度的操作都能快速完成，
但是这绝不是一件容易的事情。&lt;/p&gt;
&lt;p&gt;位图数组的表达方式也有其好处，比如除了快照之外，也可以非常容易地表达类似 ZFS
的克隆和独立的文件系统这样的概念，这些东西和快照一样，占用仅有的 256 个快照数量限制。
这样表达的克隆可以有数据块和别的文件系统共享，文件系统之间也可以有类似
reflink 的机制共享数据块，在位图数组的相应位置将位置1即可。&lt;/p&gt;
&lt;p&gt;使用位图数组的做法，也只是 WAFL 早期可能采用的方式，由于 WAFL 本身是闭源产品，
难以获知它具体的工作原理。哈佛大学和 NetApp 的职员曾经在 FAST10
(USENIX Conference on File and Storage Technologies) 上发表过一篇讲解高效跟踪和使用
back reference 的论文，叫
&lt;a class="reference external" href="https://www.usenix.org/legacy/event/fast10/tech/full_papers/macko.pdf"&gt;Tracking Back References in a Write-Anywhere File System&lt;/a&gt;
，可以推测在新一代 WAFL 的设计中可能使用了类似 btrfs backref 的实现方式，接下来会详细介绍。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id24"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id53"&gt;3.3   ZFS 中关于快照和克隆的空间跟踪算法&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
How ZFS snapshots really work And why they perform well (usually)&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/NXg86uBDSqI"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;p&gt;&lt;a class="reference external" href="https://www.bsdcan.org/2019/schedule/attachments/500_How%20ZFS%20Snapshots%20Really%20Work.pdf"&gt;幻灯片可以从这里下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;embed class="embed-responsive-item" src="//farseerfc.me/zhs/images/500_How_ZFS_Snapshots_Really_Work.pdf" style="width:90%;height:480px"/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;OpenZFS 的项目领导者，同时也是最初设计 ZFS 中 DMU 子系统的作者 Matt Ahrens 在 DMU
和                                                    DSL
中设计并实现了 ZFS 独特的快照的空间跟踪算法。他也在很多地方发表演讲，讲过这个算法的思路和细节，
比如右侧就是他在 BSDCan 2019 做的演讲
&lt;a class="reference external" href="https://youtu.be/NXg86uBDSqI"&gt;How ZFS snapshots really work And why they perform well (usually)&lt;/a&gt;
的 YouTube 视频。&lt;/p&gt;
&lt;p&gt;其中 Matt 讲到了三个删除快照的算法，分别可以叫做「🐢乌龟算法」、「🐰兔子算法」、「🐆豹子算法」，
接下来简单讲讲这些算法背后的思想和实现方式。&lt;/p&gt;
&lt;div class="section" id="id26"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id54"&gt;🐢乌龟算法：概念上 ZFS 如何删快照&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;乌龟算法没有实现在 ZFS 中，不过方便理解 ZFS 在概念上如何考虑快照删除这个问题，从而帮助理解
后面的🐰兔子算法和🐆豹子算法。&lt;/p&gt;
&lt;p&gt;要删除一个快照， ZFS 需要找出这个快照引用到的「独占」数据块，也就是那些不和别的数据集或者快照共享的
数据块。 ZFS 删除快照基于这几点条件：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;ZFS 快照是只读的。创建快照之后无法修改其内容。&lt;/li&gt;
&lt;li&gt;ZFS 的快照是严格按时间顺序排列的，这里的时间指 TXG id ，即记录文件系统提交所属事务组的严格递增序号。&lt;/li&gt;
&lt;li&gt;ZFS 不存在 reflink 之类的机制，从而在某个时间点删除掉的数据块，不可能在比它更后面的快照中「复活」。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第三点关于 reflink 造成的数据复活现象可能需要解释一下，比如在（支持 reflink 的） btrfs 中有如下操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;btrfs subvolume snapshot -r fs s1&lt;/span&gt;
&lt;span class="code-line"&gt;rm fs/somefile&lt;/span&gt;
&lt;span class="code-line"&gt;btrfs subvolume snapshot -r fs s2&lt;/span&gt;
&lt;span class="code-line"&gt;cp --reflink&lt;span class="o"&gt;=&lt;/span&gt;always s1/somefile fs/somefile&lt;/span&gt;
&lt;span class="code-line"&gt;btrfs subvolume snapshot -r fs s3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们对 fs 创建了 s1 快照，删除了 fs 中某个文件，创建了 s2 快照，然后用 reflink
把刚刚删除的文件从 s1 中复制出来，再创建 s3 。如此操作之后，按时间顺序有 s1、s2、s3 三个快照：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/f91316de.png"/&gt;
&lt;p&gt;其中只有 s2 不存在 somefile ，而 s1 、 s3 和当前的 fs 都有，并且都引用到了同一个数据块。
于是从时间线来看， somefile 的数据块在 s2 中「死掉」了，又在 s3 中「复活」了。&lt;/p&gt;
&lt;p&gt;而 ZFS (目前还）不支持 reflink ，所以没法像这样让数据块复活。一旦某个数据块在某个快照中「死」了，
就意味着它在随后的所有快照中都不再被引用到了。&lt;/p&gt;
&lt;p&gt;ZFS 的快照具有的上述三点条件，使得 ZFS 的快照删除算法可以基于 birth time
。回顾上面 &lt;a class="reference internal" href="#id18"&gt;ZFS 的块指针&lt;/a&gt; 中讲到， ZFS 的每个块指针都有一个 birth txg
属性，记录这个块诞生时 pool 所在的 txg 。于是可以根据这个 birth txg
找到快照所引用的「独占」数据块然后释放掉它们。&lt;/p&gt;
&lt;p&gt;具体来说，🐢乌龟算法可以这样删除一个快照：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;在 DSL 层找出要删除的快照（我们叫他 s ），它的前一个快照（叫它 ps ），后一个快照（叫它 ns
），分别有各自的 birth txg 叫 s.birth, ps.birth, ns.birth 。&lt;/li&gt;
&lt;li&gt;遍历 s 的 DMU 对象集指针所引出的所有块指针。
这里所有块指针在逻辑上构成一个由块指针组成的树状结构，可以有间接块组成的指针树，可以有对象集的
dnode 保存的块指针，这些都可以看作是树状结构的中间节点。&lt;ol class="arabic"&gt;
&lt;li&gt;每个树节点的指针 bp，考察如果 bp.birth &amp;lt;= ps.birth
，那么这个指针和其下所有指针都还被前一个快照引用着，需要保留这个 bp 引出的整个子树。&lt;/li&gt;
&lt;li&gt;按定义 bp.birth 不可能 &amp;gt; s.birth 。&lt;/li&gt;
&lt;li&gt;对所有满足 ps.birth &amp;lt; bp.birtu &amp;lt;= s.birth 的 bp ，需要去遍历 ns
的相应块指针（同样文件的同样偏移位置），看是否还在引用 bp 。&lt;ul&gt;
&lt;li&gt;如果存在，继续递归往下考察树状结构中 bp 的所有子节点指针。因为可能共享了这个 bp 但
CoW 了新的子节点。&lt;/li&gt;
&lt;li&gt;如果不存在，说明下一个快照中已经删了 bp 。这时可以确定地说 bp 是 s 的「独占」数据块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;释放掉所有找到的 s 所「独占」的数据块。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述算法的一些边角情况可以自然地处理，比如没有后一个快照时使用当前数据集的写入点，
没有前一个快照时那么不被后一个快照引用的数据块都是当前要删除快照的独占数据块。&lt;/p&gt;
&lt;p&gt;分析一下乌龟算法的复杂度的话，算法需要分两次，读 s 和 ns 中引用到的所有 ps
之后创建的数据块的指针，重要的是这些读都是在整个文件系统范围内的随机读操作，所以速度非常慢……&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id27"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id55"&gt;🐰兔子算法：死亡列表算法（ZFS早期）&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;可以粗略地认为🐢乌龟算法算是用 birth txg 优化代码路径的 GC 算法，利用了一部分元数据中的 birth txg
信息来避免扫描所有元数据，但是概念上仍然是在扫描元数据找出快照的独占数据块，
而非记录和跟踪快照的数据块，在最坏的情况下仍然可能需要扫描几乎所有元数据。&lt;/p&gt;
&lt;p&gt;🐰兔子算法基于🐢乌龟算法的基本原理，在它基础上跟踪快照所引用数据块的一些信息，
从而很大程度上避免了扫描元数据的开销。ZFS 在早期使用这个算法跟踪数据集和快照引用数据块的情况。&lt;/p&gt;
&lt;p&gt;🐰兔子算法为每个数据集（文件系统或快照）增加了一个数据结构，叫死亡列表（dead list），
记录 &lt;strong&gt;前一个快照中还活着，而当前数据集中死掉了的数据块指针&lt;/strong&gt;
，换句话说就是在本数据集中「杀掉」的数据块。举例画图大概是这样&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/ab76244a.png"/&gt;
&lt;p&gt;上图中有三个快照和一个文件系统，共 4 个数据集。每个数据集维护自己的死亡列表，
死亡列表中是那些在该数据集中被删掉的数据块。于是🐰兔子算法把🐢乌龟算法所做的操作分成了两部分，
一部分在文件系统删除数据时记录死亡列表，另一部分在删除快照时根据死亡列表释放需要释放的块。&lt;/p&gt;
&lt;p&gt;在当前文件系统删除数据块（不再被当前文件系统引用）时，负责比对 birth txg
维护当前文件系统的死亡列表。每删除一个数据块，指针为 bp 时，判断 bp.birth
和文件系统最新的快照（上图为 s3）的 birth：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;bp.birth &amp;lt;= s3.birth： 说明 bp 被 s3 引用，于是将 bp 加入 fs1 的 deadlist&lt;/li&gt;
&lt;li&gt;bp.birth &amp;gt; s3.birth：说明 bp 指向的数据块诞生于 s3 之后，可以直接释放 bp 指向的块。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建新快照时，将当前文件系统（图中 fs1）的死亡列表交给快照，文件系统可以初始化一个空列表。&lt;/p&gt;
&lt;p&gt;删除快照时，我们有被删除的快照 s 和前一个快照 ps 、后一个快照 ns ，需要读入当前快照 s
和后一个快照 ns 的死亡列表：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;对 s.deadlist 中的每个指针 bp&lt;ul&gt;
&lt;li&gt;复制 bp 到 ns.deadlist&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对 ns.deadlist 中的每个指针 bp （其中包含了上一步复制来的）&lt;ul&gt;
&lt;li&gt;如果 bp.birth &amp;gt; ps.birth ，释放 bp 的空间&lt;/li&gt;
&lt;li&gt;否则保留 bp&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;换个说法的话， &lt;strong&gt;死亡列表记录的是每个数据集需要负责删除，但因为之前的快照还引用着所以不能删除的数据块列表&lt;/strong&gt;
。从当前文件系统中删除一个数据块时，这个职责最初落在当前文件系统身上，随后跟着创建新快照职责被转移到新快照上。
每个负责的数据集根据数据块的出生时间是否早于之前一个快照来判断现在是否能立刻释放该块，
删除一个快照时则重新评估自己负责的和下一个快照负责的数据块的出生时间。&lt;/p&gt;
&lt;p&gt;从所做的事情来看，🐰兔子算法并没有比🐢乌龟算法少做很多事情。🐢乌龟算法删除一个快照，
需要遍历当前快照和后一个快照两组数据块指针中，新写入的部分；
🐰兔子算法则需要遍历当前快照和后一个快照两个死亡列表中，新删除的块指针。
但是实际🐰兔子算法能比🐢乌龟算法快不少，因为维护死亡列表的操作只在文件系统删除数据时和删除快照时，
顺序写入，并且删除快照时也只需要顺序读取死亡列表。在磁盘这种块设备上，顺序访问能比随机访问有数量级的差异。&lt;/p&gt;
&lt;p&gt;不过记录死亡列表也有一定存储开销。最差情况下，比如把文件系统写满之后，创建一个快照，
再把所有数据都删掉，此时文件系统引用的所有数据块的块指针都要保存在文件系统的死亡列表中。
按 ZFS 默认的 128KiB 数据块大小，每块需要 128 字节的块指针，存储这些死亡列表所需开销可能要
整个文件系统大小的 1/1024 。如果用 4KiB 的数据块大小，所需开销则是 1/32 ， 1TiB
的盘会有 32GiB 拿来存放这些块指针，将高于用位图数组所需的存储量。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id28"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id56"&gt;🐆豹子算法：死亡列表的子列表&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;🐆豹子算法是 ZFS 后来在 2009 年左右实现的算法。在🐰兔子算法中就可以看到，每次删除快照操作死亡列表的时候，
都需要扫描死亡列表中的块指针，根据指针中记录的 birth txg 做判断是否能直接释放或是需要保留到另一个快照的死亡列表。
于是🐆豹子算法的思路是，在死亡列表中记录块指针时，就把其中的块指针按 birth txg 分成子列表（sublist）。&lt;/p&gt;
&lt;p&gt;比如上面🐰兔子算法中那4个死亡列表，可以这样拆成子列表：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/34b39b01.png"/&gt;
&lt;p&gt;这样拆成子列表之后，每次从死亡列表中释放数据块都能根据出生时间找到对应的子列表，
然后连续释放整个子列表。每次合并死亡列表时，也能直接用单链表穿起需要合并的子列表，不需要复制块指针。&lt;/p&gt;
&lt;p&gt;死亡列表并不在跟踪快照的独占大小，而是在跟踪快照所需负责删除的数据块大小，
从这个数值可以推算出快照的独占大小之类的信息。
有了按出生时间排列的死亡列表子列表之后，事实上给任何一个出生时间到死亡时间的范围，
都可以找出对应的几个子列表，从而根据子列表的大小可以快速计算出每个快照范围的「独占」数据块、
「共享」数据块等大小，这不光在删除快照时很有用，也可以用来根据大小估算 zfs send
或者别的基于快照操作时需要的时间。&lt;/p&gt;
&lt;p&gt;从直觉上理解，虽然 ZFS 没有直接记录每个数据块属于哪个数据集，但是 ZFS
跟踪记录了每个数据块的归属信息，也就是说由哪个数据集负责释放这个数据块。
在文件系统中删除数据块或者快照时，这个归属信息跟着共享数据块转移到别的快照中，直到最终被释放掉。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id29"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id57"&gt;生存日志：ZFS 如何管理克隆的空间占用&lt;/a&gt;&lt;/h4&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Fast Clone Deletion by Sara Hartse&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/GLABJRWwGMk"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;以上三种算法负责在 ZFS 中跟踪快照的空间占用，它们都基于数据块的诞生时间，所以都假设 ZFS
中对数据块的分配是位于连续的快照时间轴上。但是明显 ZFS 除了快照和文件系统，
还有另一种数据集可能分配数据块，那就是 &lt;a class="reference internal" href="#id12"&gt;克隆&lt;/a&gt;
，于是还需要在克隆中使用不同的算法单独管理因克隆而分配的数据块。
OpenZFS Summit 2017 有个演讲 &lt;a class="reference external" href="https://www.youtube.com/watch?v=GLABJRWwGMk"&gt;Fast Clone Deletion by Sara Hartse&lt;/a&gt;
解释了其中的细节。&lt;/p&gt;
&lt;p&gt;首先克隆的存在本身会锁住克隆引用到的快照，不能删除这些被依赖的快照，
所以克隆无须担心靠快照共享的数据块的管理问题。因此克隆需要管理的，是从快照分离之后，
新创建的数据块。&lt;/p&gt;
&lt;p&gt;和🐢乌龟算法一样，原理上删除克隆的时候可以遍历克隆引用的整个 DMU
对象集，找出其中晚于快照的诞生时间的数据块，然后释放它们。也和🐢乌龟算法一样，
这样扫描整个对象集的开销很大，所以使用一个列表来记录数据块指针。
克隆管理新数据块的思路和快照的🐰兔子算法维持死亡列表的思路相反，
记录所有新诞生的数据块，这个列表叫做「生存日志（livelist）」。&lt;/p&gt;
&lt;p&gt;克隆不光要记录新数据块的诞生，还要记录新数据块可能的死亡，所以磁盘上保存的生存日志虽然叫 livelist
，但不像死亡列表那样是列表的形式，而是日志的形式，而内存中保存的生存日志则组织成了棵
&lt;a class="reference external" href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91"&gt;自平衡树（AVLTree）&lt;/a&gt; 来加速查找。&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/7f244754.png"/&gt;
&lt;p&gt;磁盘上存储的生存日志如上图，每个表项记录它是分配（A）或者删除（F）一个数据块，同时记录数据块的地址。
这些记录在一般情况下直接记录在日志末尾，随着对克隆的写入操作而不断增长，长到一定程度则从内存中的
AVL Tree 直接输出一个新的生存日志替代掉旧的，合并其中对应的分配和删除操作。&lt;/p&gt;
&lt;p&gt;生存日志可以无限增长，从而要将整个生存列表载入内存也有不小的开销，这里的解决方案有点像快照管理中用
🐆豹子算法改进🐰兔子算法的思路，把一个克隆的整个生存日志也按照数据块的诞生时间拆分成子列表。
Sara Hartse 的演讲 Fast Clone Deletion 中继续解释了其中的细节和优化方案，感兴趣的可以看看。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id30"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id58"&gt;3.4   btrfs 的空间跟踪算法：引用计数与反向引用&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;理解了 ZFS 中根据 birth txg 管理快照和克隆的算法之后，可以发现它们基于的假设难以用于 WAFL
和 btrfs 。 ZFS 严格区分文件系统、快照、克隆，并且不存在 reflink ，从而可以用 birth txg
判断数据块是否需要保留，而 WAFL 和 btrfs 中不存在 ZFS 的那些数据集分工，又想支持 reflink
，可见单纯基于 birth txg 不足以管理 WAFL 和 btrfs 子卷。&lt;/p&gt;
&lt;p&gt;让我们回到一开始日志结构文件系统中基于垃圾回收（GC）的思路上来，作为程序员来看，
当垃圾回收的性能不足以满足当前需要时，大概很自然地会想到：引用计数（reference counting）。
编程语言中用引用计数作为内存管理策略的缺陷是：强引用不能成环，
这在文件系统中看起来不是很严重的问题，文件系统总体上看是个树状结构，或者就算有共享的数据也是个
上下层级分明的有向图，很少会使用成环的指针，以及文件系统记录指针的时候也都会区分指针的类型，
根据指针类型可以分出强弱引用。&lt;/p&gt;
&lt;div class="section" id="extent-tree"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id59"&gt;EXTENT_TREE 和引用计数&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;btrfs 中就是用引用计数的方式跟踪和管理数据块的。引用计数本身不能保存在 FS_TREE
或者指向的数据块中，因为这个计数需要能够变化，对只读快照来说整个 FS_TREE 都是只读的。
所以这里增加一层抽象， btrfs 中关于数据块的引用计数用一个单独的 CoW B树来记录，叫做
EXTENT_TREE ，保存于 ROOT_TREE 中的 2 号对象位置。&lt;/p&gt;
&lt;p&gt;btrfs 中每个块都是按 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Extent_(file_systems)"&gt;区块（extent）&lt;/a&gt;
的形式分配的，区块是一块连续的存储空间，而非 zfs 中的固定大小。每个区块记录存储的位置和长度，
以及这里所说的引用计数。所以本文最开始讲 &lt;a class="reference internal" href="#btrfs"&gt;Btrfs 的子卷和快照&lt;/a&gt; 中举例的那个平坦布局，如果画上
EXTENT_TREE 大概像是下图这样，其中每个粗箭头是一个区块指针，指向磁盘中的逻辑地址，细箭头则是对应的
EXTENT_TREE 中关于这块区块的描述：&lt;/p&gt;
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;

&lt;!-- Generated by graphviz version 2.40.1 (20161225.0304)
 --&gt;
&lt;!-- Title: Flat_layout_extents_on_disk Pages: 1 --&gt;
&lt;svg class="svg-responsive" height="599pt" viewbox="0.00 0.00 1280.00 598.88" width="1280pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
&lt;g class="graph" id="graph0" transform="scale(1 1) rotate(0) translate(4 594.8766)"&gt;
&lt;title&gt;Flat_layout_extents_on_disk&lt;/title&gt;
&lt;polygon fill="#ffffff" points="-4,4 -4,-594.8766 1276,-594.8766 1276,4 -4,4" stroke="transparent"&gt;&lt;/polygon&gt;
&lt;!-- superblock --&gt;
&lt;g class="node" id="node1"&gt;
&lt;title&gt;superblock&lt;/title&gt;
&lt;polygon fill="none" points="0,-315.5 0,-407.5 123,-407.5 123,-315.5 0,-315.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="61.5" y="-392.3"&gt;SUPERBLOCK&lt;/text&gt;
&lt;polyline fill="none" points="0,-384.5 123,-384.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="61.5" y="-369.3"&gt;...&lt;/text&gt;
&lt;polyline fill="none" points="0,-361.5 123,-361.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="61.5" y="-346.3"&gt;root_tree&lt;/text&gt;
&lt;polyline fill="none" points="0,-338.5 123,-338.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="61.5" y="-323.3"&gt;...&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree --&gt;
&lt;g class="node" id="node2"&gt;
&lt;title&gt;roottree&lt;/title&gt;
&lt;polygon fill="none" points="195,-62 195,-361 504,-361 504,-62 195,-62" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-345.8"&gt;ROOT_TREE&lt;/text&gt;
&lt;polyline fill="none" points="195,-338 504,-338 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-322.8"&gt;2: extent_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-315 504,-315 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-299.8"&gt;3: chunk_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-292 504,-292 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-276.8"&gt;4: dev_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-269 504,-269 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-253.8"&gt;5: fs_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-246 504,-246 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-230.8"&gt;6: root_dir "default" -&amp;gt; ROOT_ITEM 256&lt;/text&gt;
&lt;polyline fill="none" points="195,-223 504,-223 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-207.8"&gt;10: free_space_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-200 504,-200 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-184.8"&gt;256: fs_tree "root"&lt;/text&gt;
&lt;polyline fill="none" points="195,-177 504,-177 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-161.8"&gt;257: fs_tree "home"&lt;/text&gt;
&lt;polyline fill="none" points="195,-154 504,-154 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-138.8"&gt;258: fs_tree "www"&lt;/text&gt;
&lt;polyline fill="none" points="195,-131 504,-131 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-115.8"&gt;259: fs_tree "postgres"&lt;/text&gt;
&lt;polyline fill="none" points="195,-108 504,-108 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-92.8"&gt;-7: tree_log_tree&lt;/text&gt;
&lt;polyline fill="none" points="195,-85 504,-85 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="349.5" y="-69.8"&gt;-5: orphan_root&lt;/text&gt;
&lt;/g&gt;
&lt;!-- superblock&amp;#45;&amp;gt;roottree --&gt;
&lt;g class="edge" id="edge1"&gt;
&lt;title&gt;superblock:sn_root-&amp;gt;roottree:label&lt;/title&gt;
&lt;path d="M123,-349.5C151.375,-349.5 160.8795,-349.5 184.9792,-349.5" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="185,-353.0001 195,-349.5 185,-346.0001 185,-353.0001" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel --&gt;
&lt;g class="node" id="node3"&gt;
&lt;title&gt;toplevel&lt;/title&gt;
&lt;polygon fill="none" points="576,-260.5 576,-490.5 923,-490.5 923,-260.5 576,-260.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-475.3"&gt;FS_TREE "toplevel"&lt;/text&gt;
&lt;polyline fill="none" points="576,-467.5 923,-467.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-452.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="576,-444.5 923,-444.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-429.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;polyline fill="none" points="576,-421.5 923,-421.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-406.3"&gt;256: dir_item: "root" -&amp;gt; ROOT_ITEM 256&lt;/text&gt;
&lt;polyline fill="none" points="576,-398.5 923,-398.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-383.3"&gt;256: dir_item: "home" -&amp;gt; ROOT_ITEM 257&lt;/text&gt;
&lt;polyline fill="none" points="576,-375.5 923,-375.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-360.3"&gt;256: dir_item: "var" -&amp;gt; INODE_ITEM 257&lt;/text&gt;
&lt;polyline fill="none" points="576,-352.5 923,-352.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-337.3"&gt;256: dir_item: "postgres" -&amp;gt; ROOT_ITEM 259&lt;/text&gt;
&lt;polyline fill="none" points="576,-329.5 923,-329.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-314.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="576,-306.5 923,-306.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-291.3"&gt;257: inode_item DIR&lt;/text&gt;
&lt;polyline fill="none" points="576,-283.5 923,-283.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-268.3"&gt;257: dir_item: "www" -&amp;gt; ROOT_ITEM 258&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;toplevel --&gt;
&lt;g class="edge" id="edge2"&gt;
&lt;title&gt;roottree:root_fs-&amp;gt;toplevel:label&lt;/title&gt;
&lt;path d="M504,-257.5C604.0795,-257.5 481.5022,-464.165 565.9262,-478.6961" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="565.7533,-482.1934 576,-479.5 566.3101,-475.2156 565.7533,-482.1934" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- root --&gt;
&lt;g class="node" id="node4"&gt;
&lt;title&gt;root&lt;/title&gt;
&lt;polygon fill="none" points="667.5,-195.5 667.5,-241.5 831.5,-241.5 831.5,-195.5 667.5,-195.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-226.3"&gt;FS_TREE "root"&lt;/text&gt;
&lt;polyline fill="none" points="667.5,-218.5 831.5,-218.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-203.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;root --&gt;
&lt;g class="edge" id="edge3"&gt;
&lt;title&gt;roottree:root_sub_root-&amp;gt;root:label&lt;/title&gt;
&lt;path d="M504,-188.5C575.5091,-188.5 591.078,-226.6548 657.3427,-230.2318" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="657.4111,-233.7347 667.5,-230.5 657.5959,-226.7372 657.4111,-233.7347" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- home --&gt;
&lt;g class="node" id="node5"&gt;
&lt;title&gt;home&lt;/title&gt;
&lt;polygon fill="none" points="667.5,-130.5 667.5,-176.5 831.5,-176.5 831.5,-130.5 667.5,-130.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-161.3"&gt;FS_TREE "home"&lt;/text&gt;
&lt;polyline fill="none" points="667.5,-153.5 831.5,-153.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-138.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;home --&gt;
&lt;g class="edge" id="edge4"&gt;
&lt;title&gt;roottree:root_sub_home-&amp;gt;home:label&lt;/title&gt;
&lt;path d="M504,-165.5C573.1185,-165.5 592.9293,-165.5 657.2326,-165.5" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="657.5,-169.0001 667.5,-165.5 657.5,-162.0001 657.5,-169.0001" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- www --&gt;
&lt;g class="node" id="node6"&gt;
&lt;title&gt;www&lt;/title&gt;
&lt;polygon fill="none" points="667.5,-65.5 667.5,-111.5 831.5,-111.5 831.5,-65.5 667.5,-65.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-96.3"&gt;FS_TREE "www"&lt;/text&gt;
&lt;polyline fill="none" points="667.5,-88.5 831.5,-88.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-73.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;www --&gt;
&lt;g class="edge" id="edge5"&gt;
&lt;title&gt;roottree:root_sub_www-&amp;gt;www:label&lt;/title&gt;
&lt;path d="M504,-142.5C537.3333,-142.5 543.742,-129.8984 576,-121.5 612.9079,-111.8909 623.9319,-102.3027 657.4191,-100.7257" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="657.5809,-104.2231 667.5,-100.5 657.4241,-97.2248 657.5809,-104.2231" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- postgres --&gt;
&lt;g class="node" id="node7"&gt;
&lt;title&gt;postgres&lt;/title&gt;
&lt;polygon fill="none" points="667,-.5 667,-46.5 832,-46.5 832,-.5 667,-.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-31.3"&gt;FS_TREE "postgres"&lt;/text&gt;
&lt;polyline fill="none" points="667,-23.5 832,-23.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="749.5" y="-8.3"&gt;256: inode_item DIR&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;postgres --&gt;
&lt;g class="edge" id="edge6"&gt;
&lt;title&gt;roottree:root_sub_postgres-&amp;gt;postgres:label&lt;/title&gt;
&lt;path d="M504,-119.5C546.5206,-119.5 538.1561,-75.8865 576,-56.5 609.5913,-39.292 622.8882,-35.9967 656.4598,-35.5574" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="656.5202,-39.0572 666.5,-35.5 656.4801,-32.0573 656.5202,-39.0572" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent_tree --&gt;
&lt;g class="node" id="node8"&gt;
&lt;title&gt;extent_tree&lt;/title&gt;
&lt;polygon fill="none" points="995,-338.5 995,-568.5 1272,-568.5 1272,-338.5 995,-338.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="1133.5" y="-553.3"&gt;EXTENT_TREE&lt;/text&gt;
&lt;polyline fill="none" points="995,-545.5 1272,-545.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="1133.5" y="-530.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="995,-522.5 1272,-522.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="1133.5" y="-507.3"&gt;0x2000 len=0x1000 : ref=1 gen=8&lt;/text&gt;
&lt;polyline fill="none" points="995,-499.5 1272,-499.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="1133.5" y="-484.3"&gt;0x3000 len=0x1000 : ref=1 gen=8&lt;/text&gt;
&lt;polyline fill="none" points="995,-476.5 1272,-476.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="1133.5" y="-461.3"&gt;0x11000 len=0x1000 : ref=1 gen=8&lt;/text&gt;
&lt;polyline fill="none" points="995,-453.5 1272,-453.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="1133.5" y="-438.3"&gt;0x12000 len=0x1000 : ref=1 gen=6&lt;/text&gt;
&lt;polyline fill="none" points="995,-430.5 1272,-430.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="1133.5" y="-415.3"&gt;0x13000 len=0x1000 : ref=1 gen=6&lt;/text&gt;
&lt;polyline fill="none" points="995,-407.5 1272,-407.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="1133.5" y="-392.3"&gt;0x14000 len=0x1000 : ref=1 gen=6&lt;/text&gt;
&lt;polyline fill="none" points="995,-384.5 1272,-384.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="1133.5" y="-369.3"&gt;0x15000 len=0x1000 : ref=1 gen=7&lt;/text&gt;
&lt;polyline fill="none" points="995,-361.5 1272,-361.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="1133.5" y="-346.3"&gt;...&lt;/text&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;extent_tree --&gt;
&lt;g class="edge" id="edge7"&gt;
&lt;title&gt;roottree:root_extent-&amp;gt;extent_tree:label&lt;/title&gt;
&lt;path d="M504,-326.5C601.4064,-326.5 498.2586,-474.812 576,-533.5 722.1806,-643.8537 805.4304,-560.628 984.9901,-557.5848" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="985.0301,-561.0847 995,-557.5 984.9707,-554.085 985.0301,-561.0847" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- roottree&amp;#45;&amp;gt;extent_tree --&gt;
&lt;g class="edge" id="edge8"&gt;
&lt;title&gt;roottree:label-&amp;gt;extent_tree:extent_roottree&lt;/title&gt;
&lt;path d="M504,-349.5C578.3499,-349.5 513.6489,-460.0002 576,-500.5 651.4417,-549.5028 885.1193,-514.1107 984.9203,-511.6341" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="985.0475,-515.1328 995,-511.5 984.9543,-508.1334 985.0475,-515.1328" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- toplevel&amp;#45;&amp;gt;extent_tree --&gt;
&lt;g class="edge" id="edge10"&gt;
&lt;title&gt;toplevel:label-&amp;gt;extent_tree:extent_toplevel&lt;/title&gt;
&lt;path d="M923,-479.5C951.9064,-479.5 960.5287,-468.4922 984.8395,-465.9983" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="985.1835,-469.4857 995,-465.5 984.8405,-462.4941 985.1835,-469.4857" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- root&amp;#45;&amp;gt;extent_tree --&gt;
&lt;g class="edge" id="edge11"&gt;
&lt;title&gt;root:label-&amp;gt;extent_tree:extent_root&lt;/title&gt;
&lt;path d="M831.5,-230.5C873.224,-230.5 891.5516,-224.0794 923,-251.5 988.2728,-308.413 911.5209,-430.9023 984.7571,-440.8546" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="984.7996,-444.3641 995,-441.5 985.2399,-437.3779 984.7996,-444.3641" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- home&amp;#45;&amp;gt;extent_tree --&gt;
&lt;g class="edge" id="edge12"&gt;
&lt;title&gt;home:label-&amp;gt;extent_tree:extent_home&lt;/title&gt;
&lt;path d="M831.5,-165.5C873.224,-165.5 892.4068,-158.1284 923,-186.5 999.5328,-257.4751 894.4682,-408.0627 984.9685,-417.9844" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="984.8335,-421.482 995,-418.5 985.1929,-414.4912 984.8335,-421.482" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- www&amp;#45;&amp;gt;extent_tree --&gt;
&lt;g class="edge" id="edge13"&gt;
&lt;title&gt;www:label-&amp;gt;extent_tree:extent_www&lt;/title&gt;
&lt;path d="M831.5,-100.5C873.224,-100.5 893.0377,-92.463 923,-121.5 1010.8577,-206.6445 877.0747,-385.0229 984.9412,-395.058" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="984.856,-398.5576 995,-395.5 985.1633,-391.5643 984.856,-398.5576" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- postgres&amp;#45;&amp;gt;extent_tree --&gt;
&lt;g class="edge" id="edge14"&gt;
&lt;title&gt;postgres:label-&amp;gt;extent_tree:extent_postgres&lt;/title&gt;
&lt;path d="M832.5,-35.5C873.7909,-35.5 893.8612,-27.2448 923,-56.5 1022.0703,-155.9659 859.5991,-361.7078 984.6327,-372.0916" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="984.8699,-375.6035 995,-372.5 985.1456,-368.609 984.8699,-375.6035" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent_tree&amp;#45;&amp;gt;extent_tree --&gt;
&lt;g class="edge" id="edge9"&gt;
&lt;title&gt;extent_tree:extent_extent-&amp;gt;extent_tree:label&lt;/title&gt;
&lt;path d="M994.6922,-483.8069C898.1723,-484.611 803,-494.4106 803,-523 803,-550.5843 891.5981,-560.6768 984.5214,-562.0745" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="984.652,-565.5762 994.6922,-562.1931 984.7337,-558.5767 984.652,-565.5762" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;/svg&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
btrfs 中关于 &lt;code class="code"&gt;
chattr +C&lt;/code&gt;
 关闭了 CoW 的文件的处理&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2020年2月20日补充&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;这里从 EXTENT_TREE 的记录可以看出，每个区块都有引用计数记录。对用 &lt;code class="code"&gt;
chattr +C&lt;/code&gt;

关闭了 CoW 的文件而言，文件数据同样还是有引用计数，可以和别的文件或者快照共享文件数据的。
这里的特殊处理在于，每次写入一个 nocow 的文件的时候，考察这个文件指向区块的引用计数，
如果引用计数 &amp;gt;1 ，表示这个文件的区块发生过 reflink ，那会对文件内容做一次 CoW 断开
reflink 并写入新位置；如果引用计数 =1 ，那么直接原地写入文件内容而不 CoW 。于是
nocow 的文件仍然能得到 reflink 和 snapshot 的功能，
使用这些功能仍然会造成文件碎片并伴随性能损失，只是在引用计数为 1 的时候不发生 CoW 。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;包括 ROOT_TREE 和 EXTENT_TREE 在内，btrfs 中所有分配的区块（extent）都在 EXTENT_TREE
中有对应的记录，按区块的逻辑地址索引。从而给定一个区块，能从 EXTENT_TREE 中找到 ref
字段描述这个区块有多少引用。不过 ROOT_TREE 、 EXTENT_TREE 和别的一些 pool-wide
数据结构本身不依赖引用计数的，这些数据结构对应的区块的引用计数总是 1 ，不会和别的树共享区块；从 FS_TREE
开始的所有树节点都可以共享区块，这包括所有子卷的元数据和文件数据，这些区块对应的引用计数可以大于
1 表示有多处引用。&lt;/p&gt;
&lt;p&gt;EXTENT_TREE 按区块的逻辑地址索引，记录了起始地址和长度，所以 EXTENT_TREE 也兼任 btrfs
的空间利用记录，充当别的文件系统中 block bitmap 的职责。比如上面例子中的 extent_tree 就表示
&lt;code class="code"&gt;
[0x2000,0x4000) [0x11000,0x16000)&lt;/code&gt;
 这两段连续的空间是已用空间，
剩下的空间按定义则是可用空间。为了加速空间分配器， btrfs 也有额外的
free space cache 记录在 ROOT_TREE 的 10 号位置 free_space_tree 中，不过在 btrfs
中这个 free_space_tree 记录的信息只是缓存，必要时可以通过
&lt;code class="code"&gt;
btrfs check --clear-space-cache&lt;/code&gt;

扔掉这个缓存重新扫描 extent_tree 并重建可用空间记录。&lt;/p&gt;
&lt;p&gt;比如我们用如下命令创建了两个文件，通过 reflink 让它们共享区块，然后创建两个快照，
然后删除文件系统中的 file2 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;write fs/file1&lt;/span&gt;
&lt;span class="code-line"&gt;cp --reflink&lt;span class="o"&gt;=&lt;/span&gt;always fs/file1 fs/file2&lt;/span&gt;
&lt;span class="code-line"&gt;btrfs subvolume snapshot fs sn1&lt;/span&gt;
&lt;span class="code-line"&gt;btrfs subvolume snapshot fs sn2&lt;/span&gt;
&lt;span class="code-line"&gt;rm fs/file2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过以上操作之后，整个 extent_tree 的结构中记录的引用计数大概如下图所示：&lt;/p&gt;
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;

&lt;!-- Generated by graphviz version 2.40.1 (20161225.0304)
 --&gt;
&lt;!-- Title: btrfs_reflink_backref Pages: 1 --&gt;
&lt;svg class="svg-responsive" height="290pt" viewbox="0.00 0.00 823.00 290.00" width="823pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
&lt;g class="graph" id="graph0" transform="scale(1 1) rotate(0) translate(4 286)"&gt;
&lt;title&gt;btrfs_reflink_backref&lt;/title&gt;
&lt;polygon fill="#ffffff" points="-4,4 -4,-286 819,-286 819,4 -4,4" stroke="transparent"&gt;&lt;/polygon&gt;
&lt;!-- root --&gt;
&lt;g class="node" id="node1"&gt;
&lt;title&gt;root&lt;/title&gt;
&lt;polygon fill="none" points="0,-90.5 0,-182.5 110,-182.5 110,-90.5 0,-90.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="55" y="-167.3"&gt;ROOT_TREE&lt;/text&gt;
&lt;polyline fill="none" points="0,-159.5 110,-159.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="55" y="-144.3"&gt;sn1&lt;/text&gt;
&lt;polyline fill="none" points="0,-136.5 110,-136.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="55" y="-121.3"&gt;sn2&lt;/text&gt;
&lt;polyline fill="none" points="0,-113.5 110,-113.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="55" y="-98.3"&gt;fs&lt;/text&gt;
&lt;/g&gt;
&lt;!-- sn1 --&gt;
&lt;g class="node" id="node2"&gt;
&lt;title&gt;sn1&lt;/title&gt;
&lt;polygon fill="none" points="182,-154.5 182,-200.5 297,-200.5 297,-154.5 182,-154.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-185.3"&gt;FS_TREE sn1&lt;/text&gt;
&lt;polyline fill="none" points="182,-177.5 297,-177.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-162.3"&gt;leaf_node&lt;/text&gt;
&lt;/g&gt;
&lt;!-- root&amp;#45;&amp;gt;sn1 --&gt;
&lt;g class="edge" id="edge1"&gt;
&lt;title&gt;root:sn1-&amp;gt;sn1:label&lt;/title&gt;
&lt;path d="M110,-148.5C143.0846,-148.5 145.1136,-181.5948 171.89,-188.3172" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="171.661,-191.8142 182,-189.5 172.4745,-184.8616 171.661,-191.8142" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- sn2 --&gt;
&lt;g class="node" id="node3"&gt;
&lt;title&gt;sn2&lt;/title&gt;
&lt;polygon fill="none" points="182,-89.5 182,-135.5 297,-135.5 297,-89.5 182,-89.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-120.3"&gt;FS_TREE sn2&lt;/text&gt;
&lt;polyline fill="none" points="182,-112.5 297,-112.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-97.3"&gt;leaf_node&lt;/text&gt;
&lt;/g&gt;
&lt;!-- root&amp;#45;&amp;gt;sn2 --&gt;
&lt;g class="edge" id="edge2"&gt;
&lt;title&gt;root:sn2-&amp;gt;sn2:label&lt;/title&gt;
&lt;path d="M110,-124.5C138.375,-124.5 147.8795,-124.5 171.9792,-124.5" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="172,-128.0001 182,-124.5 172,-121.0001 172,-128.0001" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- fs --&gt;
&lt;g class="node" id="node4"&gt;
&lt;title&gt;fs&lt;/title&gt;
&lt;polygon fill="none" points="188.5,-24.5 188.5,-70.5 290.5,-70.5 290.5,-24.5 188.5,-24.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-55.3"&gt;FS_TREE fs&lt;/text&gt;
&lt;polyline fill="none" points="188.5,-47.5 290.5,-47.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-32.3"&gt;leaf_node&lt;/text&gt;
&lt;/g&gt;
&lt;!-- root&amp;#45;&amp;gt;fs --&gt;
&lt;g class="edge" id="edge3"&gt;
&lt;title&gt;root:fs-&amp;gt;fs:label&lt;/title&gt;
&lt;path d="M110,-101.5C145.8591,-101.5 148.6975,-67.0059 178.3652,-60.5382" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="178.9088,-64.0009 188.5,-59.5 178.1954,-57.0374 178.9088,-64.0009" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent --&gt;
&lt;g class="node" id="node7"&gt;
&lt;title&gt;extent&lt;/title&gt;
&lt;polygon fill="none" points="599,-97.5 599,-281.5 815,-281.5 815,-97.5 599,-97.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="707" y="-266.3"&gt;EXTENT_TREE extent_tree&lt;/text&gt;
&lt;polyline fill="none" points="599,-258.5 815,-258.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="707" y="-243.3"&gt;root_tree : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-235.5 815,-235.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="707" y="-220.3"&gt;sn1 fs_tree : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-212.5 815,-212.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="707" y="-197.3"&gt;sn2 fs_tree : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-189.5 815,-189.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="707" y="-174.3"&gt;sn1 sn2 leaf_node: ref 2&lt;/text&gt;
&lt;polyline fill="none" points="599,-166.5 815,-166.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="707" y="-151.3"&gt;fs fs_tree : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-143.5 815,-143.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="707" y="-128.3"&gt;fs leaf_node : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-120.5 815,-120.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="707" y="-105.3"&gt;file1 : ref 3&lt;/text&gt;
&lt;/g&gt;
&lt;!-- root&amp;#45;&amp;gt;extent --&gt;
&lt;g class="edge" id="edge7"&gt;
&lt;title&gt;root:label-&amp;gt;extent:root&lt;/title&gt;
&lt;path d="M110,-171.5C146.3929,-171.5 147.3645,-199.3276 182,-210.5 355.7912,-266.56 410.8974,-248.22 588.778,-247.5202" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="589.007,-251.0198 599,-247.5 588.9931,-244.0198 589.007,-251.0198" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- snleaf --&gt;
&lt;g class="node" id="node5"&gt;
&lt;title&gt;snleaf&lt;/title&gt;
&lt;polygon fill="none" points="369,-104 369,-173 527,-173 527,-104 369,-104" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-157.8"&gt;FS_TREE leaf_node&lt;/text&gt;
&lt;polyline fill="none" points="369,-150 527,-150 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-134.8"&gt;file1&lt;/text&gt;
&lt;polyline fill="none" points="369,-127 527,-127 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-111.8"&gt;file2&lt;/text&gt;
&lt;/g&gt;
&lt;!-- sn1&amp;#45;&amp;gt;snleaf --&gt;
&lt;g class="edge" id="edge4"&gt;
&lt;title&gt;sn1:leaf-&amp;gt;snleaf:label&lt;/title&gt;
&lt;path d="M297,-165.5C325.4188,-165.5 334.8506,-162.3549 358.9677,-161.6424" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="359.0507,-165.1416 369,-161.5 358.9513,-158.1423 359.0507,-165.1416" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- sn1&amp;#45;&amp;gt;extent --&gt;
&lt;g class="edge" id="edge8"&gt;
&lt;title&gt;sn1:label-&amp;gt;extent:sn1&lt;/title&gt;
&lt;path d="M297,-189.5C331.0225,-189.5 335.608,-208.9802 369,-215.5 465.9727,-234.434 494.7483,-225.1896 588.7672,-224.5355" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="589.0122,-228.0348 599,-224.5 588.9879,-221.0348 589.0122,-228.0348" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- sn2&amp;#45;&amp;gt;snleaf --&gt;
&lt;g class="edge" id="edge5"&gt;
&lt;title&gt;sn2:leaf-&amp;gt;snleaf:label&lt;/title&gt;
&lt;path d="M297,-100.5C335.1725,-100.5 328.7599,-151.0314 358.921,-160.1113" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="358.6158,-163.6023 369,-161.5 359.5713,-156.6678 358.6158,-163.6023" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- sn2&amp;#45;&amp;gt;extent --&gt;
&lt;g class="edge" id="edge9"&gt;
&lt;title&gt;sn2:label-&amp;gt;extent:sn2&lt;/title&gt;
&lt;path d="M297,-124.5C338.0913,-124.5 330.8441,-167.2481 369,-182.5 460.9878,-219.27 494.1557,-202.7369 588.7239,-201.5638" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="589.022,-205.0621 599,-201.5 588.9784,-198.0622 589.022,-205.0621" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- fsleaf --&gt;
&lt;g class="node" id="node6"&gt;
&lt;title&gt;fsleaf&lt;/title&gt;
&lt;polygon fill="none" points="369,-.5 369,-46.5 527,-46.5 527,-.5 369,-.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-31.3"&gt;FS_TREE leaf_node&lt;/text&gt;
&lt;polyline fill="none" points="369,-23.5 527,-23.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-8.3"&gt;file1&lt;/text&gt;
&lt;/g&gt;
&lt;!-- fs&amp;#45;&amp;gt;fsleaf --&gt;
&lt;g class="edge" id="edge6"&gt;
&lt;title&gt;fs:leaf-&amp;gt;fsleaf:label&lt;/title&gt;
&lt;path d="M290.5,-35.5C321.7092,-35.5 331.9802,-35.5 358.7727,-35.5" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="359,-39.0001 369,-35.5 359,-32.0001 359,-39.0001" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- fs&amp;#45;&amp;gt;extent --&gt;
&lt;g class="edge" id="edge11"&gt;
&lt;title&gt;fs:label-&amp;gt;extent:fs&lt;/title&gt;
&lt;path d="M290.5,-59.5C396.7559,-59.5 430.015,-51.0924 527,-94.5 561.6044,-109.9879 558.3556,-146.986 588.8984,-153.5091" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="588.7061,-157.007 599,-154.5 589.3895,-150.0404 588.7061,-157.007" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- snleaf&amp;#45;&amp;gt;extent --&gt;
&lt;g class="edge" id="edge10"&gt;
&lt;title&gt;snleaf:label-&amp;gt;extent:snleaf&lt;/title&gt;
&lt;path d="M527,-161.5C556.0672,-161.5 564.4226,-174.0803 588.7972,-176.9306" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="588.8205,-180.4372 599,-177.5 589.2106,-173.4481 588.8205,-180.4372" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- snleaf&amp;#45;&amp;gt;extent --&gt;
&lt;g class="edge" id="edge13"&gt;
&lt;title&gt;snleaf:f1-&amp;gt;extent:f1&lt;/title&gt;
&lt;path d="M527,-138.5C558.0104,-138.5 563.4149,-114.4944 589.024,-109.4307" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="589.3684,-112.9139 599,-108.5 588.7181,-105.9442 589.3684,-112.9139" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- snleaf&amp;#45;&amp;gt;extent --&gt;
&lt;g class="edge" id="edge14"&gt;
&lt;title&gt;snleaf:f2-&amp;gt;extent:f1&lt;/title&gt;
&lt;path d="M527,-115.5C555.5088,-115.5 564.7912,-109.9961 588.944,-108.7491" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="589.0898,-112.2467 599,-108.5 588.9163,-105.2488 589.0898,-112.2467" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- fsleaf&amp;#45;&amp;gt;extent --&gt;
&lt;g class="edge" id="edge12"&gt;
&lt;title&gt;fsleaf:label-&amp;gt;extent:fsleaf&lt;/title&gt;
&lt;path d="M527,-35.5C576.5833,-35.5 550.1066,-118.4746 588.994,-130.1429" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="588.6203,-133.6242 599,-131.5 589.5611,-126.6877 588.6203,-133.6242" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- fsleaf&amp;#45;&amp;gt;extent --&gt;
&lt;g class="edge" id="edge15"&gt;
&lt;title&gt;fsleaf:f1-&amp;gt;extent:f1&lt;/title&gt;
&lt;path d="M527,-11.5C576.9145,-11.5 549.8453,-95.3389 588.934,-107.1288" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="588.6191,-110.6181 599,-108.5 589.564,-103.6822 588.6191,-110.6181" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;/svg&gt;
&lt;p&gt;上图简化了一些细节，实际上每个文件可以引用多个区块（文件碎片），
其中每个对区块的引用都可以指明引用到具体某个区块记录的某个地址偏移和长度，
也就是说文件引用的区块可以不是区块记录中的一整个区块，而是一部分内容。&lt;/p&gt;
&lt;p&gt;图中可见，整个文件系统中共有5个文件路径可以访问到同一个文件的内容，分别是
&lt;code class="code"&gt;
sn1/​file1, sn1/​file2, sn2/​file1, sn2/​file2, fs/​file1&lt;/code&gt;
 ，
在 extent_tree 中， sn1 和 sn2 可能共享了一个 B树 叶子节点，这个叶子节点的引用计数为 2
，然后每个文件的内容都指向同一个 extent ，这个 extent 的引用计数为 3 。&lt;/p&gt;
&lt;p&gt;删除子卷时，通过引用计数就能准确地释放掉子卷所引用的区块。具体算法挺符合直觉的：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;从子卷的 FS_TREE 往下遍历&lt;ul&gt;
&lt;li&gt;遇到引用计数 &amp;gt;1 的区块，减小该块的计数即可，不需要再递归下去&lt;/li&gt;
&lt;li&gt;遇到引用计数 =1 的区块，就是子卷独占的区块，需要释放该块并递归往下继续扫描&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大体思路挺像上面介绍的 &lt;a class="reference external" href="🐢乌龟算法：概念上ZFS如何删快照"&gt;ZFS 快照删除的🐢乌龟算法&lt;/a&gt;
，只不过根据引用计数而非 birth txg 判断是否独占数据块。性能上说， btrfs
的B树本身内容就比较紧凑，FS_TREE 一个结构就容纳了文件 inode 和引用的区块信息，
EXTENT_TREE 按地址排序也比较紧凑，所以删除算法的随机读写不像 ZFS 的🐢乌龟算法那么严重，
实际实现代码里面也可能通过 btrfs generation 做一些类似基于 birth txg 优化的快速代码路径。
即便如此，扫描 FS_TREE 仍然可能需要耗时良久，这个递归的每一步操作都会记录在 ROOT_TREE
中专门的结构，也就是说删除一个子卷的操作可以执行很长时间并跨越多个 pool commit 。
&lt;code class="code"&gt;
btrfs subvolume delete&lt;/code&gt;
 命令默认也只是记录下这个删除操作，然后就返回一句类似：
&lt;code class="code"&gt;
Delete subvolume (no-commit): /​subvolume/​path&lt;/code&gt;
 的输出，不会等删除操作执行结束。
相比之下 ZFS 那边删除一个快照或文件系统必须在一个 txg 内执行完，没有中间过程的记录，
所以如果耗时很久会影响整个 pool 的写入，于是 ZFS 那边必须对这些操作优化到能在一个 txg
内执行完的程度(摧毁克隆方面
&lt;a class="reference external" href="https://www.delphix.com/blog/delphix-engineering/performance-zfs-destroy"&gt;ZFS 还有 async_destroy 优化&lt;/a&gt;
可能有些帮助)。&lt;/p&gt;
&lt;p&gt;只需要引用计数就足够完成快照的创建、删除之类的功能，也能支持 reflink 了（仔细回想，
reflink 其实就是 reference counted link 嘛），普通读写下也只需要引用计数。
但是只有引用计数不足以知道区块的归属，不能用引用计数统计每个子卷分别占用多少空间，
独占多少区块而又共享多少区块。上面的例子就可以看出，所有文件都指向同一个区块，该区块的引用计数为
3 ，而文件系统中一共有 5 个路径能访问到该文件。可见从区块根据引用计数反推子卷归属信息不是那么一目了然的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="back-reference"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id60"&gt;反向引用（back reference）&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;单纯从区块的引用计数难以看出整个文件系统所有子卷中有多少副本。
也就是说单有引用计数的一个数字还不够，需要记录具体反向的从区块往引用源头指的引用，这种结构在
btrfs 中叫做「反向引用（back reference，简称 backref）」。所以在上图中每一个指向 EXTENT_TREE
的单向箭头，在 btrfs 中都有记录一条反向引用，通过反向引用记录能反过来从被指针指向的位置找回到记录指针的地方。&lt;/p&gt;
&lt;p&gt;反向引用（backref）是 btrfs 中非常关键的机制，在 btrfs kernel wiki 专门有一篇页面
&lt;a class="reference external" href="https://btrfs.wiki.kernel.org/index.php/Resolving_Extent_Backrefs"&gt;Resolving Extent Backrefs&lt;/a&gt;
解释它的原理和实现方式。&lt;/p&gt;
&lt;p&gt;对上面的引用计数的例子画出反向引用的指针大概是这样：&lt;/p&gt;
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;

&lt;!-- Generated by graphviz version 2.40.1 (20161225.0304)
 --&gt;
&lt;!-- Title: btrfs_reflink_backref Pages: 1 --&gt;
&lt;svg class="svg-responsive" height="546pt" viewbox="0.00 0.00 890.00 546.46" width="890pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
&lt;g class="graph" id="graph0" transform="scale(1 1) rotate(0) translate(4 542.4604)"&gt;
&lt;title&gt;btrfs_reflink_backref&lt;/title&gt;
&lt;polygon fill="#ffffff" points="-4,4 -4,-542.4604 886,-542.4604 886,4 -4,4" stroke="transparent"&gt;&lt;/polygon&gt;
&lt;!-- root --&gt;
&lt;g class="node" id="node1"&gt;
&lt;title&gt;root&lt;/title&gt;
&lt;polygon fill="none" points="0,-299 0,-391 110,-391 110,-299 0,-299" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="55" y="-375.8"&gt;ROOT_TREE&lt;/text&gt;
&lt;polyline fill="none" points="0,-368 110,-368 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="55" y="-352.8"&gt;sn1&lt;/text&gt;
&lt;polyline fill="none" points="0,-345 110,-345 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="55" y="-329.8"&gt;sn2&lt;/text&gt;
&lt;polyline fill="none" points="0,-322 110,-322 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="55" y="-306.8"&gt;fs&lt;/text&gt;
&lt;/g&gt;
&lt;!-- sn1 --&gt;
&lt;g class="node" id="node2"&gt;
&lt;title&gt;sn1&lt;/title&gt;
&lt;polygon fill="none" points="182,-343 182,-389 297,-389 297,-343 182,-343" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-373.8"&gt;FS_TREE sn1&lt;/text&gt;
&lt;polyline fill="none" points="182,-366 297,-366 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-350.8"&gt;leaf_node&lt;/text&gt;
&lt;/g&gt;
&lt;!-- root&amp;#45;&amp;gt;sn1 --&gt;
&lt;g class="edge" id="edge1"&gt;
&lt;title&gt;root:sn1-&amp;gt;sn1:label&lt;/title&gt;
&lt;path d="M110,-357C139.6875,-357 147.165,-373.6575 171.9941,-377.3013" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="171.7804,-380.7948 182,-378 172.2681,-373.8118 171.7804,-380.7948" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- sn2 --&gt;
&lt;g class="node" id="node3"&gt;
&lt;title&gt;sn2&lt;/title&gt;
&lt;polygon fill="none" points="182,-278 182,-324 297,-324 297,-278 182,-278" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-308.8"&gt;FS_TREE sn2&lt;/text&gt;
&lt;polyline fill="none" points="182,-301 297,-301 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-285.8"&gt;leaf_node&lt;/text&gt;
&lt;/g&gt;
&lt;!-- root&amp;#45;&amp;gt;sn2 --&gt;
&lt;g class="edge" id="edge2"&gt;
&lt;title&gt;root:sn2-&amp;gt;sn2:label&lt;/title&gt;
&lt;path d="M110,-333C139.5791,-333 147.2379,-317.1357 172.0219,-313.6654" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="172.2551,-317.1578 182,-313 171.7892,-310.1733 172.2551,-317.1578" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- fs --&gt;
&lt;g class="node" id="node4"&gt;
&lt;title&gt;fs&lt;/title&gt;
&lt;polygon fill="none" points="188.5,-213 188.5,-259 290.5,-259 290.5,-213 188.5,-213" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-243.8"&gt;FS_TREE fs&lt;/text&gt;
&lt;polyline fill="none" points="188.5,-236 290.5,-236 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-220.8"&gt;leaf_node&lt;/text&gt;
&lt;/g&gt;
&lt;!-- root&amp;#45;&amp;gt;fs --&gt;
&lt;g class="edge" id="edge3"&gt;
&lt;title&gt;root:fs-&amp;gt;fs:label&lt;/title&gt;
&lt;path d="M110,-310C150.6377,-310 145.4268,-258.1984 178.1842,-249.295" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="179.0138,-252.7184 188.5,-248 178.1419,-245.7729 179.0138,-252.7184" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent --&gt;
&lt;g class="node" id="node7"&gt;
&lt;title&gt;extent&lt;/title&gt;
&lt;polygon fill="none" points="599,-.5 599,-529.5 882,-529.5 882,-.5 599,-.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-514.3"&gt;EXTENT_TREE extent_tree&lt;/text&gt;
&lt;polyline fill="none" points="599,-506.5 882,-506.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-491.3"&gt;root_tree : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-483.5 882,-483.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-468.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="599,-460.5 882,-460.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-445.3"&gt;sn1 fs_tree : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-437.5 882,-437.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-422.3"&gt;backref ROOT_TREE sn1&lt;/text&gt;
&lt;polyline fill="none" points="599,-414.5 882,-414.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-399.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="599,-391.5 882,-391.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-376.3"&gt;sn2 fs_tree : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-368.5 882,-368.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-353.3"&gt;backref ROOT_TREE sn2&lt;/text&gt;
&lt;polyline fill="none" points="599,-345.5 882,-345.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-330.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="599,-322.5 882,-322.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-307.3"&gt;sn1 sn2 leaf_node: ref 2&lt;/text&gt;
&lt;polyline fill="none" points="599,-299.5 882,-299.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-284.3"&gt;backref sn1 FS_TREE node&lt;/text&gt;
&lt;polyline fill="none" points="599,-276.5 882,-276.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-261.3"&gt;backref sn2 FS_TREE node&lt;/text&gt;
&lt;polyline fill="none" points="599,-253.5 882,-253.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-238.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="599,-230.5 882,-230.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-215.3"&gt;fs fs_tree : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-207.5 882,-207.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-192.3"&gt;backref ROOT_TREE fs&lt;/text&gt;
&lt;polyline fill="none" points="599,-184.5 882,-184.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-169.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="599,-161.5 882,-161.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-146.3"&gt;fs leaf_node : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-138.5 882,-138.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-123.3"&gt;backref fs FS_TREE node&lt;/text&gt;
&lt;polyline fill="none" points="599,-115.5 882,-115.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-100.3"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="599,-92.5 882,-92.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-77.3"&gt;file1 : ref 3&lt;/text&gt;
&lt;polyline fill="none" points="599,-69.5 882,-69.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-54.3"&gt;backref sn1 FS_TREE leaf_node file1&lt;/text&gt;
&lt;polyline fill="none" points="599,-46.5 882,-46.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-31.3"&gt;backref sn1 FS_TREE leaf_node file2&lt;/text&gt;
&lt;polyline fill="none" points="599,-23.5 882,-23.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-8.3"&gt;backref fs FS_TREE leaf_node file1&lt;/text&gt;
&lt;/g&gt;
&lt;!-- root&amp;#45;&amp;gt;extent --&gt;
&lt;!-- snleaf --&gt;
&lt;g class="node" id="node5"&gt;
&lt;title&gt;snleaf&lt;/title&gt;
&lt;polygon fill="none" points="369,-92.5 369,-161.5 527,-161.5 527,-92.5 369,-92.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-146.3"&gt;FS_TREE leaf_node&lt;/text&gt;
&lt;polyline fill="none" points="369,-138.5 527,-138.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-123.3"&gt;file1&lt;/text&gt;
&lt;polyline fill="none" points="369,-115.5 527,-115.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-100.3"&gt;file2&lt;/text&gt;
&lt;/g&gt;
&lt;!-- sn1&amp;#45;&amp;gt;snleaf --&gt;
&lt;g class="edge" id="edge4"&gt;
&lt;title&gt;sn1:leaf-&amp;gt;snleaf:label&lt;/title&gt;
&lt;path d="M297,-354C389.3923,-354 281.9198,-165.6262 358.6977,-150.9095" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="359.3466,-154.3659 369,-150 358.7309,-147.3931 359.3466,-154.3659" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- sn1&amp;#45;&amp;gt;extent --&gt;
&lt;!-- sn2&amp;#45;&amp;gt;snleaf --&gt;
&lt;g class="edge" id="edge5"&gt;
&lt;title&gt;sn2:leaf-&amp;gt;snleaf:label&lt;/title&gt;
&lt;path d="M297,-289C362.7688,-289 306.3617,-164.7874 358.7675,-151.2017" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="359.4765,-154.6425 369,-150 358.66,-147.6903 359.4765,-154.6425" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- sn2&amp;#45;&amp;gt;extent --&gt;
&lt;!-- fsleaf --&gt;
&lt;g class="node" id="node6"&gt;
&lt;title&gt;fsleaf&lt;/title&gt;
&lt;polygon fill="none" points="369,-27 369,-73 527,-73 527,-27 369,-27" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-57.8"&gt;FS_TREE leaf_node&lt;/text&gt;
&lt;polyline fill="none" points="369,-50 527,-50 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-34.8"&gt;file1&lt;/text&gt;
&lt;/g&gt;
&lt;!-- fs&amp;#45;&amp;gt;fsleaf --&gt;
&lt;g class="edge" id="edge6"&gt;
&lt;title&gt;fs:leaf-&amp;gt;fsleaf:label&lt;/title&gt;
&lt;path d="M290.5,-224C366.7574,-224 296.2794,-76.8315 358.7804,-63.0345" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="359.4034,-66.4894 369,-62 358.6983,-59.525 359.4034,-66.4894" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- fs&amp;#45;&amp;gt;extent --&gt;
&lt;!-- snleaf&amp;#45;&amp;gt;extent --&gt;
&lt;!-- snleaf&amp;#45;&amp;gt;extent --&gt;
&lt;!-- snleaf&amp;#45;&amp;gt;extent --&gt;
&lt;!-- fsleaf&amp;#45;&amp;gt;extent --&gt;
&lt;!-- fsleaf&amp;#45;&amp;gt;extent --&gt;
&lt;!-- extent&amp;#45;&amp;gt;root --&gt;
&lt;g class="edge" id="edge7"&gt;
&lt;title&gt;extent:br1-&amp;gt;root:label&lt;/title&gt;
&lt;path d="M599,-426C561.4977,-426 563.1005,-459.8426 527,-470 379.398,-511.5302 320.1998,-536.4223 182,-470 139.2574,-449.4568 157.8497,-389.8142 120.2,-381.0742" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="120.3116,-377.5667 110,-380 119.5784,-384.5282 120.3116,-377.5667" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;root --&gt;
&lt;g class="edge" id="edge8"&gt;
&lt;title&gt;extent:br2-&amp;gt;root:label&lt;/title&gt;
&lt;path d="M599,-357C554.3693,-357 568.1678,-409.7629 527,-427 470.5865,-450.6205 230.539,-447.6953 182,-432 147.9627,-420.9939 148.904,-387.2293 120.0001,-380.9952" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="120.2975,-377.5076 110,-380 119.6042,-384.4732 120.2975,-377.5076" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;root --&gt;
&lt;g class="edge" id="edge11"&gt;
&lt;title&gt;extent:br5-&amp;gt;root:label&lt;/title&gt;
&lt;path d="M599,-196C437.2729,-196 451.6981,-351.8392 297,-399 248.1103,-413.9044 232.6864,-405.5752 182,-399 152.8975,-395.2247 144.817,-383.2055 120.2855,-380.5309" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="120.1671,-377.0202 110,-380 119.8063,-384.0109 120.1671,-377.0202" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;sn1 --&gt;
&lt;g class="edge" id="edge9"&gt;
&lt;title&gt;extent:br3-&amp;gt;sn1:label&lt;/title&gt;
&lt;path d="M599,-288C532.2547,-288 382.0082,-369.7603 307.4346,-377.4253" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="306.7924,-373.9553 297,-378 307.1774,-380.9447 306.7924,-373.9553" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;sn2 --&gt;
&lt;g class="edge" id="edge10"&gt;
&lt;title&gt;extent:br4-&amp;gt;sn2:label&lt;/title&gt;
&lt;path d="M599,-265C466.5438,-265 434.5081,-310.5934 307.1513,-312.9087" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="306.9681,-309.4101 297,-313 307.0311,-316.4099 306.9681,-309.4101" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;fs --&gt;
&lt;g class="edge" id="edge12"&gt;
&lt;title&gt;extent:br6-&amp;gt;fs:label&lt;/title&gt;
&lt;path d="M599,-127C561.4977,-127 561.4368,-156.1499 527,-171 460.1724,-199.8178 437.6774,-189.9207 369,-214 336.6245,-225.3513 329.7175,-243.9007 300.743,-247.4153" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="300.2843,-243.9357 290.5,-248 300.6832,-250.9244 300.2843,-243.9357" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;snleaf --&gt;
&lt;g class="edge" id="edge13"&gt;
&lt;title&gt;extent:br7-&amp;gt;snleaf:label&lt;/title&gt;
&lt;path d="M599,-58C550.9315,-58 574.6566,-136.8505 537.245,-148.5549" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="536.4131,-145.1375 527,-150 537.3909,-152.0689 536.4131,-145.1375" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;snleaf --&gt;
&lt;g class="edge" id="edge14"&gt;
&lt;title&gt;extent:br8-&amp;gt;snleaf:label&lt;/title&gt;
&lt;path d="M599,-35C542.4668,-35 581.652,-136.0742 537.0836,-148.7085" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="536.4743,-145.2579 527,-150 537.3637,-152.2011 536.4743,-145.2579" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;fsleaf --&gt;
&lt;g class="edge" id="edge15"&gt;
&lt;title&gt;extent:br9-&amp;gt;fsleaf:label&lt;/title&gt;
&lt;path d="M599,-12C563.8453,-12 565.2313,-52.7112 537.2135,-60.6626" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="536.4609,-57.2312 527,-62 537.3698,-64.1719 536.4609,-57.2312" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;/svg&gt;
&lt;p&gt;EXTENT_TREE 中每个 extent 记录都同时记录了引用到这个区块的反向引用列表。反向引用有两种记录方式：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;普通反向引用（Normal back references）。记录这个指针来源所在是哪颗B树、 B树中的对象 id 和对象偏移。&lt;ul&gt;
&lt;li&gt;对文件区块而言，就是记录文件所在子卷、inode、和文件内容的偏移。&lt;/li&gt;
&lt;li&gt;对子卷的树节点区块而言，就是记录该区块的上级树节点在哪个B树的哪个位置开始。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享反向引用（Shared back references）。记录这个指针来源区块的逻辑地址。&lt;ul&gt;
&lt;li&gt;无论对文件区块而言，还是对子卷的树节点区块而言，都是直接记录了保存这个区块指针的上层树节点的逻辑地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有两种记录方式是因为它们各有性能上的优缺点：&lt;/p&gt;
&lt;table border="0" class="docutils table field-list" frame="void" rules="none"&gt;
&lt;col class="field-name"/&gt;
&lt;col class="field-body"/&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;普通反向引用:&lt;/th&gt;&lt;td class="field-body"&gt;因为通过对象编号记录，所以当树节点 CoW 改变了地址时不需要调整地址，
从而在普通的读写和快照之类的操作下有更好的性能，
但是在解析反向引用时需要额外一次树查找。
同时因为这个额外查找，普通反向引用也叫间接反向引用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;共享反向引用:&lt;/th&gt;&lt;td class="field-body"&gt;因为直接记录了逻辑地址，所以当这个地址的节点被 CoW 的时候也需要调整这里记录的地址。
在普通的读写和快照操作下，调整地址会增加写入从而影响性能，但是在解析反向引用时更快。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;通常通过普通写入、快照、 reflink 等方式创建出来的引用是普通反向引用，
由于普通反向引用记录了包含它的B树，从而可以说绑在了某棵树比如某个子卷上，
当这个普通反向引用指向的对象不再存在，而这个反向引用还在通过别的途径共享时，
这个普通反向引用会转换共享反向引用；共享反向引用在存在期间不会变回普通反向引用。&lt;/p&gt;
&lt;p&gt;比如上图反向引用的例子中，我们先假设所有画出的反向引用都是普通反向引用，于是图中标为 file1
引用数为 3 的那个区块有 3 条反向引用记录，其中前两条都指向 sn1 里面的文件，分别是 sn1/file1
和 sn1/file2 ，然后 sn1 和 sn2 共享了 FS_TREE 的叶子节点。&lt;/p&gt;
&lt;p&gt;假设这时我们删除 sn1/file2，执行了代码 &lt;code class="code"&gt;
rm sn1/​file2&lt;/code&gt;
 之后：&lt;/p&gt;
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;

&lt;!-- Generated by graphviz version 2.40.1 (20161225.0304)
 --&gt;
&lt;!-- Title: btrfs_reflink_shared_backref Pages: 1 --&gt;
&lt;svg class="svg-responsive" height="614pt" viewbox="0.00 0.00 890.00 613.50" width="890pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
&lt;g class="graph" id="graph0" transform="scale(1 1) rotate(0) translate(4 609.5)"&gt;
&lt;title&gt;btrfs_reflink_shared_backref&lt;/title&gt;
&lt;polygon fill="#ffffff" points="-4,4 -4,-609.5 886,-609.5 886,4 -4,4" stroke="transparent"&gt;&lt;/polygon&gt;
&lt;!-- root --&gt;
&lt;g class="node" id="node1"&gt;
&lt;title&gt;root&lt;/title&gt;
&lt;polygon fill="none" points="0,-375.5 0,-467.5 110,-467.5 110,-375.5 0,-375.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="55" y="-452.3"&gt;ROOT_TREE&lt;/text&gt;
&lt;polyline fill="none" points="0,-444.5 110,-444.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="55" y="-429.3"&gt;sn1&lt;/text&gt;
&lt;polyline fill="none" points="0,-421.5 110,-421.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="55" y="-406.3"&gt;sn2&lt;/text&gt;
&lt;polyline fill="none" points="0,-398.5 110,-398.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="55" y="-383.3"&gt;fs&lt;/text&gt;
&lt;/g&gt;
&lt;!-- sn1 --&gt;
&lt;g class="node" id="node2"&gt;
&lt;title&gt;sn1&lt;/title&gt;
&lt;polygon fill="none" points="182,-419.5 182,-465.5 297,-465.5 297,-419.5 182,-419.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-450.3"&gt;FS_TREE sn1&lt;/text&gt;
&lt;polyline fill="none" points="182,-442.5 297,-442.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-427.3"&gt;leaf_node&lt;/text&gt;
&lt;/g&gt;
&lt;!-- root&amp;#45;&amp;gt;sn1 --&gt;
&lt;g class="edge" id="edge1"&gt;
&lt;title&gt;root:sn1-&amp;gt;sn1:label&lt;/title&gt;
&lt;path d="M110,-433.5C139.6875,-433.5 147.165,-450.1575 171.9941,-453.8013" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="171.7804,-457.2948 182,-454.5 172.2681,-450.3118 171.7804,-457.2948" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- sn2 --&gt;
&lt;g class="node" id="node3"&gt;
&lt;title&gt;sn2&lt;/title&gt;
&lt;polygon fill="none" points="182,-354.5 182,-400.5 297,-400.5 297,-354.5 182,-354.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-385.3"&gt;FS_TREE sn2&lt;/text&gt;
&lt;polyline fill="none" points="182,-377.5 297,-377.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-362.3"&gt;leaf_node&lt;/text&gt;
&lt;/g&gt;
&lt;!-- root&amp;#45;&amp;gt;sn2 --&gt;
&lt;g class="edge" id="edge2"&gt;
&lt;title&gt;root:sn2-&amp;gt;sn2:label&lt;/title&gt;
&lt;path d="M110,-409.5C139.5791,-409.5 147.2379,-393.6357 172.0219,-390.1654" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="172.2551,-393.6578 182,-389.5 171.7892,-386.6733 172.2551,-393.6578" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- fs --&gt;
&lt;g class="node" id="node4"&gt;
&lt;title&gt;fs&lt;/title&gt;
&lt;polygon fill="none" points="188.5,-250.5 188.5,-296.5 290.5,-296.5 290.5,-250.5 188.5,-250.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-281.3"&gt;FS_TREE fs&lt;/text&gt;
&lt;polyline fill="none" points="188.5,-273.5 290.5,-273.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="239.5" y="-258.3"&gt;leaf_node&lt;/text&gt;
&lt;/g&gt;
&lt;!-- root&amp;#45;&amp;gt;fs --&gt;
&lt;g class="edge" id="edge3"&gt;
&lt;title&gt;root:fs-&amp;gt;fs:label&lt;/title&gt;
&lt;path d="M110,-386.5C163.0775,-386.5 135.9169,-298.4687 178.3378,-286.777" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="179.0145,-290.2196 188.5,-285.5 178.1416,-283.2742 179.0145,-290.2196" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent --&gt;
&lt;g class="node" id="node8"&gt;
&lt;title&gt;extent&lt;/title&gt;
&lt;polygon fill="none" points="599,-30 599,-605 882,-605 882,-30 599,-30" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-589.8"&gt;EXTENT_TREE extent_tree&lt;/text&gt;
&lt;polyline fill="none" points="599,-582 882,-582 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-566.8"&gt;root_tree : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-559 882,-559 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-543.8"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="599,-536 882,-536 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-520.8"&gt;sn1 fs_tree : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-513 882,-513 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-497.8"&gt;backref ROOT_TREE sn1&lt;/text&gt;
&lt;polyline fill="none" points="599,-490 882,-490 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-474.8"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="599,-467 882,-467 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-451.8"&gt;sn2 fs_tree : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-444 882,-444 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-428.8"&gt;backref ROOT_TREE sn2&lt;/text&gt;
&lt;polyline fill="none" points="599,-421 882,-421 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-405.8"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="599,-398 882,-398 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-382.8"&gt;sn1 sn2 leaf_node: ref 2&lt;/text&gt;
&lt;polyline fill="none" points="599,-375 882,-375 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-359.8"&gt;backref sn1 FS_TREE node&lt;/text&gt;
&lt;polyline fill="none" points="599,-352 882,-352 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-336.8"&gt;backref sn2 FS_TREE node&lt;/text&gt;
&lt;polyline fill="none" points="599,-329 882,-329 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-313.8"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="599,-306 882,-306 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-290.8"&gt;fs fs_tree : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-283 882,-283 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-267.8"&gt;backref ROOT_TREE fs&lt;/text&gt;
&lt;polyline fill="none" points="599,-260 882,-260 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-244.8"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="599,-237 882,-237 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-221.8"&gt;fs leaf_node : ref 1&lt;/text&gt;
&lt;polyline fill="none" points="599,-214 882,-214 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-198.8"&gt;backref fs FS_TREE node&lt;/text&gt;
&lt;polyline fill="none" points="599,-191 882,-191 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-175.8"&gt; &lt;/text&gt;
&lt;polyline fill="none" points="599,-168 882,-168 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-152.8"&gt;file1 : ref 4&lt;/text&gt;
&lt;polyline fill="none" points="599,-145 882,-145 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-129.8"&gt;backref FS_TREE leaf_node file1&lt;/text&gt;
&lt;polyline fill="none" points="599,-122 882,-122 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-106.8"&gt;backref FS_TREE leaf_node file2&lt;/text&gt;
&lt;polyline fill="none" points="599,-99 882,-99 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-83.8"&gt;backref fs FS_TREE leaf_node file1&lt;/text&gt;
&lt;polyline fill="none" points="599,-76 882,-76 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-60.8"&gt;backref sn1 FS_TREE leaf_node file1&lt;/text&gt;
&lt;polyline fill="none" points="599,-53 882,-53 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="740.5" y="-37.8"&gt; &lt;/text&gt;
&lt;/g&gt;
&lt;!-- root&amp;#45;&amp;gt;extent --&gt;
&lt;!-- sn1leaf --&gt;
&lt;g class="node" id="node5"&gt;
&lt;title&gt;sn1leaf&lt;/title&gt;
&lt;polygon fill="none" points="369,-.5 369,-46.5 527,-46.5 527,-.5 369,-.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-31.3"&gt;FS_TREE leaf_node&lt;/text&gt;
&lt;polyline fill="none" points="369,-23.5 527,-23.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-8.3"&gt;file1&lt;/text&gt;
&lt;/g&gt;
&lt;!-- sn1&amp;#45;&amp;gt;sn1leaf --&gt;
&lt;g class="edge" id="edge4"&gt;
&lt;title&gt;sn1:leaf-&amp;gt;sn1leaf:label&lt;/title&gt;
&lt;path d="M297,-430.5C471.7886,-430.5 202.0422,-51.535 358.5979,-35.9916" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="359.1764,-39.4682 369,-35.5 358.8459,-32.476 359.1764,-39.4682" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- sn1&amp;#45;&amp;gt;extent --&gt;
&lt;!-- snleaf --&gt;
&lt;g class="node" id="node6"&gt;
&lt;title&gt;snleaf&lt;/title&gt;
&lt;polygon fill="none" points="369,-131 369,-200 527,-200 527,-131 369,-131" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-184.8"&gt;FS_TREE leaf_node&lt;/text&gt;
&lt;polyline fill="none" points="369,-177 527,-177 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-161.8"&gt;file1&lt;/text&gt;
&lt;polyline fill="none" points="369,-154 527,-154 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-138.8"&gt;file2&lt;/text&gt;
&lt;/g&gt;
&lt;!-- sn2&amp;#45;&amp;gt;snleaf --&gt;
&lt;g class="edge" id="edge5"&gt;
&lt;title&gt;sn2:leaf-&amp;gt;snleaf:label&lt;/title&gt;
&lt;path d="M297,-365.5C378.2769,-365.5 292.1456,-203.3841 359.0359,-189.4523" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="359.3784,-192.9356 369,-188.5 358.7123,-185.9674 359.3784,-192.9356" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- sn2&amp;#45;&amp;gt;extent --&gt;
&lt;!-- fsleaf --&gt;
&lt;g class="node" id="node7"&gt;
&lt;title&gt;fsleaf&lt;/title&gt;
&lt;polygon fill="none" points="369,-65.5 369,-111.5 527,-111.5 527,-65.5 369,-65.5" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-96.3"&gt;FS_TREE leaf_node&lt;/text&gt;
&lt;polyline fill="none" points="369,-88.5 527,-88.5 " stroke="#000000"&gt;&lt;/polyline&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="448" y="-73.3"&gt;file1&lt;/text&gt;
&lt;/g&gt;
&lt;!-- fs&amp;#45;&amp;gt;fsleaf --&gt;
&lt;g class="edge" id="edge6"&gt;
&lt;title&gt;fs:leaf-&amp;gt;fsleaf:label&lt;/title&gt;
&lt;path d="M290.5,-261.5C366.3764,-261.5 296.6069,-115.24 358.8289,-101.5281" fill="none" stroke="#000000" stroke-width="2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="359.4027,-104.988 369,-100.5 358.6987,-98.0235 359.4027,-104.988" stroke="#000000" stroke-width="2"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- fs&amp;#45;&amp;gt;extent --&gt;
&lt;!-- snleaf&amp;#45;&amp;gt;extent --&gt;
&lt;!-- snleaf&amp;#45;&amp;gt;extent --&gt;
&lt;!-- snleaf&amp;#45;&amp;gt;extent --&gt;
&lt;!-- fsleaf&amp;#45;&amp;gt;extent --&gt;
&lt;!-- fsleaf&amp;#45;&amp;gt;extent --&gt;
&lt;!-- extent&amp;#45;&amp;gt;root --&gt;
&lt;g class="edge" id="edge7"&gt;
&lt;title&gt;extent:br1-&amp;gt;root:label&lt;/title&gt;
&lt;path d="M599,-501.5C464.7417,-501.5 431.2493,-506.9443 297,-508.5 245.8923,-509.0922 230.6319,-524.2253 182,-508.5 147.9627,-497.4939 148.904,-463.7293 120.0001,-457.4952" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="120.2975,-454.0076 110,-456.5 119.6042,-460.9732 120.2975,-454.0076" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;root --&gt;
&lt;g class="edge" id="edge8"&gt;
&lt;title&gt;extent:br2-&amp;gt;root:label&lt;/title&gt;
&lt;path d="M599,-432.5C412.6839,-432.5 366.7679,-499.4688 182,-475.5 152.8975,-471.7247 144.817,-459.7055 120.2855,-457.0309" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="120.1671,-453.5202 110,-456.5 119.8063,-460.5109 120.1671,-453.5202" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;root --&gt;
&lt;g class="edge" id="edge11"&gt;
&lt;title&gt;extent:br5-&amp;gt;root:label&lt;/title&gt;
&lt;path d="M599,-271.5C551.9428,-271.5 221.2192,-319.4954 182,-345.5 136.0546,-375.9645 164.6578,-446.8667 119.9606,-455.6104" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="119.649,-452.1242 110,-456.5 120.2717,-459.0965 119.649,-452.1242" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;sn1 --&gt;
&lt;g class="edge" id="edge9"&gt;
&lt;title&gt;extent:br3-&amp;gt;sn1:label&lt;/title&gt;
&lt;path d="M599,-363.5C547.0832,-363.5 416.9848,-384.6803 369,-404.5 336.5079,-417.9206 335.7513,-447.8324 307.2897,-453.5466" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="306.6344,-450.0922 297,-454.5 307.2803,-457.0624 306.6344,-450.0922" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;sn2 --&gt;
&lt;g class="edge" id="edge10"&gt;
&lt;title&gt;extent:br4-&amp;gt;sn2:label&lt;/title&gt;
&lt;path d="M599,-340.5C496.1267,-340.5 469.5943,-344.9663 369,-366.5 339.744,-372.7627 332.1354,-386.1139 307.089,-388.9595" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="306.7984,-385.47 297,-389.5 307.1729,-392.4599 306.7984,-385.47" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;fs --&gt;
&lt;g class="edge" id="edge12"&gt;
&lt;title&gt;extent:br6-&amp;gt;fs:label&lt;/title&gt;
&lt;path d="M599,-202.5C546.6951,-202.5 418.875,-236.743 369,-252.5 336.4361,-262.7879 329.5387,-281.3788 300.696,-284.9117" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="300.2817,-281.4297 290.5,-285.5 300.685,-288.418 300.2817,-281.4297" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;sn1leaf --&gt;
&lt;g class="edge" id="edge16"&gt;
&lt;title&gt;extent:br10-&amp;gt;sn1leaf:label&lt;/title&gt;
&lt;path d="M599,-64.5C568.2751,-64.5 562.532,-41.4968 537.2718,-36.4649" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="537.2835,-32.9507 527,-35.5 536.6288,-39.92 537.2835,-32.9507" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;snleaf --&gt;
&lt;g class="edge" id="edge13"&gt;
&lt;title&gt;extent:br7-&amp;gt;snleaf:label&lt;/title&gt;
&lt;path d="M599,-133.5C562.5069,-133.5 566.0966,-178.6709 537.119,-187.1404" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="536.4449,-183.6995 527,-188.5 537.377,-190.6371 536.4449,-183.6995" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;snleaf --&gt;
&lt;g class="edge" id="edge14"&gt;
&lt;title&gt;extent:br8-&amp;gt;snleaf:label&lt;/title&gt;
&lt;path d="M599,-110.5C555.6919,-110.5 570.9782,-176.228 537.2833,-187.0115" fill="none" stroke="#000000" stroke-dasharray="5,2"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="536.3954,-183.6035 527,-188.5 537.3983,-190.5313 536.3954,-183.6035" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- extent&amp;#45;&amp;gt;fsleaf --&gt;
&lt;g class="edge" id="edge15"&gt;
&lt;title&gt;extent:br9-&amp;gt;fsleaf:label&lt;/title&gt;
&lt;path d="M599,-87.5C570.1662,-87.5 561.4234,-97.7215 537.1414,-100.0373" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="536.8301,-96.5478 527,-100.5 537.1492,-103.5405 536.8301,-96.5478" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;/svg&gt;
&lt;p&gt;那么 sn1 会 CoW 那个和 sn2 共享的叶子节点，有了新的属于 sn1 的叶子，从而断开了原本 file1
中对这个共享叶子节点的两个普通反向引用，转化成共享反向引用（图中用虚线箭头描述），
并且插入了一个新的普通反向引用指向新的 sn1 的叶子节点。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="backref-walking"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id61"&gt;遍历反向引用(backref walking)&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;有了反向引用记录之后，可以给定一个逻辑地址，从 EXTENT_TREE 中找到地址的区块记录，
然后从区块记录中的反向引用记录一步步往回遍历，直到遇到 ROOT_TREE
，最终确定这个逻辑地址的区块在整个文件系统中有多少路径能访问它。
这个遍历反向引用的操作，在 btrfs 文档和代码中被称作 backref walking 。&lt;/p&gt;
&lt;p&gt;比如还是上面的反向引用图例中 sn1 和 sn2 完全共享叶子节点的那个例子，通过 backref walking
，我们能从 file1 所记录的 3 个反向引用，推出全部 5 个可能的访问路径。&lt;/p&gt;
&lt;p&gt;backref walking 作为很多功能的基础设施，从 btrfs 相当早期（3.3内核）就有，很多 btrfs
的功能实际依赖 backref walking 的正确性。列举一些需要 backref walking 来实现的功能：&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;qgroup&lt;/p&gt;
&lt;p&gt;btrfs 的子卷没有记录子卷的磁盘占用开销，靠引用计数来删除子卷，
所以也不需要详细统计子卷的空间占用情况。不过对一些用户的使用场景，可能需要统计子卷空间占用。由于
可能存在的共享元数据和数据，子卷占用不能靠累计加减法的方式算出来，所以 btrfs 有了
qgroup 和 quota 功能，用来统计子卷或者别的管理粒度下的占用空间情况。为了实现 qgroup
，需要 backref walking 来计算区块共享的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;send&lt;/p&gt;
&lt;p&gt;btrfs send 在计算子卷间的差异时，也通过 backref walking 寻找能靠 reflink
共享的区块，从而避免传输数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;balance/scrub&lt;/p&gt;
&lt;p&gt;balance 和 scrub 都会调整区块的地址，通过 backref walking
能找到所有引用到这个地址的位置并正确修改地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;check&lt;/p&gt;
&lt;p&gt;当需要打印诊断信息的时候，除了提供出错的数据所在具体地址之外，通过 backref walking
也能提供受影响的文件路径之类的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
btrfs 的 reflink-aware defrag&lt;/div&gt;
&lt;div class="panel-body"&gt;
这里想提一下 btrfs 一直计划中，但是还没有成功实现的 reflink-aware defrag
。文件碎片一直是 CoW 文件系统的大问题，对 btrfs 和对 ZFS 都是同样。ZFS 完全不支持碎片整理，
而 btrfs 目前只提供了文件级别的碎片整理，这会切断现有的 reflink 。计划中的
reflink-aware defrag 也是基于 backref walking ，根据区块引用的碎片程度，整理碎片而某种程度上保持
reflink 。btrfs 曾经实现了这个，但是因为 bug 太多不久就取消了相关功能，目前这个工作处于停滞阶段。&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可见 backref walking 的能力对 btrfs 的许多功能都非常重要（不像 ZPL 的
&lt;a class="reference external" href="https://utcc.utoronto.ca/~cks/space/blog/solaris/ZFSPathLookupTrick"&gt;dnode 中记录的 parent dnode 那样只用于诊断信息&lt;/a&gt;
）。不过 backref walking
根据区块共享的情况的不同，也可能导致挺大的运行期开销，包括算法时间上的和内存占用方面的开销。
比如某个子卷中有 100 个文件通过 reflink 共享了同一个区块，然后对这个子卷做了 100 个快照，
那么对这一个共享区块的 backref walking 结果可能解析出 10000 个路径。可见随着使用 reflink
和快照， backref walking 的开销可能爆炸式增长。最近 btrfs 邮件列表也有一些用户汇报，在大量子卷
和通过 reflink 做过 dedup 的 btrfs 文件系统上 send 快照时，可能导致内核分配大量内存甚至
panic 的情形，在 5.5 内核中 btrfs send 试图控制 send 时 clone reference
的数量上限来缓解这种边角问题。&lt;/p&gt;
&lt;p&gt;值得再强调的是，在没有开启 qgroup 的前提下，正常创建删除快照或 reflink
，正常写入和覆盖区块之类的文件系统操作，只需要引用计数就足够，虽然可能需要调整反向引用记录（
尤其是共享反向引用的地址），但是不需要动用 backref walking 这样的重型武器。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="zfs-vs-btrfs-dedup"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id62"&gt;4   ZFS vs btrfs 的 dedup 功能现状&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上面讨论 ZFS 的快照和克隆如何跟踪数据块时，故意避开了 ZFS 的 dedup 功能，因为要讲 dedup
可能需要先理解引用计数在文件系统中的作用，而 btrfs 正好用了引用计数。
于是我们再回来 ZFS 这边，看看 ZFS 的 dedup 是具体如何运作的。&lt;/p&gt;
&lt;p&gt;稍微了解过 btrfs 和 ZFS 两者的人，或许有不少 btrfs 用户都眼馋 ZFS 有 in-band dedup
的能力，可以在写入数据块的同时就去掉重复数据，而 btrfs 只能「退而求其次」地选择第三方 dedup
方案，用外部工具扫描已经写入的数据，将其中重复的部分改为 reflink 。又或许有不少 btrfs
用户以为 zfs 的 dedup 就是在内存和磁盘中维护一个类似
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Bloom_filter"&gt;Bloom filter&lt;/a&gt;
的结构，然后根据结果对数据块增加 reflink ，从而 zfs 内部大概一定有类似 reflink
的设施，进一步质疑为什么 btrfs 还迟迟没有实现这样一个 Bloom filter 。
或许还有从 btrfs 转移到 ZFS 的用户有疑惑，
&lt;a class="reference external" href="https://github.com/zfsonlinux/zfs/issues/405"&gt;为什么 ZFS 还没有暴露出 reflink 的用户空间接口&lt;/a&gt;
，或者既然 ZFS 已经有了 dedup ，
&lt;a class="reference external" href="https://github.com/zfsonlinux/zfs/issues/2554"&gt;能不能临时开关 dedup 来提供类似 reflink 式的共享数据块&lt;/a&gt;
而避免 ZFS 长期开 dedup 导致的巨大性能开销。&lt;/p&gt;
&lt;p&gt;看过上面 &lt;a class="reference internal" href="#id24"&gt;ZFS 中关于快照和克隆的空间跟踪算法&lt;/a&gt; 之后我们会发现，其实 ZFS 中并没有
能对应 btrfs reflink 的功能，而是根据数据块指针中的 birth txg
来跟踪快照和克隆的共享数据块的。这引来更多疑惑：&lt;/p&gt;
&lt;div class="section" id="zfs-dedup"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id63"&gt;4.1   ZFS 是如何实现 dedup 的？&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Dedup Performance by Matt Ahrens&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/PYxFDBgxFS8"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ZFS 是在 Sun/OpenSolaris 寿命相当晚期的 2009 年获得的 dedup 功能，就在 Oracle 收购 Sun
，OpenSolaris 分裂出 Illumos 从而 ZFS 分裂出 Oracle ZFS 和 OpenZFS 的时间点之前。因此
&lt;a class="reference external" href="https://utcc.utoronto.ca/~cks/space/blog/solaris/ZFSDedupBadDocumentation"&gt;关于 ZFS dedup 如何实现的文档相对匮乏&lt;/a&gt;
，大部分介绍 ZFS 的文档或者教程会讲到 ZFS dedup 的用法，但是对 dedup
的实现细节、性能影响、乃至使用场景之类的话题就很少提了（甚至很多教程讲了一堆用法之后说类似，
「我评估之后觉得我不需要开 dedup ，你可以自己评估一下」这样的建议）。&lt;/p&gt;
&lt;p&gt;OpenZFS Summit 2017 上 Matt 有个演讲，主要内容关于今后如何改进 dedup
性能的计划，其中讲到的计划还没有被具体实现，不过可以窥探一下 dedup 现在在 ZFS 中是如何工作的。
Chris 的博客也有两篇文章《
&lt;a class="reference external" href="https://utcc.utoronto.ca/~cks/space/blog/solaris/ZFSDedupStorage"&gt;What I can see about how ZFS deduplication seems to work on disk&lt;/a&gt;
》和《
&lt;a class="reference external" href="https://utcc.utoronto.ca/~cks/space/blog/solaris/ZFSDedupStorageII"&gt;An important addition to how ZFS deduplication works on the disk&lt;/a&gt;
》介绍了他对此的认识，在这里我也尝试来总结一下 ZFS dedup 特性如何工作。&lt;/p&gt;
&lt;p&gt;ZFS dedup 是存储池级别（pool-wide）开关的特性，所以大概在 MOS 之类的地方有存储一个特殊的数据结构，
叫 DeDup Table 简称 DDT 。DDT 目前是存储设备上的一个 hash table ，因为是存储池级别的元数据，
所以在 ZFS 中存储了三份完全一样的 DDT ，DDT 的内容是大概如下结构：&lt;/p&gt;
&lt;table border="0" class="docutils table borderless"&gt;
&lt;colgroup&gt;
&lt;col width="24%"/&gt;
&lt;col width="54%"/&gt;
&lt;col width="22%"/&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Checksum&lt;/th&gt;
&lt;th class="head"&gt;DVA(Data Virtual Address)&lt;/th&gt;
&lt;th class="head"&gt;Refcount&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;0x12345678&lt;/td&gt;
&lt;td&gt;vdev=1 addr=0x45671234&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0x5678efab&lt;/td&gt;
&lt;td&gt;vdev=2 addr=0x37165adb&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0x98765432&lt;/td&gt;
&lt;td&gt;vdev=1 addr=0xac71be12&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0xabcd1234&lt;/td&gt;
&lt;td&gt;vdev=0 addr=0xc1a2231d&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;... ...&lt;/td&gt;
&lt;td&gt;... ...&lt;/td&gt;
&lt;td&gt;... ...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;DDT 中对每个数据块存有3个东西：数据块的 checksum 、DVA （就是
&lt;a class="reference internal" href="#id18"&gt;ZFS 的块指针&lt;/a&gt; 中的 DVA）和引用计数。在存储池开启 dedup
特性之后，每次新写入一个数据块，都会先计算出数据块的 checksum ，然后查找 DDT
，存在的话增加 DDT 条目的引用计数，不存在的话插入 DDT 条目。每次释放一个数据块，同样需要查找
DDT 调整引用计数。&lt;/p&gt;
&lt;p&gt;除了 DDT 之外，文件系统中记录的块指针中也有个特殊标志位记录这个块是否经过了 DDT
。读取数据不需要经过 DDT ，但是子卷、克隆或者文件系统正常删除数据块的时候，
需要根据块指针中的标志位判断是否需要检查和调整 DDT 。&lt;/p&gt;
&lt;p&gt;从而关于 dedup 的实现可以得知以下一些特点：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;开启 dedup 之后，每个写入操作放大成 3+1 个随机位置的写入操作，每个删除操作变成 1 个写入操作。没有
dedup 时删除块并不需要立刻写入，只需要记录在内存中并在 MOS 提交的时候调整磁盘占用情况即可。&lt;/li&gt;
&lt;li&gt;只有开启 dedup 期间写入的数据块才会参与 dedup 。对已经有数据的存储池，后来开启的 dedup
不会影响已经写好的数据，从而即使后来新的写入与之前的写入有重复也得不到 dedup 效果。
DDT 中没有记录的数据块不会参与 dedup 。换句话说 DDT 中那些引用计数为 1
的记录也是必须存在的，否则这些数据块没有机会参与 dedup 。&lt;/li&gt;
&lt;li&gt;关闭 dedup 之后，只要 DDT 中还存有数据，那么对这些数据的删除操作仍然有性能影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从直觉上可以这样理解：在 ZFS 中每个数据块都有其「归属」，没有 dedup
的时候，数据块归属于某个数据集（文件系统、快照、克隆），
该数据集需要负责释放该数据块或者把从属信息转移到别的数据集（快照）上。
而在开启 dedup 期间，产生的写入的数据块实际归属于 DDT
而不是任何一个数据集，数据集需要查询和调整 DDT 中记录的引用计数来决定是否能释放数据块。&lt;/p&gt;
&lt;p&gt;乍看起来 DDT 貌似挺像 btrfs 的 EXTENT_TREE ，但是本质上 EXTENT_TREE 是根据区块地址排序的，
而 DDT 因为是个 hashtable 所以是根据 checksum 排序的。并且 EXTENT_TREE
中记录的区块可以是任意大小，而 DDT 中记录的数据块是固定大小的，所以碎片不严重的情况下 DDT 要比
EXTENT_TREE 多记录很多数据块。这些区别都非常影响操作 DDT 时的性能。&lt;/p&gt;
&lt;p&gt;DDT 本身是个 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#dmu"&gt;DMU&lt;/a&gt; 对象，所以对 DDT 的读写也是经过 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#dmu"&gt;DMU&lt;/a&gt; 的 CoW 读写，从而也经过 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#arc"&gt;ARC&lt;/a&gt;
的缓存。想要有比较合理的 dedup 性能，需要整个 DDT 都尽量保持在内存 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#arc"&gt;ARC&lt;/a&gt; 或者 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#l2arc"&gt;L2ARC&lt;/a&gt; 缓存中，
于是 dedup 特性也有了非常占用内存的特点。每个 DDT 表项需要大概 192 字节来描述一个（
默认 128KiB 大小的）数据块，由此可以估算一下平均每 2TiB 的数据需要 3GiB 的内存来支持 dedup 的功能。&lt;/p&gt;
&lt;p&gt;Matt 的视频中后面讲到优化 ZFS dedup 的一些思路，大体上未来 ZFS 可以做这些优化：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;DDT 在内存中仍然是 hashtable ，在存储介质上则换成类似 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#zil"&gt;ZIL&lt;/a&gt; 的日志结构，让 DDT
尽量保持在内存中，并且绕过 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#dmu"&gt;DMU&lt;/a&gt; 减少写入放大。&lt;/li&gt;
&lt;li&gt;给 DDT 表项瘦身，从192字节缩减到接近64字节。&lt;/li&gt;
&lt;li&gt;当遇到内存压力时，从 DDT 中随机剔除掉引用计数为 1 的表项。被剔除的表项没有了未来参与 dedup
的可能性，但是能减轻内存压力。剔除引用计数为 1 的表项仍然可以维持数据块的归属信息（
处理上当作是没有 dedup 的形式），但是引用计数更高的表项没法剔除。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些优化策略目的是想让 dedup 的性能损失能让更多使用场景接受。不过因为缺乏开发者意愿，
目前这些策略还只是计划，没有实现在 ZFS 的代码中。&lt;/p&gt;
&lt;p&gt;因为以上特点， ZFS 目前 dedup 特性的适用场景极为有限，只有在 IO 带宽、内存大小都非常充裕，
并且可以预见到很多重复的数据的时候适合。听说过的 ZFS dedup
的成功案例是，比如提供虚拟机服务的服务商，在宿主文件系统上用 ZFS 的 zvol
寄宿虚拟机的磁盘镜像，客户在虚拟机内使用其它文件系统。大部分客户可能用类似版本的操作系统，
从而宿主机整体来看有很多 dedup 的潜质。不过这种应用场景下，服务商很可能偏向选择 CephFS
这样的分布式文件系统提供虚拟机镜像存储，而不是 ZFS 这样局限在单系统上的本地文件系统。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="btrfs-dedup"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id64"&gt;4.2   btrfs 的 dedup&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;btrfs 目前没有内建的 dedup 支持，但是因为有 reflink 所以可以通过第三方工具在事后扫描文件块来实现
dedup 。这一点乍看像是某种将就之策，实际上了解了 ZFS dedup 的实现之后可以看出这个状况其实更灵活。&lt;/p&gt;
&lt;p&gt;在 btrfs 中实现 in-band dedup 本身不算很复杂，增加一个内存中的 bloom filter 然后按情况插入
reflink 的正常思路就够了。在
&lt;a class="reference external" href="https://btrfs.wiki.kernel.org/index.php/User_notes_on_dedupe"&gt;btrfs kernel wiki 中有篇笔记&lt;/a&gt;
提到已经有了实验性的 in-band dedup 内核支持的实现。这个实现已经越来越成熟，虽然还有诸多使用限制，
不过实现正确性上问题不大，迟迟没有办法合并进主线内核的原因更多是性能上的问题。&lt;/p&gt;
&lt;p&gt;如果 btrfs 有了 in-band dedup 这样系统性的 dedup 方案，那么不可避免地会增加文件系统中使用
reflink 的数量。这将会暴露出 backref walking 这样的基础设施中许多潜在的边角情况下的性能瓶颈。
前面解释过 backref walking 操作是个挺大开销的操作，并且开销随着快照和 reflink
的使用而爆炸式增长。直到最近的 btrfs 更新仍然在试图优化和改善现有 backref walking
的性能问题，可以预测 btrfs 的内建 dedup 支持将需要等待这方面更加成熟。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id33"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id65"&gt;5   结论和展望&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;不知不觉围绕 btrfs 和 zfs 的快照功能写了一大篇，前前后后写了一个半月，
文中提及的很多细节我自己也没有自信，如果有错误还请指出。&lt;/p&gt;
&lt;p&gt;稍微列举一些我觉得比较重要的结论，算是 TL;DR 的 takeaway notes 吧：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ZFS 的快照非常轻量。完全可以像 NILFS2 的连续快照那样，每小时一个快照，每天24小时，每年
365天不间断地创建快照，实际似乎也有公司是这样用的。如此频繁的快照不同于 NILFS2
等文件系统提供的连续快照，但是也没有那些日志结构文件系统实现连续快照所需承担的巨大 GC 开销。
并且 ZFS 可以没有额外开销地算出快照等数据集的空间占用之类的信息。&lt;/li&gt;
&lt;li&gt;btrfs 的快照相对也很轻量，比 LVM 和 dm-thin 的快照轻便很多，但是不如 ZFS 的快照轻，因为
btrfs 有维护反向引用的开销。 btrfs 要得知子卷的空间占用情况需要开启 qgroup
特性，这会对一些需要 backref walking 的操作有一些额外性能损失。&lt;/li&gt;
&lt;li&gt;btrfs 对快照和 reflink 没有限制，日常桌面系统下使用也不太会遇到性能问题。
不过系统性地（自动化地）大量使用快照和 reflink ，在一些操作下可能会有性能问题，值得注意。&lt;/li&gt;
&lt;li&gt;因为没有 reflink ， ZFS 的数据集划分需要一些前期计划。 ZFS 中共享元数据的方式只有快照，
所以要尽量多细分文件系统，方便以后能利用到快照特性，划分的粒度大致按照可能要回滚快照的粒度来。
btrfs 有 reflink ，于是这里有很多自由度，即便前期计划不够详细也可以通过 reflink
相对快速调整子卷结构。&lt;/li&gt;
&lt;li&gt;dedup 在 zfs 和 btrfs 都是个喜忧参半的特性，开启前要仔细评估可能的性能损失。ZFS dedup
的成功案例是，比如虚拟机服务的服务商，在宿主文件系统上用 ZFS
寄宿虚拟机的磁盘镜像，客户在虚拟机可能用类似版本的操作系统，从而宿主机整体来看有很多 dedup
的潜质。一般桌面场景下 dedup 的收益不明显，反而有巨大内存和IO带宽开销。&lt;/li&gt;
&lt;li&gt;相比 btrfs ，ZFS 更严格地遵守 CoW 文件系统「仅写一次」的特点，甚至就算遇到了数据块损坏，
修复数据块的时候也只能在原位写入。 btrfs 因为有反向引用所以在这方面灵活很多。&lt;/li&gt;
&lt;li&gt;ZFS 不支持对单个文件关闭 CoW ，所有文件（以及所有 zvol）都经过 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#dmu"&gt;DMU&lt;/a&gt; 层有 CoW
语义，这对一些应用场景有性能影响。btrfs 可以对单个文件关闭 CoW ，但是关闭 CoW
同时也丢失了写文件的事务性语义。&lt;/li&gt;
&lt;li&gt;ZFS 不支持碎片整理，靠 ARC 加大缓存来解决碎片带来的性能问题。 btrfs 有 defrag
，但是目前的实现会切断 reflink 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后关于 ZFS 没有 reflink 也没有反向引用的情况，想引用几段话。&lt;/p&gt;
&lt;p&gt;FreeBSD 的发起人之一，FreeBSD 的 FFS 维护者，
&lt;a class="reference external" href="https://youtu.be/IQp_FglfzUQ?t=2619"&gt;Kirk McKusick 曾经在 OpenZFS developer summit 2015&lt;/a&gt;
这么说过：&lt;/p&gt;
&lt;blockquote&gt;
I decided I'd add a wish list since I have a whole bunch of people here
that could actually possibly consider doing this. Both competitors of ZFS,
which are basically WAFL and BTRFS, kind of maintained back pointers.
And back pointers allow a lot of things like disk migration,
you can go through and tune up file layout, if you're working with
direct-mapped flash it allows you to do that effectively.
This has been a long -- and I understand big debate with the ZFS people and
I'm not going to try and talk about that -- but there's a very nice paper
that I've cited here, "Tracking Back References in a Write Anywhere File System",
that is it integrates keeping track of the back pointers in a way that would
work very well with ZFS. And so the cost is low, the cost of actually using
it is a little higher, but it's not unreasonable. So there's the reference
to that paper and if any of you are contemplating that you should read the
paper because if nothing else it's a great paper.&lt;/blockquote&gt;
&lt;p&gt;Kirk McKusick 呼吁 ZFS 开发者们考虑在 ZFS 中实现类似 backref
的基础设施，从而可能在未来获得更多有用的特性。&lt;/p&gt;
&lt;p&gt;和 ZFS 实现 backref 相关的一点是目前 ZFS 的块指针的组织结构。对此
ZFS 的 &lt;a class="reference external" href="//farseerfc.me/zhs/zfs-layered-architecture-design.html#zpl"&gt;ZPL&lt;/a&gt; 层原作者之一的
&lt;a class="reference external" href="https://youtu.be/xMH5rCL8S2k?t=1037"&gt;Mark Shellenbaum 在 OpenZFS developer summit 2016&lt;/a&gt;
也曾说过这样的话：&lt;/p&gt;
&lt;blockquote&gt;
(Q: Are there any things that we that we have regretted we did?)
A: I guess not so much on the ZPL, but with the way block pointers maybe weren't
fully virtualized, you know that things like that.&lt;/blockquote&gt;
&lt;p&gt;以及 ZFS 的最初的作者 &lt;a class="reference external" href="https://youtu.be/yNKZQBsTX08?t=2"&gt;Jeff 在 OpenZFS developer summit 2015&lt;/a&gt;
也曾说过：&lt;/p&gt;
&lt;blockquote&gt;
... and then certainly one thing i'd always wish we had done but there really
were always implementation difficulties was true virtual block addressing.
Because it would made dedup simpler, or would have made you know
compression of data, defragging, all that kind of stuff simpler.
That would have been really nice to have. But we never did the way that was
sort of tracable in terms of both the cost and the transactional semantics.&lt;/blockquote&gt;
&lt;p&gt;ZFS 这些开发者元老们都希望 ZFS 能有某种类似 backref 的机制，或者让块指针记录的地址更抽象的机制。&lt;/p&gt;
&lt;p&gt;关于这一点，ZFS 最重要的作者 Matt 如何看的呢？ Matt 近期似乎没有发表过看法，但是熟悉 ZFS
的人可能听到过 Matt 一直在计划的另一项 ZFS 特性中看出些端倪，叫 BP rewrite
，或者 BP virtualization 。从 Matt 还在 Sun 的时候开始，就试图在 ZFS 中实现
BP rewrite 特性，提供某种系统性的基础设施，能够快速地找到并改写大量数据块指针。
在网上搜索很多 ZFS 功能的实现细节，最终都会带到关于 BP rewrite 的讨论（甚至可以说论战）中。
Matt 最近给 OpenZFS 实现的两项功能，
&lt;a class="reference external" href="https://www.youtube.com/watch?v=Njt82e_3qVo"&gt;toplevel vdev removal 和 raidz expansion&lt;/a&gt;
如果有 BP rewrite 将会容易很多，而他们目前是在没有 BP rewrite 的前提下，通过一连串额外抽象实现的。&lt;/p&gt;
&lt;p&gt;从 BP rewrite 这个兔子洞中，还能引出更多 btrfs 和 ZFS 关于设备管理的差异，这个有待今后再谈。&lt;/p&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="tech"></category><category term="FS笔记"></category><category term="FS notes"></category><category term="btrfs"></category><category term="zfs"></category><category term="cow"></category><category term="snapshot"></category><category term="clone"></category><category term="subvolume"></category><category term="dedup"></category><category term="reflink"></category><category term="SPA"></category><category term="DMU"></category><category term="DSL"></category><category term="ZPL"></category></entry><entry><title>ZFS 分层架构设计</title><link href="//farseerfc.me/zhs/zfs-layered-architecture-design.html" rel="alternate"></link><published>2020-02-04T16:59:00+09:00</published><updated>2020-02-04T16:59:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2020-02-04:/zhs/zfs-layered-architecture-design.html</id><summary type="html">
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2020年2月9日更新过&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;ZFS 在设计之初源自于 Sun 内部多次重写 UFS 的尝试，背负了重构 Solaris
诸多内核子系统的重任，从而不同于 Linux 的文件系统只负责文件系统的功能而把其余功能（比如内存脏页管理，
IO调度）交给内核更底层的子系统， ZFS 的整体设计更层次化并更独立，很多部分可能和 Linux/FreeBSD
内核已有的子系统有功能重叠。&lt;/p&gt;
&lt;p&gt;似乎很多关于 ZFS 的视频演讲和幻灯片有讲到子系统架构，但是找了半天也没找到网上关于这个的说明文档。
于是写下这篇笔记试图从 ZFS 的早期开发历程开始，记录一下 ZFS 分层架构中各个子系统之间的分工。
也有几段 OpenZFS Summit 视频佐以记录那段历史。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;早期架构&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;早期 ZFS 在开发时大体可以分为上下三层，分别是 ZPL， DMU 和 SPA ，这三层分别由三组人负责。&lt;/p&gt;
&lt;p&gt;最初在 Sun 内部带领 ZFS …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2020年2月9日更新过&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;ZFS 在设计之初源自于 Sun 内部多次重写 UFS 的尝试，背负了重构 Solaris
诸多内核子系统的重任，从而不同于 Linux 的文件系统只负责文件系统的功能而把其余功能（比如内存脏页管理，
IO调度）交给内核更底层的子系统， ZFS 的整体设计更层次化并更独立，很多部分可能和 Linux/FreeBSD
内核已有的子系统有功能重叠。&lt;/p&gt;
&lt;p&gt;似乎很多关于 ZFS 的视频演讲和幻灯片有讲到子系统架构，但是找了半天也没找到网上关于这个的说明文档。
于是写下这篇笔记试图从 ZFS 的早期开发历程开始，记录一下 ZFS 分层架构中各个子系统之间的分工。
也有几段 OpenZFS Summit 视频佐以记录那段历史。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;早期架构&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;早期 ZFS 在开发时大体可以分为上下三层，分别是 ZPL， DMU 和 SPA ，这三层分别由三组人负责。&lt;/p&gt;
&lt;p&gt;最初在 Sun 内部带领 ZFS 开发的是 &lt;a class="reference external" href="https://blogs.oracle.com/bonwick/"&gt;Jeff Bonwick&lt;/a&gt;
，他首先有了对 ZFS 整体架构的构思，然后游说 Sun 高层，亲自组建起了 ZFS
开发团队，招募了当时刚从大学毕业的 &lt;a class="reference external" href="http://open-zfs.org/wiki/User:Mahrens"&gt;Matt Ahrens&lt;/a&gt;
。作为和 Sun 高层谈妥的条件， Jeff 也必须负责 Solaris 整体的 Storage &amp;amp; Filesystem Team
，于是他又从 Solaris 的 Storage Team 抽调了 UFS 部分的负责人 Mark Shellenbaum 和
Mark Maybee 来开发 ZFS 。而如今昔日升阳已然日落， Jeff
成立了独立公司继续开拓服务器存储领域， Matt 是 OpenZFS 项目的负责人，两位 Mark 则留在了
Sun/Oracle 成为了 Oracle ZFS 分支的维护者。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
The Birth of ZFS by Jeff Bonwick&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/dcV2PaMTAJ4"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Story Time (Q&amp;amp;A) with Matt and Jeff&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/yNKZQBsTX08"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
ZFS First Mount by Mark Shellenbaum&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/xMH5rCL8S2k"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
ZFS past &amp;amp; future by Mark Maybee&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/c1ek1tFjhH8"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在开发早期，作为分工， Jeff 负责 ZFS 设计中最底层的 SPA ，提供多个存储设备组成的存储池抽象；
Matt 负责 ZFS 设计中最至关重要的 DMU 引擎，在块设备基础上提供具有事务语义的对象存储；
而两位 Mark 负责 ZFS 设计中直接面向用户的 ZPL ，在 DMU 基础上提供完整 POSIX 文件系统语义。
ZFS 设计中这最初的分工也体现在了 ZFS 现在子系统分层的架构上，继续影响（增强或者限制） ZFS
今后发展的方向。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;子系统整体架构&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先 ZFS 整体架构如下图，其中圆圈是 ZFS 给内核层的外部接口，方框是 ZFS 内部子系统（
我给方框的子系统加上了超链接）：&lt;/p&gt;
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;

&lt;!-- Generated by graphviz version 2.40.1 (20161225.0304)
 --&gt;
&lt;!-- Title: ZFS_Layer_Architecture Pages: 1 --&gt;
&lt;svg class="svg-responsive" height="626pt" viewbox="0.00 0.00 806.50 626.00" width="807pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
&lt;g class="graph" id="graph0" transform="scale(1 1) rotate(0) translate(4 622)"&gt;
&lt;title&gt;ZFS_Layer_Architecture&lt;/title&gt;
&lt;polygon fill="#ffffff" points="-4,4 -4,-622 802.5,-622 802.5,4 -4,4" stroke="transparent"&gt;&lt;/polygon&gt;
&lt;g class="cluster" id="clust4"&gt;
&lt;title&gt;clusterTOL&lt;/title&gt;
&lt;g id="a_clust4"&gt;&lt;a xlink:href="#tol" xlink:title="TOL"&gt;
&lt;polygon fill="none" points="493.5,-355 493.5,-574 583.5,-574 583.5,-355 493.5,-355" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="538.5" y="-558.8"&gt;TOL&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;g class="cluster" id="clust9"&gt;
&lt;title&gt;clusterSPA&lt;/title&gt;
&lt;g id="a_clust9"&gt;&lt;a xlink:href="#spa" xlink:title="SPA"&gt;
&lt;polygon fill="none" points="415.5,-64 415.5,-283 649.5,-283 649.5,-64 415.5,-64" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="532.5" y="-267.8"&gt;SPA&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- Filesystem API --&gt;
&lt;g class="node" id="node1"&gt;
&lt;title&gt;Filesystem API&lt;/title&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="62.5" y="-596.3"&gt;Filesystem API&lt;/text&gt;
&lt;/g&gt;
&lt;!-- VFS --&gt;
&lt;g class="node" id="node5"&gt;
&lt;title&gt;VFS&lt;/title&gt;
&lt;ellipse cx="62.5" cy="-525" fill="none" rx="30.5947" ry="18" stroke="#000000"&gt;&lt;/ellipse&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="62.5" y="-521.3"&gt;VFS&lt;/text&gt;
&lt;/g&gt;
&lt;!-- Filesystem API&amp;#45;&amp;gt;VFS --&gt;
&lt;g class="edge" id="edge1"&gt;
&lt;title&gt;Filesystem API-&amp;gt;VFS&lt;/title&gt;
&lt;path d="M62.5,-581.8446C62.5,-573.3401 62.5,-563.0076 62.5,-553.4964" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="66.0001,-553.2481 62.5,-543.2482 59.0001,-553.2482 66.0001,-553.2481" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- Block device API --&gt;
&lt;g class="node" id="node2"&gt;
&lt;title&gt;Block device API&lt;/title&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="437.5" y="-596.3"&gt;Block device API&lt;/text&gt;
&lt;/g&gt;
&lt;!-- /dev/zvol/... --&gt;
&lt;g class="node" id="node6"&gt;
&lt;title&gt;/dev/zvol/...&lt;/title&gt;
&lt;ellipse cx="421.5" cy="-525" fill="none" rx="63.8893" ry="18" stroke="#000000"&gt;&lt;/ellipse&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="421.5" y="-521.3"&gt;/dev/zvol/...&lt;/text&gt;
&lt;/g&gt;
&lt;!-- Block device API&amp;#45;&amp;gt;/dev/zvol/... --&gt;
&lt;g class="edge" id="edge2"&gt;
&lt;title&gt;Block device API-&amp;gt;/dev/zvol/...&lt;/title&gt;
&lt;path d="M433.6268,-581.8446C431.7795,-573.1849 429.5277,-562.6301 427.4684,-552.9768" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="430.8469,-552.0379 425.3375,-542.9882 424.001,-553.4984 430.8469,-552.0379" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZFS Management API (libzfs) --&gt;
&lt;g class="node" id="node3"&gt;
&lt;title&gt;ZFS Management API (libzfs)&lt;/title&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="684.5" y="-596.3"&gt;ZFS Management API (libzfs)&lt;/text&gt;
&lt;/g&gt;
&lt;!-- /dev/zfs ioctl --&gt;
&lt;g class="node" id="node7"&gt;
&lt;title&gt;/dev/zfs ioctl&lt;/title&gt;
&lt;ellipse cx="684.5" cy="-525" fill="none" rx="69.5877" ry="18" stroke="#000000"&gt;&lt;/ellipse&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="684.5" y="-521.3"&gt;/dev/zfs ioctl&lt;/text&gt;
&lt;/g&gt;
&lt;!-- ZFS Management API (libzfs)&amp;#45;&amp;gt;/dev/zfs ioctl --&gt;
&lt;g class="edge" id="edge3"&gt;
&lt;title&gt;ZFS Management API (libzfs)-&amp;gt;/dev/zfs ioctl&lt;/title&gt;
&lt;path d="M684.5,-581.8446C684.5,-573.3401 684.5,-563.0076 684.5,-553.4964" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="688.0001,-553.2481 684.5,-543.2482 681.0001,-553.2482 688.0001,-553.2481" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- NFS/Samba API (libshare) --&gt;
&lt;g class="node" id="node4"&gt;
&lt;title&gt;NFS/Samba API (libshare)&lt;/title&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="246.5" y="-596.3"&gt;NFS/Samba API (libshare)&lt;/text&gt;
&lt;/g&gt;
&lt;!-- NFS/CIFS vop_rwlock --&gt;
&lt;g class="node" id="node8"&gt;
&lt;title&gt;NFS/CIFS vop_rwlock&lt;/title&gt;
&lt;ellipse cx="225.5" cy="-525" fill="none" rx="114.2798" ry="18" stroke="#000000"&gt;&lt;/ellipse&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="225.5" y="-521.3"&gt;NFS/CIFS vop_rwlock&lt;/text&gt;
&lt;/g&gt;
&lt;!-- NFS/Samba API (libshare)&amp;#45;&amp;gt;NFS/CIFS vop_rwlock --&gt;
&lt;g class="edge" id="edge4"&gt;
&lt;title&gt;NFS/Samba API (libshare)-&amp;gt;NFS/CIFS vop_rwlock&lt;/title&gt;
&lt;path d="M241.4165,-581.8446C238.966,-573.0928 235.9735,-562.4053 233.2473,-552.669" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="236.6034,-551.6741 230.5367,-542.9882 229.8627,-553.5616 236.6034,-551.6741" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- VFS&amp;#45;&amp;gt;NFS/CIFS vop_rwlock --&gt;
&lt;g class="edge" id="edge5"&gt;
&lt;title&gt;VFS-&amp;gt;NFS/CIFS vop_rwlock&lt;/title&gt;
&lt;path d="M93.0625,-525C95.6653,-525 98.2682,-525 100.871,-525" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="100.9106,-528.5001 110.9105,-525 100.9105,-521.5001 100.9106,-528.5001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZPL --&gt;
&lt;g class="node" id="node9"&gt;
&lt;title&gt;ZPL&lt;/title&gt;
&lt;g id="a_node9"&gt;&lt;a xlink:href="#zpl" xlink:title="ZPL"&gt;
&lt;polygon fill="none" points="367.5,-471 313.5,-471 313.5,-435 367.5,-435 367.5,-471" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="340.5" y="-449.3"&gt;ZPL&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- VFS&amp;#45;&amp;gt;ZPL --&gt;
&lt;g class="edge" id="edge6"&gt;
&lt;title&gt;VFS-&amp;gt;ZPL&lt;/title&gt;
&lt;path d="M86.3025,-513.3546C91.5594,-511.0472 97.1562,-508.7886 102.5,-507 171.7912,-483.808 255.7337,-467.3568 303.1418,-459.0894" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="303.9854,-462.4959 313.2493,-457.3547 302.8013,-455.5968 303.9854,-462.4959" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZVOL --&gt;
&lt;g class="node" id="node10"&gt;
&lt;title&gt;ZVOL&lt;/title&gt;
&lt;g id="a_node10"&gt;&lt;a xlink:href="#zvol" xlink:title="ZVOL"&gt;
&lt;polygon fill="none" points="483,-471 424,-471 424,-435 483,-435 483,-471" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="453.5" y="-449.3"&gt;ZVOL&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- /dev/zvol/...&amp;#45;&amp;gt;ZVOL --&gt;
&lt;g class="edge" id="edge7"&gt;
&lt;title&gt;/dev/zvol/...-&amp;gt;ZVOL&lt;/title&gt;
&lt;path d="M429.575,-506.8314C433.1102,-498.8771 437.336,-489.369 441.2456,-480.5723" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="444.4532,-481.9729 445.3163,-471.4133 438.0565,-479.1299 444.4532,-481.9729" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- DSL --&gt;
&lt;g class="node" id="node11"&gt;
&lt;title&gt;DSL&lt;/title&gt;
&lt;g id="a_node11"&gt;&lt;a xlink:href="#dsl" xlink:title="DSL"&gt;
&lt;polygon fill="none" points="557.5,-543 503.5,-543 503.5,-507 557.5,-507 557.5,-543" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="530.5" y="-521.3"&gt;DSL&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- /dev/zfs ioctl&amp;#45;&amp;gt;DSL --&gt;
&lt;g class="edge" id="edge10"&gt;
&lt;title&gt;/dev/zfs ioctl-&amp;gt;DSL&lt;/title&gt;
&lt;path d="M614.5895,-525C598.9983,-525 583.4071,-525 567.8159,-525" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="567.5703,-521.5001 557.5703,-525 567.5703,-528.5001 567.5703,-521.5001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- VDEV --&gt;
&lt;g class="node" id="node20"&gt;
&lt;title&gt;VDEV&lt;/title&gt;
&lt;g id="a_node20"&gt;&lt;a xlink:href="#vdev" xlink:title="VDEV"&gt;
&lt;polygon fill="none" points="546,-108 487,-108 487,-72 546,-72 546,-108" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="516.5" y="-86.3"&gt;VDEV&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- /dev/zfs ioctl&amp;#45;&amp;gt;VDEV --&gt;
&lt;g class="edge" id="edge29"&gt;
&lt;title&gt;/dev/zfs ioctl-&amp;gt;VDEV&lt;/title&gt;
&lt;path d="M689.2656,-506.9623C696.0025,-479.8344 707.5,-426.8236 707.5,-381 707.5,-381 707.5,-381 707.5,-234 707.5,-186.6526 686.8759,-174.3079 650.5,-144 623.0063,-121.0926 584.5356,-106.9458 555.8638,-98.9099" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="556.7296,-95.5186 546.165,-96.3181 554.9223,-102.2812 556.7296,-95.5186" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- DMU --&gt;
&lt;g class="node" id="node13"&gt;
&lt;title&gt;DMU&lt;/title&gt;
&lt;g id="a_node13"&gt;&lt;a xlink:href="#dmu" xlink:title="DMU"&gt;
&lt;polygon fill="none" points="555.5,-399 501.5,-399 501.5,-363 555.5,-363 555.5,-399" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="528.5" y="-377.3"&gt;DMU&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- NFS/CIFS vop_rwlock&amp;#45;&amp;gt;DMU --&gt;
&lt;g class="edge" id="edge15"&gt;
&lt;title&gt;NFS/CIFS vop_rwlock-&amp;gt;DMU&lt;/title&gt;
&lt;path d="M285.6968,-509.563C314.41,-500.7092 348.5163,-487.9433 376.5,-471 396.6786,-458.7825 395.9728,-448.2337 415.5,-435 439.4387,-418.7766 469.0038,-404.835 491.8877,-395.1832" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="493.3442,-398.3685 501.2501,-391.3152 490.6713,-391.8989 493.3442,-398.3685" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZAP --&gt;
&lt;g class="node" id="node12"&gt;
&lt;title&gt;ZAP&lt;/title&gt;
&lt;g id="a_node12"&gt;&lt;a xlink:href="#zap" xlink:title="ZAP"&gt;
&lt;polygon fill="none" points="555.5,-471 501.5,-471 501.5,-435 555.5,-435 555.5,-471" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="528.5" y="-449.3"&gt;ZAP&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- ZPL&amp;#45;&amp;gt;ZAP --&gt;
&lt;g class="edge" id="edge8"&gt;
&lt;title&gt;ZPL-&amp;gt;ZAP&lt;/title&gt;
&lt;path d="M367.5472,-469.1304C396.6265,-484.3281 444.0019,-502.8552 483.5,-489 490.6397,-486.4955 497.4881,-482.3291 503.5943,-477.7013" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="505.9521,-480.293 511.4185,-471.2173 501.4855,-474.9032 505.9521,-480.293" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZPL&amp;#45;&amp;gt;DMU --&gt;
&lt;g class="edge" id="edge12"&gt;
&lt;title&gt;ZPL-&amp;gt;DMU&lt;/title&gt;
&lt;path d="M367.7478,-440.7581C372.3191,-438.7848 377.0292,-436.8006 381.5,-435 418.7731,-419.9886 462.0037,-404.312 491.8902,-393.7414" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="493.2174,-396.9848 501.4861,-390.3607 490.8913,-390.3825 493.2174,-396.9848" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZIL --&gt;
&lt;g class="node" id="node15"&gt;
&lt;title&gt;ZIL&lt;/title&gt;
&lt;g id="a_node15"&gt;&lt;a xlink:href="#zil" xlink:title="ZIL"&gt;
&lt;polygon fill="none" points="480.5,-327 426.5,-327 426.5,-291 480.5,-291 480.5,-327" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="453.5" y="-305.3"&gt;ZIL&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- ZPL&amp;#45;&amp;gt;ZIL --&gt;
&lt;g class="edge" id="edge16"&gt;
&lt;title&gt;ZPL-&amp;gt;ZIL&lt;/title&gt;
&lt;path d="M354.8115,-434.7623C374.5947,-409.5518 410.4107,-363.9103 433.0226,-335.0952" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="435.8847,-337.1173 439.3047,-327.0896 430.3778,-332.7959 435.8847,-337.1173" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZVOL&amp;#45;&amp;gt;DMU --&gt;
&lt;g class="edge" id="edge13"&gt;
&lt;title&gt;ZVOL-&amp;gt;DMU&lt;/title&gt;
&lt;path d="M472.4257,-434.8314C481.4857,-426.1337 492.4809,-415.5783 502.3265,-406.1265" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="504.7904,-408.613 509.5804,-399.1628 499.9426,-403.5633 504.7904,-408.613" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- DSL&amp;#45;&amp;gt;ZAP --&gt;
&lt;g class="edge" id="edge9"&gt;
&lt;title&gt;DSL-&amp;gt;ZAP&lt;/title&gt;
&lt;path d="M529.9953,-506.8314C529.7814,-499.131 529.5271,-489.9743 529.2894,-481.4166" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="532.7879,-481.3122 529.0115,-471.4133 525.7906,-481.5066 532.7879,-481.3122" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- DSL&amp;#45;&amp;gt;DMU --&gt;
&lt;g class="edge" id="edge14"&gt;
&lt;title&gt;DSL-&amp;gt;DMU&lt;/title&gt;
&lt;path d="M545.614,-506.7768C552.8549,-496.8586 560.7524,-483.9858 564.5,-471 568.9365,-455.6274 569.1365,-450.3135 564.5,-435 561.5436,-425.2355 556.1748,-415.6229 550.47,-407.2762" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="553.2129,-405.0973 544.4905,-399.0831 547.5586,-409.2239 553.2129,-405.0973" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZAP&amp;#45;&amp;gt;DMU --&gt;
&lt;g class="edge" id="edge11"&gt;
&lt;title&gt;ZAP-&amp;gt;DMU&lt;/title&gt;
&lt;path d="M528.5,-434.8314C528.5,-427.131 528.5,-417.9743 528.5,-409.4166" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="532.0001,-409.4132 528.5,-399.4133 525.0001,-409.4133 532.0001,-409.4132" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ARC --&gt;
&lt;g class="node" id="node14"&gt;
&lt;title&gt;ARC&lt;/title&gt;
&lt;g id="a_node14"&gt;&lt;a xlink:href="#arc" xlink:title="ARC"&gt;
&lt;polygon fill="none" points="555.5,-327 501.5,-327 501.5,-291 555.5,-291 555.5,-327" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="528.5" y="-305.3"&gt;ARC&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- DMU&amp;#45;&amp;gt;ARC --&gt;
&lt;g class="edge" id="edge17"&gt;
&lt;title&gt;DMU-&amp;gt;ARC&lt;/title&gt;
&lt;path d="M528.5,-362.8314C528.5,-355.131 528.5,-345.9743 528.5,-337.4166" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="532.0001,-337.4132 528.5,-327.4133 525.0001,-337.4133 532.0001,-337.4132" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- MetaSlab --&gt;
&lt;g class="node" id="node19"&gt;
&lt;title&gt;MetaSlab&lt;/title&gt;
&lt;g id="a_node19"&gt;&lt;a xlink:href="#metaslab" xlink:title="MetaSlab"&gt;
&lt;polygon fill="none" points="641,-180 556,-180 556,-144 641,-144 641,-180" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="598.5" y="-158.3"&gt;MetaSlab&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- DMU&amp;#45;&amp;gt;MetaSlab --&gt;
&lt;g class="edge" id="edge23"&gt;
&lt;title&gt;DMU-&amp;gt;MetaSlab&lt;/title&gt;
&lt;path d="M555.6383,-368.3974C585.2203,-352.9755 630.9457,-323.7894 650.5,-283 663.3726,-256.1483 661.6355,-243.6173 650.5,-216 646.1775,-205.2796 638.5956,-195.4983 630.5361,-187.2948" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="632.7442,-184.5652 623.0801,-180.2228 627.927,-189.644 632.7442,-184.5652" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZIO --&gt;
&lt;g class="node" id="node16"&gt;
&lt;title&gt;ZIO&lt;/title&gt;
&lt;g id="a_node16"&gt;&lt;a xlink:href="#zio" xlink:title="ZIO"&gt;
&lt;polygon fill="none" points="555.5,-252 501.5,-252 501.5,-216 555.5,-216 555.5,-252" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="528.5" y="-230.3"&gt;ZIO&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- ARC&amp;#45;&amp;gt;ZIO --&gt;
&lt;g class="edge" id="edge20"&gt;
&lt;title&gt;ARC-&amp;gt;ZIO&lt;/title&gt;
&lt;path d="M528.5,-290.8446C528.5,-282.3401 528.5,-272.0076 528.5,-262.4964" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="532.0001,-262.2481 528.5,-252.2482 525.0001,-262.2482 532.0001,-262.2481" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- L2ARC --&gt;
&lt;g class="node" id="node17"&gt;
&lt;title&gt;L2ARC&lt;/title&gt;
&lt;g id="a_node17"&gt;&lt;a xlink:href="#l2arc" xlink:title="L2ARC"&gt;
&lt;polygon fill="none" points="641.5,-252 573.5,-252 573.5,-216 641.5,-216 641.5,-252" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="607.5" y="-230.3"&gt;L2ARC&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- ARC&amp;#45;&amp;gt;L2ARC --&gt;
&lt;g class="edge" id="edge21"&gt;
&lt;title&gt;ARC-&amp;gt;L2ARC&lt;/title&gt;
&lt;path d="M554.9972,-290.9209C558.2877,-288.3716 561.5341,-285.6973 564.5,-283 572.1249,-276.0657 579.7661,-267.8645 586.4472,-260.1753" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="589.4807,-262.0092 593.2739,-252.1166 584.1396,-257.4845 589.4807,-262.0092" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZIL&amp;#45;&amp;gt;ZIO --&gt;
&lt;g class="edge" id="edge19"&gt;
&lt;title&gt;ZIL-&amp;gt;ZIO&lt;/title&gt;
&lt;path d="M480.869,-292.5464C484.9519,-289.5928 488.9697,-286.3728 492.5,-283 499.3026,-276.501 505.7319,-268.5881 511.2235,-261.0336" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="514.3671,-262.6436 517.2054,-252.436 508.6211,-258.6456 514.3671,-262.6436" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- SLOG --&gt;
&lt;g class="node" id="node18"&gt;
&lt;title&gt;SLOG&lt;/title&gt;
&lt;g id="a_node18"&gt;&lt;a xlink:href="#slog" xlink:title="SLOG"&gt;
&lt;polygon fill="none" points="483,-252 424,-252 424,-216 483,-216 483,-252" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="453.5" y="-230.3"&gt;SLOG&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- ZIL&amp;#45;&amp;gt;SLOG --&gt;
&lt;g class="edge" id="edge18"&gt;
&lt;title&gt;ZIL-&amp;gt;SLOG&lt;/title&gt;
&lt;path d="M453.5,-290.8446C453.5,-282.3401 453.5,-272.0076 453.5,-262.4964" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="457.0001,-262.2481 453.5,-252.2482 450.0001,-262.2482 457.0001,-262.2481" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZIO&amp;#45;&amp;gt;MetaSlab --&gt;
&lt;g class="edge" id="edge24"&gt;
&lt;title&gt;ZIO-&amp;gt;MetaSlab&lt;/title&gt;
&lt;path d="M546.164,-215.8314C554.4732,-207.2848 564.5264,-196.9443 573.5918,-187.6198" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="576.1369,-190.023 580.5982,-180.4133 571.1179,-185.1435 576.1369,-190.023" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZIO&amp;#45;&amp;gt;VDEV --&gt;
&lt;g class="edge" id="edge28"&gt;
&lt;title&gt;ZIO-&amp;gt;VDEV&lt;/title&gt;
&lt;path d="M526.9802,-215.7623C524.9334,-191.201 521.2706,-147.2474 518.8628,-118.3541" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="522.3259,-117.7644 518.0075,-108.0896 515.3501,-118.3458 522.3259,-117.7644" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- L2ARC&amp;#45;&amp;gt;ZIO --&gt;
&lt;g class="edge" id="edge22"&gt;
&lt;title&gt;L2ARC-&amp;gt;ZIO&lt;/title&gt;
&lt;path d="M573.4775,-234C570.8786,-234 568.2797,-234 565.6807,-234" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="565.6563,-230.5001 555.6563,-234 565.6562,-237.5001 565.6563,-230.5001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- L2ARC&amp;#45;&amp;gt;VDEV --&gt;
&lt;g class="edge" id="edge26"&gt;
&lt;title&gt;L2ARC-&amp;gt;VDEV&lt;/title&gt;
&lt;path d="M581.9503,-215.8625C570.0905,-206.3385 556.6295,-193.7883 547.5,-180 535.0104,-161.137 527.0138,-136.7121 522.2764,-118.0676" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="525.6279,-117.032 519.9132,-108.1105 518.8171,-118.6485 525.6279,-117.032" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- SLOG&amp;#45;&amp;gt;VDEV --&gt;
&lt;g class="edge" id="edge25"&gt;
&lt;title&gt;SLOG-&amp;gt;VDEV&lt;/title&gt;
&lt;path d="M461.479,-215.7623C472.3192,-190.9846 491.7938,-146.4714 504.4277,-117.5939" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="507.7841,-118.6541 508.5858,-108.0896 501.371,-115.8483 507.7841,-118.6541" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- MetaSlab&amp;#45;&amp;gt;VDEV --&gt;
&lt;g class="edge" id="edge27"&gt;
&lt;title&gt;MetaSlab-&amp;gt;VDEV&lt;/title&gt;
&lt;path d="M577.8079,-143.8314C567.8052,-135.0485 555.645,-124.3712 544.8001,-114.8489" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="547.0092,-112.1308 537.1854,-108.1628 542.3906,-117.3909 547.0092,-112.1308" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- physical storage devices --&gt;
&lt;g class="node" id="node21"&gt;
&lt;title&gt;physical storage devices&lt;/title&gt;
&lt;path d="M613,-32.7273C613,-34.5331 569.7472,-36 516.5,-36 463.2528,-36 420,-34.5331 420,-32.7273 420,-32.7273 420,-3.2727 420,-3.2727 420,-1.4669 463.2528,0 516.5,0 569.7472,0 613,-1.4669 613,-3.2727 613,-3.2727 613,-32.7273 613,-32.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;path d="M613,-32.7273C613,-30.9214 569.7472,-29.4545 516.5,-29.4545 463.2528,-29.4545 420,-30.9214 420,-32.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="516.5" y="-14.3"&gt;physical storage devices&lt;/text&gt;
&lt;/g&gt;
&lt;!-- VDEV&amp;#45;&amp;gt;physical storage devices --&gt;
&lt;g class="edge" id="edge30"&gt;
&lt;title&gt;VDEV-&amp;gt;physical storage devices&lt;/title&gt;
&lt;path d="M516.5,-71.8314C516.5,-64.131 516.5,-54.9743 516.5,-46.4166" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="520.0001,-46.4132 516.5,-36.4133 513.0001,-46.4133 520.0001,-46.4132" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;/svg&gt;
&lt;p&gt;接下来从底层往上介绍一下各个子系统的全称和职能。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="spa"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;SPA&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Storage Pool Allocator&lt;/p&gt;
&lt;p&gt;从内核提供的多个块设备中抽象出存储池的子系统。 SPA 进一步分为 ZIO 和 VDEV 两大部分和其余一些小的子系统。&lt;/p&gt;
&lt;p&gt;SPA 对 DMU 提供的接口不同于传统的块设备接口，完全利用了 CoW 文件系统对写入位置不敏感的特点。
传统的块设备接口通常是写入时指定一个写入地址，把缓冲区写到磁盘指定的位置上，而 DMU 可以让 SPA
做两种操作：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;code class="code"&gt;
write&lt;/code&gt;
 ， DMU 交给 SPA 一个数据块的内存指针， SPA
负责找设备写入这个数据块，然后返回给 DMU 一个 block pointer 。&lt;/li&gt;
&lt;li&gt;&lt;code class="code"&gt;
read&lt;/code&gt;
 ，DMU 交给 SPA 一个 block pointer ，SPA 读取设备并返回给 DMU
完整的数据块。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是说，在 DMU 让 SPA 写数据块时， DMU 还不知道 SPA 会写入的地方，这完全由 SPA 判断，
这一点通常被称为 Write Anywhere ，在别的 CoW 文件系统比如 Btrfs 和 WAFL 中也有这个特点。
反过来 SPA 想要对一个数据块操作时，也完全不清楚这个数据块用于什么目的，属于什么文件或者文件系统结构。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="vdev"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;VDEV&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Virtual DEVice&lt;/p&gt;
&lt;p&gt;VDEV 在 ZFS 中的作用相当于 Linux 内核的 Device Mapper 层或者 FreeBSD GEOM 层，提供
Stripe/Mirror/RAIDZ 之类的多设备存储池管理和抽象。 ZFS 中的 vdev
形成一个树状结构，在树的底层是从内核提供的物理设备，
其上是虚拟的块设备。每个虚拟块设备对上对下都是块设备接口，除了底层的物理设备之外，位于中间层的
vdev 需要负责地址映射、容量转换等计算过程。&lt;/p&gt;
&lt;p&gt;除了用于存储数据的 Stripe/Mirror/RAIDZ 之类的 VDEV ，还有一些特殊用途的 VDEV
，包括提供二级缓存的 L2ARC 设备，以及提供 ZIL 高速日志的 SLOG 设备。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="zio"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;ZIO&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
ZIO Pipeline by George Wilson&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/qkA5HhfzsvM"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ZFS I/O&lt;/p&gt;
&lt;p&gt;作用相当于内核的 IO scheduler 和 pagecache write back 机制。
OpenZFS Summit 有个演讲整理了 ZIO 流水线的工作原理。
ZIO 内部使用流水线和事件驱动机制，避免让上层的 ZFS 线程阻塞等待在 IO 操作上。
ZIO 把一个上层的写请求转换成多个写操作，负责把这些写操作合并到
transaction group 提交事务组。 ZIO 也负责将读写请求按同步还是异步分成不同的读写优先级并实施优先级调度，
在 &lt;a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler"&gt;OpenZFS 项目 wiki 页有一篇描述 ZIO 调度&lt;/a&gt;
的细节。&lt;/p&gt;
&lt;p&gt;除了调度之外， ZIO 层还负责在读写流水线中拆解和拼装数据块。上层 DMU 交给 SPA 的数据块有固定大小，
目前默认是 128KiB ，pool 整体的参数可以调整块大小在 4KiB 到 8MiB 之间。ZIO
拿到整块大小的数据块之后，在流水线中可以对数据块做诸如以下操作：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;用压缩算法，压缩/解压数据块。&lt;/li&gt;
&lt;li&gt;查询 dedup table ，对数据块去重。&lt;/li&gt;
&lt;li&gt;加密/解密数据块。&lt;/li&gt;
&lt;li&gt;计算数据块的校验和。&lt;/li&gt;
&lt;li&gt;如果底层分配器不能分配完整的 128KiB （或 zpool 设置的大小），那么尝试分配多个小块，然后用多个
512B 的指针间接块连起多个小块的，拼装成一个虚拟的大块，这个机制叫
&lt;a class="reference external" href="https://utcc.utoronto.ca/~cks/space/blog/solaris/ZFSGangBlocks"&gt;gang block&lt;/a&gt;
。通常 ZFS 中用到 gang block 时，整个存储池处于极度空间不足的情况，由 gang block
造成严重性能下降，而 gang block 的意义在于在空间接近要满的时候也能 CoW
写入一些元数据，释放亟需的存储空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可见经过 ZIO 流水线之后，数据块不再是统一大小，这使得 ZFS 用在 4K 对齐的磁盘或者 SSD
上有了一些新的挑战。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="metaslab"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;MetaSlab&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
MetaSlab Allocation Performance by Paul Dagnelie&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/LZpaTGNvalE"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;MetaSlab 是 ZFS 的块分配器。 VDEV 把存储设备抽象成存储池之后， MetaSlab
负责实际从存储设备上分配数据块，跟踪记录可用空间和已用空间。&lt;/p&gt;
&lt;p&gt;叫 MetaSlab 这个名字是因为 Jeff 最初同时也给 Solaris 内核写过
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Slab_allocation"&gt;slab 分配器&lt;/a&gt;
，一开始设计 SPA 的时候 Jeff 想在 SPA 中也利用 Solaris 的 slab
分配器对磁盘空间使用类似的分配算法。后来 MetaSlab 逐渐不再使用 slab 算法，只有名字留了下来。&lt;/p&gt;
&lt;p&gt;MetaSlab 的结构很接近于 FreeBSD UFS 的 cylinder group ，或者 ext2/3/4 的 block group
，或者 xfs 的 allocation group ，目的都是让存储分配策略「局域化」，
或者说让近期分配的数据块的物理地址比较接近。在存储设备上创建 zpool
的时候，首先会尽量在存储设备上分配 200 个左右的 MetaSlab ，随后给 zpool
增加设备的话使用接近的 MetaSlab 大小。每个 MetaSlab 是连续的一整块空间，在 MetaSlab
内对数据块空间做分配和释放。磁盘中存储的 MetaSlab 的分配情况是按需载入内存的，系统
import zpool 时不需要载入所有 MetaSlab 到内存，而只需加载一小部分。当前载入内存的 MetaSlab
剩余空间告急时，会载入别的 MetaSlab 尝试分配，而从某个 MetaSlab 释放空间不需要载入 MetaSlab
。&lt;/p&gt;
&lt;p&gt;OpenZFS Summit 也有一个对 MetaSlab 分配器性能的介绍，可以看到很多分配器内的细节。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="arc"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;ARC&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
ELI5: ZFS Caching Explain Like I'm 5: How the ZFS Adaptive Replacement Cache works&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/1Wo3i2gkAIk"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Adaptive Replacement Cache&lt;/p&gt;
&lt;p&gt;ARC 的作用相当于 Linux/Solaris/FreeBSD 中传统的 page/buffer cache 。
和传统 pagecache 使用 LRU (Least Recently Used) 之类的算法剔除缓存页不同， ARC
算法试图在 LRU 和 LFU(Least Frequently Used) 之间寻找平衡，从而复制大文件之类的线性大量
IO 操作不至于让缓存失效率猛增。最近 FOSDEM 2019 有一个介绍 ZFS ARC 工作原理的视频。&lt;/p&gt;
&lt;p&gt;不过 ZFS 采用它自有的 ARC 一个显著缺点在于，不能和内核已有的 pagecache 机制相互配合，尤其在
系统内存压力很大的情况下，内核与 ZFS 无关的其余部分可能难以通知 ARC 释放内存。所以 ARC
是 ZFS 消耗内存的大户之一（另一个是可选的 dedup table），也是
&lt;a class="reference external" href="http://open-zfs.org/wiki/Performance_tuning#Adaptive_Replacement_Cache"&gt;ZFS 性能调优&lt;/a&gt;
的重中之重。&lt;/p&gt;
&lt;p&gt;当然， ZFS 采用 ARC 不依赖于内核已有的 pagecache 机制除了 LFU 平衡的好处之外，也有别的有利的一面。
系统中多次读取因 snapshot 或者 dedup 而共享的数据块的话，在 ZFS 的 ARC 机制下，同样的
block pointer 只会被缓存一次；而传统的 pagecache 因为基于 inode 判断是否有共享，
所以即使这些文件有共享页面（比如 btrfs/xfs 的 reflink 形成的），也会多次读入内存。 Linux
的 btrfs 和 xfs 在 VFS 层面有共用的 reflink 机制之后，正在努力着手改善这种局面，而 ZFS
因为 ARC 所以从最初就避免了这种浪费。&lt;/p&gt;
&lt;p&gt;和很多传言所说的不同， ARC 的内存压力问题不仅在 Linux 内核会有，在 FreeBSD 和
Solaris/Illumos 上也是同样，这个在
&lt;a class="reference external" href="https://youtu.be/xMH5rCL8S2k?t=997"&gt;ZFS First Mount by Mark Shellenbaum 的问答环节 16:37 左右有提到&lt;/a&gt;
。其中 Mark Shellenbaum 提到 Matt 觉得让 ARC 并入现有 pagecache
子系统的工作量太大，难以实现。&lt;/p&gt;
&lt;p&gt;因为 ARC 工作在 ZIO 上层，所以 ARC 中缓存的数据是经过 ZIO
从存储设备中读取出来之后解压、解密等处理之后的，原始的数据。最近 ZFS 的版本有支持一种新特性叫
&lt;a class="reference external" href="https://www.illumos.org/issues/6950"&gt;Compressed ARC&lt;/a&gt;
，打破 ARC 和 VDEV 中间 ZIO 的壁垒，把压缩的数据直接缓存在 ARC
中。这么做是因为压缩解压很快的情况下，压缩的 ARC 能节省不少内存，让更多数据保留在 ARC
中从而提升缓存利用率，并且在有 L2ARC 的情况下也能增加 L2ARC 能存储的缓存。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="l2arc"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;L2ARC&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Level 2 Adaptive Replacement Cache&lt;/p&gt;
&lt;p&gt;这是用 ARC 算法实现的二级缓存，保存于高速存储设备上。常见用法是给 ZFS pool 配置一块 SSD
作为 L2ARC 高速缓存，减轻内存 ARC 的负担并增加缓存命中率。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="slog"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;SLOG&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Separate intent LOG&lt;/p&gt;
&lt;p&gt;SLOG 是额外的日志记录设备。 SLOG 之于 ZIL 有点像 L2ARC 之余 ARC ， L2ARC 是把内存中的
ARC 放入额外的高速存储设备，而 SLOG 是把原本和别的数据块存储在一起的 ZIL
放到额外的高速存储设备。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tol"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;TOL&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Transactional Object Layer&lt;/p&gt;
&lt;p&gt;这一部分子系统在数据块的基础上提供一个事务性的对象语义层，这里事务性是指，
对对象的修改处于明确的状态，不会因为突然断电之类的原因导致状态不一致。TOL
中最主要的部分是 DMU 层。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="dmu"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;DMU&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Data Management Unit&lt;/p&gt;
&lt;p&gt;在块的基础上提供「对象（object）」的抽象。每个「对象」可以是一个文件，或者是别的 ZFS 内部需要记录的东西。&lt;/p&gt;
&lt;p&gt;DMU 这个名字最初是 Jeff 想类比于操作系统中内存管理的 MMU(Memory Management Unit)，
Jeff 希望 ZFS 中增加和删除文件就像内存分配一样简单，增加和移除块设备就像增加内存一样简单，
由 DMU 负责从存储池中分配和释放数据块，对上提供事务性语义，管理员不需要管理文件存储在什么存储设备上。
这里事务性语义指对文件的修改要么完全成功，要么完全失败，不会处于中间状态，这靠 DMU 的 CoW
语义实现。&lt;/p&gt;
&lt;p&gt;DMU 实现了对象级别的 CoW 语义，从而任何经过了 DMU 做读写的子系统都具有了 CoW 的特征，
这不仅包括文件、文件夹这些 ZPL 层需要的东西，也包括文件系统内部用的 spacemap 之类的设施。
相反，不经过 DMU 的子系统则可能没法保证事务语义。这里一个特例是 ZIL ，一定程度上绕过了 DMU
直接写日志。说一定程度是因为 ZIL 仍然靠 DMU 来扩展长度，当一个块写满日志之后需要等 DMU
分配一个新块，在分配好的块内写日志则不需要经过 DMU 。所有经过 DMU 子系统的对象都有 CoW
语义，也意味着 ZFS 中不能对某些文件可选地关闭 CoW ，不能提供数据库应用的 direct IO 之类的接口。&lt;/p&gt;
&lt;p&gt;「对象（object）」抽象是 DMU 最重要的抽象，一个对象的大小可变，占用一个或者多个数据块（
默认一个数据块 128KiB ）。上面提到 SPA 的时候也讲了 DMU 和 SPA 之间不同于普通块设备抽象的接口，这使得 DMU
按整块的大小分配空间。当对象使用多个数据块存储时， DMU 提供间接块（indirect block）来引用这些数据块。
间接块很像传统 Unix 文件系统（Solaris UFS 或者 Linux ext2）中的一级二级三级间接块，
一个间接块存储很多块指针（block pointer），多个间接块形成树状结构，最终一个块指针可以引用到一个对象。
更现代的文件系统比如 ext4/xfs/btrfs/ntfs 提供了 extent 抽象，可以指向一个连续范围的存储块，
而 ZFS 不使用类似 extent 的抽象。DMU 采用间接块而不是 extent
，使得 ZFS 的空间分配更趋向碎片化，为了避免碎片化造成的性能影响，需要尽量延迟写入使得一次写入能在磁盘上
尽量连续，这里 ARC 提供的缓存和 ZIO 提供的流水线对延迟写入避免碎片有至关重要的帮助。&lt;/p&gt;
&lt;p&gt;有了「对象（object）」的抽象之后， DMU 进一步实现了「对象集（objectset）」的抽象，
一个对象集中保存一系列按顺序编号的 dnode （ ZFS 中类似 inode 的数据结构），每个 dnode 有足够空间
指向一个对象的最多三个块指针，如果对象需要更多数据块可以使用间接块，如果对象很小也可以直接压缩进
dnode 。随后 DSL 又进一步用对象集来实现数据集（dataset）抽象，提供比如文件系统（filesystem
）、快照（snapshot）、克隆（clone）之类的抽象。一个对象集中的对象可以通过 dnode 编号相互引用，
就像普通文件系统的硬链接引用 inode 编号那样。&lt;/p&gt;
&lt;p&gt;上面也提到因为 SPA 和 DMU 分离， SPA 完全不知道数据块用于什么目的；这一点其实对 DMU 也是类似，
DMU 虽然能从某个对象找到它所占用的数据块，但是 DMU 完全不知道这个对象在文件系统或者存储池中是
用来存储什么的。当 DMU 读取数据遇到坏块（block pointer 中的校验和与 block pointer
指向的数据块内容不一致）时，它知道这个数据块在哪儿（具体哪个设备上的哪个地址），
但是不知道这个数据块是否和别的对象共享，不知道搬动这个数据块的影响，也没法从对象反推出文件系统路径，
（除了明显开销很高地扫一遍整个存储池）。所以 DMU 在遇到读取错误（普通的读操作或者 scrub/resilver
操作中）时，只能选择在同样的地址，原地写入数据块的备份（如果能找到或者推算出备份的话）。&lt;/p&gt;
&lt;p&gt;或许有人会疑惑，既然从 SPA 无法根据数据地址反推出对象，在 DMU 也无法根据对象反推出文件，那么
zfs 在遇到数据损坏时是如何在诊断信息中给出损坏的文件路径的呢？这其实基于 ZPL 的一个黑魔法：
&lt;a class="reference external" href="https://utcc.utoronto.ca/~cks/space/blog/solaris/ZFSPathLookupTrick"&gt;在 dnode 记录父级 dnode 的编号&lt;/a&gt;
。因为是个黑魔法，这个记录不总是对的，所以只能用于诊断信息，不能基于这个实现别的文件系统功能。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="zap"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;ZAP&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ZFS Attribute Processor&lt;/p&gt;
&lt;p&gt;在 DMU 提供的「对象」抽象基础上提供紧凑的 name/value 映射存储，
从而文件夹内容列表、文件扩展属性之类的都是基于 ZAP 来存。 ZAP 在内部分为两种存储表达：
microZAP 和 fatZAP 。&lt;/p&gt;
&lt;p&gt;一个 microZAP 占用一整块数据块，能存 name 长度小于 50 字符并且 value 是 uint64_t 的表项，
每个表项 64 字节。 &lt;del&gt;fatZAP 则是个树状结构，能存更多更复杂的东西。&lt;/del&gt;&lt;ins&gt;fatZAP 是个 on disk 的散利表，指针表中是 64bit 对 name 的 hash ，指向单链表的子节点列表，子节点中的 value 可以是任意类型的数据（不光是 uint64_t ）。&lt;/ins&gt;&lt;/p&gt;
&lt;p&gt;可见 microZAP 非常适合表述一个普通大小的文件夹里面包含到很多普通文件 inode （ZFS 是 dnode）的引用。
&lt;del&gt;&lt;/del&gt;&lt;ins&gt;fatZAP 则不光可以用于任意大小的文件夹，还可以表达 ZFS 的配置属性之类的东西，非常灵活。&lt;/ins&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;a class="reference external" href="https://youtu.be/xMH5rCL8S2k?t=526"&gt;ZFS First Mount by Mark Shellenbaum 的8:48左右&lt;/a&gt;
提到，最初 ZPL 中关于文件的所有属性（包括访问时间、权限、大小之类所有文件都有的）都是基于
ZAP 来存，也就是说每个文件都有个 ZAP ，其中有叫做 size 呀 owner
之类的键值对，就像是个 JSON 对象那样，这让 ZPL 一开始很容易设计原型并且扩展。然后文件夹内容列表有另一种数据结构
ZDS（ZFS Directory Service），后来常见的文件属性在 ZPL 有了专用的紧凑数据结构，而 ZDS 则渐渐融入了 ZAP 。
&lt;del&gt;&lt;/del&gt;&lt;ins&gt;这些变化详见下面 ZPL 。&lt;/ins&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="dsl"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;DSL&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Dataset and Snapshot Layer&lt;/p&gt;
&lt;p&gt;数据集和快照层，负责创建和管理快照、克隆等数据集类型，跟踪它们的写入大小，最终删除它们。
由于 DMU 层面已经负责了对象的写时复制语义和对象集的概念，所以 DSL 层面不需要直接接触写文件之类来自 ZPL
的请求，无论有没有快照对 DMU 层面一样采用写时复制的方式修改文件数据。
不过在删除快照和克隆之类的时候，则需要 DSL 参与计算没有和别的数据集共享的数据块并且删除它们。&lt;/p&gt;
&lt;p&gt;DSL 管理数据集时，也负责管理数据集上附加的属性。ZFS 每个数据集有个属性列表，这些用 ZAP 存储，
DSL 则需要根据数据集的上下级关系，计算出继承的属性，最终指导 ZIO 层面的读写行为。&lt;/p&gt;
&lt;p&gt;除了管理数据集， DSL 层面也提供了 zfs 中 send/receive 的能力。 ZFS 在 send 时从 DSL
层找到快照引用到的所有数据块，把它们直接发往管道，在 receive 端则直接接收数据块并重组数据块指针。
因为 DSL 提供的 send/receive 工作在 DMU 之上，所以在 DSL 看到的数据块是 DMU
的数据块，下层 SPA 完成的数据压缩、加密、去重等工作，对 DMU 层完全透明。所以在最初的
send/receive 实现中，假如数据块已经压缩，需要在 send 端经过 SPA 解压，再 receive
端则重新压缩。最近 ZFS 的 send/receive 逐渐打破 DMU 与 SPA
的壁垒，支持了直接发送已压缩或加密的数据块的能力。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="zil"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;ZIL&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ZFS Intent Log&lt;/p&gt;
&lt;p&gt;记录两次完整事务语义提交之间的日志，用来加速实现 fsync 之类的文件事务语义。&lt;/p&gt;
&lt;p&gt;原本 CoW 的文件系统不需要日志结构来保证文件系统结构的一致性，在 DMU
保证了对象级别事务语义的前提下，每次完整的 transaction group commit
都保证了文件系统一致性，挂载时也直接找到最后一个 transaction group 从它开始挂载即可。
不过在 ZFS 中，做一次完整的 transaction group commit 是个比较耗时的操作，
在写入文件的数据块之后，还需要更新整个 object set ，然后更新 meta-object set
，最后更新 uberblock ，为了满足事务语义这些操作没法并行完成，所以整个 pool
提交一次需要等待好几次磁盘写操作返回，短则一两秒，长则几分钟，
如果事务中有要删除快照等非常耗时的操作可能还要等更久，在此期间提交的事务没法保证一致。&lt;/p&gt;
&lt;p&gt;对上层应用程序而言，通常使用 fsync 或者 fdatasync 之类的系统调用，确保文件内容本身的事务一致性。
如果要让每次 fsync/fdatasync 等待整个 transaction group commit
完成，那会严重拖慢很多应用程序，而如果它们不等待直接返回，则在突发断电时没有保证一致性。
从而 ZFS 有了 ZIL ，记录两次 transaction group 的 commit 之间发生的 fsync
，突然断电后下次 import zpool 时首先找到最近一次 transaction group ，在它基础上重放
ZIL 中记录的写请求和 fsync 请求，从而满足 fsync API 要求的事务语义。&lt;/p&gt;
&lt;p&gt;显然对 ZIL 的写操作需要绕过 DMU 直接写入数据块，所以 ZIL 本身是以日志系统的方式组织的，每次写
ZIL 都是在已经分配的 ZIL 块的末尾添加数据，分配新的 ZIL 块仍然需要经过 DMU
的空间分配。&lt;/p&gt;
&lt;p&gt;传统日志型文件系统中对 data 开启日志支持会造成每次文件系统写入操作需要写两次到设备上，
一次写入日志，再一次覆盖文件系统内容；在
ZIL 实现中则不需要重复写两次， DMU 让 SPA 写入数据之后 ZIL 可以直接记录新数据块的
block pointer ，所以使用 ZIL 不会导致传统日志型文件系统中双倍写入放大的问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="zvol"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id18"&gt;ZVOL&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ZFS VOLume&lt;/p&gt;
&lt;p&gt;有点像 loopback block device ，暴露一个块设备的接口，其上可以创建别的
FS 。对 ZFS 而言实现 ZVOL 的意义在于它是比文件更简单的接口，所以在实现完整 ZPL
之前，一开始就先实现了 ZVOL ，而且
&lt;a class="reference external" href="https://youtu.be/xMH5rCL8S2k?t=298"&gt;早期 Solaris 没有 thin provisioning storage pool 的时候可以用 ZVOL 模拟很大的块设备，当时 Solaris 的 UFS 团队用它来测试 UFS 对 TB 级存储的支持情况&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;因为 ZVOL 基于 DMU 上层，所以 DMU 所有的文件系统功能，比如 snapshot / dedup / compression
都可以用在 ZVOL 上，从而让 ZVOL 上层的传统文件系统也具有类似的功能。并且 ZVOL 也具有了 ARC
缓存的能力，和 dedup 结合之下，非常适合于在一个宿主机 ZFS
上提供对虚拟机文件系统镜像的存储，可以节省不少存储空间和内存占用开销。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="zpl"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id19"&gt;ZPL&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ZFS Posix Layer&lt;/p&gt;
&lt;p&gt;提供符合 POSIX 文件系统语义的抽象，也就是包括文件、目录、软链接、套接字这些抽象以及
inode 访问时间、权限那些抽象，ZPL 是 ZFS 中对一个普通 FS 而言用户直接接触的部分。
ZPL 可以说是 ZFS 最复杂的子系统，也是 ZFS 作为一个文件系统而言最关键的部分。&lt;/p&gt;
&lt;p&gt;ZPL 的实现中直接使用了 ZAP 和 DMU 提供的抽象，比如每个 ZPL 文件用一个 DMU 对象表达，每个
ZPL 目录用一个 ZAP 对象表达，然后 DMU 对象集对应到 ZPL 下的一个文件系统。
也就是说 ZPL 负责把操作系统 VFS 抽象层的那些文件系统操作接口，翻译映射到基于 DMU 和 ZAP
的抽象上。传统 Unix 中的管道、套接字、软链接之类的没有什么数据内容的东西则在 ZPL 直接用 dnode
实现出来。 ZPL 也需要进一步实现文件权限、所有者、访问日期、扩展属性之类杂七杂八的文件系统功能。&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2020年2月9日添加&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;继续上述 ZAP 格式变化的讨论，在 ZPL 抛弃早期用 ZAP 的设计之后， ZPL 中 znode （ZPL 扩展的 dnode）
保存文件属性的机制成为了一个小的子系统，叫
&lt;a class="reference external" href="https://github.com/illumos/illumos-gate/blob/master/usr/src/uts/common/fs/zfs/sa.c"&gt;ZFS System Attributes&lt;/a&gt;
。 SA 的设计照顾了旧版 ZPL znode 格式兼容问题，有新旧两代格式。旧版 znode
格式是固定偏移位置存取属性的 SA ，因此透过预先注册好的描述旧版 znode 格式的固定映射表，
SA 依然能用同样的代码路径存取旧版的 znode 。而后来
&lt;a class="reference external" href="https://utcc.utoronto.ca/~cks/space/blog/solaris/ZFSSystemAttributes"&gt;灵活的新设计下的 SA 更有意思&lt;/a&gt;
，ZFS 认识到，大部分 znode 的属性都可以用有限的几种属性集来表达，
比如普通文件有一组类似的属性（权限、所有者之类的）， zvol 有另一组（明显 zvol 不需要很多 ZPL
文件的属性），整个 ZFS dataset 可以「注册」几种属性布局，然后让每个 znode 引用其中一种布局，
这样 znode 保存的属性仍然是可以任意变化的，又不需要在每个 znode 中都记录所有属性的名字。
SA 的出现提升了 ZPL 的可扩展性。 ZPL 为了应付不同的操作系统之间文件系统 API 的差异，可以使用
SA 在 znode 之中加入针对不同操作系统和应用场景的属性。例如，在支持 NFSv4 ACL 的操作系统上，ZFS
既可以用现有方式把 DACL ACEs 放在独立于文件对象的单独对象中，也可以把 DACL ACEs 放在 SA 内。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://youtu.be/xMH5rCL8S2k?t=456"&gt;在 ZFS First Mount by Mark Shellenbaum&lt;/a&gt;
中介绍了很多在最初实现 ZPL 过程中的坎坷， ZPL 的困难之处在于需要兼容现有应用程序对传统文件系统
API 的使用方式，所以他们需要大量兼容性测试。视频中讲到非常有意思的一件事是， ZFS
在设计时不想重复 Solaris UFS 设计中的很多缺陷，于是实现 VFS API 时有诸多取舍和再设计。
其中他们遇到了 &lt;code class="code"&gt;
VOP_RWLOCK&lt;/code&gt;
 ，这个是 UFS 提供的文件级别读写锁。对一些应用尤其是
NFS 而言，文件读写锁能保证应用层的一致性，而对另一些应用比如数据库而言，
文件锁的粒度太大造成了性能问题。在设计 ZPL 的时候他们不想在 ZFS 中提供 &lt;code class="code"&gt;
VOP_RWLOCK&lt;/code&gt;

，这让 NFS 开发者们很难办（要记得 NFS 也是 Solaris 对 Unix 世界贡献的一大发明）。
最终 ZFS 把 DMU 的内部细节也暴露给了 NFS ，让 NFS 基于 DMU 的对象创建时间（ TXG id
）而不是文件锁来保证 NFS 的一致性。结果是现在 ZFS 中也有照顾 NFS 的代码，后来也加入了
Samba/CIFS 的支持，从而在 ZFS 上设置 NFS export 时是通过 ZFS 的机制而非系统原生的 NFS
export 机制。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="FS笔记"></category><category term="FS notes"></category><category term="zfs"></category><category term="layered"></category><category term="architecture"></category><category term="SPA"></category><category term="DMU"></category><category term="ZPL"></category><category term="ZIO"></category><category term="VDEV"></category><category term="ARC"></category><category term="ZAP"></category><category term="DSL"></category><category term="ZIL"></category><category term="ZVOL"></category></entry><entry><title>用 usbip 转发 raspberry pi 的 USB 键盘鼠标给 Arch Linux 的 PC</title><link href="//farseerfc.me/zhs/usbip-forward-raspberrypi.html" rel="alternate"></link><published>2019-02-07T02:14:00+09:00</published><updated>2019-02-07T02:14:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2019-02-07:/zhs/usbip-forward-raspberrypi.html</id><summary type="html">&lt;p&gt;惠狐 &lt;a class="reference external" href="/links.html#megumifox"&gt;megumifox&lt;/a&gt; 写了篇 &lt;a class="reference external" href="https://blog.megumifox.com/public/2019/02/06/%E7%94%A8pulseaudio%E5%B0%86%E7%94%B5%E8%84%91%E7%9A%84%E5%A3%B0%E9%9F%B3%E7%94%A8%E6%89%8B%E6%9C%BA%E6%94%BE%E5%87%BA%E6%9D%A5/"&gt;用PulseAudio将电脑的声音用手机放出来&lt;/a&gt;
，文末提到想知道我怎么用树莓派转发 USB 的，于是写篇文章记录一下。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;起因&lt;/h2&gt;
&lt;p&gt;家里有个装了 Arch Linux ARM 的树莓派3B 闲置着，装了 Arch Linux ARM 偶尔上电更新一下，
不过因为性能实在不适合做别的事情于是一直在吃灰。某日 &lt;del&gt;给老婆安利幻想万华镜&lt;/del&gt;&lt;ins&gt;和老婆看片&lt;/ins&gt;
的时候， &lt;del&gt;老婆不吃安利于是迁怒键盘鼠标&lt;/del&gt;&lt;ins&gt;键盘鼠标被长长的 USB 线扯着感觉很难受&lt;/ins&gt;
，于是偶发奇想，能不能利用一下树莓派的多达 4 个 USB 2.0 端口接鼠标键盘呢，
这样鼠标键盘就可以跟着树莓派来回走，不用拖着长长的 USB 线了。&lt;/p&gt;
&lt;p&gt;上网搜了一下， Linux 环境有个 usbip 工具正好能做到这个。原理也很直观， usbip 能把 USB …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;惠狐 &lt;a class="reference external" href="/links.html#megumifox"&gt;megumifox&lt;/a&gt; 写了篇 &lt;a class="reference external" href="https://blog.megumifox.com/public/2019/02/06/%E7%94%A8pulseaudio%E5%B0%86%E7%94%B5%E8%84%91%E7%9A%84%E5%A3%B0%E9%9F%B3%E7%94%A8%E6%89%8B%E6%9C%BA%E6%94%BE%E5%87%BA%E6%9D%A5/"&gt;用PulseAudio将电脑的声音用手机放出来&lt;/a&gt;
，文末提到想知道我怎么用树莓派转发 USB 的，于是写篇文章记录一下。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;起因&lt;/h2&gt;
&lt;p&gt;家里有个装了 Arch Linux ARM 的树莓派3B 闲置着，装了 Arch Linux ARM 偶尔上电更新一下，
不过因为性能实在不适合做别的事情于是一直在吃灰。某日 &lt;del&gt;给老婆安利幻想万华镜&lt;/del&gt;&lt;ins&gt;和老婆看片&lt;/ins&gt;
的时候， &lt;del&gt;老婆不吃安利于是迁怒键盘鼠标&lt;/del&gt;&lt;ins&gt;键盘鼠标被长长的 USB 线扯着感觉很难受&lt;/ins&gt;
，于是偶发奇想，能不能利用一下树莓派的多达 4 个 USB 2.0 端口接鼠标键盘呢，
这样鼠标键盘就可以跟着树莓派来回走，不用拖着长长的 USB 线了。&lt;/p&gt;
&lt;p&gt;上网搜了一下， Linux 环境有个 usbip 工具正好能做到这个。原理也很直观， usbip 能把 USB
端口上的数据封装成 IP 协议通过网络转发出去，从而两个网络间相互联通的电脑就可以远程转发 USB 了。
设置好的话，就像是一台 PC 多了几个位于树莓派上的 USB 端口，插上树莓派的 USB 设备统统作为 PC
的设备。&lt;/p&gt;
&lt;p&gt;这篇文章假设有一个装了 Arch Linux 的 PC ，和一个装了 Arch Linux ARM 的树莓派，
并且两者间能通过网络互相访问到。别的发行版上大概也可以这么做，只是我没有试过。 usbip
工具似乎普遍被发行版打包了，除此之外需要的也只是 Linux 内核提供好的功能而已。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="arch-linux-arm"&gt;
&lt;h2&gt;设置 Arch Linux ARM 的树莓派端&lt;/h2&gt;
&lt;p&gt;假设树莓派上面网络已经设置妥当，开机插电就能自动联网。接下来安装 usbip 工具：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo pacman -Syu usbip&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后需要记录一下树莓派的 IP 地址：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ip addr&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;3: wlan0: ......&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;inet 192.168.0.117/24 brd 192.168.0.255 scope global noprefixroute wlan0&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;......&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来给 udev 添加一个规则，当插入 usb 设备的时候，执行我的脚本 usbipall.sh
把 usb 设备通过 usbip 共享出去：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; cat /etc/udev/rules.d/usbipall.rules&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;ACTION=="add", SUBSYSTEM=="usb", RUN+="/usr/bin/bash /usr/local/bin/usbipall.sh"&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个 rules 文件 &lt;a class="reference external" href="https://github.com/farseerfc/dotfiles/blob/master/usbiprpi/usbipall.rules"&gt;可以在我的 dotfiles 里面找到&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;然后规则调用的 usbipall.sh 我这么写的， &lt;a class="reference external" href="https://github.com/farseerfc/dotfiles/blob/master/usbiprpi/usbipall.sh"&gt;文件同样在我的 dotfiles 里面&lt;/a&gt; ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nv"&gt;allusb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;usbip list -p -l&lt;span class="k"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;for&lt;/span&gt; usb in &lt;span class="nv"&gt;$allusb&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="nv"&gt;busid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$usb&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sed &lt;span class="s2"&gt;"s|#.*||g;s|busid=||g"&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"1-1.1"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;then&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="c1"&gt;# ignoring usb ethernet&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;continue&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;fi&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;date -Iseconds&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;: Exporting &lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    usbip &lt;span class="nb"&gt;bind&lt;/span&gt; --busid&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;done&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;)&lt;/span&gt; &amp;gt;&amp;gt;/var/log/usbipall.log &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个脚本做了这样几件事。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;调用 &lt;code class="code"&gt;
usbip list --local&lt;/code&gt;
 列出本地所有 usb 设备。&lt;/li&gt;
&lt;li&gt;针对每个设备&lt;ol class="arabic"&gt;
&lt;li&gt;取出它的 busid&lt;/li&gt;
&lt;li&gt;判断是不是树莓派的 USB 以太网卡，不是的话继续&lt;/li&gt;
&lt;li&gt;通过 &lt;code class="code"&gt;
usbip bind --busid=&lt;/code&gt;
 命令把这个 usb 设备导出到网上&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最后把所有输出记录到 /var/log/usbipall.log 日志里面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;树莓派这边设置就完成了。从此之后插入的 usb 设备就会统统导出出去。&lt;/p&gt;
&lt;p&gt;这里需要注意一下，启用了 udev 规则之后，就没法插键盘鼠标到树莓派上控制它了……我都是从另一端 ssh
上树莓派操作的。如果有什么地方设置错误，可能需要把树莓派的 SD 卡拔下来插到电脑上，删除掉 rules
文件……&lt;/p&gt;
&lt;p&gt;仔细检查设置正确了之后，重新载入 udev 规则，或者重启树莓派：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;#&lt;/span&gt; systemctl restart systemd-udevd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样树莓派这边就设置好了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="arch-linux-pc"&gt;
&lt;h2&gt;设置 Arch Linux 的 PC 端&lt;/h2&gt;
&lt;p&gt;同样假设 PC 这边也已经联网。接下来同样安装 usbip 工具：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo pacman -Syu usbip&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我写了个小脚本去链接树莓派端， &lt;a class="reference external" href="https://github.com/farseerfc/dotfiles/blob/master/usbiprpi/usbiprpi3.sh"&gt;这个文件 usbiprpi3.sh 也在我的 dotfiles&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nv"&gt;rpi3&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"192.168.0.117"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;modprobe vhci-hcd&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nv"&gt;allusb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;usbip list -p -r &lt;span class="nv"&gt;$rpi3&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; cut -d&lt;span class="s2"&gt;":"&lt;/span&gt; -f1 -s &lt;span class="p"&gt;|&lt;/span&gt; sed &lt;span class="s1"&gt;'s|^[ \t]*||;/^$/d'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;for&lt;/span&gt; busid in &lt;span class="nv"&gt;$allusb&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"1-1.1"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;then&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="c1"&gt;# ignoring usb ethernet&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;continue&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;fi&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Attaching &lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    usbip attach --remote&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$rpi3&lt;/span&gt; --busid&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;done&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中脚本第一行填入上面记录下来的树莓派的 IP 地址，接下来脚本做了这么几件事：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;用 modprobe 确认加载 vhci-hcd 通用虚拟键鼠驱动&lt;/li&gt;
&lt;li&gt;用 &lt;code class="code"&gt;
usbip list --remote=&lt;/code&gt;
 列出远程设备上已经导出了的 USB 设备，取出他们的 busid&lt;/li&gt;
&lt;li&gt;对每个设备用 &lt;code class="code"&gt;
usbip attach&lt;/code&gt;
 接上该设备&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后就已经准备妥当，接下来是见证奇迹的时刻：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sleep &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; sudo ./usbiprpi3.sh&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;Attaching 1-1.4.3&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;Attaching 1-1.4.1&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为只有一套键盘鼠标，所以先 sleep 个 10 秒，在此期间快速把键鼠拔下来插到树莓派的 USB 口上去。
如果对自己手速没自信也可以把时间设长一点。然后用 root 权限执行 usbiprpi3.sh 。&lt;/p&gt;
&lt;p&gt;一切正常的话，先能观测插上树莓派的键盘鼠标被树莓派初始化了一下，比如键盘灯会亮，
然后这些设备会被导出出去，从而键盘灯灭掉，然后 10 秒等待结束后他们被远程接到了 PC 端，
又会被初始化一下，同时 PC 端这边会有上述 Attaching 的输出。然后键盘鼠标就能像平常一样用啦。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;使用体验&lt;/h2&gt;
&lt;p&gt;因为就是通过 IP 转发 USB 嘛，所以就和普通地接 USB 的体验差不多，当然前提是网络环境足够稳定。
在我家间隔 5 米到无线路由器的环境下，基本感觉不到网络延迟的影响。
通过这种方式聊天上网应该和直接接 USB 设备完全一样。本文就是在通过树莓派转发的前提下用键盘打字写的。&lt;/p&gt;
&lt;p&gt;不过如果网络负载本身就很大的话，可能会一些延迟，比如我开着 OBS 直播打东方的时候，原本就手残
的我感觉更加手残了……&lt;/p&gt;
&lt;p&gt;试过拿着树莓派在房间到处走，走到无线信号覆盖不到的地方， usbip 会断掉，PC 上的现象就像是 USB
设备被拔下来了……所以如果无线网络不稳的话，可能需要对上面脚本做个循环？不过那样可能会用起来很别扭吧。&lt;/p&gt;
&lt;p&gt;以及，上述操作 usbip 是走 TCP 3240 端口，数据包大概完全没有加密，所以考虑安全性的话，
最好还是在内网环境使用。不过转念一想，万一有别人接上了我导出出去的 USB ，也就是截获我的键盘，
PC 这边没法 attach 设备了，应该马上会发现吧。我敲打 sudo 之类命令的时候 shell 里面没有回显，
就不会再继续敲密码了。而且似乎对攻击者也没有什么好处？要是他 usb attach 到了我的设备上，
我就能控制他的键盘了耶~&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="linux"></category><category term="archlinux"></category><category term="raspberrypi"></category><category term="usbip"></category><category term="usb"></category><category term="forward"></category></entry><entry><title>【译】使用 GNU stow 管理你的点文件</title><link href="//farseerfc.me/zhs/using-gnu-stow-to-manage-your-dotfiles.html" rel="alternate"></link><published>2018-12-08T03:35:00+09:00</published><updated>2018-12-08T03:35:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2018-12-08:/zhs/using-gnu-stow-to-manage-your-dotfiles.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;译注&lt;/h2&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;这篇是翻译自 &lt;a class="reference external" href="http://brandon.invergo.net/news/2012-05-26-using-gnu-stow-to-manage-your-dotfiles.html"&gt;Brandon Invergo 的博客的英文文章 Using GNU Stow to manage your dotfiles&lt;/a&gt; 。
Brandon Invergo 的博客采用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"&gt;CC-BY-SA 3.0&lt;/a&gt;
授权，因此本文也同样采用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"&gt;CC-BY-SA 3.0&lt;/a&gt;
，不同于其它我写的文章是 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;CC-BY-NC-SA 4.0&lt;/a&gt;
授权。&lt;/p&gt;
&lt;p&gt;我自己已经使用此文中介绍的方案管理 &lt;a class="reference external" href="https://git.io/fcdots"&gt;我自己的 dotfiles&lt;/a&gt;
快 3 年了。最早想采用这样的管理方案是为了方便在多台 Arch Linux 系统之间同步配置，
后来逐渐主力系统也更新换代了一次，又同步到了自己的 vps 上去，目前管理多个 Arch Linux
上都多少都有这套配置。甚至装好 Arch Linux 添加好用户最初做的事情就是安装 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;译注&lt;/h2&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;这篇是翻译自 &lt;a class="reference external" href="http://brandon.invergo.net/news/2012-05-26-using-gnu-stow-to-manage-your-dotfiles.html"&gt;Brandon Invergo 的博客的英文文章 Using GNU Stow to manage your dotfiles&lt;/a&gt; 。
Brandon Invergo 的博客采用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"&gt;CC-BY-SA 3.0&lt;/a&gt;
授权，因此本文也同样采用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"&gt;CC-BY-SA 3.0&lt;/a&gt;
，不同于其它我写的文章是 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;CC-BY-NC-SA 4.0&lt;/a&gt;
授权。&lt;/p&gt;
&lt;p&gt;我自己已经使用此文中介绍的方案管理 &lt;a class="reference external" href="https://git.io/fcdots"&gt;我自己的 dotfiles&lt;/a&gt;
快 3 年了。最早想采用这样的管理方案是为了方便在多台 Arch Linux 系统之间同步配置，
后来逐渐主力系统也更新换代了一次，又同步到了自己的 vps 上去，目前管理多个 Arch Linux
上都多少都有这套配置。甚至装好 Arch Linux 添加好用户最初做的事情就是安装 stow git
然后 clone 了我自己的 dotfiles repo 下来，然后按需取想要的配置，快捷方便有效。&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;p&gt;废话不多说，下面是原文和翻译。与之前的翻译一样，正文部分给出原文引用以便对照参考。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;使用 GNU stow 管理你的点文件&lt;/h2&gt;
&lt;a aria-controls="8b1882fc" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#8b1882fc" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="8b1882fc"&gt;
&lt;blockquote&gt;
I accidentally stumbled upon something yesterday that I felt like sharing,
which fell squarely into the "why the hell didn't I know about this before?"
category. In this post, I'll describe how to manage the various
configuration files in your GNU/Linux home directory
(aka "dotfiles" like .bashrc) using GNU Stow.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;我昨天偶然间发现一些我觉得值得分享的经验，就是那种「为毛我没有早点知道这个？」那一类的。
我将在这篇文章中介绍如何使用 GNU Stow 管理你的 GNU/Linux 系统中位于用户家目录里的各种配置文件
（通常又叫「点文件(dotfiles)」比如 .bashrc）。&lt;/p&gt;
&lt;a aria-controls="71af1930" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#71af1930" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="71af1930"&gt;
&lt;blockquote&gt;
The difficulty is that it would be helpful to manage one's configuration
files with a version control system like Git, Mercurial or Bazaar, but
many/most dotfiles reside at the top-level of your home directory,
where it wouldn't be a good idea to initialize a VCS repository.
Over time I've come across various programs which aim to manage this
for you by keeping all the files in a subdirectory and then installing or
linking them into their appropriate places. None of those programs ever
really appealed to me. They would require a ton of dependencies
(like Ruby and a ton of libraries for it) or they would require me to
remember how to use them, which is difficult when really for such a task
you rarely use the program.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;这件事的困难之处在于，如果能用版本管理系统(VCS, Version Control System)比如
Git, Mercurial(hg), Bazaar(bzr)
管理点文件的话会非常方便，但是这些点文件大部分都位于家目录的顶级目录下，
在这个位置不太适合初始化一个版本管理仓库。这些年下来我试过很多程序，设计目的在于解决这个问题，
帮你把这些配置文件安置在某个下级目录中，然后安装或者链接这些文件到它们应该在的位置。
尝试下来这些程序没有一个真正能打动我。它们要么有很多依赖（比如 Ruby 和一大坨库），
要么需要我记住如何用它，考虑到同步配置这种不算经常使用的场合，要记住用法真的挺难。&lt;/p&gt;
&lt;a aria-controls="f79eff90" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#f79eff90" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="f79eff90"&gt;
&lt;blockquote&gt;
Lately I've been using GNU Stow to manage programs I install from source to
/usr/local/. Basically, in this typical usage, you install locally built
packages to /usr/local/stow/${PKGNAME}-{PKGVERSION} and then
from /usr/local/stow/ you run # stow ${PKGNAME}-${PKGVERSION} and the
program generates symbolic links to all the programs' files into the
appropriate places under /usr/local/. Then, when you uninstall a program
via Stow, you don't have to worry about any stray files that you or a
provide Makefile may have missed. It also makes handling alternate versions
of a program quite easy (i.e. when I'm experimenting with different
configurations of dwm or st).&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;最近我在用 GNU Stow 来管理我从源代码在本地编译安装到 &lt;code class="code"&gt;
/​usr/​local/​&lt;/code&gt;
 中的一些程序。
基本上说，在这种常见用法下，是你把这些本地编译的包配置安装到
&lt;code class="code"&gt;
/​usr/​local/​stow/​${PKGNAME}-{PKGVERSION}&lt;/code&gt;
 这样的位置，然后在
&lt;code class="code"&gt;
/​usr/​local/​stow/​&lt;/code&gt;
 目录中执行 &lt;code class="code"&gt;
# stow ${PKGNAME}-${PKGVERSION}&lt;/code&gt;

，然后它就会为程序所有的文件创建符号链接放在 &lt;code class="code"&gt;
/​usr/​local&lt;/code&gt;

中合适的地方。然后当你想用 Stow 卸载这个程序的时候，就不必再考虑会留下什么垃圾文件，
或者找不到安装时用的 Makefile 了。这种安装方式下也可以非常容易地切换一个程序的不同版本
（比如我想尝试不同配置选项下的 &lt;a class="reference external" href="https://dwm.suckless.org/"&gt;dwm&lt;/a&gt; 或者
&lt;a class="reference external" href="https://st.suckless.org/"&gt;st&lt;/a&gt; 的时候）。&lt;/p&gt;
&lt;a aria-controls="de09a7d8" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#de09a7d8" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="de09a7d8"&gt;
&lt;blockquote&gt;
Some time ago I happened across a mailing list posting where someone
described using Stow to manage the installation of their dotfiles.
I didn't pay much attention to it but my brain must have filed it away
for later. Yesterday I decided to give it a try and I have to say that
it is so much more convenient than those other dedicated dotfile-management
programs, even if it wasn't an immediately obvious option.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;前段时间在我扫邮件列表的时候，看到某个帖子中某人在说使用 Stow 管理安装他的点文件。
当时我没特别在意这个帖子，但是大概我大脑潜意识把它归档保存为今后阅读了。
昨天我想起来试试这种用法，试过后我不得不说，这比那些专门设计用来做这任务的点文件管理器要方便太多了，
虽然表面上看起来这种用法没那么显而易见。&lt;/p&gt;
&lt;a aria-controls="2e827562" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#2e827562" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="2e827562"&gt;
&lt;blockquote&gt;
The procedure is simple. I created the ${HOME}/dotfiles directory and then
inside it I made subdirectories for all the programs whose cofigurations
I wanted to manage. Inside each of those directories, I moved in all the
appropriate files, maintaining the directory structure of my home directory.
So, if a file normally resides at the top level of your home directory,
it would go into the top level of the program's subdirectory.
If a file normally goes in the default ${XDG_CONFIG_HOME}/${PKGNAME}
location (${HOME}/.config/${PKGNAME}), then it would instead go in
${HOME}/dotfiles/${PKGNAME}/.config/${PKGNAME} and so on.
Finally, from the dotfiles directory, you just run $ stow $PKGNAME and
Stow will symlink all the package's configuration files to the appropriate
locations. It's then easy to make the dotfiles a VCS repository so you can
keep track of changes you make (plus it makes it so much easier to share
configurations between different computers, which was my main reason to
do it).&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;方法很简单。我建了个 &lt;code class="code"&gt;
${HOME}/​dotfiles&lt;/code&gt;
 文件夹，然后在里面为我想管理的每个程序配置都
创建一个子文件夹。然后我把这些程序的配置从原本的家目录移动到这每一个对应的子文件夹中，
并保持它们在家目录中的文件夹结构。比如，如果某个文件原本应该位于家目录的顶层文件夹里，
那它现在应该放在这个程序名子目录的顶层文件夹。如果某个配置文件通常应该位于默认的
&lt;code class="code"&gt;
${XDG_CONFIG_HOME}/​${PKGNAME}&lt;/code&gt;
 位置 (&lt;code class="code"&gt;
${HOME}/​.config/​${PKGNAME}&lt;/code&gt;
)，
那么现在它应该放在 &lt;code class="code"&gt;
${HOME}/​dotfiles/​${PKGNAME}/​.config/​${PKGNAME}&lt;/code&gt;

，如此类推。然后在那个 dotfiles 文件夹里面，直接运行 &lt;code class="code"&gt;
$ stow $PKGNAME&lt;/code&gt;
 命令，
Stow 就会为你自动创建这些配置文件的符号链接到合适的位置。接下来就很容易为这个 dotfiles
目录初始化版本管理仓库，从而记录你对这些配置文件做的修改（并且这也可以极度简化在不同电脑之间
共享配置，这也是我想要这么做的主要原因）。&lt;/p&gt;
&lt;a aria-controls="5e0e831d" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#5e0e831d" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="5e0e831d"&gt;
&lt;blockquote&gt;
For example, let's say you want to manage the configuration for Bash,
VIM and Uzbl. Bash has a couple files in the top-level directory;
VIM typically has your .vimrc file on the top-level and a .vim directory;
and Uzbl has files in ${XDG_CONFIG_HOME}/uzbl and ${XDG_DATA_HOME}/uzbl.
So, your home directory looks like this:&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;举个例子，比如说你想管理 Bash, VIM, Uzbl 这三个程序的配置文件。Bash 会在家目录的顶层文件夹
放几个文件； VIM 通常会有在顶层文件夹的 .vimrc 文件和 .vim 目录；然后 Uzbl 的配置位于
&lt;code class="code"&gt;
${XDG_CONFIG_HOME}/​uzbl&lt;/code&gt;
 以及 &lt;code class="code"&gt;
${XDG_DATA_HOME}/​uzbl&lt;/code&gt;

。于是在迁移配置前，你的家目录的文件夹结构应该看起来像这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;home/&lt;/span&gt;
&lt;span class="code-line"&gt;    brandon/&lt;/span&gt;
&lt;span class="code-line"&gt;        .config/&lt;/span&gt;
&lt;span class="code-line"&gt;            uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;        .local/&lt;/span&gt;
&lt;span class="code-line"&gt;            share/&lt;/span&gt;
&lt;span class="code-line"&gt;                uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                    [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;        .vim/&lt;/span&gt;
&lt;span class="code-line"&gt;            [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;        .bashrc&lt;/span&gt;
&lt;span class="code-line"&gt;        .bash_profile&lt;/span&gt;
&lt;span class="code-line"&gt;        .bash_logout&lt;/span&gt;
&lt;span class="code-line"&gt;        .vimrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;a aria-controls="8c2a2e91" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#8c2a2e91" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="8c2a2e91"&gt;
&lt;blockquote&gt;
You would then create a dotfiles subdirectory and move all the files there:&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;然后迁移配置的方式是，应该建一个 dotfiles 子目录，然后像这样移动所有配置文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;home/&lt;/span&gt;
&lt;span class="code-line"&gt;    /brandon/&lt;/span&gt;
&lt;span class="code-line"&gt;        .config/&lt;/span&gt;
&lt;span class="code-line"&gt;        .local/&lt;/span&gt;
&lt;span class="code-line"&gt;            .share/&lt;/span&gt;
&lt;span class="code-line"&gt;        dotfiles/&lt;/span&gt;
&lt;span class="code-line"&gt;            bash/&lt;/span&gt;
&lt;span class="code-line"&gt;                .bashrc&lt;/span&gt;
&lt;span class="code-line"&gt;                .bash_profile&lt;/span&gt;
&lt;span class="code-line"&gt;                .bash_logout&lt;/span&gt;
&lt;span class="code-line"&gt;            uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                .config/&lt;/span&gt;
&lt;span class="code-line"&gt;                    uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                        [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;                .local/&lt;/span&gt;
&lt;span class="code-line"&gt;                    share/&lt;/span&gt;
&lt;span class="code-line"&gt;                        uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                            [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;            vim/&lt;/span&gt;
&lt;span class="code-line"&gt;                .vim/&lt;/span&gt;
&lt;span class="code-line"&gt;                    [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;                .vimrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;a aria-controls="a3ea20b7" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#a3ea20b7" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="a3ea20b7"&gt;
&lt;blockquote&gt;
Then, perform the following commands:&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;然后执行以下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; ~/dotfiles&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; stow bash&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; stow uzbl&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; stow vim&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;a aria-controls="6a03f8ee" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#6a03f8ee" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="6a03f8ee"&gt;
&lt;blockquote&gt;
And, voila, all your config files (well, symbolic links to them) are all
in the correct place, however disorganized that might be, while the actual
files are all neatly organized in your dotfiles directory, which is easily
turned into a VCS repo. One handy thing is that if you use multiple
computers, which may not have the same software installed on them,
you can pick and choose which configurations to install when you need them.
All of your dotfiles are always available in your dotfiles directory,
but if you don't need the configuration for one program, you simply don't
Stow it and thus it does not clutter your home directory.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;然后，瞬间，所有你的配置文件（的符号链接）就安安稳稳地放入了它们该在的地方，无论原本这些目录结构
有多么错综复杂，这样安排之后的 dotfiles 文件夹内的目录结构立刻整理得有条有理，
并且可以很容易地转换成版本控制仓库。非常有用的一点是，如果你有多台电脑，可能这些电脑并没有
安装完全一样的软件集，那么你可以手选一些你需要的软件配置来安装。在你的 dotfiles 文件夹中总是
可以找到所有的配置文件，但是如果你不需要某个程序的某份配置，那你就不对它执行 stow
命令，它就不会扰乱你的家目录。&lt;/p&gt;
&lt;a aria-controls="68a93e12" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#68a93e12" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="68a93e12"&gt;
&lt;blockquote&gt;
Well, that's all there is to it. Hopefully someone else out there finds
this useful! I know I've found it to be a huge help.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;嗯，以上就是整个用法介绍。希望能有别人觉得这个用法有用！我知道对我来说这个非常有帮助。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="linux"></category><category term="dotfiles"></category><category term="stow"></category></entry><entry><title>启用 GitHub Issue 作为博客留言系统</title><link href="//farseerfc.me/zhs/github-issues-as-comments.html" rel="alternate"></link><published>2016-08-07T16:28:00+09:00</published><updated>2016-08-07T16:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2016-08-07:/zhs/github-issues-as-comments.html</id><summary type="html">&lt;p&gt;从今天起本博客将启用 GitHub Issue 作为留言系统。
原本使用的 Disqus 将继续保留一段时间，目前没有关闭的计划。&lt;/p&gt;
&lt;p&gt;换用 GitHub Issue 是计划了好久的事情了，最初重做这个主题的时候就有考虑过。
这个想法的契机是看到了这篇
&lt;a class="reference external" href="http://ivanzuzak.info/2011/02/18/github-hosted-comments-for-github-hosted-blogs.html"&gt;GitHub hosted comments for GitHub hosted blogs&lt;/a&gt;
，然后立马觉得这个想法很符合寄宿在 GitHub Pages 上的博客。
一个限制是要求评论者必须有 GitHub
账户，考虑到我的博客的受众这个要求估计不算太过分。
使用 GitHub Issue 的好处么，比如自带的 GFMD
富文本格式，邮件通知，还有订阅和取消订阅通知，邮件回复，
这些方面都不比第三方留言系统逊色。&lt;/p&gt;
&lt;p&gt;换用 GitHub Issue 另一方面原因是最近听说 Disqus
被部分墙了，想必以后墙也会越来越高。之前曾经试过在这个博客换上多说，
然而效果我并不喜欢，多说喜欢侵入页面加很多奇怪的东西 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;从今天起本博客将启用 GitHub Issue 作为留言系统。
原本使用的 Disqus 将继续保留一段时间，目前没有关闭的计划。&lt;/p&gt;
&lt;p&gt;换用 GitHub Issue 是计划了好久的事情了，最初重做这个主题的时候就有考虑过。
这个想法的契机是看到了这篇
&lt;a class="reference external" href="http://ivanzuzak.info/2011/02/18/github-hosted-comments-for-github-hosted-blogs.html"&gt;GitHub hosted comments for GitHub hosted blogs&lt;/a&gt;
，然后立马觉得这个想法很符合寄宿在 GitHub Pages 上的博客。
一个限制是要求评论者必须有 GitHub
账户，考虑到我的博客的受众这个要求估计不算太过分。
使用 GitHub Issue 的好处么，比如自带的 GFMD
富文本格式，邮件通知，还有订阅和取消订阅通知，邮件回复，
这些方面都不比第三方留言系统逊色。&lt;/p&gt;
&lt;p&gt;换用 GitHub Issue 另一方面原因是最近听说 Disqus
被部分墙了，想必以后墙也会越来越高。之前曾经试过在这个博客换上多说，
然而效果我并不喜欢，多说喜欢侵入页面加很多奇怪的东西，比如用户的头像通常是
http 的……也试过结合新浪微博的评论，而新浪微博越来越封闭，API 也越来越不靠谱。&lt;/p&gt;
&lt;p&gt;使用 GitHub Issue 作为评论的方式比较简单，上面那篇博客里面提到了，代码量不比
加载 Disqus 多多少，而且没有了 iframe 的困扰，唯一麻烦的地方就是要稍微设计一下布局方式让它融入
现有的页面布局。
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/blob/2ea6c9f3227275fe86ddaa75d8fc6496b3b03d8c/templates/includes/comments.html#L32"&gt;我参考上面的实现在这里&lt;/a&gt; 。
这个加载代码使用两个变量加载 Issue Comments ，一个是在 pelicanconf.py 里的
&lt;code class="code"&gt;
GITHUB_REPO&lt;/code&gt;
 ，可以指向任何 Repo ，我指向 farseerfc/farseerfc.github.io
的这个 GitHub Page repo ，另一个变量是每篇文章里需要加上 &lt;code class="code"&gt;
issueid&lt;/code&gt;

的元数据，关连文章到每个 Issue 上。&lt;/p&gt;
&lt;p&gt;还有一个稍微麻烦的事情是现在每写一篇文章之后都要新建一个 issue 了。
手动操作有点累人，于是我 &lt;a class="reference external" href="https://github.com/farseerfc/farseerfc/blob/master/createissue.py"&gt;写了个脚本&lt;/a&gt;
自动搜索 pelican 的 content 文件夹里面文章的 slug 并且对没有 issueid 关连的
文章创建 issue 。&lt;/p&gt;
&lt;p&gt;好啦新的留言系统的外观样式还在测试中，希望大家多留言帮我测试一下！&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2016年8月7日19:30更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;新增了对 GitHub Issue comments 里面
&lt;a class="reference external" href="https://developer.github.com/v3/issues/comments/#reactions-summary"&gt;reactions&lt;/a&gt;
的支持，套用 font-awesome 的图标（似乎没 GitHub 上的图标好看）。这个还属于 GitHub API
的实验性功能，要加入 &lt;code class="code"&gt;
Accept: application/​vnd.github.squirrel-girl-preview&lt;/code&gt;

HTTP 头才能拿到。&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2016年8月7日23:16更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;感谢 @iovxw 的测试让我发现 github 的高亮回复和邮件回复是需要特殊处理的。
高亮回复用上了 &lt;a class="reference external" href="https://github.com/sindresorhus/github-markdown-css"&gt;这里的 CSS&lt;/a&gt;
邮件引言的展开事件直接用 jQuery 做了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;".email-hidden-toggle &amp;gt; a"&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"click"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;preventDefault&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;".email-hidden-reply"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;toggle&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还得注意邮件的回复需要 CSS 里面 &lt;code class="code"&gt;
white-space: pre-wrap&lt;/code&gt;
 。&lt;/p&gt;
</content><category term="tech"></category><category term="pelican"></category><category term="github"></category><category term="pages"></category><category term="issues"></category></entry><entry><title>PacVis: 可视化 pacman 本地数据库</title><link href="//farseerfc.me/zhs/pacvis.html" rel="alternate"></link><published>2016-07-31T03:52:00+09:00</published><updated>2016-07-31T03:52:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2016-07-31:/zhs/pacvis.html</id><summary type="html">
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
PacVis&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Demo of PacVis" class="img-responsive" src="//farseerfc.me/zhs/images/pacvis-first.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pacvis"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;我为什么要做 PacVis&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我喜欢 Arch Linux ，大概是因为唯有 Arch Linux 能给我对整个系统「了如指掌」的感觉。
在 Arch Linux 里我能清楚地知道我安装的每一个包，能知道系统里任何一个文件是来自哪个包，
以及我为什么要装它。或许对 Debian/Fedora/openSUSE 足够熟悉了之后也能做到这两点，
不过他们的细致打包的结果通常是包的数量比 Arch 要多个 3 到 10 倍，并且打包的细节也比 Arch
Linux 简单的 PKGBUILD 要复杂一个数量级。&lt;/p&gt;
&lt;p&gt;每一个装过 Arch Linux 的人大概都知道，装了 Arch Linux 之后得到的系统非常朴素，按照
ArchWiki 上的流程一路走下来的话，最关键的一条命令就是 &lt;code class="code"&gt;
pacstrap /​mnt …&lt;/code&gt;&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
PacVis&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Demo of PacVis" class="img-responsive" src="//farseerfc.me/zhs/images/pacvis-first.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pacvis"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;我为什么要做 PacVis&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我喜欢 Arch Linux ，大概是因为唯有 Arch Linux 能给我对整个系统「了如指掌」的感觉。
在 Arch Linux 里我能清楚地知道我安装的每一个包，能知道系统里任何一个文件是来自哪个包，
以及我为什么要装它。或许对 Debian/Fedora/openSUSE 足够熟悉了之后也能做到这两点，
不过他们的细致打包的结果通常是包的数量比 Arch 要多个 3 到 10 倍，并且打包的细节也比 Arch
Linux 简单的 PKGBUILD 要复杂一个数量级。&lt;/p&gt;
&lt;p&gt;每一个装过 Arch Linux 的人大概都知道，装了 Arch Linux 之后得到的系统非常朴素，按照
ArchWiki 上的流程一路走下来的话，最关键的一条命令就是 &lt;code class="code"&gt;
pacstrap /​mnt base&lt;/code&gt;
 ，
它在 &lt;code class="code"&gt;
/​mnt&lt;/code&gt;
 里作为根调用 &lt;code class="code"&gt;
pacman -S base&lt;/code&gt;
 装上了整个 base 组，
然后就没有然后了。这个系统一开始空无一物，你需要的任何东西都是后来一点点用
&lt;code class="code"&gt;
pacman&lt;/code&gt;
 手动装出来的，没有累赘，按你所需。&lt;/p&gt;
&lt;p&gt;然而时间长了，系统中难免会有一些包，是你装过用过然后忘记了，
然后这些包就堆在系统的角落里，就像家里陈年的老家具，占着地，落着灰。虽然
&lt;code class="code"&gt;
pacman -Qtd&lt;/code&gt;
 能方便地帮你找出所有
&lt;strong&gt;曾经作为依赖被装进来，而现在不被任何包依赖&lt;/strong&gt; 的包，但是对于那些你手动指定的包，
它就无能为力了。&lt;/p&gt;
&lt;p&gt;于是我就一直在找一个工具能帮我梳理系统中包的关系，方便我：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;找出那些曾经用过而现在不需要的包&lt;/li&gt;
&lt;li&gt;找出那些体积大而且占地方的包&lt;/li&gt;
&lt;li&gt;厘清系统中安装了的包之间的关系&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="figure"&gt;
&lt;img alt="Android System Architecture" class="img-responsive" src="//farseerfc.me/zhs/images/Android-System-Architecture.jpg"/&gt;
&lt;p class="caption"&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Android_(operating_system)"&gt;Android 系统架构&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;关于最后一点「厘清包的关系」，我曾经看到过
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Architecture_of_OS_X"&gt;macOS 系统架构图&lt;/a&gt;
和 Android 的系统架构图，对其中的层次化架构印象深刻，之后就一直在想，是否能画出现代
Linux 桌面系统上类似的架构图呢？又或者 Linux 桌面系统是否会展现完全不同的样貌？
从维基百科或者别的渠道能找到 Linux 内核、或者 Linux 图形栈，
或者某个桌面环境的架构，但是没有找到覆盖一整个发行版的样貌的。
于是我便想，能不能从包的依赖关系中自动生成这样一张图呢。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;PacVis的老前辈们&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在开始写 PacVis 之前，我试过一些类似的工具，他们都或多或少能解决一部分我的需要，
又在某些方面有所不足。这些工具成为了 PacVis 的雏形，启发了 PacVis
应该做成什么样子。&lt;/p&gt;
&lt;div class="section" id="pactree"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id13"&gt;pactree&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;pactree 曾经是一个
&lt;a class="reference external" href="https://bbs.archlinux.org/viewtopic.php?id=51795"&gt;独立的项目&lt;/a&gt; ，现在则是
&lt;a class="reference external" href="https://www.archlinux.org/pacman/pactree.8.html"&gt;pacman 的一部分&lt;/a&gt; 了。
从手册页可以看出， pactree 的输出是由某个包开始的依赖树。
加上 &lt;code class="code"&gt;
--graph&lt;/code&gt;
 参数之后 pactree 还能输出
&lt;a class="reference external" href="http://www.graphviz.org/"&gt;dot&lt;/a&gt; 格式的矢量图描述，然后可以用 dot 画出依赖图：&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;code class="code"&gt;
pactree pacvis-git -d3 --graph | dot -Tpng &amp;gt;pacvis-pactree.png&lt;/code&gt;
&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="pactree --graph" class="img-responsive" src="//farseerfc.me/zhs/images/pacvis-pactree.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; pactree pacvis-git -d3&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;pacvis-git&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;├─python-tornado&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│ └─python&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─expat&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─bzip2&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─gdbm&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─openssl&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─libffi&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   └─zlib&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;├─pyalpm&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│ ├─python&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│ └─pacman&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─bash&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─glibc&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─libarchive&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─curl&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─gpgme&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─pacman-mirrorlist&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   └─archlinux-keyring&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;└─python-setuptools&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;  └─python-packaging&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;    ├─python-pyparsing&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;    └─python-six&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt; $&lt;/span&gt; pactree pacvis-git -d3 --graph &lt;span class="p"&gt;|&lt;/span&gt; dot -Tpng &amp;gt;pacvis-pactree.png&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从画出的图可以看出，因为有共用的依赖，所以从一个包开始的依赖关系已经不再是一棵
&lt;a class="reference external" href="https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B"&gt;图论意义上的树(Tree)&lt;/a&gt;
了。最初尝试做 PacVis 的早期实现的时候，就是试图用 bash/python 脚本解析 pactree 和
pacman 的输出，在 pactree 的基础上把整个系统中所有安装的包全都包含到一张图里。
当然后来画出的结果并不那么理想，首先由于图非常巨大，导致 dot
的自动布局要耗费数小时，最后画出的图也过于巨大基本上没法看。&lt;/p&gt;
&lt;p&gt;然而不得不说没有 pactree 就不会有 PacVis ，甚至 pacman 被分离出 alpm
库也和 pactree 用 C 重写的过程有很大关系，而 PacVis 用来查询 pacman 数据库的库
pyalpm 正是 alpm 的 Python 绑定。因为 pactree 的需要而增加出的 alpm 库奠定了 PacVis
实现的基石。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pacgraph"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;pacgraph&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
pacgraph 的输出&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="pacgraph" class="img-responsive" src="//farseerfc.me/zhs/images/pacvis-pacgraph.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="http://kmkeen.com/pacgraph/index.html"&gt;pacgraph&lt;/a&gt; 是一位 Arch Linux 的
Trusted User &lt;a class="reference external" href="http://kmkeen.com/"&gt;keenerd&lt;/a&gt; 写的程序，和
PacVis 一样也是用 Python 实现的。
比起 pactree ， pacgraph 明显更接近我的需求，它默认绘制整个系统的所有安装包，
并且用聪明的布局算法解决了 dot 布局的性能问题。&lt;/p&gt;
&lt;p&gt;pacgraph 的输出是一个富有艺术感的依赖图，图中用不同的字体大小表示出了每个包占用
的磁盘空间。通过观察 pacgraph 的输出，我们可以清楚地把握系统全局的样貌，
比如一眼看出这是个桌面系统还是个服务器系统，并且可以很容易地发现那些占用磁盘空间
巨大的包，考虑清理这些包以节约空间。&lt;/p&gt;
&lt;p&gt;更棒的是 pacgraph 还提供了一个交互性的 GUI 叫做 pacgraph-tk ，显然通过 tk 实现。
用这个 GUI 可以缩放观察整幅图的细节，或者选中某个包观察它和别的包的依赖关系。&lt;/p&gt;
&lt;p&gt;pacgraph 还支持通过参数指定只绘制个别包的依赖关系，就像 pactree 那样。&lt;/p&gt;
&lt;p&gt;不过 pacgraph 也不是完全满足我的需要。如我前面说过，我希望绘制出的图能反应
&lt;strong&gt;这个发行版的架构面貌&lt;/strong&gt; ，而 pacgraph 似乎并不区别「该包依赖的包」和「依赖该包的包」
这两种截然相反的依赖关系。换句话说 pacgraph 画出的是一张无向图，
而我更想要一张有向图，或者说是 &lt;strong&gt;有层次结构的依赖关系图&lt;/strong&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;于是就有了 PacVis&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
PacVis 刚打开的样子&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="PacVis on startup" class="img-responsive" src="//farseerfc.me/zhs/images/pacvis-second.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;总结了老前辈们的优势与不足，我便开始利用空余时间做我心目中的 PacVis 。
前后断断续续写了两个月，又分为两个阶段，第一阶段做了基本的功能和雏形，
第二阶段套用上 &lt;a class="reference external" href="https://getmdl.io/"&gt;https://getmdl.io/&lt;/a&gt; 的模板，总算有了能拿得出手给别人看的样子。&lt;/p&gt;
&lt;p&gt;于是乎前两天在 AUR 上给 pacvis 打了个
&lt;a class="reference external" href="https://aur.archlinux.org/packages/pacvis-git/"&gt;pacvis-git&lt;/a&gt;
包，现在想在本地跑 pacvis 应该很方便了，用任何你熟悉的 aurhelper
就可以安装，也可以直接从 aur 下载 PKGBUILD 打包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;~$ git clone aur@aur.archlinux.org:pacvis-git.git&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;~$ cd pacvis-git&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;~/pacvis-git$ makepkg -si&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;~/pacvis-git$ pacvis&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;Start PacVis at http://localhost:8888/&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照提示说的，接下来打开浏览器访问 &lt;a class="reference external" href="http://localhost:8888/"&gt;http://localhost:8888/&lt;/a&gt; 就能看到 PacVis
的样子了。仅仅作为尝试也可以直接打开跑在我的服务器上的 demo:
&lt;a class="reference external" href="https://pacvis.farseerfc.me/"&gt;https://pacvis.farseerfc.me/&lt;/a&gt; ，这个作为最小安装的服务器载入速度大概比普通的桌面系统快一点。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
在 Windows msys2 跑 PacVis&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="PacVis on Windows msys2" class="img-responsive" src="//farseerfc.me/zhs/images/pacvis-msys2.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;另外补充一下，因为 PacVis 只依赖 pyalpm 和 tornado ，所以在别的基于 pacman
的系统上跑它应该也没有任何问题，包括
&lt;a class="reference external" href="https://msys2.github.io/"&gt;Windows 上的 msys2&lt;/a&gt; 里（尽管在 msys2 上编译
tornado 的包可能要花些功夫）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;PacVis 的图例和用法&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;操作上 PacVis 仿照地图程序比如 Google Maps 的用法，可以用滚轮或者触摸屏的手势
缩放、拖拽，右上角有个侧边栏，不需要的话可以点叉隐藏掉，右下角有缩放的按钮和
回到全局视图的按钮，用起来应该还算直观。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="PacVis showing pacvis-git" class="img-responsive" src="//farseerfc.me/zhs/images/pacvis-pacvis-git.png"/&gt;
&lt;p class="caption"&gt;pacvis-git 包的依赖&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;先解释图形本身，整张图由很多小圆圈的节点，以及节点之间的箭头组成。
一个圆圈就代表一个软件包，而一条箭头代表一个依赖关系。缩放到细节的话，
能看到每个小圆圈的下方标注了这个软件包的名字，鼠标悬浮在圆圈上也会显示相应信息。
还可以点开软件包，在右侧的边栏里会有更详细的信息。&lt;/p&gt;
&lt;p&gt;比如图例中显示了 pacvis-git 自己的依赖，它依赖 pyalpm, python-tornado 和
python-setuptools ，其中 pyalpm 又依赖 pacman 。图中用
&lt;span class="label label-primary"&gt;紫色&lt;/span&gt; 表示手动安装的包，
&lt;span class="label label-warning"&gt;橙色&lt;/span&gt; 表示被作为依赖安装的包，
箭头的颜色也随着包的颜色改变。&lt;/p&gt;
&lt;p&gt;值得注意的是图中大多数箭头都是由下往上指的，这是因为 PacVis 按照包的依赖关系做
了拓扑排序，并且给每个包赋予了一个拓扑层级。比如 pacvis-git 位于 39
层，那么它依赖的 pyalpm 就位于 38 层，而 pyalpm 依赖的 pacman 就位于 37
层。根据层级关系排列包是 PacVis 于 pacgraph 之间最大的不同之处。&lt;/p&gt;
&lt;p&gt;除了手动缩放， PacVis 还提供了搜索框，根据包名快速定位你感兴趣的包。
以及在右侧边栏中的 Dep 和 Req-By 等页中，包的依赖关系也是做成了按钮的形式，
可以由此探索包和包之间的关联。&lt;/p&gt;
&lt;p&gt;最后稍微解释一下两个和实现相关的参数：&lt;/p&gt;
&lt;div class="label label-info"&gt;
Max Level&lt;/div&gt;
&lt;p&gt;这是限制 PacVis 载入的最大拓扑层。系统包非常多的时候 PacVis
的布局算法会显得很慢，限制层数有助于加快载入，特别是在调试 PacVis 的时候比较有用。&lt;/p&gt;
&lt;div class="label label-info"&gt;
Max Required-By&lt;/div&gt;
&lt;p&gt;这是限制 PacVis 绘制的最大被依赖关系。稍微把玩一下 PacVis 就会发现系统内绝大多数
的包都直接依赖了 glibc 或者 gcc-libs 等个别的几个包，而要绘制这些依赖的话会导致
渲染出的图中有大量长直的依赖线，不便观察。于是可以通过限制这个值，使得 PacVis
不绘制被依赖太多的包的依赖关系，有助于让渲染出的图更易观察。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;从 PacVis 能了解到的一些事实&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
一个 KDE 桌面的 PacVis 结果全图， &lt;a class="reference external" href="//farseerfc.me/zhs/images/pacvis-16384.png"&gt;放大（17M）&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="A normal KDE desktop in PacVis" class="img-responsive" src="//farseerfc.me/zhs/images/pacvis-4096-anno.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;稍微玩一下 PacVis 就能发现不少有趣现象，上述「绝大多数包依赖 glibc 」就是一例。
除此之外还有不少值得玩味的地方。&lt;/p&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id18"&gt;依赖层次&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;系统中安装的包被明显地分成了这样几个层次：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;glibc 等 C 库&lt;/li&gt;
&lt;li&gt;Bash/Perl/Python 等脚本语言&lt;/li&gt;
&lt;li&gt;coreutils/gcc/binutils 等核心工具&lt;/li&gt;
&lt;li&gt;pacman / systemd 等较大的系统工具&lt;/li&gt;
&lt;li&gt;gtk{2,3}/qt{4,5} 等 GUI toolkit&lt;/li&gt;
&lt;li&gt;chromium 等 GUI 应用&lt;/li&gt;
&lt;li&gt;Plasma/Gnome 等桌面环境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大体上符合直观的感受，不过细节上有很多有意思的地方，比如 zsh 因为 gdbm
间接依赖了 bash，这也说明我们不可能在系统中用 zsh 完全替代掉 bash。
再比如 python （在 Arch Linux 中是 python3）和 python2 和 pypy
几乎在同一个拓扑层级。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="zsh depends on bash because of gdbm" class="img-responsive" src="//farseerfc.me/zhs/images/pacvis-zsh-bash.png" style="width: 45%;"/&gt;
&lt;p class="caption"&gt;zsh 因为 gdbm 间接依赖了 bash&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;不过偶尔显示的依赖层级不太符合直观，比如 qt5-base &amp;lt; qt4 &amp;lt; gtk2 &amp;lt; gtk3 。
qt5 因为被拆成了数个包所以比 qt4 更低级这可以理解，而 gtk 系比 qt
系更高级这一点是很多人（包括我）没有预料到的吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;循环依赖&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有些包的依赖关系形成了循环依赖，一个例子是 freetype2 和 harfbuzz，freetype2
是绘制字体的库，harfbuzz 是解析 OpenType 字形的库，两者对对方互相依赖。
另一个例子是 KDE 的 kio 和 kinit，前者提供类似 FUSE 的资源访问抽象层，
后者初始化 KDE 桌面环境。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="freetype2 harfbuzz" class="img-responsive" src="//farseerfc.me/zhs/images/pacvis-freetype2-harfbuzz.png" style="width: 45%;"/&gt;
&lt;p class="caption"&gt;freetype2 和 harfbuzz 之间的循环依赖&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;因为这些循环依赖的存在，使得 PacVis 在实现时不能直接拓扑排序，我采用环探测
算法找出有向图中所有的环，并且打破这些环，然后再使用拓扑排序。
因此我在图中用红色的箭头表示这些会导致环的依赖关系。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id20"&gt;有些包没有依赖关系&lt;/a&gt;&lt;/h3&gt;
&lt;div class="figure"&gt;
&lt;img alt="PacVis Level 0" class="img-responsive" src="//farseerfc.me/zhs/images/pacvis-level0.png" style="width: 45%;"/&gt;
&lt;p class="caption"&gt;man-pages 和 licenses 没有依赖关系&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;有些包既不被别的包依赖，也不依赖别的包，而是孤立在整张图中，比如
man-pages 和 licenses 。这些包在图中位于最顶端，拓扑层级是 0 ，我用
&lt;span class="label label-info"&gt;蓝色&lt;/span&gt; 正方形特别绘制它们。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="linux"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id21"&gt;只看依赖关系的话 Linux 内核完全不重要&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;所有用户空间的程序都依赖着 glibc ，而 glibc 则从定义良好的 syscall 调用内核。
因此理所当然地，如果只看用户空间的话， glibc 和别的 GNU 组件是整个 GNU/Linux
发行版的中心，而 Linux 则是位于依赖层次中很深的位置，甚至在我的 demo 服务器上
Linux 位于整个图中的最底端，因为它的安装脚本依赖 mkinitcpio
而后者依赖了系统中的众多组件。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pacman-qtd"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id22"&gt;pacman -Qtd 不能找到带有循环依赖的孤儿包&lt;/a&gt;&lt;/h3&gt;
&lt;div class="figure"&gt;
&lt;img alt="pacman -Qtd cannot find packages with circle dependency" class="img-responsive" src="//farseerfc.me/zhs/images/pacvis-circledeps-Qtd.png" style="width: 45%;"/&gt;
&lt;p class="caption"&gt;msys2 中带有循环依赖的孤儿包&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这是我在 msys2 上测试 PacVis 的时候发现的，我看到在渲染的图中有一片群岛，
没有连上任何手动安装的包。这种情况很不正常，因为我一直在我的所有系统中跑
&lt;code class="code"&gt;
pacman -Qtd&lt;/code&gt;
 找出孤儿包并删掉他们。放大之后我发现这些包中有一条循环依赖，
这说明 &lt;code class="code"&gt;
pacman -Qtd&lt;/code&gt;
 不能像语言的垃圾回收机制那样找出有循环依赖的孤儿包。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id23"&gt;PacVis 的未来&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;目前的 PacVis 基本上是我最初开始做的时候设想的样子，随着开发逐渐又增加了不少功能。
一些是迫于布局算法的性能而增加的（比如限制层数）。&lt;/p&gt;
&lt;p&gt;今后准备再加入以下这些特性：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;更合理的 optdeps 处理。目前只是把 optdeps 关系在图上画出来了。&lt;/li&gt;
&lt;li&gt;更合理的 &lt;strong&gt;依赖关系抉择&lt;/strong&gt; 。有时候包的依赖关系并不是直接根据包名，而是
&lt;code class="code"&gt;
provides&lt;/code&gt;
 由一个包提供另一个包的依赖。目前 PacVis 用 alpm
提供的方式抉择这种依赖，于是这种关系并没有记录在图上。&lt;/li&gt;
&lt;li&gt;目前的层级关系没有考虑包所在的仓库 (core/extra/community/...) 或者包所属的组。
加入这些关系能更清晰地表达依赖层次。&lt;/li&gt;
&lt;li&gt;目前没有办法只显示一部分包的关系。以后准备加入像 pactree/pacgraph 一样显示部分包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你希望 PacVis 出现某些有趣的用法和功能，也
&lt;a class="reference external" href="https://github.com/farseerfc/pacvis/issues"&gt;请给我提 issue&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="python"></category><category term="pacvis"></category><category term="pacman"></category><category term="arch"></category><category term="linux"></category><category term="pacgraph"></category></entry><entry><title>X 中的混成器与 Composite 扩展</title><link href="//farseerfc.me/zhs/compositor-in-X-and-compositext.html" rel="alternate"></link><published>2015-03-19T17:45:00+09:00</published><updated>2015-03-19T17:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-03-19:/zhs/compositor-in-X-and-compositext.html</id><summary type="html">
&lt;p&gt;在上篇文章 &lt;a class="reference external" href="//farseerfc.me/zhs/brief-history-of-compositors-in-desktop-os.html"&gt;「桌面系统的混成器简史」&lt;/a&gt;
中我介绍了其它桌面系统中的混成器的发展史和工作原理，
话题回到我们的正题 Linux 系统上，来说说目前 X 中混成器是如何工作的。
这篇文章将比上一篇深入更多技术细节，不想看太多细节的可以直接跳过看 &lt;a class="reference external" href="#id6"&gt;结论&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="x"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;原始的 X 的绘图模型&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先，没有混成器的时候 X 是这样画图的：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/e06d011e.png"/&gt;
&lt;p&gt;X 的应用程序没有统一的绘图 API 。GTK+ 在 3.0 之后统一用 &lt;a class="reference external" href="http://cairographics.org/"&gt;Cairo&lt;/a&gt; 绘图，
而 Cairo 则是基于 PDF 1.4 的绘图模型构建的，
GTK 的 2.0 和之前的版本中也有很大一部分的绘图是用 Cairo 进行，
其余则通过 xlib 或者 xcb 调用 X 核心协议提供的绘图原语绘图 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
&lt;p&gt;在上篇文章 &lt;a class="reference external" href="//farseerfc.me/zhs/brief-history-of-compositors-in-desktop-os.html"&gt;「桌面系统的混成器简史」&lt;/a&gt;
中我介绍了其它桌面系统中的混成器的发展史和工作原理，
话题回到我们的正题 Linux 系统上，来说说目前 X 中混成器是如何工作的。
这篇文章将比上一篇深入更多技术细节，不想看太多细节的可以直接跳过看 &lt;a class="reference external" href="#id6"&gt;结论&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="x"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;原始的 X 的绘图模型&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先，没有混成器的时候 X 是这样画图的：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/e06d011e.png"/&gt;
&lt;p&gt;X 的应用程序没有统一的绘图 API 。GTK+ 在 3.0 之后统一用 &lt;a class="reference external" href="http://cairographics.org/"&gt;Cairo&lt;/a&gt; 绘图，
而 Cairo 则是基于 PDF 1.4 的绘图模型构建的，
GTK 的 2.0 和之前的版本中也有很大一部分的绘图是用 Cairo 进行，
其余则通过 xlib 或者 xcb 调用 X 核心协议提供的绘图原语绘图。
QT 的情况也是类似，基本上用 QPaint 子系统绘制成位图然后交给 X 的显示服务器。
显示服务器拿到这些绘制请求之后，再在屏幕上的相应位置绘制整个屏幕。
当然还有很多老旧的不用 GTK 或者 QT 的程序，他们则直接调用 X 核心协议提供的绘图原语。&lt;/p&gt;
&lt;p&gt;值得注意一点是 X 上除了没有统一的绘图模型，也没有统一的矢量图格式。
X 核心协议的绘图原语提供的是像素单位的绘图操作，没有类似 GDI+ 或者 Quartz
提供的 &lt;ruby&gt;&lt;rb&gt;设备无关&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Device Independence&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的「点」的抽象。所以只用 X
的绘图原语的话，我们可以把 (1,1) 这个像素点涂黑，但是不能把 (0.5, 0.5)
这个点涂黑，这一设计缺陷在
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix Hater's Handbook&lt;/a&gt;
中已经被吐槽过了。因为这个缺陷，所以直接用 X 绘图原语绘制的图像不能像
矢量图那样进行无损缩放。同样的缺陷导致 X 绘图原语绘制的字符不能做到
&lt;ruby&gt;&lt;rb&gt;子像素级&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;subpixel-level&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; &lt;ruby&gt;&lt;rb&gt;抗锯齿&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;anti-aliasing&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
（这解释了默认配置下的 xterm 和
&lt;a class="reference external" href="http://arch.acgtyrant.com/2015/01/05/I-do-not-recommend-urxvt-again-now/"&gt;urxvt 中的字体渲染为什么难看&lt;/a&gt;
）。相比之下 GDI 有对应的 WMF 矢量图格式， Quartz 有对应的 PDF 矢量图格式，
而 X 中没有这样的格式对应。因为没有统一的矢量图格式，所以无论是 Cairo 、QPaint
还是没有用这些绘图库但是同样在意字体和曲线渲染效果的程序（比如 Firefox 和
Chromium）都需要首先渲染到内部的 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/X_PixMap"&gt;XPixMap&lt;/a&gt;
位图格式，做好子像素渲染和矢量缩放，然后再把渲染好的位图转交给 X 图形服务器。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="composite"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;通过 Composite 扩展重定向窗口输出&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2004年发布的 X11R6.8 版本的 Xorg 引入了
&lt;a class="reference external" href="http://freedesktop.org/wiki/Software/CompositeExt/"&gt;Composite 扩展&lt;/a&gt;
。这个扩展背后的动机以及前因后果在一篇文章
&lt;a class="reference external" href="http://keithp.com/~keithp/talks/xarch_ols2004/xarch-ols2004-html/"&gt;The (Re)Architecture of the X Window System&lt;/a&gt;
中有详细的表述。Composite 扩展允许某个 X 程序做这几件事情：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;通过 &lt;code class="code"&gt;
RedirectSubwindows&lt;/code&gt;
 调用将一个窗口树中的所有窗口渲染重定向到
&lt;ruby&gt;&lt;rb&gt;内部存储&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;off-screen storage&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。重定向的时候可以指定让 X
自动更新窗口的内容到屏幕上或者由混成器手动更新。&lt;/li&gt;
&lt;li&gt;通过 &lt;code class="code"&gt;
NameWindowPixmap&lt;/code&gt;
 取得某个窗口的内部存储。&lt;/li&gt;
&lt;li&gt;通过 &lt;code class="code"&gt;
GetOverlayWindow&lt;/code&gt;
 获得一个特殊的用于绘图的窗口，
在这个窗口上绘制的图像将覆盖在屏幕的最上面。&lt;/li&gt;
&lt;li&gt;通过 &lt;code class="code"&gt;
CreateRegionFromBorderClip&lt;/code&gt;
 取得某个窗口的边界剪裁区域（不一定是矩形）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了 Composite 扩展，一个 X 程序就可以调用这些 API 实现混成器。
这里有篇 &lt;a class="reference external" href="http://www.talisman.org/~erlkonig/misc/x11-composite-tutorial/"&gt;教学解释如何使用 Composite 扩展&lt;/a&gt; 。开启了混成的 X 是这样绘图的：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/18f7774d.png"/&gt;
&lt;p&gt;整个 X 的混成器模型与 Mac OS X 的混成器模型相比，有如下几点显著的区别：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;混成的部分是交由外部的程序完成的，对混成的绘制方式和绘制普通窗口一样。
出于效率考虑，绝大多数 X 上的混成器额外使用了 XRender 扩展或者
OpenGL/EGL 来加速绘制贴图。不过即使如此，还是不能避免同样的位图（内容不一定完全一致，
比如 X 可以在窗口交给它的位图上加上边框然后再返还给混成器） &lt;strong&gt;在不同的三个程序之间来回传递&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code class="code"&gt;
RedirectSubwindows&lt;/code&gt;
 调用针对的是一个窗口树，换句话说是一个窗口
及其全部子窗口，不同于 Mac OS X 中混成器会拿到全部窗口的输出。
这个特点其实并不算是限制，因为 X 中每个虚拟桌面都有一个根窗口，只要指定这个根窗口
就可以拿到整个虚拟桌面上的全部可见窗口输出了。
反而这个设计提供了一定的自由度，比如我们可以用这个调用实现一个截图程序，
拿到某个特定窗口的输出，而不用在意别的窗口。&lt;/li&gt;
&lt;li&gt;为了让窗口有输出，窗口必须显示在当前桌面上，不能处于最小化
状态或者显示在别的虚拟桌面，用 X 的术语说就是窗口必须处于 &lt;ruby&gt;&lt;rb&gt;被映射&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;mapped&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
的状态。因此直接用上述方法 &lt;strong&gt;不能得到没有显示的窗口的输出&lt;/strong&gt; ，比如不能对最小化的窗口
直接实现 Windows 7 中的 Aero Peak 之类的效果。这个限制可以想办法绕开，
比如在需要窗口输出的时候临时把窗口映射到桌面上，拿到输出之后再隐藏起来，
不过要实现这一点需要混成器和窗口管理器相互配合。&lt;/li&gt;
&lt;li&gt;不像 Mac OS X 的基于 OpenGL Surface 的绘图模型是 &lt;ruby&gt;&lt;rb&gt;设备无关&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;device independent&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
的，这里 X 的绘图模型是 &lt;ruby&gt;&lt;rb&gt;设备相关&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;device dependent&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的。
这既是优点也是缺点。从缺点方面而言，显示到 X 的位图输出因为设备相关性，
所以严格对应显示器的点阵，并不适合作为文档格式打印出来。当然无论是 Cairo
还是 QPaint 都提供了到 PostScript 或者 PDF 后端的输出，所以实用层面这个并不构成问题。
设备相关这一点的优点在于，绘制到 XPM 位图的时候，程序和绘图库是能拿到输出设备（显示器）
的特殊属性的，从而绘图库能考虑不同的色彩、分辨率、 DPI 或者
&lt;ruby&gt;&lt;rb&gt;子像素布局&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;subpixel layout&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 这些属性以提供最好的渲染效果。
Mac OS X 10.4 在设计的时候也曾考虑过提供无极缩放的支持，而这种支持到了 Mac OS X
10.5 中就缩水变成了 Retina 的固定 2 倍缩放。这种局面在 X
上没有发生正是因为 X 的绘图模型的这种设备相关性，而 Mac OS X 的混成器采用的
OpenGL Surface 则无视了这些设备相关的属性。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;输入事件的重定向，这可能做到么？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通过上述 Composite 扩展提供的 API ，混成器可以把窗口的 &lt;strong&gt;输出&lt;/strong&gt; 重定向到自己的窗口上。
但是仅仅重定向输出，整个 X 还不处于可用状态，因为 &lt;strong&gt;没有重定向输入&lt;/strong&gt; 。
考虑一下用户试图用鼠标点击某个按钮或者文本框，这时鼠标处于的位置是在 OverlayWindow
上绘制的位置，这个鼠标事件会交给 OverlayWindow ，而用户期待这个事件被发送给他看到的按钮上。&lt;/p&gt;
&lt;p&gt;需要重定向的事件主要有键盘和鼠标事件两大类（暂时先不考虑触摸屏之类的额外输入）。
由于 Composite 扩展并没有直接提供这方面的重定向 API ，这使得输入事件处理起来都比较麻烦，&lt;/p&gt;
&lt;p&gt;假设要重定向键盘事件，混成器需要效仿输入法框架（fcitx, ibus, scim）
那样处理一部分按键事件并把其余事件转给具有输入焦点的程序。
看看现有的输入法框架和诸多程序间的问题，我们就能知道这里的坑有多深。
于是 &lt;strong&gt;大部分 X 的混成器都不处理键盘事件重定向&lt;/strong&gt;
。再来看重定向鼠标事件，这边的坑比重定向键盘事件的坑更多，
因为不像重定向窗口输出那样只需要考虑 &lt;ruby&gt;&lt;rb&gt;顶层&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;top-level&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 窗口，
重定向鼠标输入的时候要考虑所有子窗口（它们有独立的事件队列），
以及要准确记录输入事件事件发生时的键盘组合键状态，还要正确实现 ICCCM/EWMH
中描述的转交窗口焦点的复杂规则，所有这些都已经在 X 中实现过的事情需要重新实现一遍。&lt;/p&gt;
&lt;p&gt;由于坑太多难以实现，所以所有 X 下的混成器的实现方式都是直接忽略这个繁重的任务，
&lt;strong&gt;不重定向输入事件&lt;/strong&gt; 而把它交给 X 处理。具体的实现方式就是通过
&lt;a class="reference external" href="http://freedesktop.org/wiki/Software/FixesExt/"&gt;XFixes&lt;/a&gt;
扩展提供的 &lt;code class="code"&gt;
SetWindowShapeRegion&lt;/code&gt;
 API 将 OverlayWindow 的 &lt;strong&gt;输入区域&lt;/strong&gt;
&lt;code class="code"&gt;
ShapeInput&lt;/code&gt;
 设为空区域，从而忽略对这个 OverlayWindow 的一切鼠标键盘事件。
这样一来对 OverlayWindow 的点击会透过 OverlayWindow 直接作用到底下的窗口上。&lt;/p&gt;
&lt;p&gt;因为选择了不重定向输入事件， X 下的混成器通常会处于以下两种状态：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;选择状态下可以缩放窗口的大小，扭曲窗口的形状，并且可以把窗口绘制在任意想要绘制的位置上
（并不是移动窗口的位置）， &lt;strong&gt;但是不能让用户与窗口的内容交互&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;正常状态下可以让用户与窗口的内容交互，但是
&lt;strong&gt;绘制的窗口位置、大小和形状必须严格地和 X 记录的窗口的位置、大小和形状保持一致&lt;/strong&gt;
。持续时间短暂的动画效果可以允许位置和形状稍有偏差，但是在动画的过程中如果用户点击了
变形缩放过的窗口，那么鼠标事件将发往错误的（ X 记录中的而非显示出的）窗口元素上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以发现这两种状态就直接对应了 Gnome 3 的普通状态和缩略图状态（点击 &lt;ruby&gt;&lt;rb&gt;活动&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Activity&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
或者戳画面左上角之后显示的状态），这也解释了为什么尽管 Gnome 3
的窗口有硕大的关闭按钮，但是在缩略图状态下 Gnome 3 仍然需要给窗口加上额外的关闭按钮：
&lt;strong&gt;因为处于缩略状态下的窗口只是一张画而不能点&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;Composite 扩展的这些限制使得 X 下的混成器目前只能实现 Mac OS X 那样的 Exposé
效果，而不能实现 &lt;a class="reference external" href="//farseerfc.me/zhs/brief-history-of-compositors-in-desktop-os.html#project-looking-glass-3d"&gt;LG3D&lt;/a&gt; 那样直接在 3D 空间中操纵窗口内容。&lt;/p&gt;
&lt;p&gt;解决重定向问题曾经的一缕曙光是 &lt;ruby&gt;&lt;rb&gt;升阳公司&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Sun Microsystems&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 在开发 &lt;a class="reference external" href="//farseerfc.me/zhs/brief-history-of-compositors-in-desktop-os.html#project-looking-glass-3d"&gt;LG3D&lt;/a&gt; 的过程中同时提议过另一个 X
扩展叫做 Event Interception 或者简称 &lt;a class="reference external" href="http://freedesktop.org/wiki/Software/XEvIE/"&gt;XEvIE&lt;/a&gt; ，这个扩展的设计目的就是提供 API
让某个程序接收并操纵全部的键盘和鼠标事件。可惜这个扩展随着升阳公司本身的陨落而
处于无人维护的状态，这一点也在它的官方网页上说明了：&lt;/p&gt;
&lt;blockquote&gt;
It has been suggested that this extension should not be used
because it is broken and maintainerless.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;Composite 扩展的不足&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通过上面的介绍，我们就已经可以看到 Composite 扩展的不足之处了。
总结起来说，主要有两大不足：&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;绘图效率低。因为同样的位图从应用程序传到 Xorg ，再从 Xorg 传到混成器，
最后从混成器再绘制到屏幕上，绕了一个大弯。这就是为什么 Wayland 的开发者在他的slide
&lt;a class="reference external" href="http://people.freedesktop.org/~daniels/lca2013-wayland-x11.pdf"&gt;the real story behind Wayland and X&lt;/a&gt;
里这么说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;and what's the X server? really bad IPC&lt;/p&gt;
&lt;p&gt;那么 X 服务器到底做了什么呢？ 非常糟糕的进程间通讯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;没有重定向输入事件。如果我们要在 X 的混成器里做这个事情，
基本上我们要全部重写一遍 X 已经写好的窗口事件分发逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然同样要重写，为什么不直接重写一遍 X 呢，扔掉那些历史负担，扔掉那些无用的 API
，重新设计可扩展的 API ，做好快速安全的 IPC —— 嗯，重写 X 就是 Wayland 的目的。&lt;/p&gt;
&lt;p&gt;不过这么重写了的 Wayland 还是我们熟悉可爱的 X 么？它有哪些地方变样了？
这将是我下一篇文章的内容。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;附录：扩展阅读&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我自己没有写过窗口管理器，没有写过混成器，没有写过 Wayland
程序，以上说的都是我从互联网上看到的整理出来的内容。写下本文的过程中我参考了这些文章：&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://keithp.com/~keithp/talks/xarch_ols2004/xarch-ols2004-html/"&gt;The (Re)Architecture of the X Window System&lt;/a&gt; 这篇2004年写的文章描述了 Composite
扩展出现的动机和历史，介绍了绘图库的实现情况，涉及了上面所说的那些 X 扩展被用到的情况和可能。
同时这篇文章还展望了很多现在的 X 已然实现了的功能，比如 OpenGL 和 X 的结合方面我们有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/GLX"&gt;GLX&lt;/a&gt; 和 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/AIGLX"&gt;AIGLX&lt;/a&gt;
，比如内核的显卡支持方面我们有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Direct_Rendering_Infrastructure"&gt;DRI&lt;/a&gt; 和 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Mode_setting"&gt;KMS&lt;/a&gt; 。总之这是一篇描述 Linux
桌面未来的发展轨迹的非常有阅读价值的历史文献。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://wingolog.org/archives/2008/07/26/so-you-want-to-build-a-compositor"&gt;so you want to build a compositor&lt;/a&gt; 这是一篇 2008 年写的博文，介绍如何用 Clutter
实现一个最简单的混成器。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.talisman.org/~erlkonig/misc/x11-composite-tutorial/"&gt;Composite tutorial&lt;/a&gt; 这是另一篇介绍如何实现一个简单的混成器的博文，用 Qt 实现，但是同样很底层。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://projects.mini-dweeb.org/projects/unagi"&gt;unagi&lt;/a&gt; 这是一个可用的（但是已经长期没有开发的）类似 xcompmgr 的混成器。这个项目貌似
是一位研究生的硕士毕业设计，同时他公开了硕士学位的毕业论文
&lt;a class="reference external" href="http://projects.mini-dweeb.org/attachments/download/3/report.pdf"&gt;Master thesis: Writing an X compositing manager&lt;/a&gt;
其中也对实现一个简单的混成器做了详尽描述，包括介绍了相关的 X 扩展和调用。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="linux"></category><category term="wayland"></category><category term="xorg"></category><category term="compositor"></category></entry><entry><title>桌面系统的混成器简史</title><link href="//farseerfc.me/zhs/brief-history-of-compositors-in-desktop-os.html" rel="alternate"></link><published>2015-03-19T13:45:00+09:00</published><updated>2015-03-19T13:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-03-19:/zhs/brief-history-of-compositors-in-desktop-os.html</id><summary type="html">
&lt;p&gt;（原本是想写篇关于 Wayland 的文章，后来越写越长感觉能形成一个系列，
于是就先把这篇背景介绍性质的部分发出来了。）&lt;/p&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;Linux 系统上要迎来 Wayland 了，或许大家能从各种渠道打听到 Wayland
是一个混成器，替代 X 作为显示服务器。
那么 &lt;strong&gt;混成器&lt;/strong&gt; 是个什么东西，桌面系统为什么需要它呢？
要理解为什么桌面系统需要 &lt;strong&gt;混成器&lt;/strong&gt; （或者它的另一个叫法，
&lt;ruby&gt;&lt;rb&gt;混成窗口管理器&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Compositing Window Manager&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
），在这篇文章中我想回顾一下历史，
了解一下混成器出现的前因后果。&lt;/p&gt;
&lt;p&gt;首先介绍一下混成器出现前主要的一类窗口管理器，也就是
&lt;ruby&gt;&lt;rb&gt;栈式窗口管理器&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Stacking Window Manager&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的实现方式。&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="label label-warning"&gt;
本文中所有桌面截图来自维基百科，不具有著作权保护。&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;早期的栈式窗口管理器&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
栈式窗口管理器的例子，Windows 3.11 的桌面&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="栈式窗口管理器的例子，Windows 3.11 的桌面" class="img-responsive" src="//farseerfc.me/zhs/images/Windows_3.11_workspace.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;我们知道最初图形界面的应用程序是全屏的，独占整个显示器（现在很多游戏机和手持设备的实现仍旧如此）。
所有程序都全屏并且任何时刻只能看到一个程序的输出，这个限制显然不能满足人们使用计算机的需求，
于是就有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/WIMP_(computing)"&gt;窗口 …&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
&lt;p&gt;（原本是想写篇关于 Wayland 的文章，后来越写越长感觉能形成一个系列，
于是就先把这篇背景介绍性质的部分发出来了。）&lt;/p&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;Linux 系统上要迎来 Wayland 了，或许大家能从各种渠道打听到 Wayland
是一个混成器，替代 X 作为显示服务器。
那么 &lt;strong&gt;混成器&lt;/strong&gt; 是个什么东西，桌面系统为什么需要它呢？
要理解为什么桌面系统需要 &lt;strong&gt;混成器&lt;/strong&gt; （或者它的另一个叫法，
&lt;ruby&gt;&lt;rb&gt;混成窗口管理器&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Compositing Window Manager&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
），在这篇文章中我想回顾一下历史，
了解一下混成器出现的前因后果。&lt;/p&gt;
&lt;p&gt;首先介绍一下混成器出现前主要的一类窗口管理器，也就是
&lt;ruby&gt;&lt;rb&gt;栈式窗口管理器&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Stacking Window Manager&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的实现方式。&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="label label-warning"&gt;
本文中所有桌面截图来自维基百科，不具有著作权保护。&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;早期的栈式窗口管理器&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
栈式窗口管理器的例子，Windows 3.11 的桌面&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="栈式窗口管理器的例子，Windows 3.11 的桌面" class="img-responsive" src="//farseerfc.me/zhs/images/Windows_3.11_workspace.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;我们知道最初图形界面的应用程序是全屏的，独占整个显示器（现在很多游戏机和手持设备的实现仍旧如此）。
所有程序都全屏并且任何时刻只能看到一个程序的输出，这个限制显然不能满足人们使用计算机的需求，
于是就有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/WIMP_(computing)"&gt;窗口&lt;/a&gt;
的概念，有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Desktop_metaphor"&gt;桌面隐喻&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;在 &lt;ruby&gt;&lt;rb&gt;桌面隐喻&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Desktop Metaphor&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 中每个窗口只占用显示面积的一小部分，
有其显示的位置和大小，可以互相遮盖。于是栈式窗口管理器就是在图形界面中实现桌面隐喻的核心功能，
其实现方式大体就是：给每个窗口一个相对的“高度”或者说“远近”，比较高的窗口显得距离用户比较近，
会覆盖其下比较低的窗口。绘图的时候窗口管理器会从把窗口按高低排序，按照从低到高的顺序使用
&lt;a class="reference external" href="http://zh.wikipedia.org/wiki/%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95"&gt;画家算法&lt;/a&gt;
绘制整个屏幕。&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;p&gt;这里还要补充一点说明，在当时图形界面的概念刚刚普及的时候，绘图操作是非常“昂贵”的。
可以想象一下 800x600 像素的显示器输出下，每帧
&lt;a class="reference external" href="http://zh.wikipedia.org/wiki/%E7%9C%9F%E5%BD%A9%E8%89%B2"&gt;真彩色&lt;/a&gt;
位图就要占掉 &lt;span class="math"&gt;\(800 \times 600 \times 3 \approx 1.4 \text{MiB}\)&lt;/span&gt; 的内存大小，30Hz
的刷新率（也就是30FPS）下每秒从 CPU 传往绘图设备的数据单单位图就需要
&lt;span class="math"&gt;\(1.4 \times 30 = 41 \text{MiB}\)&lt;/span&gt; 的带宽。对比一下当时的
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/VESA_Local_Bus"&gt;VESA 接口&lt;/a&gt; 总的数据传输能力也就是
&lt;span class="math"&gt;\(25 \text{MHz} \times 32 \text{bits} = 100 \text{MiB/s}\)&lt;/span&gt; 左右，
而 Windows 3.1 的最低内存需求是 1MB，对当时的硬件而言无论是显示设备、内存或是CPU，
这无疑都是一个庞大的负担。&lt;/p&gt;
&lt;p&gt;于是在当时的硬件条件下采用栈式窗口管理器有一个巨大 &lt;strong&gt;优势&lt;/strong&gt; ：如果正确地采用画家算法，
并且合理地控制重绘时 &lt;strong&gt;只绘制没有被别的窗口覆盖的部分&lt;/strong&gt; ，那么无论有多少窗口互相
遮盖，都可以保证每次绘制屏幕的最大面积不会超过整个显示器的面积。
同样因为实现方式栈式窗口管理器也有一些难以回避的 &lt;strong&gt;限制&lt;/strong&gt; ：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;窗口必须是矩形的，不能支持不规则形状的窗口。&lt;/li&gt;
&lt;li&gt;不支持透明或者半透明的颜色。&lt;/li&gt;
&lt;li&gt;为了优化效率，在缩放窗口和移动窗口的过程中，窗口的内容不会得到重绘请求，
必须等到缩放或者移动命令结束之后窗口才会重绘。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上这些限制在早期的 X11 窗口管理器比如 twm 以及 XP 之前经典主题的 Windows
或者经典的 Mac OS 上都能看到。
在这些早期的窗口环境中，如果你拖动或者缩放一个窗口，那么将显示变化后的窗口边界，
这些用来预览的边界用快速的位图反转方式绘制。当你放开鼠标的时候才会触发窗口的
重绘事件。
虽然有很多方法或者说技巧能绕过这些限制，比如 Windows XP 上就支持了实时的
重绘事件和不规则形状的窗口剪裁，不过这些技巧都是一连串的 hack ，难以扩展。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nextstep-mac-os-x"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;NeXTSTEP 与 Mac OS X 中混成器的发展&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
NeXTSTEP 桌面&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="NeXTSTEP 桌面" class="img-responsive" src="//farseerfc.me/zhs/images/NeXTSTEP_desktop.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;转眼进入了千禧年， Windows 称霸了 PC 产业，苹果为重振 Macintosh 请回了 Jobs 基于 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/NeXTSTEP"&gt;NeXTSTEP&lt;/a&gt;
开发 Mac OSX 。&lt;/p&gt;
&lt;p&gt;NeXTSTEP 在当时提供的 GUI 界面技术相比较于同年代的 X 和 Windows 有一个很特别的地方：
拖动滚动条或者移动窗口的时候，窗口的内容是 &lt;strong&gt;实时更新&lt;/strong&gt; 的，这比只显示一个缩放大小的框框来说被认为更直观。
而实现这个特性的基础是在 NeXTSTEP 中运用了
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Display_PostScript"&gt;Display PostScript (DPS)&lt;/a&gt;
技术，简单地说，就是每个窗口并非直接输出到显示设备，而是把内容输出到 (Display) PostScript
格式交给窗口管理器，然后窗口管理器再在需要的时候把 PostScript 用软件解释器解释成位图显示在屏幕上。&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/8d293c10.png"/&gt;
&lt;p&gt;比起让窗口直接绘制，这种方案在滚动和移动窗口的时候不需要重新渲染保存好的 DPS ，
所以能实现实时渲染。到了实现 Mac OS X 的时候，为了同时兼容老的 Mac 程序 API (carbon)
以及更快的渲染速度，以及考虑到 Adobe 对苹果收取的高昂的 Display PostScript 授权费，
Mac OS X 的 Quartz 技术在矢量图的 PDF 描述模型和最终渲染之间又插入了一层抽象：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/5807c26a.png"/&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Mission Control&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Mission Control" class="img-responsive" src="//farseerfc.me/zhs/images/Mac_OS_X_Lion_Preview_-_Mission_Control.jpg"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;也就是说在 Mac OS X 中无论窗口用何种方式绘图，都会绘制输出成一副内存中的位图交给混成器，
而后者再在需要的时候将位图混成在屏幕上。这种设计使得 2001年3月发布的 Mac OS X v10.0
成为了第一个广泛使用的具有软件混成器的操作系统。&lt;/p&gt;
&lt;p&gt;到了 Mac OS X v10.2 的时候，苹果又引入了 Quartz Extreme 让最后的混成渲染这一步发生在
显卡上。然后在 2003年1月公开亮相的 Mac OS X v10.3 中，他们公布了 Exposé (后来改名为
Mission Control) 功能，把窗口的缩略图（而不是事先绘制的图标）并排显示在桌面上，
方便用户挑选打开的窗口。&lt;/p&gt;
&lt;p&gt;由于有了混成器的这种实现方式，使得可能把窗口渲染的图像做进一步加工，添加阴影、三维和动画效果。
这使得 Mac OS X 有了美轮美奂的动画效果和 Exposé 这样的方便易用的功能。
或许对于乔布斯而言，更重要的是因为有了混成器，窗口的形状终于能显示为他
&lt;a class="reference external" href="http://www.folklore.org/StoryView.py?story=Round_Rects_Are_Everywhere.txt"&gt;梦寐以求&lt;/a&gt;
的 &lt;a class="reference external" href="http://www.uiandus.com/blog/2009/7/26/realizations-of-rounded-rectangles.html"&gt;圆角矩形&lt;/a&gt;
了！&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="project-looking-glass-3d"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;插曲：昙花一现的 Project Looking Glass 3D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在苹果那边刚刚开始使用混成器渲染窗口的 2003 年，昔日的 &lt;ruby&gt;&lt;rb&gt;升阳公司&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Sun Microsystems&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
则在 Linux 和 Solaris 上用 Java3D 作出了另一个炫酷到没有朋友的东西，被他们命名为
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Project_Looking_Glass"&gt;Project Looking Glass 3D&lt;/a&gt;
（缩写LG3D，别和 Google 的 Project Glass 混淆呀）。这个项目的炫酷实在难以用言语描述，
好在还能找到两段视频展示它的效果。&lt;/p&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_JXv8VlpoK_g"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/JXv8VlpoK_g"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XOTEzMzM3MTY0"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XOTEzMzM3MTY0" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_JXv8VlpoK_g"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XOTEzMzM3MTY0"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_zcPIEMvyPy4"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/zcPIEMvyPy4"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XOTEzMzQwMjky"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XOTEzMzQwMjky" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_zcPIEMvyPy4"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XOTEzMzQwMjky"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
LG3D&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="LG3D" class="img-responsive" src="//farseerfc.me/zhs/images/LG3D.jpg"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如视频中展示的那样， LG3D 完全突破了传统的栈式窗口管理方式，
在三维空间中操纵二维的窗口平面，不仅像传统的窗口管理器那样可以缩放和移动窗口，
还能够旋转角度甚至翻转到背面去。从视频中难以体会到的一点是， LG3D 在实现方式上与
Mac OS X 中的混成器有一个本质上的不同，那就是处于（静止或动画中）缩放或旋转状态
下的窗口是 &lt;strong&gt;可以接受输入事件&lt;/strong&gt; 的。这一重要区别在后面 Wayland 的说明中还会提到。
LG3D 项目展示了窗口管理器将如何突破传统的栈式管理的框架，可以说代表了窗口管理器的未来发展趋势。&lt;/p&gt;
&lt;p&gt;LG3D 虽然以 GPL 放出了实现的源代码，不过整个项目已经停滞开发许久了。
官方曾经放出过一个
&lt;a class="reference external" href="http://sourceforge.net/projects/lg3d-livecd/"&gt;预览版的 LiveCD&lt;/a&gt;
。可惜时隔久远（12年前了）在我的 VirtualBox 上已经不能跑起来这个 LiveCD 了……&lt;/p&gt;
&lt;p&gt;更为可惜的是，就在这个项目刚刚公开展示出来的时候，乔布斯就致电升阳，
说如果继续商业化这个产品，升阳公司将涉嫌侵犯苹果的知识产权
（时间顺序上来看，苹果最初展示 Exposé 是在 2003年6月23日的
Apple Worldwide Developers Conference ，而升阳最初展示
LG3D 是在 2003年8月5日的 LinuxWorld Expo）。
虽然和乔布斯的指控无关，升阳公司本身的业务也着重于服务器端的业务，
后来随着升阳的财政困难，这个项目也就停止开发并不了了之了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="windows"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;Windows 中的混成器&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Longhorn 中的 Wobbly 效果&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_X0idaN0MY1U"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/X0idaN0MY1U"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XOTEzMzY5NjQ0"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XOTEzMzY5NjQ0" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_X0idaN0MY1U"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XOTEzMzY5NjQ0"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面说到， Windows 系列中到 XP 为止都还没有使用混成器绘制窗口。
看着 Mac OS X 上有了美轮美奂的动画效果， Windows 这边自然不甘示弱。
于是同样在 2003 年展示的 Project Longhorn 中就演示了 wobbly 效果的窗口，
并且跳票推迟多年之后的 Windows Vista 中实现了完整的混成器
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Desktop_Window_Manager"&gt;Desktop Window Manager (DWM)&lt;/a&gt;
。整个 DWM 的架构和 Mac OS X 上看到的很像：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/1763baf6.png"/&gt;
&lt;p&gt;和 Mac OS X 的情况类似， Windows Vista 之后的应用程序有两套主要的绘图库，一套是从早期
Win32API 就沿用至今的 GDI（以及GDI+），另一套是随着 Longhorn 计划开发出的 WPF 。
WPF 的所有用户界面控件都绘制在 DirectX 贴图上，所以使用了 WPF 的程序也可以看作是
DirectX 程序。而对老旧的 GDI 程序而言，它们并不是直接绘制到 DirectX 贴图的。首先每一个
GDI 的绘图操作都对应一条
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Windows_Metafile"&gt;Windows Metafile (WMF)&lt;/a&gt;
记录，所以 WMF 就可以看作是 Mac OS X 的 Quartz 内部用的 PDF 或者 NeXTSTEP 内部用的
DPS，它们都是矢量图描述。随后，这些 WMF 绘图操作被通过一个
Canonical Display Driver (cdd.dll) 的内部组建转换到 DirectX 平面，并且保存起来交给
DWM。最后， DWM 拿到来自 CDD 或者 DirectX 的平面，把它们混合起来绘制在屏幕上。&lt;/p&gt;
&lt;p&gt;值得注意的细节是，WPF 底层的绘图库几乎肯定有 C/C++ 绑定对应， Windows 自带的不少应用程序
和 Office 2007 用了 Ribbon 之后的版本都采用这套绘图引擎，不过微软没有公开这套绘图库的
C/C++ 实现的底层细节，而只能通过 .Net 框架的 WPF 访问它。这一点和 OS X 上只能通过
Objective-C 下的 Cocoa API 调用 Quartz 的情况类似。&lt;/p&gt;
&lt;p&gt;另外需要注意的细节是 DirectX 的单窗口限制在 Windows Vista 之后被放开了，或者严格的说是
基于 WDDM 规范下的显卡驱动支持了多个 DirectX 绘图平面。
在早期的 Windows 包括 XP 上，整个桌面上同一时刻只能有一个程序的窗口处于 DirectX 的
&lt;strong&gt;直接绘制&lt;/strong&gt; 模式，而别的窗口如果想用 DirectX 的话，要么必须改用软件渲染要么就不能工作。
这种现象可以通过打开多个播放器或者窗口化的游戏界面观察到。
而在 WDDM 规范的 Vista 中，所有窗口最终都绘制到 DirectX 平面上，换句话说每个窗口都是
DirectX 窗口。又或者我们可以认为，整个界面上只有一个真正的窗口也就是 DWM 绘制的全屏窗口，
只有 DWM 处于 DirectX 的直接渲染模式下，而别的窗口都输出到 DirectX 平面里（可能通过了硬件加速）。&lt;/p&gt;
&lt;p&gt;由 DWM 的这种实现方式，可以解释为什么
&lt;a class="reference external" href="http://gaming.stackexchange.com/questions/13066/why-is-windowed-mode-always-slower-in-games"&gt;窗口模式下的游戏总是显得比较慢&lt;/a&gt;
，原因是整个桌面有很多不同的窗口都需要 DWM 最后混成，而如果在全屏模式下，只有游戏
处于 DirectX 的直接渲染方式，从而不会浪费对游戏而言宝贵的 GPU 资源。&lt;/p&gt;
&lt;p&gt;由于 DWM 实现了混成器，使得 Vista 和随后的 Windows 7 有了
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Windows_Aero"&gt;Aero Glass&lt;/a&gt; 的界面风格，
有了 Flip 3D 、Aero Peek 等等的这些辅助功能和动画效果。
这套渲染方式延续到 Windows 8 之后，虽然 Windows 8 还提出了 Modern UI
不过传统桌面上的渲染仍旧是依靠混成器来做的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="linux"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;这就结束了？ Linux 桌面呢？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;别急，我写这些文章的目的是想聊聊 Linux 中的混成器，尤其是 X 下现有的混成器和 Wayland
，这篇文章只是个背景介绍。关于 X 中混成器的实现方式和限制，且听我下回分解。&lt;/p&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="tech"></category><category term="desktop"></category><category term="compositor"></category><category term="macosx"></category><category term="windows"></category><category term="window"></category><category term="manager"></category></entry><entry><title>用 Travis-CI 生成 Github Pages 博客</title><link href="//farseerfc.me/zhs/travis-push-to-github-pages-blog.html" rel="alternate"></link><published>2015-02-20T11:10:00+09:00</published><updated>2015-02-20T11:10:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-02-20:/zhs/travis-push-to-github-pages-blog.html</id><summary type="html">
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月21日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;上次介绍过 &lt;a class="reference external" href="//farseerfc.me/zhs/redesign-pelican-theme.html"&gt;这个博客改换了主题&lt;/a&gt; ，
本以为这个话题可以告一段落了，没想到还能继续写呢。&lt;/p&gt;
&lt;p&gt;寄宿在 Github Pages 上的静态博客通常有两种方案，其一是使用 &lt;a class="reference external" href="http://jekyllrb.com/"&gt;Jekyll&lt;/a&gt; 方式撰写，这可以利用
Github Pages 原本就有的
&lt;a class="reference external" href="https://help.github.com/articles/using-jekyll-with-pages/"&gt;Jekyll支持&lt;/a&gt;
生成静态网站。另一种是在 &lt;strong&gt;本地&lt;/strong&gt; 也就是自己的电脑上生成好，然后把生成的 HTML 网站 push
到 Github Pages ，这种情况下 Github Pages 就完全只是一个静态页面宿主环境。&lt;/p&gt;
&lt;p&gt;我用 &lt;a class="reference external" href="http://getpelican.com/"&gt;Pelican&lt;/a&gt; 生成博客，当然就只能选择后一种方式了。这带来一些不便，比如本地配置 pelican
还是有一点点复杂的，所以不能随便找台电脑就开始写博客。有的时候只是想修正一两个错别字，
这时候必须打开某台特定的电脑才能编辑博客就显得不太方便了。再比如 pelican 本身虽然是 python
写的所以跨平台，但是具体到博客的配置方面， Windows …&lt;/p&gt;</summary><content type="html">
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月21日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;上次介绍过 &lt;a class="reference external" href="//farseerfc.me/zhs/redesign-pelican-theme.html"&gt;这个博客改换了主题&lt;/a&gt; ，
本以为这个话题可以告一段落了，没想到还能继续写呢。&lt;/p&gt;
&lt;p&gt;寄宿在 Github Pages 上的静态博客通常有两种方案，其一是使用 &lt;a class="reference external" href="http://jekyllrb.com/"&gt;Jekyll&lt;/a&gt; 方式撰写，这可以利用
Github Pages 原本就有的
&lt;a class="reference external" href="https://help.github.com/articles/using-jekyll-with-pages/"&gt;Jekyll支持&lt;/a&gt;
生成静态网站。另一种是在 &lt;strong&gt;本地&lt;/strong&gt; 也就是自己的电脑上生成好，然后把生成的 HTML 网站 push
到 Github Pages ，这种情况下 Github Pages 就完全只是一个静态页面宿主环境。&lt;/p&gt;
&lt;p&gt;我用 &lt;a class="reference external" href="http://getpelican.com/"&gt;Pelican&lt;/a&gt; 生成博客，当然就只能选择后一种方式了。这带来一些不便，比如本地配置 pelican
还是有一点点复杂的，所以不能随便找台电脑就开始写博客。有的时候只是想修正一两个错别字，
这时候必须打开某台特定的电脑才能编辑博客就显得不太方便了。再比如 pelican 本身虽然是 python
写的所以跨平台，但是具体到博客的配置方面， Windows 环境和 Linux/OSX/Unix-like
环境下还是有
&lt;a class="reference external" href="http://pelican.readthedocs.org/en/latest/settings.html#date-format-and-locale"&gt;些许出入&lt;/a&gt;
的。还有就是没有像 wordpress 那样的基于 web
的编辑环境，在手机上就不能随便写一篇博客发表出来（不知道有没有勇士尝试过在
Android 的 &lt;a class="reference external" href="https://code.google.com/p/android-scripting/"&gt;SL4A&lt;/a&gt; 环境下的 python 中跑 pelican ，还要配合一个
&lt;a class="reference external" href="https://play.google.com/store/apps/details?id=com.romanenco.gitt"&gt;Android 上的 git 客户端&lt;/a&gt; ）。&lt;/p&gt;
&lt;p&gt;当然并不是因此就束手无策了，感谢 &lt;a class="reference external" href="https://travis-ci.org/"&gt;Travis-CI&lt;/a&gt; 提供了免费的
&lt;ruby&gt;&lt;rb&gt;持续整合&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Continuous integration&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 虚拟机环境，
通过它全自动生成静态博客成为了可能。&lt;/p&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;关于 Travis-CI&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88"&gt;持续整合&lt;/a&gt;
原本是 &lt;ruby&gt;&lt;rb&gt;敏捷开发&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Agile Development&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
或者 &lt;ruby&gt;&lt;rb&gt;极限编程&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Extreme Programming&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 中提到的概念，大意就是说在开发的过程中，
一旦有微小的变更，就全自动地 &lt;strong&gt;持续&lt;/strong&gt; 合并到主线中， &lt;strong&gt;整合&lt;/strong&gt; 变更的内容到发布版本里。
这里的 &lt;strong&gt;整合&lt;/strong&gt; 实际上可以理解为 &lt;strong&gt;全自动测试&lt;/strong&gt; 加上 &lt;strong&gt;生成最终产品&lt;/strong&gt; 。
可以看到 &lt;strong&gt;持续整合&lt;/strong&gt; 实际强调 &lt;strong&gt;全自动&lt;/strong&gt; ，于是需要有一个服务器不断地监听主线开发的变更内容，
一旦有任何变更（可以理解为 git commit ）就自动调用测试和部署脚本。&lt;/p&gt;
&lt;p&gt;于是要用持续整合就需要一个整合服务器，幸而 Travis-CI 对 github 上的公开 repo
提供了免费的整合服务器虚拟机服务，和 github 的整合非常自然。所以我们就可以用它提供的虚拟机
为博客生成静态网站。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;启用 Travis-CI 自动编译&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这一步很简单，访问 &lt;a class="reference external" href="https://travis-ci.org/"&gt;https://travis-ci.org/&lt;/a&gt; 并用你的 Github 账户登录，
授权它访问你的账户信息就可以了。然后在 &lt;a class="reference external" href="https://travis-ci.org/repositories"&gt;https://travis-ci.org/repositories&lt;/a&gt; 里开启
需要编译的 repo ，这样 Travis-CI 就会监视对这个 repo 的所有 push 操作，并且对
每个 push 调用测试了。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="在 Travis-CI 中开启对 Github Repo 的持续整合" class="img-responsive" src="//farseerfc.me/zhs/images/travis-repo-enable.png"/&gt;
&lt;p class="caption"&gt;在 Travis-CI 中开启对 Github Repo 的持续整合&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;然后在 repo 的根目录放一个 &lt;code class="code"&gt;
.travis.yml&lt;/code&gt;
 文件描述编译的步骤。
&lt;strong&gt;暂时&lt;/strong&gt; 测试的目的下我写的 &lt;code class="code"&gt;
.travis.yml&lt;/code&gt;
 大概是下面这样。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;language&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;python&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nt"&gt;python&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;"2.7"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nt"&gt;before_install&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo apt-add-repository ppa:chris-lea/node.js -y&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo apt-get update&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo apt-get install nodejs ditaa doxygen parallel&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nt"&gt;install&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo pip install pelican&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo pip install jinja2&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo pip install babel&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo pip install beautifulsoup4&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo pip install markdown&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo npm install -g less&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;wget "http://downloads.sourceforge.net/project/plantuml/plantuml.jar?r=&amp;amp;ts=1424308684&amp;amp;use_mirror=jaist" -O plantuml.jar&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo mkdir -p /opt/plantuml&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo cp plantuml.jar /opt/plantuml&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;echo "#! /bin/sh" &amp;gt; plantuml&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;echo 'exec java -jar /opt/plantuml/plantuml.jar "$@"' &amp;gt;&amp;gt; plantuml&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo install -m 755 -D plantuml /usr/bin/plantuml&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;wget https://bintray.com/artifact/download/byvoid/opencc/opencc-1.0.2.tar.gz&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;tar xf opencc-1.0.2.tar.gz&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;cd opencc-1.0.2 &amp;amp;&amp;amp; make &amp;amp;&amp;amp; sudo make install &amp;amp;&amp;amp; cd ..&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo locale-gen zh_CN.UTF-8&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo locale-gen zh_HK.UTF-8&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo locale-gen en_US.UTF-8&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo locale-gen ja_JP.UTF-8&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone --depth 1 https://github.com/farseerfc/pelican-plugins plugins&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone --depth 1 https://github.com/farseerfc/pelican-bootstrap3 theme&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;mkdir output&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;env SITEURL="farseerfc.me" make publish&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Travis-CI 提供的虚拟机是比较标准的 Ubuntu 12.04 LTS ，打上了最新的补丁，并且根据你指定的
语言选项会把相应的解释器和编译器升级到最新版（或者指定的版本）。这里用 python 语言的配置，
所以 python 是 2.7 的最新版并且有 pip 可以直接用。
配置中的 before_install 和 install 的区别其实不大，其中任何一个失败的话算作
build errored 而不是 build fail ，而如果在 script 里失败的话算作 build fail 。&lt;/p&gt;
&lt;p&gt;为了编译我的模板，还需要比较新的 less.js ，所以添加了 ppa 装了个最新的 nodejs
并用它装上了 less 。
还从源码编译安装上了最新版的 opencc 1.0.2 ，因为 Ubuntu 源里的 opencc 的版本比较老(0.4)，
然后 doxygen 作为 opencc 的编译依赖也装上了。
其它安装的东西么，除了 pelican 之外都是插件们需要的。以及我还需要生成 4 个语言的 locale
所以调用了 4 次 locale-gen 。由于是比较标准的 Ubuntu 环境，所以基本上编译的步骤和在本地
Linux 环境中是一样的，同样的这套配置应该可以直接用于本地 Ubuntu 下编译我的博客。&lt;/p&gt;
&lt;p&gt;写好 &lt;code class="code"&gt;
.travis.yml&lt;/code&gt;
 之后把它 push 到 github ，然后 travis 这边就会自动 clone
下来开始编译。 travis 上能看到编译的完整过程和输出，一切正常的话编译结束之后
build 的状态就会变成 passing ，比如
&lt;a class="reference external" href="https://travis-ci.org/farseerfc/farseerfc/builds/51344614"&gt;我的这次的build&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="travis-ci-github"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;从 Travis-CI 推往 Github&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上面的测试编译通过了之后，下一步就是让 travis-ci 编译的结果自动推到 Github Pages
并发布出来。要推往 Github 自然需要设置 Github 用户的身份，在本地设置的时候是把
ssh key 添加到 github 账户就可以了，在编译细节都通过 github repo 公开了的 travis 上
当然不能放推送用的私有 key ，所以我们需要另外一种方案传递密码。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Github 上创建 Personal Access Token&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Github 上创建 Personal Access Token" class="img-responsive" src="//farseerfc.me/zhs/images/travis-blog-push.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;好在 Github 支持通过 &lt;a class="reference external" href="https://github.com/settings/applications"&gt;Personal Access Token&lt;/a&gt;
的方式验证，这个和 App Token 一样可以随时吊销，同时完全是个人创建的。另一方面 Travis-CI
支持加密一些私密数据，通过环境变量的方式传递给编译脚本，避免公开密码这样的关键数据。&lt;/p&gt;
&lt;p&gt;首先创建一个 &lt;a class="reference external" href="https://github.com/settings/applications"&gt;Personal Access Token&lt;/a&gt;
，这里需要勾选一些给这个 Token 的权限，我只给予了最小的 public_repo 权限，如侧边里的图。
生成之后会得到一长串 Token 的散列码。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
如果你不能使用 travis 命令&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月21日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;使用 &lt;code class="code"&gt;
travis encrypt&lt;/code&gt;
 命令来加密重要数据最方便，不过如果有任何原因，
比如 ruby 版本太低或者安装不方便之类的，那么不用担心，我们直接通过
&lt;a class="reference external" href="http://docs.travis-ci.com/api/#repository-keys"&gt;travis api&lt;/a&gt;
也能加密数据。&lt;/p&gt;
&lt;p&gt;第一步用这个命令得到你的repo的 pubkey ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;curl -H "Accept: application/vnd.travis-ci.2+json" https://api.travis-ci.org/repos/&amp;lt;github-id/repo&amp;gt;/key | python2 -m json.tool | grep key | sed 's/.*"key": "\(.*\)"/\1/' | xargs -0 echo -en | sed 's/ RSA//' &amp;gt; travis.pem&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的 &amp;lt;github-id/repo&amp;gt; 替换成 github 上的 用户名/repo名， 比如我的是
farseerfc/farseer 。travis api 获得的结果是一个 json ，所以还用 python 的
json 模块处理了一下，然后把其中包含 key 的行用 &lt;code class="code"&gt;
grep&lt;/code&gt;
 提取出来，用
&lt;code class="code"&gt;
sed&lt;/code&gt;
 匹配出 key 的字符串本身，然后 &lt;code class="code"&gt;
xargs -0 echo -en&lt;/code&gt;

解释掉转义字符，然后删掉其中的 "&amp;lt;空格&amp;gt;RSA" 几个字（否则 openssl 不能读），
最后保存在名为 travis.pem 的文件里。&lt;/p&gt;
&lt;p&gt;有了 pubkey 之后用 openssl 加密我们需要加密的东西并用 base64 编码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;echo -n 'GIT_NAME="Jiachen Yang" GIT_EMAIL=farseerfc@gmail.com GH_TOKEN=&amp;lt;Personal Access Token&amp;gt;' | openssl rsautl -encrypt -pubin -inkey travis.pem | base64 -w0&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;替换了相应的身份信息和token之后，这行得到的结果就是 secure 里要写的加密过的内容。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后我们需要 &lt;code class="code"&gt;
travis&lt;/code&gt;
 命令来加密这个 token ， archlinux 用户可以安装
&lt;code class="code"&gt;
aur/​ruby-travis&lt;/code&gt;
 ，其它用户可以用 gems 安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; gem install travis&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;装好之后，在设定了 Travis-CI 的 repo 的目录中执行一下 &lt;code class="code"&gt;
travis status&lt;/code&gt;
 ，
命令会指导你登录 Travis-CI 并验证 repo 。正常的话会显示最新的 build 状态。
然后同样在这个 repo 目录下执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; travis encrypt &lt;span class="s1"&gt;'GIT_NAME="Jiachen Yang" GIT_EMAIL=farseerfc@gmail.com GH_TOKEN=&amp;lt;Personal Access Token&amp;gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然上面一行里的相应信息替换为个人的信息，作为这个命令的执行结果会得到另一长串散列码，
把这串散列写入刚才的 &lt;code class="code"&gt;
.travis.yml&lt;/code&gt;
 文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;env&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;secure&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"long&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;secure&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;base64&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;string"&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了这段声明之后， Travis-CI 就会在每次编译之前，设置上面加密的环境变量。
然后在编译脚本中利用这些环境变量来生成博客：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git config --global user.email "$GIT_EMAIL"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git config --global user.name "$GIT_NAME"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git config --global push.default simple&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone --depth 1 https://github.com/farseerfc/pelican-plugins plugins&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone --depth 1 https://github.com/farseerfc/pelican-bootstrap3 theme&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone --depth 1 https://$GH_TOKEN@github.com/farseerfc/farseerfc.github.io output&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;env SITEURL="farseerfc.me" make publish&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nt"&gt;after_success&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;cd output&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git add -A .&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git commit -m "update from travis"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git push --quiet&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="alert alert-warning compound"&gt;
&lt;p&gt;这里要注意最后 &lt;code class="code"&gt;
git push&lt;/code&gt;
 的时候一定要加上 &lt;code class="code"&gt;
--quiet&lt;/code&gt;
，因为默认不加的时候会把
代入了 &lt;code class="code"&gt;
$GH_TOKEN&lt;/code&gt;
 的 URL 显示出来，从而上面的加密工作就前功尽弃了……&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;根据 &lt;a class="reference external" href="http://docs.travis-ci.com/user/build-lifecycle/"&gt;travis 的文档&lt;/a&gt;
， after_success 里写的步骤只有在 script 里的全都完全无错执行完之后才会执行，这正是我们
push 的条件。目前 after_success 的成功与否不会影响到 build 的状态。
具体我用的配置见
&lt;a class="reference external" href="https://github.com/farseerfc/farseerfc/blob/master/.travis.yml"&gt;这里的最新版&lt;/a&gt; 。
在我的 &lt;code class="code"&gt;
make github&lt;/code&gt;
 中
&lt;a class="reference external" href="https://github.com/farseerfc/farseerfc/blob/master/Makefile#L102"&gt;调用了&lt;/a&gt;
&lt;code class="code"&gt;
git push&lt;/code&gt;
 命令，从而执行了 &lt;code class="code"&gt;
make github&lt;/code&gt;
 之后就会自动部署到 github 上。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="web"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;用 Web 编辑并发布静态博客&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;经过以上设置之后，一切正常的话，每次对主 repo 推送更新的同时， Travis-CI 就会自动
拉来更新然后编译并发布了。可以放置这样的图标 &lt;img alt="travisIcon" class="img-responsive no-responsive" src="https://travis-ci.org/farseerfc/farseerfc.svg?branch=master"/&gt; 在项目的 &lt;code class="code"&gt;
Readme.md&lt;/code&gt;

中显示编译状态。&lt;/p&gt;
&lt;p&gt;这样设置之后的另一个好处就在于可以利用 Github 的 Web 界面编辑文章内容。在 Github 里
编辑和保存之后会自动作为一个 commit 提交，所以也会触发 Travis-CI 的自动编译。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="在 Github 的 Web 界面中直接编辑文章内容" class="img-responsive" src="//farseerfc.me/zhs/images/travis-edit-github-web.png"/&gt;
&lt;p class="caption"&gt;在 Github 的 Web 界面中直接编辑文章内容&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;以及虽然目前还没有好用的 Github 的手机客户端，不过直接用 Android/iPhone 的浏览器登录
github 并编辑文章的可用性也还不错，所以同样的方式也可以直接在手机上发布博文了。&lt;/p&gt;
&lt;p&gt;That is all, happy blogging ~&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="pelican"></category><category term="github"></category><category term="pages"></category><category term="travis"></category><category term="travis-ci"></category><category term="ubuntu"></category></entry><entry><title>archlinux 上用 chrome 实现 透明计算 远程登录</title><link href="//farseerfc.me/zhs/arch-chrome-remote-desktop.html" rel="alternate"></link><published>2015-02-13T20:39:00+09:00</published><updated>2015-02-13T20:39:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-02-13:/zhs/arch-chrome-remote-desktop.html</id><summary type="html">
&lt;p&gt;&lt;a class="reference external" href="http://news.sciencenet.cn/htmlnews/2015/1/311393.shtm"&gt;透明计算&lt;/a&gt;
具体是什么，因为他们没有公开技术细节所以我并不知道，只是看
&lt;a class="reference external" href="http://v.qq.com/page/h/v/q/h0145ebh1vq.html"&gt;公开出来的演示视频&lt;/a&gt;
，感觉似乎只要能从手机上远程登录系统桌面，就能算是透明计算了。
如果透明计算真是这个意思，那么我似乎已经用着这个技术很多年了嘛。&lt;/p&gt;
&lt;p&gt;Xorg 上常用的远程桌面工具有很多，基于 VNC 协议的、基于NX的和基于 RDP 协议的都能找到，
直接 ssh X forwarding 效果也不错。只是这些方案的一个 &lt;strong&gt;不太易用&lt;/strong&gt; 的地方在于，需要
通过 ip 访问到远程的电脑，所以在跨越 NAT 之类的情况下不太容易使用。&lt;/p&gt;
&lt;p&gt;于是今天介绍一个使用方便设置也简单的方法： 通过 chrome-remote-desktop 在 archlinux
上使用远程桌面。这个方案的优势在于，借助 Google 的云端服务器（内部貌似是XMPP协议下的握手）
方便地实现了 NAT 穿透，无论什么网络环境基本都能使用。当然，要支持远程登录，
位于远端的登录的计算机必须一直开着 …&lt;/p&gt;</summary><content type="html">
&lt;p&gt;&lt;a class="reference external" href="http://news.sciencenet.cn/htmlnews/2015/1/311393.shtm"&gt;透明计算&lt;/a&gt;
具体是什么，因为他们没有公开技术细节所以我并不知道，只是看
&lt;a class="reference external" href="http://v.qq.com/page/h/v/q/h0145ebh1vq.html"&gt;公开出来的演示视频&lt;/a&gt;
，感觉似乎只要能从手机上远程登录系统桌面，就能算是透明计算了。
如果透明计算真是这个意思，那么我似乎已经用着这个技术很多年了嘛。&lt;/p&gt;
&lt;p&gt;Xorg 上常用的远程桌面工具有很多，基于 VNC 协议的、基于NX的和基于 RDP 协议的都能找到，
直接 ssh X forwarding 效果也不错。只是这些方案的一个 &lt;strong&gt;不太易用&lt;/strong&gt; 的地方在于，需要
通过 ip 访问到远程的电脑，所以在跨越 NAT 之类的情况下不太容易使用。&lt;/p&gt;
&lt;p&gt;于是今天介绍一个使用方便设置也简单的方法： 通过 chrome-remote-desktop 在 archlinux
上使用远程桌面。这个方案的优势在于，借助 Google 的云端服务器（内部貌似是XMPP协议下的握手）
方便地实现了 NAT 穿透，无论什么网络环境基本都能使用。当然，要支持远程登录，
位于远端的登录的计算机必须一直开着 Chrome Remote Desktop 的后台服务。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Chrome Remote Desktop 插件&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Chrome Remote Desktop 插件" class="img-responsive" src="//farseerfc.me/zhs/images/chrome-remote-desktop-plugin.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="chrome-remote-desktop"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;Chrome Remote Desktop 的客户端&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;虽然可能有很多人不知道，不过 Chrome 内包括远程桌面的功能很久了。只是这个功能的界面默认
没有提供界面，要使用它需要安装 Google 官方出品的
&lt;a class="reference external" href="https://chrome.google.com/webstore/detail/chrome-remote-desktop/gbchcmhmhahfdphkhkmpfmihenigjmpp"&gt;remote-desktop 插件&lt;/a&gt; 。
装好之后远程桌面的客户端就准备好，可以用来远程访问别的计算机桌面了（无论是 Windows/OS X
还是 Linux 都支持）。并且不光可以自己远程访问自己账户的桌面，还可以远程协助朋友的桌面。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="archlinux"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;Archlinux 上设置远程登录的服务器&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;有了客户端之后还要设置一下才能让桌面作为远程登录的服务器。Windows 和 OS X 上 Chrome
会自动下载需要的安装包，无脑下一步就能装好了。Linux上由于发行版众多，桌面配置各异，
所以需要一点手动配置。官方的设置步骤记载在 &lt;a class="reference external" href="https://support.google.com/chrome/answer/1649523"&gt;这里&lt;/a&gt;
其中给出了 debian 用的二进制包和 Ubuntu 12.10 上的设置方式，以下设置是参考官方步骤。&lt;/p&gt;
&lt;p&gt;首先要安装 chrome-remote-desktop 这个包，这个包实际上对应了 Windows/OS X 上用安装程序
安装的 Remote Desktop Host Controller。 archlinux 上开启了
&lt;a class="reference external" href="https://github.com/archlinuxcn/repo"&gt;[archlinuxcn]&lt;/a&gt;
仓库的话，可以直接安装打好的包。或者可以从
&lt;a class="reference external" href="https://aur.archlinux.org/packages/chrome-remote-desktop/"&gt;AUR&lt;/a&gt; 装。&lt;/p&gt;
&lt;pre&gt;&lt;span class="code-line"&gt;$ pacman -Ss chrome-remote-desktop&lt;br/&gt;&lt;span style="color:purple;font-weight:bold;"&gt;archlinuxcn/&lt;/span&gt;&lt;span style="font-weight:bold;"&gt;chrome-remote-desktop &lt;/span&gt;&lt;span style="color:green;font-weight:bold;"&gt;40.0.2214.44-1&lt;/span&gt;&lt;br/&gt;Allows you to securely access your computer over the Internet through Chrome.&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;装好之后从会说这么一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;groupadd：无效的组 ID “chrome-remote-desktop”&lt;/p&gt;
&lt;p&gt;Please create ~/.config/chrome-remote-desktop folder manually, if it doesn't exist, or else you can't use CRD.
The needed files are created by the Chrome app, inside the chrome-remote-desktop folder, after Enabling Remote Connections.
To {enable,start} the service use systemctl --user {enable,start} chrome-remote-desktop&lt;/p&gt;
&lt;p&gt;You may need to create a ~/.chrome-remote-desktop-session file with commands to start your session&lt;/p&gt;
&lt;p&gt;Go to &lt;a class="reference external" href="https://support.google.com/chrome/answer/1649523"&gt;https://support.google.com/chrome/answer/1649523&lt;/a&gt; for more information.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那句报错是 AUR 里打的包还没跟上上游 Google 的更改导致的错误，
首先我们需要把远程登录的用户添加入 chrome-remote-desktop 这个用户组里。
新版本的 chrome remote desktop 提供了一个命令做这个事情，所以执行以下命令就可以了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; /opt/google/chrome-remote-desktop/chrome-remote-desktop --add-user&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们需要手动创建 &lt;code class="code"&gt;
~/​.config/​chrome-remote-desktop&lt;/code&gt;
 这个文件夹，内容是空的
就好了，随后 chrome 会往这里面放 &lt;code class="code"&gt;
host#.json&lt;/code&gt;
 文件用于身份验证。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; mkdir ~/.config/chrome-remote-desktop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们要创建一个 shell 脚本 &lt;code class="code"&gt;
~/​.chrome-remote-desktop-session&lt;/code&gt;
 ，这是远程
登录时的 .xinitrc ，内容么就是启动你想在远程登录时用的桌面环境。
这里可以指定一个和你正在登录的 WM/DE 不同的桌面，比如我启动 xfce4：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; cat ~/.chrome-remote-desktop-session&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;#&lt;/span&gt;!/bin/bash&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;startxfce4&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; chmod &lt;span class="m"&gt;755&lt;/span&gt; .chrome-remote-desktop-session&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来需要从 Chrome 的插件里启用远程桌面。打开 Chrome 的 Remote Desktop 插件，这时
应该可以看到一个「启用远程链接」的按钮。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="Chrome Remote Desktop 插件中「启用远程链接」的按钮" class="img-responsive" src="//farseerfc.me/zhs/images/chrome-remote-desktop-enable-button.png"/&gt;
&lt;p class="caption"&gt;Chrome Remote Desktop 插件中「启用远程链接」的按钮&lt;/p&gt;
&lt;/div&gt;
&lt;div class="alert alert-warning compound"&gt;
&lt;p&gt;在撰写本文的时候， Archlinux 官方源里的 chromium 的版本和 aur/google-chrome
的版本尚且还是 40.0.2214.111 ，而 Chrome Web Store 中提供的 Chrome Remote
Desktop 的插件的版本是 41.0.2272.41 。虽然通常并不要求两者版本一致，不过貌似最近
Chrome 内部的 Remoting 功能更改了 API 导致可能出问题。如果你找不到
「启用远程链接」的按钮，请尝试一下新版本的 Chrome 比如 google-chrome-dev 。
在这一步启用之后，老版本的 chrome 应该也就能使用远程桌面了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="alert alert-warning compound"&gt;
&lt;p&gt;在32位的 Linux 版本上，最近更新的 Chrome Remote Desktop 插件可能无法正确识别 Host
的版本，具体 &lt;a class="alert-link reference external" href="https://code.google.com/p/chromium/issues/detail?id=332930"&gt;参考这个 bug&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;点击「启用远程链接」，设定一个 PIN 密码（不需要很复杂，这里首先有 Google 帐号验证保证只有
你才能访问），然后就能看到这套电脑的 hostname 出现在「我的电脑」列表里。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="启用远程链接之后的样子" class="img-responsive" src="//farseerfc.me/zhs/images/chrome-remote-desktop-after-enabled.png"/&gt;
&lt;p class="caption"&gt;启用远程链接之后的样子&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;同时，启用了远程链接之后，可以在刚刚创建的 ~/.config/chrome-remote-desktop
文件夹中找到记录了验证信息的文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ls .config/chrome-remote-desktop&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;chrome-profile  host#8cfe7ecfd6bb17955c1ea22f77d0d800.json  pulseaudio#8cfe7ecfd6&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以启动对应的 systemd 用户服务了，如果想自动启动服务要记得 &lt;code class="code"&gt;
systemctl --user enable&lt;/code&gt;
 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; systemctl --user start chrome-remote-desktop.service&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果上面的设置一切正常，就可以看到 chrome-remote-desktop 启动了另外一个 Xorg 执行你
刚刚指定的桌面环境：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="htop 中看到的 chrome-remote-desktop 启动的另外一个 Xorg" class="img-responsive" src="//farseerfc.me/zhs/images/chrome-remote-desktop-htop.png"/&gt;
&lt;p class="caption"&gt;htop 中看到的 chrome-remote-desktop 启动的另外一个 Xorg&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;然后就可以试着通过 Remote Desktop 插件登录到这个新开的 Xorg 了：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="「远程」登录到新的 XFCE4" class="img-responsive" src="//farseerfc.me/zhs/images/chrome-remote-desktop-xfce4.png"/&gt;
&lt;p class="caption"&gt;「远程」登录到新的 XFCE4&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="linux-chrome-windows-os-x"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;Linux 版本的 Chrome远程桌面 和 Windows/ OS X 上的区别&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通过上面的设置步骤也可以看出，Linux版本的远程桌面会在后台开一个独立的 X 会话，而不能
复用现在已有的 X 会话。对远程登录的用法而言这还能接受，对远程协助的功能而言有点问题，
因为正在使用的人不能观察协助者做了什么，协助者也不能继续请求协助的人的操作。&lt;/p&gt;
&lt;p&gt;当然目前 Chrome 远程桌面的 Linux Host Controller 还只是 beta 版本，官方只测试支持
Ubuntu 12.04 和 12.10 （14.04之后似乎有
&lt;a class="reference external" href="https://code.google.com/p/chromium/issues/detail?id=366432"&gt;Bug&lt;/a&gt;
），所以不能要求太多。希望以后能改善吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bonus"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;Bonus： 手机远程登录&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
手机上的 Chrome 远程桌面 App&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="手机上的 Chrome 远程桌面 App" class="img-responsive" src="//farseerfc.me/zhs/images/chrome-remote-desktop-android.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过上面的设置就可以从任何一个 Chrome 远程桌面客户端登录刚刚设置的这台电脑了。
因为 Chrome 在三大桌面系统 Windows / OS X / Linux 上都有，所以应该能覆盖大多数桌面
系统了。&lt;/p&gt;
&lt;p&gt;除了桌面的 Chrome 之外还有一个客户端是 Android 上的
&lt;a class="reference external" href="https://play.google.com/store/apps/details?id=com.google.chromeremotedesktop"&gt;Chrome 远程桌面 App&lt;/a&gt; 经过上面的设置之后，从这个 App 也能看到并登录：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="手机远程登录" class="img-responsive" src="//farseerfc.me/zhs/images/chrome-remote-desktop-android-logined.png"/&gt;
&lt;p class="caption"&gt;手机远程登录&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;好啦，开始享受国家自然科学一等奖的透明计算技术吧！&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="linux"></category><category term="archlinux"></category><category term="arch"></category><category term="chrome"></category><category term="remote"></category><category term="desktop"></category></entry><entry><title>换到 farseerfc.me 域名</title><link href="//farseerfc.me/zhs/switch-to-farseerfc-dot-me-domain.html" rel="alternate"></link><published>2015-01-26T23:32:00+09:00</published><updated>2015-01-26T23:32:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-01-26:/zhs/switch-to-farseerfc-dot-me-domain.html</id><summary type="html">&lt;p&gt;上个月就在 &lt;ruby&gt;&lt;rb&gt;狗爹&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;godaddy&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 上买了个自己的域名 &lt;code class="code"&gt;
farseerfc.me&lt;/code&gt;
 准备用在这个
博客上，当时试着转到过这个域名，发现 &lt;ruby&gt;&lt;rb&gt;自定义域名&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;custom domain&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
只支持 http 不支持 https ，想着还要买自己的证书，于是就扔在了一旁。不用自定义域名的话，
放在 github.io 上是可以用 HTTPS 的。
今天在 &lt;a class="reference external" href="//webchat.freenode.net/?channels=archlinux-cn"&gt;#archlinux-cn&lt;/a&gt; 上受大牛 &lt;a class="reference external" href="/links.html#quininer"&gt;quininer&lt;/a&gt; 和 &lt;a class="reference external" href="/links.html#lilydjwg"&gt;lilydjwg&lt;/a&gt; 点播，
发现 cloudflare 有提供
&lt;a class="reference external" href="https://blog.cloudflare.com/introducing-universal-ssl/"&gt;免费的支持 SSL 的 CDN 服务&lt;/a&gt;
赶快去申请了一个，感觉非常赞，于是就换过来了。&lt;/p&gt;
&lt;p&gt;设置的方法按照 &lt;a class="reference external" href="https://me.net.nz/blog/github-pages-secure-with-cloudflare/"&gt;这篇博文&lt;/a&gt;
说的一步步做下来，如它所述，用 CloudFlare …&lt;/p&gt;</summary><content type="html">&lt;p&gt;上个月就在 &lt;ruby&gt;&lt;rb&gt;狗爹&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;godaddy&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 上买了个自己的域名 &lt;code class="code"&gt;
farseerfc.me&lt;/code&gt;
 准备用在这个
博客上，当时试着转到过这个域名，发现 &lt;ruby&gt;&lt;rb&gt;自定义域名&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;custom domain&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
只支持 http 不支持 https ，想着还要买自己的证书，于是就扔在了一旁。不用自定义域名的话，
放在 github.io 上是可以用 HTTPS 的。
今天在 &lt;a class="reference external" href="//webchat.freenode.net/?channels=archlinux-cn"&gt;#archlinux-cn&lt;/a&gt; 上受大牛 &lt;a class="reference external" href="/links.html#quininer"&gt;quininer&lt;/a&gt; 和 &lt;a class="reference external" href="/links.html#lilydjwg"&gt;lilydjwg&lt;/a&gt; 点播，
发现 cloudflare 有提供
&lt;a class="reference external" href="https://blog.cloudflare.com/introducing-universal-ssl/"&gt;免费的支持 SSL 的 CDN 服务&lt;/a&gt;
赶快去申请了一个，感觉非常赞，于是就换过来了。&lt;/p&gt;
&lt;p&gt;设置的方法按照 &lt;a class="reference external" href="https://me.net.nz/blog/github-pages-secure-with-cloudflare/"&gt;这篇博文&lt;/a&gt;
说的一步步做下来，如它所述，用 CloudFlare 的优点如下：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;CDN 加速&lt;/li&gt;
&lt;li&gt;SSL (HTTPS) 加密&lt;/li&gt;
&lt;li&gt;支持 SPDY 协议&lt;/li&gt;
&lt;li&gt;支持 IPv6&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年12月29日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;现在不光支持 SPDY 而且支持 HTTP/2 了。&lt;/p&gt;
&lt;p&gt;然后 &lt;strong&gt;免费账户&lt;/strong&gt; 的一些缺点有：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;CloudFlare 和 github.io 之间的数据不是加密的，因为 github
&lt;ruby&gt;&lt;rb&gt;自定义域名&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;custom domain&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 还不支持使用自己的证书。这也是一开始我没用
自定义域名的原因嘛，这没有办法……&lt;/li&gt;
&lt;li&gt;CloudFlare 给免费账户签名的 SSL 证书比较新，不支持一些老的设备和浏览器，比如不支持
老的 XP 系统的 IE 或者 2.x 的 Android。这种情况下没办法只能用没有加密的 HTTP 了。&lt;/li&gt;
&lt;li&gt;不支持 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security"&gt;HSTS 头&lt;/a&gt;
，所以不能从服务器这边强制浏览器用 HTTPS。当然可以放个 javascript 跳转，
也可以用 &lt;a class="reference external" href="https://www.eff.org/https-everywhere"&gt;HTTPSEverywhere&lt;/a&gt; 这种方案。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年12月29日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;如评论中 &lt;a class="reference external" href="http://farseerfc.me/switch-to-farseerfc-dot-me-domain.html#comment-2015037231"&gt;提到的&lt;/a&gt;
现在支持 HSTS 了。&lt;/p&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;设置步骤&lt;/h2&gt;
&lt;p&gt;基本按照默认的选项下一步就可以了。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;和那个博主一样我把 &lt;ruby&gt;&lt;rb&gt;安全级别&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Security profile&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 降到了 Low ，即使是可疑流量也
不会要求输入 CAPTCHA 。&lt;/li&gt;
&lt;li&gt;把 SSL 方式开在 Flexible SSL，访客到 CloudFlare 是加密的，而 CloudFlare 到
github.io 是不加密的。&lt;/li&gt;
&lt;li&gt;把 CDN 开到了 CDT+Full Optimization ，可以对访问加速。由于是完全静态的博客，没有
动态变化的内容，所以应该比较安全。&lt;/li&gt;
&lt;li&gt;服务器设置的一步需要将 &lt;ruby&gt;&lt;rb&gt;域名解析服务器&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;DNS nameservers&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 从狗爹的服务器改到
CloudFlare 的，如下图：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="figure"&gt;
&lt;img alt="更改狗爹的域名服务器" class="img-responsive" src="//farseerfc.me/zhs/images/godaddy.png"/&gt;
&lt;p class="caption"&gt;更改狗爹的域名服务器&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;申请好之后就由 CloudFlare 接管域名解析了，接下来在 CloudFlare 的 DNS 设置添加一条
&lt;a class="reference external" href="https://help.github.com/articles/tips-for-configuring-an-a-record-with-your-dns-provider/"&gt;A 类规则指向 github pages 的 IP&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="更改CloudFlare的DNS规则" class="img-responsive" src="//farseerfc.me/zhs/images/cloudflaredns.png"/&gt;
&lt;p class="caption"&gt;更改CloudFlare的DNS规则&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;等一切都反映到 DNS 服务器上就设置完成了，接下来给
&lt;a class="reference external" href="https://help.github.com/articles/adding-a-cname-file-to-your-repository/"&gt;farseerfc.github.io push 一个 CNAME 文件&lt;/a&gt;
写上我的域名就可以了。我用 Makefile 配合我的 pelican 配置做这个：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;publish&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;rmdrafts&lt;/span&gt; &lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="n"&gt;clean&lt;/span&gt; &lt;span class="n"&gt;theme&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;[&lt;/span&gt; ! -d &lt;span class="k"&gt;$(&lt;/span&gt;OUTPUTDIR&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; find &lt;span class="k"&gt;$(&lt;/span&gt;OUTPUTDIR&lt;span class="k"&gt;)&lt;/span&gt; -mindepth &lt;span class="m"&gt;1&lt;/span&gt; -not -wholename &lt;span class="s2"&gt;"*/.git*"&lt;/span&gt; -delete&lt;/span&gt;
&lt;span class="code-line"&gt;  rm -rf cache&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;SITEURL&lt;span class="k"&gt;)&lt;/span&gt; &amp;gt; content/static/CNAME&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;$(&lt;/span&gt;PELICAN&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;INPUTDIR&lt;span class="k"&gt;)&lt;/span&gt; -o &lt;span class="k"&gt;$(&lt;/span&gt;OUTPUTDIR&lt;span class="k"&gt;)&lt;/span&gt; -s &lt;span class="k"&gt;$(&lt;/span&gt;PUBLISHCONF&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;PELICANOPTS&lt;span class="k"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;$(&lt;/span&gt;MAKE&lt;span class="k"&gt;)&lt;/span&gt; rsthtml&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nf"&gt;github&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;OUTPUTDIR&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; git checkout master&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  env &lt;span class="nv"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"farseerfc.me"&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MAKE&lt;span class="k"&gt;)&lt;/span&gt; publish&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;OUTPUTDIR&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; git add . &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; git commit -m &lt;span class="s2"&gt;"update"&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; git push&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'//'&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;getenv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"SITEURL"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'localhost:8000'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;STATIC_PATHS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'static'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'images'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'uml'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'images/favicon.ico'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'static/CNAME'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;EXTRA_PATH_METADATA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="s1"&gt;'images/favicon.ico'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;'path'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'favicon.ico'&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="s1"&gt;'static/CNAME'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;'path'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'CNAME'&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后把生成的静态网站 push 到 github 之后可以从项目设置里看到域名的变化：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="Github 配置好自定义域名之后的变化" class="img-responsive" src="//farseerfc.me/zhs/images/githubdomain.png"/&gt;
&lt;p class="caption"&gt;Github 配置好自定义域名之后的变化&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;最后把Disqus的评论也迁移到新的域名，disqus有方便的迁移向导，一直下一步就可以了。&lt;/p&gt;
&lt;p&gt;这样就一切都设置妥当了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;致谢&lt;/h2&gt;
&lt;p&gt;最后要感谢提供消息的 &lt;a class="reference external" href="/links.html#quininer"&gt;quininer&lt;/a&gt; 和 &lt;a class="reference external" href="/links.html#lilydjwg"&gt;lilydjwg&lt;/a&gt; ，感谢撰写设置步骤的
&lt;em&gt;Jonathan J Hunt&lt;/em&gt; ， 感谢 CloudFlare 提供免费 SSL CDN 服务，感谢 Github 提供
方便免费的 Pages 托管。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="pelican"></category><category term="domain"></category><category term="cloudflare"></category><category term="github"></category></entry><entry><title>重新设计了 Pelican 的主题与插件</title><link href="//farseerfc.me/zhs/redesign-pelican-theme.html" rel="alternate"></link><published>2015-01-25T22:45:00+09:00</published><updated>2015-01-25T22:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-01-25:/zhs/redesign-pelican-theme.html</id><summary type="html">
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月14日更新&lt;/strong&gt;&lt;/div&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id38"&gt;前言: 新天新地，将一切都更新了 &lt;a class="footnote-reference" href="#id37" id="id1"&gt;[1]&lt;/a&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;不知不觉间放任这边长草很久了，从上次
&lt;a class="reference external" href="//farseerfc.me/zhs/try-pelican.html"&gt;折腾主题&lt;/a&gt; 到现在都快三年了，
而从上次 &lt;a class="reference external" href="//farseerfc.me/zhs/marry-me.html"&gt;写了篇告白信&lt;/a&gt; 到现在也有快两年了。
这期间曾经把主题配色从 &lt;a class="reference external" href="http://getbootstrap.com/2.3.2/"&gt;Bootstrap 2&lt;/a&gt; 默认的
白底黑字改成了让眼睛更舒适的黑底白字，也不过是用 drop-in 的配色方案而已，没有本质上的改进。&lt;/p&gt;
&lt;p&gt;洞中一日世上千载，两年里 Bootstrap 已经升上 &lt;a class="reference external" href="http://getbootstrap.com/"&gt;v3.3&lt;/a&gt; ,
而 Pelican 则已经升到 &lt;a class="reference external" href="https://github.com/getpelican/pelican/releases/tag/3.5.0"&gt;3.5&lt;/a&gt; 了。
早就眼馋 Bootstrap 和 Pelican 中的诸多新功能新设计，不过无奈于时间有限只能饱饱眼福。&lt;/p&gt;
&lt;p&gt;近日想写的东西越积越多，终于下定决心花了前前后后 &lt;strong&gt;两个月&lt;/strong&gt; 的时间重新设计了一遍
Pelican 的主题，配合一些我觉得有用的插件。于是本博客就变成你们现在看到的样子了。
（以及本篇博文也用了两个月的时间写完，其间还发了几篇别的短文，算是恢复写博客的尝试吧 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月14日更新&lt;/strong&gt;&lt;/div&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id38"&gt;前言: 新天新地，将一切都更新了 &lt;a class="footnote-reference" href="#id37" id="id1"&gt;[1]&lt;/a&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;不知不觉间放任这边长草很久了，从上次
&lt;a class="reference external" href="//farseerfc.me/zhs/try-pelican.html"&gt;折腾主题&lt;/a&gt; 到现在都快三年了，
而从上次 &lt;a class="reference external" href="//farseerfc.me/zhs/marry-me.html"&gt;写了篇告白信&lt;/a&gt; 到现在也有快两年了。
这期间曾经把主题配色从 &lt;a class="reference external" href="http://getbootstrap.com/2.3.2/"&gt;Bootstrap 2&lt;/a&gt; 默认的
白底黑字改成了让眼睛更舒适的黑底白字，也不过是用 drop-in 的配色方案而已，没有本质上的改进。&lt;/p&gt;
&lt;p&gt;洞中一日世上千载，两年里 Bootstrap 已经升上 &lt;a class="reference external" href="http://getbootstrap.com/"&gt;v3.3&lt;/a&gt; ,
而 Pelican 则已经升到 &lt;a class="reference external" href="https://github.com/getpelican/pelican/releases/tag/3.5.0"&gt;3.5&lt;/a&gt; 了。
早就眼馋 Bootstrap 和 Pelican 中的诸多新功能新设计，不过无奈于时间有限只能饱饱眼福。&lt;/p&gt;
&lt;p&gt;近日想写的东西越积越多，终于下定决心花了前前后后 &lt;strong&gt;两个月&lt;/strong&gt; 的时间重新设计了一遍
Pelican 的主题，配合一些我觉得有用的插件。于是本博客就变成你们现在看到的样子了。
（以及本篇博文也用了两个月的时间写完，其间还发了几篇别的短文，算是恢复写博客的尝试吧。）&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
在迈阿密参加 &lt;a class="reference external" href="http://icsr2015.ipd.kit.edu/"&gt;ICSR 2015&lt;/a&gt; 的时候
拍到的街边一家叫 Pelican 的旅馆&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Pelican Hotel" class="img-responsive" src="//farseerfc.me/zhs/images/pelican.jpg"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="bootstrap-3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id39"&gt;Bootstrap 3 的新设计&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;全新的 &lt;ruby&gt;&lt;rb&gt;优先移动设备&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;mobile-first&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; &lt;ruby&gt;&lt;rb&gt;响应式&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;responsive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 设计。
原本Bootstrap 2虽然有响应式设计，
不过诸多细节不能符合我的需求，最终还是得手工 hack &lt;code class="code"&gt;
@media&lt;/code&gt;
 查询去微调。
现在的 &lt;ruby&gt;&lt;rb&gt;优先移动设备&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;mobile-first&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; &lt;ruby&gt;&lt;rb&gt;响应式&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;responsive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
&lt;ruby&gt;&lt;rb&gt;栅格系统&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;grid system&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 则相对显得科学很多了，也终于能在手持
设备上看起来舒服一些。诸位可以尝试改变窗口宽度，或者在不同的手持设备上打开这个
blog ，体验一下这个页面在不同显示器大小中的效果。如果仍有问题欢迎
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/issues"&gt;发 Issue 给我&lt;/a&gt;  。&lt;/li&gt;
&lt;li&gt;科学的 &lt;ruby&gt;&lt;rb&gt;导航栏&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Navbar&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。
比 Bootstrap 2 那个科学很多了。无论是 &lt;ruby&gt;&lt;rb&gt;保持&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;sticky&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 在上端还是跟着浮动，
或者像这边这样 &lt;a class="reference external" href="http://www.virtuosoft.eu/code/bootstrap-autohidingnavbar/"&gt;自动隐藏&lt;/a&gt; 都很简单。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多细节参考 &lt;a class="reference external" href="http://getbootstrap.com/"&gt;Bootstrap 3 主页&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pelican-3-5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id40"&gt;Pelican 3.5 的新功能&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Python 2 和 Python 3 统一代码：
再没有恼人的 unicode 相关的问题了。这对 blog 系统来说相当重要啊。
而且还能方便切换 pypy 等不同的解释器。&lt;/li&gt;
&lt;li&gt;全新的插件系统：非常多功能强大的 &lt;a class="reference external" href="https://github.com/getpelican/pelican-plugins"&gt;插件&lt;/a&gt; 等着你。&lt;/li&gt;
&lt;li&gt;增强了导入系统：嗯总算可以导入我的中文的 wordpress 博客了。（虽然那边长草更久了……）&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://pelican.readthedocs.org/en/latest/content.html#linking-to-internal-content"&gt;站内链接&lt;/a&gt;
：不用 &lt;ruby&gt;&lt;rb&gt;硬编码&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;hard code&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 目标页面的链接了，可以直接写源文件的位置然后让 pelican
处理，这样能简化各种 &lt;ruby&gt;&lt;rb&gt;插件&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;plugin&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 和 &lt;ruby&gt;&lt;rb&gt;主题&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;theme&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多细节参考 &lt;a class="reference external" href="http://pelican.readthedocs.org/en/latest/"&gt;Pelican 文档&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id41"&gt;新的文件夹布局&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Pelican 的新文件夹布局&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;pre&gt;&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span style="color:blue;font-weight:bold;"&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:blue;font-weight:bold;"&gt;cache&lt;/span&gt;             生成页面的 pickle 缓存&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:blue;font-weight:bold;"&gt;content&lt;/span&gt;           读取的全部内容&lt;/span&gt;
&lt;span class="code-line"&gt;│   ├── &lt;span style="color:blue;font-weight:bold;"&gt;&amp;lt;categories&amp;gt;&lt;/span&gt;      按分类存放的文章&lt;/span&gt;
&lt;span class="code-line"&gt;│   ├── &lt;span style="color:blue;font-weight:bold;"&gt;pages&lt;/span&gt;             像 About 这样的固定页面&lt;/span&gt;
&lt;span class="code-line"&gt;│   └── &lt;span style="color:blue;font-weight:bold;"&gt;static&lt;/span&gt;            文章内用到的静态内容&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:blue;font-weight:bold;"&gt;drafts&lt;/span&gt;            文章的草稿箱&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:green;font-weight:bold;"&gt;Makefile&lt;/span&gt;          生成用的 makefile&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:green;font-weight:bold;"&gt;pelicanconf.py&lt;/span&gt;    测试时用的快速 Pelican 配置&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:green;font-weight:bold;"&gt;publishconf.py&lt;/span&gt;    部署时用的耗时 Pelican 配置&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:teal;font-weight:bold;"&gt;output&lt;/span&gt;          -&amp;gt; &lt;span style="color:blue;font-weight:bold;"&gt;../farseerfc.github.io&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:teal;font-weight:bold;"&gt;plugins&lt;/span&gt;         -&amp;gt; &lt;span style="color:blue;font-weight:bold;"&gt;../pelican-plugins&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;└── &lt;span style="color:teal;font-weight:bold;"&gt;theme&lt;/span&gt;           -&amp;gt; &lt;span style="color:blue;font-weight:bold;"&gt;../pelican-bootstrap3&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/farseerfc/farseerfc.github.com"&gt;之前的博客&lt;/a&gt; 仍然留在
github 上，其中的内容完全搬过来了。开始写老博客的时候 Pelican 版本较早，没有形成好的
文件夹布局，导致生成的文章、使用的模板和撰写的内容全都混在一起，非常难以管理，
于是趁改版之际用了新的文件夹布局方式，并分为 4 个 git repo 分别管理历史。&lt;/p&gt;
&lt;p&gt;首先是存放 &lt;a class="reference external" href="https://github.com/farseerfc/farseerfc"&gt;总的博客内容的 repo&lt;/a&gt; ，
其布局是如图那样的。这样将生成的静态网站和生成网站用的配置啦内容啦分开之后，顿时清晰了很多。&lt;/p&gt;
&lt;p&gt;然后这个内容 repo 中的三个符号链接分别指向三个子 repo（没用 &lt;code class="code"&gt;
git submodule&lt;/code&gt;

管理纯粹是因为偷懒）。 theme 指向
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3"&gt;pelican-bootstrap3&lt;/a&gt;
，是我修改过的 pelican 主题。
plugins 指向 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-plugins"&gt;pelican-plugins&lt;/a&gt;
，由于 plugins 的质量有些参差不齐，其中不少 plugin
都按我的需要做了些许修改，一些是功能改进，另一些则是修bug（比如不少plugin只支持 python 2）。
最后 output 指向
&lt;a class="reference external" href="https://github.com/farseerfc/farseerfc.github.io"&gt;farseerfc.github.io&lt;/a&gt;
也就是发布的静态网站啦。&lt;/p&gt;
&lt;p&gt;接下来从 &lt;strong&gt;主题&lt;/strong&gt; 和 &lt;strong&gt;插件&lt;/strong&gt; 两个方面介绍一下改版的细节。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="material-design-bootstrap-3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id42"&gt;主题： Material Design 风格的 Bootstrap 3&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上篇 &lt;a class="reference external" href="//farseerfc.me/zhs/summarize-material-design-css-framework.html"&gt;博文&lt;/a&gt;
就总结了我为了这个博客寻找了一堆 CSS 框架，并且最终决定用
&lt;a class="reference external" href="http://fezvrasta.github.io/bootstrap-material-design/"&gt;bootstrap-material-design&lt;/a&gt;
, &lt;a class="reference external" href="https://github.com/DandyDev/pelican-bootstrap3"&gt;DandyDev/pelican-bootstrap3&lt;/a&gt;
和 &lt;a class="reference external" href="http://getbootstrap.com/"&gt;Bootstrap 3&lt;/a&gt; 这三个项目结合的方式实现这个模板的主题。
这三个项目都或多或少经过了我的修改，修改后的项目以 pelican-bootstrap3 为基础放在
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3"&gt;这里&lt;/a&gt; ，包括 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/tree/master/static/bootstrap"&gt;Bootstrap3 样式&lt;/a&gt;
和 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/tree/master/static/material"&gt;Material 样式&lt;/a&gt;。&lt;/p&gt;
&lt;div class="section" id="id16"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id43"&gt;对 Bootstrap 3 的定制&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;由于架构完善，修改 Bootstrap 3 感觉非常简单。另一方面我在 Web 前端技术上的技能点也不多，
所以修改的地方非常有限，只能按我自己的需求定制而已。&lt;/p&gt;
&lt;div class="section" id="id17"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id44"&gt;响应式设备的大小&lt;/a&gt;&lt;/h4&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
修改了 Bootstrap 3 响应式设备的大小&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;screen-xs&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="nt"&gt;320px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;screen-sm&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="nt"&gt;598px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;/*  768px; */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;screen-md&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="nt"&gt;952px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;/*  992px; */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;screen-lg&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="nt"&gt;1350px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;/* 1200px; */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;screen-xl&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="nt"&gt;2030px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;container-sm&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="nt"&gt;582px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;/*  750px; */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;container-md&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="nt"&gt;930px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;/*  970px; */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;container-lg&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;1320px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;/* 1170px; */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;container-xl&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;1990px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;首先把 Bootstrap 3 默认适配的几个 &lt;a class="reference external" href="http://getbootstrap.com/css/#grid"&gt;响应式设备的大小&lt;/a&gt;
改成了我需要的大小。 &lt;code class="code"&gt;
xs&lt;/code&gt;
 和 &lt;code class="code"&gt;
sm&lt;/code&gt;
 的大小分别按照我的手机屏幕 &lt;strong&gt;竖屏&lt;/strong&gt; 和
&lt;strong&gt;横屏&lt;/strong&gt; 时候的浏览器页面宽度来算， &lt;code class="code"&gt;
md&lt;/code&gt;
 是想兼容 Nexus 7 横屏 960 的宽度以及
一个常见上网本 1024 的宽度。 &lt;code class="code"&gt;
lg&lt;/code&gt;
 的大小则按照常见的笔记本 1366 宽的屏幕来适配。&lt;/p&gt;
&lt;p&gt;这里 Bootstrap 3 支持的设备大小的一个问题是，它最多考虑到 1200 像素宽的显示器，而更宽的
比如 1600、 2048 甚至 2560 像素宽的显示器现在也并不少见，其结果就是页面中左右两侧
有很大的空间被浪费掉了。作为深受这一问题困扰的用户之一，我用
&lt;a class="reference external" href="http://stackoverflow.com/a/25644266"&gt;这里介绍的方法&lt;/a&gt;
给 bootstrap 增加了一类「 &lt;ruby&gt;&lt;rb&gt;比大更大&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;bigger than bigger&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 」的
&lt;code class="code"&gt;
xl&lt;/code&gt;
 响应式设备尺寸，宽度设为支持 2048 像素宽的显示器，具体的修改反映在
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/blob/master/static/bootstrap/variables.less"&gt;variables.less&lt;/a&gt;
文件里。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id20"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id45"&gt;根据宽度自动分栏和瀑布式布局&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;接下来目标是让主页的文章列表像 Google+ 主页那样根据显示器宽度自动调整分栏，使得宽度不同的
显示器上每个分栏的宽度接近。想要达到的效果是，根据上面定义的屏幕宽度尺寸：&lt;/p&gt;
&lt;table border="0" class="docutils table borderless"&gt;
&lt;colgroup&gt;
&lt;col width="26%"/&gt;
&lt;col width="17%"/&gt;
&lt;col width="18%"/&gt;
&lt;col width="39%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;code class="code"&gt;
xs&lt;/code&gt;
 用单栏 &lt;ruby&gt;&lt;rb&gt;流动&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;fluid&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 布局&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;code class="code"&gt;
sm&lt;/code&gt;
 用上方单栏文章列表、下方双栏 &lt;ruby&gt;&lt;rb&gt;侧边栏&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;sidebar&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 固定布局&lt;/td&gt;
&lt;td&gt;&lt;code class="code"&gt;
md&lt;/code&gt;
 用单栏文章列表、单栏 侧边栏 固定布局&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;table border="0" class="docutils table first last borderless"&gt;
&lt;colgroup&gt;
&lt;col width="100%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;ruby&gt;&lt;rb&gt;导航栏&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Navbar&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;侧边栏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;底栏&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;table border="0" class="docutils table first last borderless"&gt;
&lt;colgroup&gt;
&lt;col width="53%"/&gt;
&lt;col width="47%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;导航栏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;文章&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;侧边栏 1&lt;/td&gt;
&lt;td&gt;侧边栏 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;&lt;ruby&gt;&lt;rb&gt;底栏&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;footer&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;td&gt;&lt;table border="0" class="docutils table first last borderless"&gt;
&lt;colgroup&gt;
&lt;col width="53%"/&gt;
&lt;col width="47%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;导航栏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章 1&lt;/td&gt;
&lt;td&gt;侧边栏 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章 2&lt;/td&gt;
&lt;td&gt;侧边栏 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;&lt;ruby&gt;&lt;rb&gt;底栏&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;footer&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;&lt;code class="code"&gt;
lg&lt;/code&gt;
 用双栏文章列表、单栏 侧边栏 固定布局&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;code class="code"&gt;
xl&lt;/code&gt;
 用三栏文章列表、双栏 侧边栏 固定布局&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;&lt;table border="0" class="docutils table first last borderless"&gt;
&lt;colgroup&gt;
&lt;col width="35%"/&gt;
&lt;col width="35%"/&gt;
&lt;col width="31%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td colspan="3"&gt;导航栏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章 1&lt;/td&gt;
&lt;td&gt;文章 3&lt;/td&gt;
&lt;td&gt;侧边栏 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章 2&lt;/td&gt;
&lt;td&gt;文章 4&lt;/td&gt;
&lt;td&gt;侧边栏 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="3"&gt;&lt;ruby&gt;&lt;rb&gt;底栏&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;footer&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;table border="0" class="docutils table first last borderless"&gt;
&lt;colgroup&gt;
&lt;col width="26%"/&gt;
&lt;col width="26%"/&gt;
&lt;col width="26%"/&gt;
&lt;col width="23%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td colspan="4"&gt;导航栏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章 1&lt;/td&gt;
&lt;td&gt;文章 3&lt;/td&gt;
&lt;td&gt;文章 5&lt;/td&gt;
&lt;td&gt;侧边栏 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章 2&lt;/td&gt;
&lt;td&gt;文章 4&lt;/td&gt;
&lt;td&gt;文章 6&lt;/td&gt;
&lt;td&gt;侧边栏 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="4"&gt;&lt;ruby&gt;&lt;rb&gt;底栏&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;footer&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一开始纯粹用 Bootstrap3 的响应式栅格实现这个分栏布局，结果发现效果不太理想，
因为文章列表和侧边栏的高度是变化的，会导致栅格间留下大片空白。后来改用
&lt;a class="reference external" href="http://cssdeck.com/labs/pinterest-like-waterfall-design-purely-css"&gt;这里示范的纯CSS瀑布式布局&lt;/a&gt;
实现文章和侧边栏的布局，具体的实现代码在
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/blob/master/static/bootstrap/waterfall.less"&gt;waterfall.less&lt;/a&gt;
，总算达到了想要的布局了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id21"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id46"&gt;正文的样式&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;最最重要的是文章正文的样式。这里我想要达到的效果是，在大屏幕上用更大的字号，让读者
看起来更舒适，同时在小屏幕上用比较小的字号，最终保证基本上「一行」的文字数接近。这个修改
主要针对 &lt;code class="code"&gt;
.jumbotron&lt;/code&gt;
，
用了 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/blob/master/static/bootstrap/jumbotron.less"&gt;不太科学的方式&lt;/a&gt;
代码太长就不贴全了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id23"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id47"&gt;一些细微的定制&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;把主题配色改成了现在这样的淡紫色
&lt;code class="code"&gt;
@brand-primary: darken(#6B5594, 6.5%);&lt;/code&gt;

，配合我的头像风格， 这个修改只需要一行。
接着删掉了 &lt;code class="code"&gt;
.btn&lt;/code&gt;
 的 &lt;code class="code"&gt;
white-space: nowrap;&lt;/code&gt;
 让按钮的文字可以换行，
这也只是一行修改。&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年1月29日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;另外我也不太喜欢 Bootstrap 3 默认在手机上的 &lt;ruby&gt;&lt;rb&gt;折叠导航栏&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;collapsed navbar&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; ，
折叠之后的操作不够直观方便而且依赖 javascript 所以有 bug …… 于是我把它关掉了，
具体方式是在 variables.less 把 &lt;code class="code"&gt;
@grid-float-breakpoint&lt;/code&gt;
 和
&lt;code class="code"&gt;
@grid-float-breakpoint-max&lt;/code&gt;
 都设为0就可以了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id24"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id48"&gt;对 bootstrap-material-design 的定制&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这里定制的地方不多。原样式中一个不太科学的做法是所有 &lt;code class="code"&gt;
.btn&lt;/code&gt;
 都强制加上了阴影
效果，这在已经有阴影的环境里用的话非常碍眼，像是 Win9x 风格的厚重睫毛膏。既然可以单独
给每个样式加阴影，于是就把 &lt;code class="code"&gt;
.btn&lt;/code&gt;
 强制的阴影去掉了，只保留鼠标悬停之后强调的阴影。&lt;/p&gt;
&lt;p&gt;其它定制的细节么就是统一配色风格，修补漏洞错误，微调响应式效果而已，这里不细说。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id25"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id49"&gt;将以上两者整合在 pelican-bootstrap3 里&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Pelican 实现显示源代码按钮&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;p&gt;显示源代码按钮借用了 Pelican 配置中自带的 &lt;code class="code"&gt;
OUTPUT_SOURCES&lt;/code&gt;
 选项将源文件复制到输出文件夹：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;OUTPUT_SOURCES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;OUTPUT_SOURCES_EXTENSION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'.rst'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在 Makefile 里用 pygmentize 把所有源代码文件着色：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;find -iname &lt;span class="s2"&gt;"*.rst"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; parallel -I@  pygmentize -f html -o @.html @&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后在按钮按下的时候用 jQuery 载入源代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;onclick&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"$.get('{{SITEURL}}/{{article.slug}}.rst.html', function(data){$('#source-code').html(data)});$('#article-content').toggle();$('#source-content').toggle();"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然难看的 hack 比较多，但是能用！&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;虽说 pelican-bootstrap3 是我 fork 出来的，不过由于我修改的地方实在太多，代码看来基本上
接近重写了一份。好在之前有给 pelican 写 bootstrap 2 主题的经验，这次修改算得上驾轻就熟。
可以对比一下 &lt;a class="reference external" href="http://dandydev.net/"&gt;上游作者的博客&lt;/a&gt; 和这里的样子体会一下感觉。
具体修改过的地方包括：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;套用 bootstrap-material-design 的各个元素样式。&lt;/li&gt;
&lt;li&gt;在文章列表模板应用上面提到的 Bootstrap 3 的栅格布局和瀑布式布局。&lt;/li&gt;
&lt;li&gt;翻译到多个语言，这里在后面的 i18n-subsite 插件里详述。&lt;/li&gt;
&lt;li&gt;套用后面会介绍到的各种插件。&lt;/li&gt;
&lt;li&gt;统一侧边栏的样式到一个模板里。&lt;/li&gt;
&lt;li&gt;添加 Atom 订阅按钮和 breadcrumb 条。&lt;/li&gt;
&lt;li&gt;对正文中出现的插图，添加点击放大的功能，通过 Bootstrap 的 &lt;code class="code"&gt;
modal&lt;/code&gt;
 实现。&lt;/li&gt;
&lt;li&gt;上面提到的用 &lt;a class="reference external" href="http://www.virtuosoft.eu/code/bootstrap-autohidingnavbar/"&gt;这个bootstrap插件&lt;/a&gt;
让导航栏自动隐藏。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;显示源代码按钮&lt;/strong&gt; ，也就是每篇文章信息栏中的
&lt;button class="btn btn-primary"&gt;&lt;i class="fa fa-code"&gt;&lt;/i&gt;&lt;/button&gt; 按钮。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pelican-restructuredtext"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id50"&gt;插件: 发挥 Pelican 和 reStructuredText 的优势&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;先列举一下我目前用到的所有插件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;PLUGINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"i18n_subsites"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s2"&gt;"plantuml"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s2"&gt;"youku"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s2"&gt;"youtube"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'tipue_search'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'neighbors'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'series'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'bootstrapify'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'twitter_bootstrap_rst_directives'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s2"&gt;"render_math"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'extract_toc'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'summary'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嗯其实不算多。接下来逐一介绍一下这些各具特色的插件。&lt;/p&gt;
&lt;div class="section" id="i18n-subsites"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id51"&gt;i18n-subsites&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个插件的目的是创建 &lt;ruby&gt;&lt;rb&gt;国际化&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;internationalization&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
&lt;ruby&gt;&lt;rb&gt;子站&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;subsite&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。&lt;/p&gt;
&lt;p&gt;之前介绍 Pelican 配置的时候就提到过，
原本的 Pelican 就支持一篇文章用多种语言书写，有 &lt;code class="code"&gt;
lang&lt;/code&gt;
 属性注明这篇文章使用的
语言，以及 &lt;code class="code"&gt;
slug&lt;/code&gt;
 属性注明多语言的翻译之间的关联，换句话说同一篇文章的多个语言
版本应该有相同的 &lt;code class="code"&gt;
slug&lt;/code&gt;
 和不同的 &lt;code class="code"&gt;
lang&lt;/code&gt;
。然后原本 Pelican 里对多语言的
实现方式是，首先有一个 &lt;strong&gt;主语言&lt;/strong&gt; 是模板和大部分文章采用的语言，文章列表中会优先列出
用 &lt;strong&gt;主语言&lt;/strong&gt; 撰写的文章，然后从 &lt;strong&gt;主语言&lt;/strong&gt; 的文章链接到别的翻译版本。
很多博客系统和CMS对多语言的支持都是这样的，这种处理方式的缺点也显而易见：作为 &lt;strong&gt;主语言&lt;/strong&gt;
的语言必须足够通用，才能让进来的人找到合适的翻译版本，所以通常 &lt;strong&gt;主语言&lt;/strong&gt; 都是英语。&lt;/p&gt;
&lt;p&gt;而这个插件做的事情描述起来很简单：将文章按语言属性分到多个子站，每个子站独立放在各自的文件夹。
比如主站是 &lt;a class="reference external" href="https://farseerfc.github.io/"&gt;https://farseerfc.github.io/&lt;/a&gt; 的话，那么英语的子站就可以是
&lt;a class="reference external" href="https://farseerfc.github.io/en/"&gt;https://farseerfc.github.io/en/&lt;/a&gt; 。
然后分别对多个子站生成静态页面。具体的实现方式是对 pelican 的页面生成步骤做了拆分：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;pelican 按正常情况读入文章，生成元信息。&lt;/li&gt;
&lt;li&gt;i18n-subsites 针对每个语言，覆盖掉 pelican 的一些选项设置比如路径和 URL ，
分别调用 pelican 的页面生成器按模板生成文章。&lt;/li&gt;
&lt;li&gt;对共用的静态内容比如模板的 js 和 css 文件，只在主站中生成，子站中的相应链接全部链回主站。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然描述起来简单，但是这个插件可以说最大化利用了 Pelican 的插件系统，实现细节相对比较
复杂，大概是我用的这些插件里面最复杂的了。不夸张的说 Pelican 3.4 支持的新插件 API 和
站内链接功能基本上就是为了配合这个插件的。至于具体它会覆盖哪些 Pelican 的配置，请参阅它的
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-plugins/blob/master/i18n_subsites/README.rst"&gt;README.md文件&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;按内容拆分多语言子站的做法只解决了问题的一半，还留下另一半的问题，也即对模板的翻译。
对这个问题， i18n-subsites 提供了两套方案供选择：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;用覆盖配置路径的方式让每个子站套用不同的模板。这配置起来简单，但是对模板维护起来有点困难。&lt;/li&gt;
&lt;li&gt;用 jinja2 的 i18n 插件，配合 Python 的 gettext 库实现内容翻译。这个方案
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-plugins/blob/master/i18n_subsites/localizing_using_jinja2.rst"&gt;配置起来比较复杂&lt;/a&gt; ，但是配置好之后用起来就很方便了。
只是要记得每次修改了模板都要更新翻译，处理 *.po 和 *.mo 文件等等琐碎事宜。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我用 jinja2 的 i18n 插件的方式实现了模板的翻译，
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/tree/master/translations"&gt;各个语言的翻译在这里&lt;/a&gt; ，
然后用 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/blob/master/SConstruct"&gt;这里的 SCons 脚本&lt;/a&gt;
根据内容是否变化自动更新 po 和 mo 文件。&lt;/p&gt;
&lt;p&gt;配置好这一套方案之后，还要注意在模板和文章中处理好链接。用 Pelican 3.4 之后推荐的
新的文章间链接的写法以及将 &lt;code class="code"&gt;
SITEURL&lt;/code&gt;
 设置为实际 URL 并且关闭 &lt;code class="code"&gt;
RELATIVE_URLS&lt;/code&gt;

之后，应该就不会出没什么问题了（可能还要考虑使用的模板和插件的兼容性，大部分都是写死了 URL 的问题）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="plantuml"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id52"&gt;plantuml&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
嵌入 PlantUML 的示例&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="uml diagram" class="img-responsive uml" src="//farseerfc.me/uml/8e4b1ee3.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="http://plantuml.sourceforge.net/"&gt;PlantUML&lt;/a&gt; 是一个Java实现的，
用接近文字描述的语言绘制 UML 图或者 GUI 界面图的工具，非常适合嵌入在
Markdown、 reStructuredText、 AsciiDoc 等这种轻量级标记语言里。
然后么这个 plantuml 插件就是定义了一个新的 reStructuredText
&lt;ruby&gt;&lt;rb&gt;指示符&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;directive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; &lt;code class="code"&gt;
.. uml::&lt;/code&gt;
，把嵌入的内容提取出来调用 plantuml 命令处理
成图像然后再插入到文章中。&lt;/p&gt;
&lt;p&gt;比如示例里的这个 UML 图就是用这样一段简单的文字描述生成的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt; &lt;span class="ow"&gt;uml&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    Object &amp;lt;|-- ArrayList&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    Object : equals()&lt;/span&gt;
&lt;span class="code-line"&gt;    ArrayList : Object[] elementData&lt;/span&gt;
&lt;span class="code-line"&gt;    ArrayList : size()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际用起来这个插件实现上稍微有点小问题：首先它只支持 python2，所以我把它改写成了 python
2 和 3 都通用的语法；其次它原本输出的文件夹似乎会被 pelican 删掉，所以把它改了个位置；
然后它输出的 URL 也和 i18n-subsites 插件间有不兼容的问题，也顺带修掉了。
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-plugins/tree/master/plantuml"&gt;修改之后的代码在这里&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年1月30日更新&lt;/strong&gt;&lt;/div&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
嵌入 Ditaa 的示例&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/973a8424.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;plantuml 是绘制UML的，除此之外还有一个类似的工具是绘制一般的 &lt;ruby&gt;&lt;rb&gt;流程图&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;diagram&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
的，叫 &lt;a class="reference external" href="http://ditaa.sourceforge.net/"&gt;ditaa&lt;/a&gt; ，和 plantuml 非常像，也比较像
reStructuredText 的表格。
于是我也照猫画虎实现了一个 ditaa 的 &lt;ruby&gt;&lt;rb&gt;指示符&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;directive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; ，用起来类似这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt; &lt;span class="ow"&gt;ditaa&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;                       +-------------+&lt;/span&gt;
&lt;span class="code-line"&gt;                       &lt;span class="o"&gt;|&lt;/span&gt;   ditaa     |-------+&lt;/span&gt;
&lt;span class="code-line"&gt;                       &lt;span class="o"&gt;|&lt;/span&gt;  Diagram    |       |&lt;/span&gt;
&lt;span class="code-line"&gt;                       +-------------+       | PNG out&lt;/span&gt;
&lt;span class="code-line"&gt;                           ^                 |&lt;/span&gt;
&lt;span class="code-line"&gt;                           &lt;span class="o"&gt;|&lt;/span&gt; ditaa in        |&lt;/span&gt;
&lt;span class="code-line"&gt;                           &lt;span class="o"&gt;|&lt;/span&gt;                 v&lt;/span&gt;
&lt;span class="code-line"&gt;     +--------+   +--------+----+    /----------------\&lt;/span&gt;
&lt;span class="code-line"&gt;     &lt;span class="o"&gt;|&lt;/span&gt;        | --+   Pelican   +--&amp;gt; |                |&lt;/span&gt;
&lt;span class="code-line"&gt;     &lt;span class="o"&gt;|&lt;/span&gt;  Text  |   +-------------+    | Beautiful Blog |&lt;/span&gt;
&lt;span class="code-line"&gt;     |Document|   |   !magic!   |    |                |&lt;/span&gt;
&lt;span class="code-line"&gt;     &lt;span class="o"&gt;|&lt;/span&gt;     {d}|   |             |    |                |&lt;/span&gt;
&lt;span class="code-line"&gt;     +---+----+   +-------------+    \----------------/&lt;/span&gt;
&lt;span class="code-line"&gt;         :                                   ^&lt;/span&gt;
&lt;span class="code-line"&gt;         &lt;span class="o"&gt;|&lt;/span&gt;          Lots of work             |&lt;/span&gt;
&lt;span class="code-line"&gt;         +-----------------------------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="render-math"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id53"&gt;render-math&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
嵌入公式的示例&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;p&gt;示范行内公式 &lt;span class="math"&gt;\(A_\text{c} = (\pi/4) d^2\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;整行公式&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\alpha{}_t(i) = P(O_1, O_2, \ldots  O_t, q_t = S_i \lambda{})
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这个插件提供在 reStructuredText 中用 LaTeX 语法插入数学公式的能力，定义了
&lt;code class="code"&gt;
:math:&lt;/code&gt;
&lt;ruby&gt;&lt;rb&gt;行内角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 和 &lt;code class="code"&gt;
.. math::&lt;/code&gt;
&lt;ruby&gt;&lt;rb&gt;指示符&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;directive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。
实际工作的渲染库当然是大名鼎鼎的 &lt;a class="reference external" href="http://www.mathjax.org/"&gt;MathJax&lt;/a&gt; ，这个插件
会用 MathJax 的 CDN 载入，所以也没有额外的依赖文件。（只是不知道是否会被国内墙掉，
如果公式显示不正常请 &lt;strong&gt;务必&lt;/strong&gt; 告诉我。）&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="youtube-youku"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id54"&gt;youtube 和 youku&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;顾名思义，这两个插件分别实现嵌入 youtube 和 youku 视频。其中 youtube 是原本就有的插件，
youku 是我照猫画虎抄的。
之前写了一篇
&lt;a class="reference external" href="//farseerfc.me/zhs/jumping-kde5-plasma-activities-button.html"&gt;KDE5 Plasma 之跳动卖萌的活动按钮&lt;/a&gt;
用到了这两个插件。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tipue-search"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id55"&gt;tipue_search&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.tipue.com/search/"&gt;Tipue search&lt;/a&gt; 是一个非常有意思也很强大的搜索工具，
通过 jQuery 实现静态博客的站内搜索功能。实现方式是，它需要你写一个 json 文件，包含
整个网站的 &lt;strong&gt;全部&lt;/strong&gt; 文章的标题和文字内容，然后在搜索的时候读入这个 json 做搜索（是不是有点耍赖）。
虽然听起来会有性能问题，但是应用在小型的静态博客上效果意外很不错，比如本站的所有文章内容
放在一起的 json 也只有 300KiB 左右。&lt;/p&gt;
&lt;p&gt;这个插件就是自动在 pelican 输出完全部静态网页之后，调用 beautifulsoup4 从所有网页中抽取出
纯文本，产生这个 json 给 Tipue 用。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="neighbors-series"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id56"&gt;neighbors 和 series&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这两个插件比较类似也都比较简单， neighbors 提供一篇文章的前后文章信息，
在主题模板里可以用来制作 &lt;strong&gt;上一篇&lt;/strong&gt; 和 &lt;strong&gt;下一篇&lt;/strong&gt; 按钮。
series 提供将多篇文章归类为一个 &lt;strong&gt;系列&lt;/strong&gt; 的支持，当然也需要在
主题模板中定义显示「文章系列」的列表。这两个插件的效果都能在本文末尾，评论区上方的部分看到。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bootstrapify-twitter-bootstrap-rst-directives"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id57"&gt;bootstrapify 和 twitter_bootstrap_rst_directives&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这两个插件让文章的 &lt;strong&gt;正文&lt;/strong&gt; 套用上 Bootstrap 的样式。&lt;/p&gt;
&lt;p&gt;bootstrapify 这个插件实现得比较简单，用 beautifulsoup4 在静态网页的结果里面过滤元素，
对 &lt;code class="code"&gt;
table&lt;/code&gt;
 , &lt;code class="code"&gt;
img&lt;/code&gt;
 , &lt;code class="code"&gt;
embed&lt;/code&gt;
 , &lt;code class="code"&gt;
iframe&lt;/code&gt;
 ,
&lt;code class="code"&gt;
video&lt;/code&gt;
 , &lt;code class="code"&gt;
object&lt;/code&gt;
 这几个标签套用上
&lt;a class="reference external" href="http://getbootstrap.com/components/#responsive-embed"&gt;响应式嵌入对象的类&lt;/a&gt;
让他们更美观。&lt;/p&gt;
&lt;p&gt;twitter_bootstrap_rst_directives 这个插件则是增加了几个 reStructuredText 的
&lt;ruby&gt;&lt;rb&gt;行内角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 和 &lt;ruby&gt;&lt;rb&gt;指示符&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;directive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。
它实现的 &lt;ruby&gt;&lt;rb&gt;行内角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 包括：
用 &lt;code class="code"&gt;
:kbd:&lt;/code&gt;
 实现如 &lt;kbd class="kbd"&gt;
Ctrl+C&lt;/kbd&gt;
 这样的键盘快捷键，
用 &lt;code class="code"&gt;
:code:&lt;/code&gt;
 嵌入代码片段，用 &lt;code class="code"&gt;
:glyph:&lt;/code&gt;
 嵌入字符图标。
它实现的 &lt;ruby&gt;&lt;rb&gt;指示符&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;directive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 包括：
&lt;a class="reference external" href="http://getbootstrap.com/components/#labels"&gt;labels 行内标签&lt;/a&gt; ，
&lt;a class="reference external" href="http://getbootstrap.com/components/#alerts"&gt;alerts 提示段落&lt;/a&gt; ，
&lt;a class="reference external" href="http://getbootstrap.com/components/#panels"&gt;panels 嵌入面板&lt;/a&gt; ，
以及还有一个 &lt;a class="reference external" href="http://getbootstrap.com/components/#media"&gt;media 混排图标&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;对其中的 &lt;code class="code"&gt;
panel&lt;/code&gt;
 我改写了它在文章正文中的样式，在 &lt;code class="code"&gt;
lg&lt;/code&gt;
 或者 &lt;code class="code"&gt;
xl&lt;/code&gt;

的屏幕宽度下，分别用 &lt;span class="math"&gt;\(\frac{1}{2}\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(\frac{1}{3}\)&lt;/span&gt; 大小的嵌入面板，
简单实现和正文文字的图文混排。&lt;/p&gt;
&lt;p&gt;除此以外我还在 twitter_bootstrap_rst_directives 这个插件里套用它的框架实现了两个额外
的 &lt;ruby&gt;&lt;rb&gt;行内角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; ， 分别是 &lt;code class="code"&gt;
:ruby:&lt;/code&gt;
 ：通过 html5 的 &lt;code class="code"&gt;
&amp;lt;ruby&amp;gt;&lt;/code&gt;

标签实现文字上方的注音（firefox下
&lt;a class="reference external" href="https://bugzilla.mozilla.org/show_bug.cgi?id=33339"&gt;不支持&lt;/a&gt;
，会使用文字后的括号显示）， 以及 &lt;code class="code"&gt;
:html:&lt;/code&gt;
 ：在
行内插入 &lt;ruby&gt;&lt;rb&gt;裸&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;raw&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; html 标签（这属于 Markdown 的基本功能，在 reStructuredText
这边由于要考虑多种输出格式于是就比较麻烦了）。这两个 &lt;ruby&gt;&lt;rb&gt;行内角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-plugins/blob/master/twitter_bootstrap_rst_directives/bootstrap_rst_directives.py#L140"&gt;实现代码在这里&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月3日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;今天又在 twitter_bootstrap_rst_directives 里增加了两个 &lt;ruby&gt;&lt;rb&gt;行内角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。
一个是 &lt;code class="code"&gt;
:twi:&lt;/code&gt;
 用来写 twitter 用户的链接，比如 &lt;a class="reference external" href="//twitter.com/farseerfc"&gt;@farseerfc&lt;/a&gt; ，另一个是
&lt;code class="code"&gt;
:irc:&lt;/code&gt;
 用来指向 freenode 的 channel ，比如 &lt;a class="reference external" href="//webchat.freenode.net/?channels=yssyd3"&gt;#yssyd3&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月14日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;今天增加了 &lt;code class="code"&gt;
.. friend::&lt;/code&gt;
 用来写好友链接，以及 &lt;code class="code"&gt;
fref&lt;/code&gt;
 用来引用好友，
比如 &lt;a class="reference external" href="/links.html#lqymgt"&gt;LQYMGT&lt;/a&gt; 这样。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="extract-toc-summary"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id58"&gt;extract_toc 和 summary&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;最后是这两个有点「名不副实」的插件。&lt;/p&gt;
&lt;p&gt;reStructuredText 原本就有自动生成
&lt;ruby&gt;&lt;rb&gt;目录&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;toc&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的功能，用起来也非常简单，只需要在想要插入目录的地方写一行
&lt;code class="code"&gt;
.. contents::&lt;/code&gt;
 ，剩下的都由 docutils 自动生成了。
只是当然这样生成的目录肯定会插入在文章的正文里，而 extract_toc 这个插件的作用就是简单地
把这个目录抽取出来，让模板能在别的地方放置这个目录。比如我这里就把目录放在了一个
&lt;code class="code"&gt;
panel&lt;/code&gt;
 里。&lt;/p&gt;
&lt;p&gt;然后 Pelican 也原本就有从文章中抽取 &lt;ruby&gt;&lt;rb&gt;总结&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;summary&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 显示在文章列表的功能。
Pelican 原始的实现似乎是按照文字数抽取前半段，不总是适合作为总结。 于是这个 summary
插件的作用其实是允许在正文中以特殊的注释的方式标注哪些部分应该被抽出来作为总结。
summary 这个插件原本的实现只允许抽取一段文字，我又对它的实现做了少许扩充，允许标注多段
文字合并起来作为总结。&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年1月29日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;今天在 extract_toc 插件的帮助下，在侧边栏里放了一个 Bootstrap affix 的目录，
它保持在页面的右侧位置不变，方便导航到文章的各个地方。具体实现方法除了 Bootstrap 3 的
&lt;a class="reference external" href="http://getbootstrap.com/javascript/#affix"&gt;Affix 文档&lt;/a&gt; ，还参考了
&lt;a class="reference external" href="http://tutsme-webdesign.info/bootstrap-3-affix/"&gt;这篇更详细的说明&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id36"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id59"&gt;结语&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个博客的配置都可以在
&lt;a class="reference external" href="https://github.com/farseerfc/farseerfc/blob/master/pelicanconf.py"&gt;github 上找到&lt;/a&gt;
，包括用来
&lt;a class="reference external" href="https://github.com/farseerfc/farseerfc/blob/master/Makefile"&gt;自动生成整个博客的 Makefile&lt;/a&gt;
，由于比较长，这里就不再贴了。&lt;/p&gt;
&lt;p&gt;折腾这个主题前后历时两个月，期间学会了不少东西，也算是不错的收获吧。
现在既然基础打好了，接下来就要开始多写博客了。（希望拖延症不会再犯……）&lt;/p&gt;
&lt;p&gt;最近发现除了我的博客之外还有一个网站
&lt;a class="reference external" href="http://www.kansaslinuxfest.us/"&gt;Kansas Linux Fest&lt;/a&gt; fork
了我的主题，不过他们用了我修改的早期版本，还是原本的 Bootstrap 3 和
bootstrap-material-design 样式。自己草草修改的东西被别人用到果然还是有点小激动呢，
以及接下来不能马马虎虎地写 commit 消息了。&lt;/p&gt;
&lt;table border="0" class="docutils table footnote" frame="void" id="id37" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;赛65:17「看哪！我造新天新地」启21:5「我将一切都更新了。」&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="tech"></category><category term="python"></category><category term="pelican"></category><category term="bootstrap"></category><category term="material"></category><category term="subsite"></category></entry><entry><title>总结一下 Material Design 的 CSS 框架</title><link href="//farseerfc.me/zhs/summarize-material-design-css-framework.html" rel="alternate"></link><published>2015-01-16T03:27:00+09:00</published><updated>2015-01-16T03:27:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-01-16:/zhs/summarize-material-design-css-framework.html</id><summary type="html">&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;现在这里的界面风格要从 Google 在 &lt;a class="reference external" href="https://www.google.com/events/io"&gt;I/O 2014 大会&lt;/a&gt;
上公布Android L 也即 后来的 Lollipop 说起。 他们在谈论界面设计的时候公布了他们的
设计准则： &lt;a class="reference external" href="http://www.google.com/design/spec/material-design/introduction.html"&gt;Material Design&lt;/a&gt; (&lt;a class="reference external" href="http://wcc723.gitbooks.io/google_design_translate/"&gt;中文非官方翻译&lt;/a&gt; )。
当然这只是一些准则，总结并描述了之前在 Web 设计和移动端 App 界面设计方面的一些规范，
并且用材料的类比来形象化的比喻这个准则。关于 Material Design 的更多中文资料可
&lt;a class="reference external" href="http://www.ui.cn/Material/"&gt;参考这里&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;看到 Material Design 之后就觉得这个设计风格非常符合直觉，于是想在这边也用上
Material Design。 但是我在 Web 前端科技树上没点多少技能点，所以想找找别人实现好的模板
或者框架直接套用上。在网络上搜索数日找到了这几个：&lt;/p&gt;
&lt;div class="section" id="polymer-paper-elements"&gt;
&lt;h2&gt;Polymer Paper Elements&lt;/h2&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Polymer&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;object class="embed-responsive-item" data="https://www.polymer-project.org/images/logos/p-logo.svg" type="image/svg+xml"&gt;
Polymer logo&lt;/object&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;Google …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;现在这里的界面风格要从 Google 在 &lt;a class="reference external" href="https://www.google.com/events/io"&gt;I/O 2014 大会&lt;/a&gt;
上公布Android L 也即 后来的 Lollipop 说起。 他们在谈论界面设计的时候公布了他们的
设计准则： &lt;a class="reference external" href="http://www.google.com/design/spec/material-design/introduction.html"&gt;Material Design&lt;/a&gt; (&lt;a class="reference external" href="http://wcc723.gitbooks.io/google_design_translate/"&gt;中文非官方翻译&lt;/a&gt; )。
当然这只是一些准则，总结并描述了之前在 Web 设计和移动端 App 界面设计方面的一些规范，
并且用材料的类比来形象化的比喻这个准则。关于 Material Design 的更多中文资料可
&lt;a class="reference external" href="http://www.ui.cn/Material/"&gt;参考这里&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;看到 Material Design 之后就觉得这个设计风格非常符合直觉，于是想在这边也用上
Material Design。 但是我在 Web 前端科技树上没点多少技能点，所以想找找别人实现好的模板
或者框架直接套用上。在网络上搜索数日找到了这几个：&lt;/p&gt;
&lt;div class="section" id="polymer-paper-elements"&gt;
&lt;h2&gt;Polymer Paper Elements&lt;/h2&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Polymer&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;object class="embed-responsive-item" data="https://www.polymer-project.org/images/logos/p-logo.svg" type="image/svg+xml"&gt;
Polymer logo&lt;/object&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;Google 官方提供的参考实现应该是 &lt;a class="reference external" href="https://www.polymer-project.org/"&gt;Polymer&lt;/a&gt; 中的
&lt;a class="reference external" href="https://www.polymer-project.org/docs/elements/paper-elements.html"&gt;Paper Elements&lt;/a&gt; 。&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;p&gt;由于是 &lt;strong&gt;官方参考实现&lt;/strong&gt; ，这个框架的确非常忠实地实现了 Material Design 的设计，但是同时
由于它基于 &lt;a class="reference external" href="http://webcomponents.org/"&gt;HTML5 Web Components&lt;/a&gt; 构建，相关技术我还
不太懂，浏览器兼容性和其余 HTML 技术的兼容性也还不太完善的样子……&lt;/p&gt;
&lt;p&gt;并且对于我这个 Web 开发的半吊子来说，Polymer 只是提供了一组设计组建，没有完善的
&lt;strong&gt;响应式&lt;/strong&gt; (responsive) 布局支持，也没有 Navbar 这种常见的框架组建，真的要用起来的话还
需要手工实现不少东西。于是口水了半天之后只好放弃……以后可能真的会换用这个，只是目前需要学
的东西太多了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="angular-material-design"&gt;
&lt;h2&gt;Angular Material Design&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
AngularJS&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="AngularJS logo" class="img-responsive" src="https://angularjs.org/img/AngularJS-large.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="https://angularjs.org/"&gt;AngularJS&lt;/a&gt; 是 Google 对 Web Components 技术的另一个
尝试。而这额 &lt;a class="reference external" href="https://material.angularjs.org/"&gt;Angular Material Design&lt;/a&gt; 项目
就是基于 AngularJS 构建的Material Design 库啦，同样是 Google 出品所以应该算得上半个
官方实现吧。 相比于 Polymer, AngularJS 算是实用了很多，提供了基于
&lt;a class="reference external" href="http://www.w3.org/TR/css3-flexbox/"&gt;CSS Flexbox&lt;/a&gt; 的布局。有人对这两者的评价是，
如果说 Polymer 代表了 &lt;strong&gt;未来趋势&lt;/strong&gt; ，那么 AngularJS 就是 &lt;strong&gt;眼下可用&lt;/strong&gt; 的 Web
Components 实现了。&lt;/p&gt;
&lt;p&gt;只不过同样是因为它是 Components 的框架，对 WebApp 的支持很丰富，大量采用 Ajax 等
JavaScript 技术， 对于我这个静态博客来说仍然稍显高级了……非常担心还不支持 HTML5 的浏览器
比如 w3m 甚至 cURL 对它的支持程度。 于是最终也没有使用它。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="materialize"&gt;
&lt;h2&gt;Materialize&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Materialize&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Materialize logo" class="img-responsive" src="https://raw.githubusercontent.com/Dogfalo/materialize/master/images/materialize.gif"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="http://materializecss.com/"&gt;Materialize&lt;/a&gt; 这是一批(自称?)熟悉 Android 上
Material Design 的设计师们新近出炉的框架，试图提供一个接近 Bootstrap 的方案。
最早是在 &lt;a class="reference external" href="http://www.reddit.com/r/web_design/comments/2lt4qy/what_do_you_think_of_materialize_a_responsive/"&gt;Reddit&lt;/a&gt; 上看到对它的讨论的，立刻觉得这个想法不错。&lt;/p&gt;
&lt;p&gt;体验一下官网的设计就可以看出，他们的动画效果非常接近 Polymer 的感觉，响应式设计的布局
也还不错。 只是同样体验一下他们现在的官网就可以看出，他们目前的
&lt;a class="reference external" href="https://github.com/Dogfalo/materialize/issues"&gt;bug 还比较多&lt;/a&gt; ，甚至一些 bug
在他们自己的主页上也有显现。 虽然不想给这个新出炉的项目泼凉水，不过看来要达到他们声称的接近
Bootstrap 的易用度还任重而道远……&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bootstrap-material-design-bootstrap3"&gt;
&lt;h2&gt;bootstrap-material-design + bootstrap3&lt;/h2&gt;
&lt;p&gt;这是我最终选择的方案。这个方案将三个项目组合在了一起，分别是
&lt;a class="reference external" href="http://fezvrasta.github.io/bootstrap-material-design/"&gt;bootstrap-material-design&lt;/a&gt;
, &lt;a class="reference external" href="https://github.com/DandyDev/pelican-bootstrap3"&gt;pelican-bootstrap3&lt;/a&gt;
和 &lt;a class="reference external" href="http://getbootstrap.com/"&gt;Bootstrap 3&lt;/a&gt; 。
Bootstrap 3 想必不用再介绍了，很多网站都在使用这套框架，定制性很高。
bootstrap-material-design 是在 Bootstrap 3 的基础上套用 Material Design 风格
制作的一套 CSS 库，当然也不是很完善并且在不断改进中，一些细节其实并不是很符合我的要求。
最后 pelican-bootstrap3 是用 Bootstrap 3 做的 pelican 模板。
这三个项目或多或少都有点不合我的口味，于是嘛就把 pelican-bootstrap3 fork了一套放在
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3"&gt;这里&lt;/a&gt; ，其中还包括我自己改
过的 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/tree/master/static/bootstrap"&gt;Bootstrap3 样式&lt;/a&gt;
和 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/tree/master/static/material"&gt;Material 样式&lt;/a&gt;
，需要的可以自取。&lt;/p&gt;
&lt;p&gt;至于细节上我定制了哪些地方，敬请听下回分解……&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="css"></category><category term="material"></category><category term="paper"></category></entry><entry><title>从非缓冲输入流到 Linux 控制台的历史</title><link href="//farseerfc.me/zhs/from-unbuffered-stdin-to-history-of-linux-tty.html" rel="alternate"></link><published>2014-12-12T17:06:00+09:00</published><updated>2014-12-12T17:06:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2014-12-12:/zhs/from-unbuffered-stdin-to-history-of-linux-tty.html</id><summary type="html">
&lt;p&gt;这篇也是源自于水源C板上板友的一个问题，涉及Linux上的控制台的实现方式和历史原因。因为内容比较长，所以在这里再排版一下发出来。
&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1418138991,file,M.1418138991.A.html"&gt;原帖在这里&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;可以设置不带缓冲的标准输入流吗？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;WaterElement(UnChanged) 于 2014年12月09日23:29:51 星期二 问到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请问对于标准输入流可以设置不带缓冲吗？比如以下程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer …&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary><content type="html">
&lt;p&gt;这篇也是源自于水源C板上板友的一个问题，涉及Linux上的控制台的实现方式和历史原因。因为内容比较长，所以在这里再排版一下发出来。
&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1418138991,file,M.1418138991.A.html"&gt;原帖在这里&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;可以设置不带缓冲的标准输入流吗？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;WaterElement(UnChanged) 于 2014年12月09日23:29:51 星期二 问到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请问对于标准输入流可以设置不带缓冲吗？比如以下程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;似乎还是需要在命令行输入后按回车才会让 &lt;code class="code"&gt;
fgets&lt;/code&gt;
 返回，不带缓冲究竟体现在哪里？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;这和缓存无关，是控制台的实现方式的问题。&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;再讲细节一点，这里有很多个程序和设备。以下按 linux 的情况讲：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;终端模拟器窗口（比如xterm）收到键盘事件&lt;/li&gt;
&lt;li&gt;终端模拟器(xterm)把键盘事件发给虚拟终端 pty1&lt;/li&gt;
&lt;li&gt;pty1 检查目前的输入状态，把键盘事件转换成 stdin 的输入，发给你的程序&lt;/li&gt;
&lt;li&gt;你的程序的 c 库从 stdin 读入一个输入，处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;标准库说的输入缓存是在 4 的这一步进行的。而行输入是在 3 的这一步被缓存起来的。&lt;/p&gt;
&lt;p&gt;终端pty有多种状态，一般控制台程序所在的状态叫「回显行缓存」状态，这个状态的意思是:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;所有普通字符的按键，会回显到屏幕上，同时记录在行缓存区里。&lt;/li&gt;
&lt;li&gt;处理退格( &lt;kbd class="kbd"&gt;
BackSpace&lt;/kbd&gt;
 )，删除( &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;
 )按键为删掉字符，左右按键移动光标。&lt;/li&gt;
&lt;li&gt;收到回车的时候把整个一行的内容发给stdin。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Cooked_mode"&gt;http://en.wikipedia.org/wiki/Cooked_mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时在Linux/Unix下可以发特殊控制符号给pty让它进入「raw」状态，这种状态下按键
不会被回显，显示什么内容都靠你程序自己控制。
如果你想得到每一个按键事件需要用raw状态，这需要自己控制回显自己处理缓冲，
简单点的方法是用 readline 这样的库（基本就是「回显行缓存」的高级扩展，支持了
Home/End，支持历史）或者 ncurses 这样的库（在raw状态下实现了一个简单的窗口/
事件处理框架）。&lt;/p&gt;
&lt;p&gt;参考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/POSIX_terminal_interface#History"&gt;http://en.wikipedia.org/wiki/POSIX_terminal_interface#History&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除此之外， &lt;kbd class="kbd"&gt;
Ctrl-C&lt;/kbd&gt;
 转换到 SIGINT ， &lt;kbd class="kbd"&gt;
Ctrl-D&lt;/kbd&gt;
 转换到 EOF 这种也是在 3 这一步做的。&lt;/p&gt;
&lt;p&gt;以及，有些终端模拟器提供的 &lt;kbd class="kbd"&gt;
Ctrl-Shift-C&lt;/kbd&gt;
 表示复制这种是在 2 这一步做的。&lt;/p&gt;
&lt;p&gt;以上是 Linux/unix 的方式。 Windows的情况大体类似，只是细节上有很多地方不一样：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;窗口事件的接收者是创建 cmd 窗口的 Win32 子系统。&lt;/li&gt;
&lt;li&gt;Win32子系统接收到事件之后，传递给位于 命令行子系统 的 cmd 程序&lt;/li&gt;
&lt;li&gt;cmd 程序再传递给你的程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Windows上同样有类似行缓存模式和raw模式的区别，只不过实现细节不太一样。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="strace"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;strace查看了下&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WaterElement(UnChanged) 于 2014年12月10日21:53:54 星期三 回复：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;感谢FC的详尽解答。&lt;/p&gt;
&lt;p&gt;用strace查看了下，设置标准输入没有缓存的话读每个字符都会调用一次 &lt;code class="code"&gt;
read&lt;/code&gt;
 系统调用，
比如输入abc：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;read(0, abc&lt;/span&gt;
&lt;span class="code-line"&gt;"a", 1)                         = 1&lt;/span&gt;
&lt;span class="code-line"&gt;read(0, "b", 1)                         = 1&lt;/span&gt;
&lt;span class="code-line"&gt;read(0, "c", 1)                         = 1&lt;/span&gt;
&lt;span class="code-line"&gt;read(0, "\n", 1)                        = 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有缓存的话就只调用一次了 &lt;code class="code"&gt;
read&lt;/code&gt;
 系统调用了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;read(0, abc&lt;/span&gt;
&lt;span class="code-line"&gt;"abc\n", 1024)                  = 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="raw-mode"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;如果想感受一下 raw mode&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;没错，这个是你的进程内C库做的缓存，tty属于字符设备所以是一个一个字符塞给你的
程序的。&lt;/p&gt;
&lt;p&gt;如果想感受一下 raw mode 可以试试下面这段程序（没有检测错误返回值）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;termios.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ttyfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;/* reset tty - useful also for restoring the terminal when this process&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;   wishes to temporarily relinquish the tty&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* flush and reset */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;/* put terminal in raw mode - see termio(7I) for modes */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* copy original and then modify below */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* input modes - clear indicated ones giving: no break, no CR to NL,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;       no parity check, no strip char, no start/stop output (sic) control */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_iflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BRKINT&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICRNL&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;INPCK&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISTRIP&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IXON&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* output modes - clear giving: no post processing such as NL to CR+NL */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_oflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OPOST&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* control modes - set 8 bit chars */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cflag&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CS8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* local modes - clear giving: echoing off, canonical off (no erase with&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;       backspace, ^U,...),  no extended functions, no signal chars (^Z,^C) */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_lflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ECHO&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICANON&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IEXTEN&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISIG&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* control chars - set return condition: min number of bytes and timer */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after 5 bytes or .8 seconds&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;                                                after first byte seen      */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* immediate - anything       */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after two bytes, no timer  */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after a byte or .8 seconds */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* put terminal in raw mode after flushing */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;atexit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;终端上的字符编程&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;vander(大青蛙) 于 2014年12月12日08:52:20 星期五 问到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;学习了！&lt;/p&gt;
&lt;p&gt;进一步想请教一下fc大神。如果我在Linux上做终端上的字符编程，是否除了用ncurses库
之外，也可以不用该库而直接与终端打交道，就是你所说的直接在raw模式？
另外，终端类型vt100和linux的差别在哪里？为什么Kevin Boone的KBox配置手册里面说必
须把终端类型设成linux，而且要加上terminfo文件，才能让终端上的vim正常工作？term
info文件又是干什么的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;Linux控制台的历史&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;嗯理论上可以不用 ncurses 库直接在 raw 模式操纵终端。&lt;/p&gt;
&lt;p&gt;这里稍微聊一下terminfo/termcap的历史，详细的历史和吐槽参考
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater's Handbook&lt;/a&gt;
第6章 Terminal Insanity。&lt;/p&gt;
&lt;p&gt;首先一个真正意义上的终端就是一个输入设备（通常是键盘）加上一个输出设备（打印
机或者显示器）。很显然不同的终端的能力不同，比如如果输出设备是打印机的话，显
示出来的字符就不能删掉了（但是能覆盖），而且输出了一行之后就不能回到那一行了
。再比如显示器终端有的支持粗体和下划线，有的支持颜色，而有的什么都不支持。
早期Unix工作在电传打字机（TeleTYpe）终端上，后来Unix被port到越来越多的机器上
，然后越来越多类型的终端会被连到Unix上，很可能同一台Unix主机连了多个不同类型
的终端。由于是不同厂商提供的不同的终端，能力各有不同，自然控制他们工作的方式
也是不一样的。所有终端都支持回显行编辑模式，所以一般的面向行的程序还比较好写
，但是那时候要撰写支持所有终端的「全屏」程序就非常痛苦，这种情况就像现在浏览
器没有统一标准下写HTML要测试各种浏览器兼容性一样。
通常的做法是&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;使用最小功能子集&lt;/li&gt;
&lt;li&gt;假设终端是某个特殊设备，不管别的设备。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;水源的代码源头 Firebird2000 就是那样的一个程序，只支持固定大小的vt102终端。&lt;/p&gt;
&lt;p&gt;这时有一个划时代意义的程序出现了，就是 vi，试图要做到「全屏可视化编辑」。这在
现在看起来很简单，但是在当时基本是天方夜谭。
vi 的做法是提出一层抽象，记录它所需要的所有终端操作，然后有一个终端类型数据库
，把那些操作映射到终端类型的具体指令上。当然并不是所有操作在所有终端类型上都
支持，所以会有一堆 fallback，比如要「强调」某段文字，在彩色终端上可能
fallback 到红色，在黑白终端上可能 fallback 到粗体。&lt;/p&gt;
&lt;p&gt;vi 一出现大家都觉得好顶赞，然后想要写更多类似 vi 这样的全屏程序。然后 vi 的作
者就把终端抽象的这部分数据库放出来形成一个单独的项目，叫 termcap （Terminal
Capibility），对应的描述终端的数据库就是 termcap 格式。然后 termcap 只是一个
数据库（所以无状态）还不够方便易用，所以后来又有人用 termcap 实现了 curses 。&lt;/p&gt;
&lt;p&gt;再后来大家用 curses/termcap 的时候渐渐发现这个数据库有一点不足：它是为 vi 设
计的，所以只实现了 vi 需要的那部分终端能力。然后对它改进的努力就形成了新的
terminfo 数据库和 pcurses 和后来的 ncurses 。 然后 VIM 出现了自然也用
terminfo 实现这部分终端操作。&lt;/p&gt;
&lt;p&gt;然后么就是 X 出现了， xterm 出现了，大家都用显示器了，然后 xterm 为了兼容各种
老程序加入了各种老终端的模拟模式。不过因为最普及的终端是 vt100 所以 xterm 默
认是工作在兼容 vt100 的模式下。然后接下来各种新程序（偷懒不用*curses的那些）
都以 xterm/vt100 的方式写。&lt;/p&gt;
&lt;p&gt;嗯到此为止是 Unix 世界的黑历史。&lt;/p&gt;
&lt;p&gt;知道这段历史的话就可以明白为什么需要 TERM 变量配合 terminfo 数据库才能用一些
Unix 下的全屏程序了。类比一下的话这就是现代浏览器的 user-agent。&lt;/p&gt;
&lt;p&gt;然后话题回到 Linux 。 大家知道 Linux 早期代码不是一个 OS， 而是 Linus 大神想
在他的崭新蹭亮的 386-PC 上远程登录他学校的 Unix 主机，接收邮件和逛水源（咳咳
）。于是 Linux 最早的那部分代码并不是一个通用 OS 而只是一个 bootloader 加一个
终端模拟器。所以现在 Linux 内核里还留有他当年实现的终端模拟器的部分代码，而这
个终端模拟器的终端类型就是 linux 啦。然后他当时是为了逛水源嘛所以 linux 终端
基本上是 vt102 的一个接近完整子集。&lt;/p&gt;
&lt;p&gt;说到这里脉络大概应该清晰了， xterm终端类型基本模拟 vt100，linux终端类型基本模
拟 vt102。这两个的区别其实很细微，都是同一个厂商的两代产品嘛。有差别的地方差
不多就是 &lt;kbd class="kbd"&gt;
Home&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
End&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageUp&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageDown&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;

这些不在 ASCII 控制字符表里的按键的映射关系不同。&lt;/p&gt;
&lt;p&gt;嗯这也就解释了为什么在linux环境的图形界面的终端里 telnet 上水源的话，上面这些
按键会错乱…… 如果设置终端类型是 linux/vt102 的话就不会乱了。在 linux 的
TTY 里 telnet 也不会乱的样子。&lt;/p&gt;
&lt;p&gt;写到这里才发现貌似有点长…… 总之可以参考
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater's Handbook&lt;/a&gt;
里的相关历史评论和吐槽，那一段非常有意思。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="c"></category><category term="linux"></category><category term="stdio"></category><category term="tty"></category><category term="unix"></category><category term="ugh"></category><category term="ncurses"></category><category term="termcap"></category><category term="terminfo"></category></entry><entry><title>KDE5 Plasma 之跳动卖萌的活动按钮</title><link href="//farseerfc.me/zhs/jumping-kde5-plasma-activities-button.html" rel="alternate"></link><published>2014-12-09T01:54:00+09:00</published><updated>2014-12-09T01:54:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2014-12-09:/zhs/jumping-kde5-plasma-activities-button.html</id><content type="html">&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;今天尝试 KDE5 Plasma 的活动的时候无意间发现这个现象。
只要把活动按钮拖出桌面，它就会在桌面边缘来回跳动。
视频如下：&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_SSbf97jGSpI"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/SSbf97jGSpI"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XODQ0NjM2MzQ4"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XODQ0NjM2MzQ4" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_SSbf97jGSpI"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XODQ0NjM2MzQ4"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;当然你可以把它再拖回来，所以这个问题还无伤大雅，只是卖萌。&lt;/p&gt;
&lt;p&gt;比比之前 Gnome3 那个跳动的界面真是好太多了：&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_TRQJdRHYwrw"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/TRQJdRHYwrw"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XNjc4MjQ5NjE2"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XNjc4MjQ5NjE2" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_TRQJdRHYwrw"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XNjc4MjQ5NjE2"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;顺便，今天还看到一个卖萌的 KDE5 Plasma 静音图标的翻译：&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;blockquote class="twitter-tweet" lang="zh-tw"&gt;&lt;p&gt;KDE5のミュート画面の中国语翻訳、「静音」のはずだが「镜音」になっている。Vocaloidファンのネタだか、単なる入力ミスだか分からない。 &lt;a href="http://t.co/ipyHjXMscR"&gt;pic.twitter.com/ipyHjXMscR&lt;/a&gt;&lt;/p&gt;— Jiachen YANG (@farseerfc) &lt;a href="https://twitter.com/farseerfc/status/541944351270518784"&gt;2014 12月 8日&lt;/a&gt;&lt;/blockquote&gt;</content><category term="tech"></category><category term="kde5"></category><category term="plasma"></category><category term="linux"></category><category term="gnome3"></category></entry><entry><title>Pyssy 项目</title><link href="//farseerfc.me/zhs/pyssy.html" rel="alternate"></link><published>2012-04-02T12:42:00+09:00</published><updated>2012-04-02T12:42:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2012-04-02:/zhs/pyssy.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;Pyssy 是用于 &lt;a class="reference external" href="https://bbs.sjtu.edu.cn"&gt;上海交通大学 饮水思源站&lt;/a&gt; 的一系列 Python 脚本和工具。&lt;/p&gt;
&lt;p&gt;Pyssy 被有意设计为既可以托管寄宿在 SAE &lt;a class="footnote-reference" href="#sae" id="id3"&gt;[1]&lt;/a&gt; 上，也可以在单机上独立使用。&lt;/p&gt;
&lt;p&gt;项目地址： &lt;a class="reference external" href="http://pyssy.sinaapp.com/"&gt;http://pyssy.sinaapp.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github上的源代码地址： &lt;a class="reference external" href="https://github.com/yssy-d3/pyssy"&gt;https://github.com/yssy-d3/pyssy&lt;/a&gt;&lt;/p&gt;
&lt;table border="0" class="docutils table footnote" frame="void" id="sae" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://sae.sina.com.cn/"&gt;Sina App Engine&lt;/a&gt; ，新浪云平台，类似 &lt;a class="reference external" href="https://appengine.google.com/"&gt;Google App Engine&lt;/a&gt; 的东西。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;依赖关系&lt;/h2&gt;
&lt;p&gt;Pyssy 使用 &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; 作为网页服务器，
并且使用 Memcached 或者 Redis 作为抓取 &lt;em&gt;水源Web&lt;/em&gt; 的缓存。&lt;/p&gt;
&lt;p&gt;SAE Python 环境下请开启 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;Pyssy 是用于 &lt;a class="reference external" href="https://bbs.sjtu.edu.cn"&gt;上海交通大学 饮水思源站&lt;/a&gt; 的一系列 Python 脚本和工具。&lt;/p&gt;
&lt;p&gt;Pyssy 被有意设计为既可以托管寄宿在 SAE &lt;a class="footnote-reference" href="#sae" id="id3"&gt;[1]&lt;/a&gt; 上，也可以在单机上独立使用。&lt;/p&gt;
&lt;p&gt;项目地址： &lt;a class="reference external" href="http://pyssy.sinaapp.com/"&gt;http://pyssy.sinaapp.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github上的源代码地址： &lt;a class="reference external" href="https://github.com/yssy-d3/pyssy"&gt;https://github.com/yssy-d3/pyssy&lt;/a&gt;&lt;/p&gt;
&lt;table border="0" class="docutils table footnote" frame="void" id="sae" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://sae.sina.com.cn/"&gt;Sina App Engine&lt;/a&gt; ，新浪云平台，类似 &lt;a class="reference external" href="https://appengine.google.com/"&gt;Google App Engine&lt;/a&gt; 的东西。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;依赖关系&lt;/h2&gt;
&lt;p&gt;Pyssy 使用 &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; 作为网页服务器，
并且使用 Memcached 或者 Redis 作为抓取 &lt;em&gt;水源Web&lt;/em&gt; 的缓存。&lt;/p&gt;
&lt;p&gt;SAE Python 环境下请开启 Memcached 支持。&lt;/p&gt;
&lt;p&gt;本地环境下请安装 Redis-py 并运行 redis-server 服务器程序。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="python"></category><category term="sjtu"></category><category term="yssy"></category></entry><entry><title>PyRuby</title><link href="//farseerfc.me/zhs/mix-ruby.html" rel="alternate"></link><published>2012-03-02T23:09:00+09:00</published><updated>2012-03-02T23:09:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2012-03-02:/zhs/mix-ruby.html</id><summary type="html">&lt;p&gt;今天在GitHub上闲逛的时候看到一个叫做 &lt;a class="reference external" href="https://github.com/danielfm/pyruby"&gt;PyRuby&lt;/a&gt; 的项目。项目的Readme说得很好：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PyRuby - Some Ruby for your Python!
PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful.

Usage
All you have to do is import the ruby module:

import ruby
From now on you should be able …&lt;/pre&gt;</summary><content type="html">&lt;p&gt;今天在GitHub上闲逛的时候看到一个叫做 &lt;a class="reference external" href="https://github.com/danielfm/pyruby"&gt;PyRuby&lt;/a&gt; 的项目。项目的Readme说得很好：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PyRuby - Some Ruby for your Python!
PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful.

Usage
All you have to do is import the ruby module:

import ruby
From now on you should be able to write Ruby code within a regular Python module. An example:

1.upto(10) { |n| puts n }
&lt;/pre&gt;
&lt;p&gt;甚至 &lt;a class="reference external" href="http://pypi.python.org/pypi/pyruby/1.0.0"&gt;PyPI&lt;/a&gt; 上还有这个项目的包。&lt;/p&gt;
&lt;p&gt;一开始我还以为这又是一个野心勃勃的基于PyPy的Ruby实现，或者某种trick在Python里面直接调用Ruby解释器。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;然后我想看看这个的源代码&lt;/h2&gt;
&lt;p&gt;只有一个ruby.py文件，内容是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"""&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;                              `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;                       .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;                  `:ohmdys+//::/::--::::////:-.```......`````.://:-`         `/dNs.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;               .+hNds:`-:-:///::------::///++///:--....--::///::-`.///.        `oMm/&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;             /hNmo.`   ``    `....```````````      ...------:::-:/+/-.:/:`       /NMs&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;            oMd/`      `::::--.---://+`           //`     `````-:::::+/-`::.`     :NM+&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;            yN`       -+.`         `/`           o.               ``::.-:. ``      :NN:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;           :Nm        -             ./           :    `.-://///:-.   `-` ``         :NN-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;          /NM/           .-:::-.`   `/            `:sdmdhyMMMMMMNNmy/`               :mNo`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        :hMd:          /dmddddNNmdy+-.          `smmy/-```hMMMMMMMhydm/ `-.``     `...:mMm+.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;      -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+-      dMN-`-+hmmmmdhhhhdddmMN-`-/o:    .-::::/oydms-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;     oNMo:+/::.         ``...--:/+ohNMNhs-      :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;    .MMo:/`o:.:+sso+:-`             sM+           ./-`       /mNh+-....-/ymNNdo::--/shd+`  -`:mm:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;    /MM-o ./ ohhsooohNmy::sh.      `yM/                       `:oyyyyyyhys+:.` hy    `/Nh`  : -NN.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;    -MM// -: ``   y: odddhh+     -omNh-          `--.` ``          ````    .:ohMMs.    +Ms  /  yMo&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;     hMoo .+.    :Mh  ````    `/hNd/.`           ohdddy::...`..`      `-/sdmdyo+NMNh+- :Mh  /  sMs&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;     .mmh:..:.  :NMm       `-/dMNM+         ./+++/:`.hM:`.````.` `-/shmNmh+-`  /Mmooso.hM/ .: `mM/&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;      .mNs://: .NMNMs-   -:-.`/+-sms.   `  `shyyyhy`sNd`   `.:+sdmmmdMM-.    .oNM+    :m/ `s``yMh&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;       -mMo  . sMNdMNNh+-.        .ydyoyy`        ``+o::+shdddhs+:-.:MM.`.-+hNMMh-    `.`-/::dNs`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        -NM-   mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.`    `/mMMdmmddNMm+`      ..-/hNh-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         sMy   NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs  `..:+ymMMMMd+--yNh.        `+hNh:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         -Mm   NMMM/yMh  -NM-`..--:NMo:--.`+My         :MNoydmNMMNmhdMh` -dNs`        `yMd:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         `MN   mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/          yMy`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;          MN   yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-.      `yMMNs.          /My&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         `MN   :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM-      ./hNNy-           /Nd`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         -Mh    dMydMmsNMNdNNMMmmmNMMMdddhys+yMo``       /Nm:  `:yNNdo.           .sNd.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         +Ms    .mMsMN::NN:.:MN: `.+NM.      +Mo          +Mm+ymNdo-            .omm+`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         yM:     .hNMd+:sMN. oMm.   oMo      +Mh   ```.:+shMNmy+-``.-:-..-//-`:yNmo`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         mM.       :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        .Mm        ``  .-:/+osyyhhddddddddddhhyysoo+/:-.  `./+//--+oo/--+ymmy/.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        :Mh   .:   `+:`        `.------------`      ```-////:/++/:../ydNdo:`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        +Ms   `/`    :+o+:-```              ``..-::///++///:-.`-+ydNdo:`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        oMs     :/:.``  `..---.``` ````````..-:/:::---.`  `-ohmmh+:`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        /Mh       .://///:::-----.-----.......`       `-+hmmy+-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         sMy`                                ``````-+ydmy+-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;          /mNs-`                        `./ohmNMNNNmy+-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;            /yNmho/:.``````````.-:/+syhdNmdyso+/-.`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;              `:+ydmNMNNNNNNNNNmdhys+/:.`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;                     ``.....`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;    LOL U MAD?&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;"""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是的……的确……这种尝试把Python和Ruby放在一起的想法绝对是疯了……&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="python"></category><category term="ruby"></category></entry><entry><title>关于C++模板的类型转换的讨论</title><link href="//farseerfc.me/zhs/discuss-cpp-template-downcast.html" rel="alternate"></link><published>2012-02-26T05:54:57+09:00</published><updated>2012-02-26T05:54:57+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2012-02-26:/zhs/discuss-cpp-template-downcast.html</id><summary type="html">
&lt;p&gt;这两天在饮水思源的C板，关于C++模板的类型转换的一个讨论，后面是我的解答。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;讨论地址&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html"&gt;http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;原问题&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;今天在书上看到模板演绎的时候可以允许cast-down，于是我写了个东西：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;_Test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;enable_if&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct …&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">
&lt;p&gt;这两天在饮水思源的C板，关于C++模板的类型转换的一个讨论，后面是我的解答。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;讨论地址&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html"&gt;http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;原问题&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;今天在书上看到模板演绎的时候可以允许cast-down，于是我写了个东西：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;_Test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;enable_if&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;traits&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="nc"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BB&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DD&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="c1"&gt;//f(b);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;奇怪的是重载决议的时候， &lt;code class="code"&gt;
f&lt;/code&gt;
 的情况下它就不让我特化的 &lt;code class="code"&gt;
f&amp;lt;A&amp;gt;&lt;/code&gt;
 进来。&lt;/p&gt;
&lt;p&gt;但是在 &lt;code class="code"&gt;
ff&lt;/code&gt;
 的情况下， &lt;code class="code"&gt;
ff&amp;lt;BB&amp;lt;long&amp;gt;&amp;gt;&lt;/code&gt;
 却进来了。&lt;/p&gt;
&lt;p&gt;在VC10和GCC3.4下测试&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;我的解答&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我们来设身处地地作为编译器，看一遍到底发生了什么。&lt;/p&gt;
&lt;p&gt;约定符号 &lt;code class="code"&gt;
#&lt;/code&gt;
 : &lt;code class="code"&gt;
A#B&lt;/code&gt;
 是把 &lt;code class="code"&gt;
B&lt;/code&gt;
 带入 &lt;code class="code"&gt;
A&amp;lt;T&amp;gt;&lt;/code&gt;
 的参数 &lt;code class="code"&gt;
T&lt;/code&gt;
 之后实例化得到的结果。&lt;/p&gt;
&lt;div class="section" id="ff"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;首先看ff的情况。&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;处理到这句的时候，编译器看到了 &lt;code class="code"&gt;
DD&amp;lt;long&amp;gt;&lt;/code&gt;
 的实例化，于是去实例化 &lt;code class="code"&gt;
DD#long&lt;/code&gt;
 ，继而实例
化了 &lt;code class="code"&gt;
BB#long&lt;/code&gt;
 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这句，首先计算重载函数集合。&lt;/p&gt;
&lt;p&gt;第一步，需要从参数 &lt;code class="code"&gt;
DD#long -&amp;gt; BB&amp;lt;T&amp;gt;&lt;/code&gt;
 推断 &lt;code class="code"&gt;
ff&amp;lt;T&amp;gt;&lt;/code&gt;
 的 &lt;code class="code"&gt;
T&lt;/code&gt;
 。根据函数模板参数推断规则：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:code:`class_template_name&amp;lt;T&amp;gt;` 类型的参数，可以用于推断 :code:`T` 。
&lt;/pre&gt;
&lt;p&gt;于是编译器推断 &lt;code class="code"&gt;
T&lt;/code&gt;
 为 &lt;code class="code"&gt;
long&lt;/code&gt;
 。这里就算不是 &lt;code class="code"&gt;
BB&lt;/code&gt;
 而是完全无关的 &lt;code class="code"&gt;
CC&lt;/code&gt;
 都可以推断成功，只要 &lt;code class="code"&gt;
CC&lt;/code&gt;
 也
是一个 &lt;code class="code"&gt;
CC&amp;lt;T&amp;gt;&lt;/code&gt;
 形式的模板。&lt;/p&gt;
&lt;p&gt;第二步，模板特化匹配。因为只有一个模板，所以匹配了最泛化的 &lt;code class="code"&gt;
ff&amp;lt;T&amp;gt;&lt;/code&gt;
 。&lt;/p&gt;
&lt;p&gt;第三步，模板实例化。&lt;/p&gt;
&lt;p&gt;推断了 &lt;code class="code"&gt;
long -&amp;gt; T&lt;/code&gt;
 之后，编译器实例化 &lt;code class="code"&gt;
ff#long&lt;/code&gt;
 。&lt;/p&gt;
&lt;p&gt;重载函数集合： &lt;code class="code"&gt;
{ff#long}&lt;/code&gt;
&lt;/p&gt;
&lt;p&gt;然后重载抉择找到唯一的可匹配的实例 &lt;code class="code"&gt;
ff#long&lt;/code&gt;
 ，检查实际参数 &lt;code class="code"&gt;
DD#long&lt;/code&gt;
 可以隐式转换到
形式参数 &lt;code class="code"&gt;
BB#long&lt;/code&gt;
 ，从而生成了这次函数调用。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="f"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;再来看f的情况。&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;计算候选重载函数集合。&lt;/p&gt;
&lt;p&gt;第一步，对所有 &lt;code class="code"&gt;
f&lt;/code&gt;
 模板推断实参。根据函数模板参数推断规则：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
带有 :code:`T` 类型的参数，可以用于推断 :code:`T` 。
&lt;/pre&gt;
&lt;p&gt;于是 &lt;code class="code"&gt;
B -&amp;gt; T&lt;/code&gt;
 被推断出来了。&lt;/p&gt;
&lt;p&gt;第二步，模板特化匹配。&lt;/p&gt;
&lt;p&gt;这里 &lt;code class="code"&gt;
B&lt;/code&gt;
 不是 &lt;code class="code"&gt;
A&lt;/code&gt;
 ，所以不能用 &lt;code class="code"&gt;
f&amp;lt;A&amp;gt;&lt;/code&gt;
 特化，只能用 &lt;code class="code"&gt;
f&amp;lt;T&amp;gt;&lt;/code&gt;
 模板。&lt;/p&gt;
&lt;p&gt;第三步，模板实例化。&lt;/p&gt;
&lt;p&gt;&lt;code class="code"&gt;
B&lt;/code&gt;
 带入 &lt;code class="code"&gt;
f&amp;lt;T&amp;gt;&lt;/code&gt;
 实例化成 &lt;code class="code"&gt;
f#B&lt;/code&gt;
 的过程中，实例化 &lt;code class="code"&gt;
traits#B&lt;/code&gt;
 。&lt;/p&gt;
&lt;p&gt;由于没有针对 &lt;code class="code"&gt;
B&lt;/code&gt;
 的特化，所以用 &lt;code class="code"&gt;
traits&amp;lt;T&amp;gt;&lt;/code&gt;
 模板， &lt;code class="code"&gt;
traits#B::value=false&lt;/code&gt;
 ，进而 &lt;code class="code"&gt;
enable_if#false&lt;/code&gt;
 没有 &lt;code class="code"&gt;
type&lt;/code&gt;
 ，出错。&lt;/p&gt;
&lt;p&gt;唯一的模板匹配出错，重载函数集合为空，SFINAE原则不能找到合适的匹配，于是报错。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="template"></category><category term="C"></category></entry><entry><title>尝试一下 Pelican</title><link href="//farseerfc.me/zhs/try-pelican.html" rel="alternate"></link><published>2012-02-24T17:33:00+09:00</published><updated>2012-02-24T17:33:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2012-02-24:/zhs/try-pelican.html</id><summary type="html">&lt;p&gt;似乎一夜之间所有的
&lt;a class="reference external" href="http://blog.yxwang.me/2011/11/migrated-to-octopress/"&gt;极客们&lt;/a&gt;
&lt;a class="reference external" href="http://xoyo.name/2012/02/migrate-to-octopress/"&gt;都&lt;/a&gt;
&lt;a class="reference external" href="http://blog.xdite.net/posts/2011/10/07/what-is-octopress/"&gt;有了&lt;/a&gt;
&lt;a class="reference external" href="http://www.yangzhiping.com/tech/octopress.html"&gt;自己&lt;/a&gt;
的 &lt;a class="reference external" href="http://pages.github.com/#user__organization_pages"&gt;Github主页&lt;/a&gt;
和 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 博客。就像所有人在他们的博客中指出的，静态博客的确比传统的WordPress方式具有更多优势。 自从看到这些
我就一直在想着自己搭一个 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;但是似乎 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 不适合我&lt;/h2&gt;
&lt;p&gt;一上手就被 &lt;a class="reference external" href="http://octopress.org/docs/setup/"&gt;Octopress的搭建步骤&lt;/a&gt; 烦到了。 &lt;a class="reference external" href="http://beginrescueend.com/"&gt;RVM&lt;/a&gt; 是什么？ &lt;a class="reference external" href="https://github.com/sstephenson/rbenv"&gt;rbenv&lt;/a&gt; 又是什么？
看来 Ruby 社区的快节奏发展已经超过了我的想象，他们似乎需要一套发行版管理器来调和不同版本之间的 Ruby 的兼容性问题。
虽然同样的兼容性问题在 Python 社区也有 &lt;a class="footnote-reference" href="#id10" id="id8"&gt;[1]&lt;/a&gt; ，不过总觉得 Python 至少还没到需要一个发行版管理器的程度 &lt;a class="footnote-reference" href="#id11" id="id9"&gt;[2]&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;真正的问题是我手上还没有一个可以让我随便玩的 Linux 环境（真的想要……）。 而无论是 &lt;a class="reference external" href="http://beginrescueend.com/"&gt;RVM&lt;/a&gt; 还是 &lt;a class="reference external" href="https://github.com/sstephenson/rbenv"&gt;rbenv&lt;/a&gt; 似乎都只支持 Unix/Linux …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;似乎一夜之间所有的
&lt;a class="reference external" href="http://blog.yxwang.me/2011/11/migrated-to-octopress/"&gt;极客们&lt;/a&gt;
&lt;a class="reference external" href="http://xoyo.name/2012/02/migrate-to-octopress/"&gt;都&lt;/a&gt;
&lt;a class="reference external" href="http://blog.xdite.net/posts/2011/10/07/what-is-octopress/"&gt;有了&lt;/a&gt;
&lt;a class="reference external" href="http://www.yangzhiping.com/tech/octopress.html"&gt;自己&lt;/a&gt;
的 &lt;a class="reference external" href="http://pages.github.com/#user__organization_pages"&gt;Github主页&lt;/a&gt;
和 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 博客。就像所有人在他们的博客中指出的，静态博客的确比传统的WordPress方式具有更多优势。 自从看到这些
我就一直在想着自己搭一个 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;但是似乎 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 不适合我&lt;/h2&gt;
&lt;p&gt;一上手就被 &lt;a class="reference external" href="http://octopress.org/docs/setup/"&gt;Octopress的搭建步骤&lt;/a&gt; 烦到了。 &lt;a class="reference external" href="http://beginrescueend.com/"&gt;RVM&lt;/a&gt; 是什么？ &lt;a class="reference external" href="https://github.com/sstephenson/rbenv"&gt;rbenv&lt;/a&gt; 又是什么？
看来 Ruby 社区的快节奏发展已经超过了我的想象，他们似乎需要一套发行版管理器来调和不同版本之间的 Ruby 的兼容性问题。
虽然同样的兼容性问题在 Python 社区也有 &lt;a class="footnote-reference" href="#id10" id="id8"&gt;[1]&lt;/a&gt; ，不过总觉得 Python 至少还没到需要一个发行版管理器的程度 &lt;a class="footnote-reference" href="#id11" id="id9"&gt;[2]&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;真正的问题是我手上还没有一个可以让我随便玩的 Linux 环境（真的想要……）。 而无论是 &lt;a class="reference external" href="http://beginrescueend.com/"&gt;RVM&lt;/a&gt; 还是 &lt;a class="reference external" href="https://github.com/sstephenson/rbenv"&gt;rbenv&lt;/a&gt; 似乎都只支持 Unix/Linux/MacOSX 。 身为极客就注定不能用 Windows 么？（或许是的……）。&lt;/p&gt;
&lt;p&gt;剩下的问题就是 Ruby 和 Python 两大阵营的对立问题了。我不熟悉 &lt;a class="reference external" href="http://daringfireball.net/projects/markdown/"&gt;Markdown&lt;/a&gt; ， 相对来说比较喜欢 &lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;ReST&lt;/a&gt; 。 似乎无论哪边都要
依赖 &lt;a class="reference external" href="http://pygments.org/"&gt;Pygments&lt;/a&gt; 作为代码着色器，那么其实 Rubyist 也至少需要安装 Python 。 我倾向于不依赖任何 Ruby 组件，最好没有 C 扩展
的纯 Python 实现。&lt;/p&gt;
&lt;p&gt;于是我开始在 Github 上找 Python 的静态博客引擎。 &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; 的作者 &lt;a class="reference external" href="https://github.com/mitsuhiko"&gt;mitsuhiko&lt;/a&gt; 写的 &lt;a class="reference external" href="https://github.com/mitsuhiko/rstblog"&gt;rstblog&lt;/a&gt; 看起来不错，不过似乎没有多少人在用。 &lt;a class="reference external" href="http://ringce.com/hyde"&gt;Hyde&lt;/a&gt; 似乎很完善，不过默认的标记语言是 MarkDown ， 又依赖于几个 Ruby 组建，而且官方网站的设计实在太前卫。 最终我看到了 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt; 。&lt;/p&gt;
&lt;table border="0" class="docutils table footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id8"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;比如 Python 2.x 与 3.x 之间看似难以跨越的鸿沟，以及 &lt;a class="reference external" href="http://pypy.org/"&gt;PyPy&lt;/a&gt; 、 &lt;a class="reference external" href="http://python.org/"&gt;CPython&lt;/a&gt; 、 &lt;a class="reference external" href="http://www.stackless.com/"&gt;Stackless&lt;/a&gt; 、 &lt;a class="reference external" href="http://cython.org/"&gt;Cython&lt;/a&gt; 等各个实现之间的微妙差别。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table border="0" class="docutils table footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id9"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;是的，我们有 &lt;a class="reference external" href="http://packages.python.org/distribute/easy_install.html"&gt;easy_install&lt;/a&gt; ，我们有 &lt;a class="reference external" href="http://www.pip-installer.org/en/latest/index.html"&gt;pip&lt;/a&gt; ， 不过这些都是包管理器，都是装好特定的Python实现之后的事情。 Python实现本身还不需要包管理器来管理。 Python 的版本问题基本上也只需要 &lt;a class="reference external" href="http://docs.python.org/release/3.0.1/library/2to3.html"&gt;2to3.py&lt;/a&gt; 和 &lt;a class="reference external" href="http://www.startcodon.com/wordpress/?cat=8"&gt;3to2.py&lt;/a&gt; 这样的轻量级转换器就可以了，你不需要为了安装多个软件而在硬盘里留下多个不同版本的 Python 。 如果为了引用的稳定性，你可以用 &lt;a class="reference external" href="http://pypi.python.org/pypi/virtualenv"&gt;virtualenv&lt;/a&gt; ，不过这又是另一回事情了。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h2&gt;那么就 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt; 吧&lt;/h2&gt;
&lt;p&gt;对我而言， &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt; 相比于 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 有几个好处：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;纯 Python 实现。 这意味着我可以换用任何 Python 解释器而不必担心兼容性问题。比如我就换成了 &lt;a class="reference external" href="http://pypy.org/"&gt;PyPy&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;多语言支持。因为 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt; 的作者似乎是个法国人。不过这个似乎大部分人不需要…… 我是想尽量把一篇博客写成三种语言作为锻炼吧。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;ReST&lt;/a&gt; 。这样我就可以用 &lt;a class="reference external" href="http://webpages.charter.net/edreamleo/front.html"&gt;Leo&lt;/a&gt; 的 @auto-rst 直接写 ReST了。简单方便快捷有效。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过似乎 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt; 的关注度不如 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 那么高，现在一些部分还有细微的问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;pelican-import 从 WordPress 导入的时候对中文、日文的支持似乎很成问题。&lt;/li&gt;
&lt;li&gt;日期格式、时区、字符集、和多语言功能的结合度还不够。  &lt;strong&gt;我在尝试改善它。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;模板还不够丰富。&lt;/li&gt;
&lt;li&gt;插件也不够多……&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;希望这么优秀的工具能够受到更多关注，以上这些问题都是增加关注度之后很快就能解决的问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="settings-py"&gt;
&lt;h2&gt;我的设置 settings.py&lt;/h2&gt;
&lt;p&gt;安装 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt; 很容易，一句话就够了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; pip install pelican&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后把文章写成ReST的格式，放在`pages`文件夹里面。(重新)生成只要：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; pelican -s settings.py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上传到 Github:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; git commit -am &lt;span class="s2"&gt;"Commit message"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; git push&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就这么简单。附上我的配置文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;TIMEZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Asia/Tokyo'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;DATE_FORMATS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="s1"&gt;'en'&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="s1"&gt;'usa'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="si"&gt;%a&lt;/span&gt;&lt;span class="s1"&gt;, &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s1"&gt; %b %Y'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="s1"&gt;'zh'&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="s1"&gt;'chs'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'%Y-%m-&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s1"&gt;, &lt;/span&gt;&lt;span class="si"&gt;%a&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="s1"&gt;'jp'&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="s1"&gt;'jpn'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'%Y/%m/&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s1"&gt; (&lt;/span&gt;&lt;span class="si"&gt;%a&lt;/span&gt;&lt;span class="s1"&gt;)'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="c1"&gt;# windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;LOCALE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'usa'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'chs'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'jpn'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;        &lt;span class="c1"&gt;# windows&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;          &lt;span class="s1"&gt;'en_US'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'zh_CN'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'ja_JP'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;# Unix/Linux&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;DEFAULT_LANG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'zh'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Farseerfc Blog'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;AUTHOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Jiachen Yang'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'farseerfcgithub'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;GITHUB_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'https://github.com/farseerfc'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'http://farseerfc.github.com'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;TAG_FEED&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'feeds/&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;.atom.xml'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s1"&gt;'twitter'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'http://twitter.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'github'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'https://github.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'facebook'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'http://www.facebook.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'weibo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'http://weibo.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'renren'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'http://www.renren.com/farseer'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;          &lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;TWITTER_USERNAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'farseerfc'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;THEME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'notmyidea'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;CSS_FILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"wide.css"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;DEFAULT_CATEGORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'Others'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;OUTPUT_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'.'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'posts'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="python"></category><category term="pelican"></category></entry></feed>