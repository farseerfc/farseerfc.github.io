<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Farseerfc的小窝</title><link href="//farseerfc.github.io/zhs/" rel="alternate"></link><link href="//farseerfc.github.io/feeds/import.atom.xml" rel="self"></link><id>//farseerfc.github.io/zhs/</id><updated>2011-09-27T02:35:00+09:00</updated><entry><title>关于我的Blogs</title><link href="//farseerfc.github.io/zhs/about-my-blogs.html" rel="alternate"></link><updated>2011-09-27T02:35:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2011-09-27:zhs/about-my-blogs.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;p&gt; 很久没有写过 blog 或者之类的东西了。这边一直荒废着。 &lt;/p&gt;
&lt;p&gt; 由于国内被墙的原因，另一个 wordpress ：  &lt;a class="reference external" href="http://fchome.sinaapp.com/"&gt;http://fchome.sinaapp.com/&lt;/a&gt;
 应该会同步更新这里的内容。 &lt;/p&gt;
&lt;p&gt; 抽空写点什么吧。 &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</summary></entry><entry><title>“…if we do this work … ” --Bill Gates</title><link href="//farseerfc.github.io/zhs/if-we-do-this-work.html" rel="alternate"></link><updated>2011-03-14T20:34:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2011-03-14:zhs/if-we-do-this-work.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 导入自 &lt;a class="reference external" href="http://blog.renren.com/blog/230263946/716517729"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From: Bill Gates&lt;/p&gt;
&lt;p&gt;’-- Sent: Sunday, January 24, 1999 8:41 AM&lt;/p&gt;
&lt;p&gt;Jeff Westorinon; Ben Fathi ;&lt;/p&gt;
&lt;p&gt;TO: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder&lt;/p&gt;
&lt;p&gt;Subject: ACPI extensions&lt;/p&gt;
&lt;p&gt;One thing I find myself wondering about is whether we shouldn’t try and
make the "ACPI" extensions somehow Windows specific.&lt;/p&gt;
&lt;p&gt;It seems unfortunate if we do this work and get our partners to do the
work and the result is that &lt;strong&gt;Linux works great without having to do the work&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maybe there is no way to avoid this problem but it does bother me.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Maybe we could define the APIs so that they work well with NT and not
the others even if they are open.&lt;/p&gt;
&lt;p&gt;Or maybe we could patent something relaled to this.&lt;/p&gt;
&lt;p&gt;From:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf"&gt;http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 如果这就是我至今在 Xen4.0 上得不到 ACPI 3.0 的完善支持的原因，那么我诅咒 Bill Gates ！ &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="microsoft"></category><category term="linux"></category><category term="acpi"></category></entry><entry><title>[zz]“西厢计划”原理小解</title><link href="//farseerfc.github.io/zhs/zz-introducing-scholarzhang.html" rel="alternate"></link><updated>2010-03-17T09:40:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2010-03-17:zhs/zz-introducing-scholarzhang.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;p&gt; 好神奇的想法，先存着，以后慢慢研究 &lt;/p&gt;
&lt;p&gt; 原文： &lt;a class="reference external" href="http://blog.youxu.info/2010/03/14/west-chamber/"&gt;http://blog.youxu.info/2010/03/14/west-
chamber/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 待月西厢下，迎风户半开。隔墙花影动，疑是玉人来。 &lt;/p&gt;
&lt;p&gt; 最近推上最流行的一个关键词是 ” 西厢计划 ”,
 这个计划名字取得很浪漫，客户端叫做张生，对，就是西厢记里面那个翻墙去见崔莺莺小姐的张生；显然，服务器端必然叫做崔莺莺。客户端的张生是最重要的部件，可以不依赖于服务端工作。因为西厢计划的作者只是简要的介绍了一下原理，其他报道又语焉不详，我当时就觉得很好奇，花了昨天一个晚上详细读了一下源代码，终于知道怎么回事了，觉得原理非常漂亮，所以写篇文章介绍总结一下。 &lt;/p&gt;
&lt;p&gt; 先说大方向。大家都知道，连接被重置的本质，是因为收到了破坏连接的一个 TCP
Reset  包。以前剑桥大学有人实验过，客户端和服务器都忽略 Reset,
 则通信可以不受影响。但是这个方法其实只有理论价值，因为绝大多数服务器都不可能忽略 Reset  的 ( 比如 Linux,  需要 root  权限配置 iptables,  而且这本身也把正常的 Reset  给忽略了 ) 。只要服务器不忽略 Reset,
 客户端再怎么弄都没用，因为服务器会停止发送数据， Reset
 这条连接。所以，很多报道说西厢计划是忽略 Reset,
 我从源代码来看应该不是这样。在我看来，西厢计划是利用了墙的一个可能的弱点 – 墙只在连接发起的时候把一个 TCP
 连接加入监听序列，如果墙认为这个连接终止了，就会从监听序列中去掉这条记录，这样，这条连接上后续的包就不会被监听。西厢计划就是让墙 “ 认为 ” 这个连接终止的一个绝妙的方法。只要墙认为这个连接两端都是死老虎，墙就不会触发关键词检测，其后所有的数据，都不存在连接被重置的问题了。 &lt;/p&gt;
&lt;p&gt; 如何让一个连接置之死地而后生，就是西厢计划那帮黑客神奇的地方了。这也不是一日之功。首先，这帮牛人发现，墙的是一个入侵检测系统，把含有关键字的包当成一种 “ 入侵 ” 来对待。采取这种设计有很多好处，但缺点是入侵检测系统可能具有的问题，墙都可能有。西厢计划主页上那篇著名的论文就是讲这些七七八八的漏洞的。可以说处理这些七七八八的漏洞是非常困难的，迫使墙的设计者 “ 拆东墙，补西墙 ” 。这样补来补去，外表看起来好像很牛逼的墙，其实有很多本质上无法简单修补的漏洞，其中有一个致命的，就是 TCP  连接状态的判定问题。出于入侵检测系统这种设计的局限，墙没有，也没办法准确判定一条 TCP
 连接的状态，而只是根据两边收到的数据来 “ 推测 ” 连接的状态。而所有的关键词检测功能，都是基于 “ 连接还活着 ” 的这个推测的结果的。因为墙的规则是在连接发起的时候开始对这条连接的检测，在连接终止的时候停止对这条连接的检测，所以，一旦对连接的状态推测错误，把还活着的连接当成已经关闭的连接，墙就会放弃对这条连接上随后所有的包的检测，他们都会都透明的穿过墙的入侵检测。 &lt;/p&gt;
&lt;p&gt; 上面只是想法，具体到 TCP
 协议实现这一层，就要只迷惑墙，还不能触及我要通信的服务器。最理想的情况下，在任何有效通信之前，就能让墙出现错误判断，这些，就需要对 TCP  协议有深刻理解了。西厢计划的那帮黑客，居然真的去读 TCP  几百页的 RFC ，还居然就发现了方法（这里我假设读者都知道 TCP
 的三次握手过程和序列号每次加一的规则）。我们都知道，三次握手的时候，在收到服务器的 SYN/ACK
 的时候，客户端如果发送 ACK  并且序列号 +1
 就算建立连接了，但是客户端如果发送一个序列号没 +1  的 FIN
 （表示连接终止，但是服务器知道，这时候连接还没建立呢， FIN
 这个包状态是错的，加上序列号也是错的，服务器自己一判断，就知道这个包是坏包，按照标准协议，服务器随手丢弃了这个包） ,
 但这个包，过墙的时候，在墙看来，是表示连接终止的 ( 墙是 ma de in china,
 是比较山寨的，不维护连接状态，并且，墙并没有记下刚才服务器出去的 SYN/ACK
 的序列号，所以墙不知道序列号错了）。所以，墙很高兴的理解为连接终止，舒了一口气去重置其他连接了，而这个连接，就成了僵尸，墙不管你客户端了，而这时候，好戏才刚刚开始。 &lt;/p&gt;
&lt;p&gt; 事实上，墙是双向检测的（或者说对每个包都检测的），因此，对服务器和客户端实现相同的对待方法，所以，墙不管客户端还不行，假如服务端有关键词传给客户端，墙还是有可能要发飙的（这里说有可能，因为我也不知道）。所以，最好的办法就是，让服务端也给墙一个终止连接的标志就好了。可是这个说起来简单，做起来难，怎么能让不受自己控制的服务器发一个自己想要的包呢？西厢计划的那帮黑客，再次去读几百页的 RFC,  令人惊讶的发现，他们居然在 RFC
 上发现了一个可以用的特性。我们上面说了，三次握手的时候，在收到 SYN/ACK
 后，客户端要给服务器发送一个序列号 +1  的 ACK ，可是，假如我不 +1 呢，直接发 ACK  包给服务器。墙已经认为你客户端是死老虎了，不理你了，不知道你搞什么飞机，让这个 ACK
 过了。可是服务器一看，不对啊，你给我的不是我期待的那个序列号， RFC
 上说了， TCP  包如果序列号错了的话，就回复一个 Reset.
 所以，服务器就回复了一个 Reset 。这个 Reset
 过墙的时候，墙一看乐了，服务器也终止连接了，好吧，两边都是死老虎了，我就不监听这条连接了。而至于客户端，这个服务器过来的 Reset  非常好识别，忽略就是。随后，客户端开始正确的发送 ACK,
 至此，三次握手成功，真正的好戏开始，而墙则认为客户端和服务器都是死老虎，直接放过。所以，张生就这样透明的过了墙。至于过墙以后所有的事情，《西厢记》里面都有记载，各位读者自行买书学习。 &lt;/p&gt;
&lt;p&gt; 现在的西厢计划客户端，即 “ 张生 ” 模块的防连接重置的原理就是这样，服务器端，即莺莺模块的实现也是类似的。防 DNS 那个，不懂 DNS
 协议，所以看不懂。我猜想，因为开发人员都是黑客，所以自然喜欢用最经得起折腾和高度定制的 Linux  开发。现在看西厢计划的实现，因为依赖于 Linux  内核模块 netfilter,
 在 Linux  上如鱼得水，但往其他平台的移植可能是个亟待解决的问题。我觉得，在其他平台上，可以通过 libpcap  和 libnet
 ，在用户态实现相同的功能，就是有点麻烦而已，有兴趣的懂网络的可以照西厢计划原理，在家自行做出此功能；当然，全中国人民都用 Linux  最好 :)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;PS 1:  据说是西厢计划一个作者画的原理图： &lt;a class="reference external" href="http://img.ly/DIi"&gt;http://img.ly/DIi&lt;/a&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;PS 2:  我对 TCP  的理解仅限于课本，如果上面的对技术的理解有错，请大家指出。 &lt;/div&gt;
&lt;div class="line"&gt;PS 3:  有些漏洞，可能是设计上本质缺陷，不是那么容易修复的。 &lt;/div&gt;
&lt;div class="line"&gt;PS 4:  除了最后一个图，本文没有其他相关链接，如需相关资料，自行 Google 。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="zz"></category></entry><entry><title>写程序让CPU占用率保持正弦函数</title><link href="//farseerfc.github.io/zhs/sine-cpu.html" rel="alternate"></link><updated>2008-06-02T23:27:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2008-06-02:zhs/sine-cpu.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 导入自 &lt;a class="reference external" href="http://blog.renren.com/blog/230263946/298871889"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 据说是一道微软的面试题。如题，写程序，让 Windows 的任务管理器中的性能监视器呈现正弦曲线。 &lt;/p&gt;
&lt;img alt=" 正弦曲线 " class="align-center img-responsive" src="http://fm531.img.xiaonei.com/pic001/20080602/23/14/large_10019p67.jpg"/&gt;
&lt;img alt=" 正弦曲线 " class="align-center img-responsive" src="http://fm541.img.xiaonei.com/pic001/20080602/23/14/large_9935o67.jpg"/&gt;

&lt;p&gt; 潜心钻研良久，得代码：（ java ） &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;sincpu&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++){&lt;/span&gt;
            &lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
            &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;calcNextSleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sin&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sleep&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;sleepTime&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleepTime&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;yield&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleepTime&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;period&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(;;){&lt;/span&gt;
            &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sin&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;period&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 多核 CPU 上测试时要注意关掉一个 CPU ： &lt;/p&gt;
&lt;img alt=" 多核 CPU 上测试 " class="align-center img-responsive" src="http://fm411.img.xiaonei.com/pic001/20080602/23/14/large_9946k67.jpg"/&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="java"></category><category term="microsoft"></category></entry><entry><title>关于神创论的一些见解</title><link href="//farseerfc.github.io/zhs/some-thought-on-creationism.html" rel="alternate"></link><updated>2008-05-12T11:16:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2008-05-12:zhs/some-thought-on-creationism.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 导入自 &lt;a class="reference external" href="http://blog.renren.com/blog/230263946/292274803"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 看到陈骉同学很有感想的一篇神创论与命运日志，觉得近日很久没有看到这样的评论了。想说几句自己的观点。 &lt;/p&gt;
&lt;p&gt; 首先我认为，神创论与宿命论没有多少关联，甚至进化论者相较于神创论者更容易接受宿命论的观点。因为神创论主张意志的存在，人所具有的个体意志与神的意志，因此在神创论者的眼中事件的结果是可以通过意志来改变的，亦即如果我从物理楼 11 楼跳下，那么我就可以改变自己死亡时间的宿命。上帝的意志同样可以左右事件的结果，也就是所谓的宿命不复存在。而进化论者不承认意志独立于物质世界的存在，你我的思考、行为，都受到物理学法则诸如量子力学的约束，这就引出了北大物理系教授的那句 “ 宇宙中的一切都是可以计算的 ” ，亦即宿命论。如我我选择现在从物理楼上跳下，我这一行为并不是处于个人的独立意志，乃是想证明这一点，亦即我跳楼这一举动是有其背后的动机与原因的，就如同计算机的输入必然导致了输出，宿命的必然终结于此。 &lt;/p&gt;
&lt;p&gt; 其次，关于事件的复杂度所导致的随机化，在大量混沌随机中也存在着如统计学和随机分形学这样的规律，并不是否认宿命的充分理由。 &lt;/p&gt;
&lt;p&gt; 关于神创论的合理性问题。我认为是否相信神的存在只是一个 boolean 二值问题，它为 true 为 false 本身并不重要，重要的是确定它的取值之后得到的推论与结果。如果否认神的存在，如现代数学这样的完美又何以存在，进化论者的解释是事物最终会向着更好更高级的方向发展，产生现代数学乃至现代科学是发展的必然。而这种论调显然有悖于物理中以热力学第二定律为首的，预言事物会随时间推演愈发混乱的论断。更进一步，甚至整个人类、整个生物系统的存在都是有悖于热力学推论的现象，是某种理论只能以 “ 小概率事件 ” 解释的现象。 &lt;/p&gt;
&lt;p&gt; 神创论的核心观点之一，是神的唯一存在性，按照邹恒明的比喻，这就如同数学中集合中元素的的唯一性一般至关重要。数学乃至近代科学的发展，其起源在于这种对神性的探求，而不仅仅是好奇心就可以解释的。反观东方文化中数学的发展，开始时领先于西方科学千余每年，但是始终作为一种 craft-oriented 的实用主义学科。可以说没有了神的唯一性支持，人们就不能确信自己能找到这样一种完美高效的学科，只能在实用的基础上发展其基础算数。可以想象，没有神的完美与唯一性，数学必将发展成现代化学或者微软软件这样，庞大而充满特例，到处都是修补与查表，怎么会像现在的完美、简洁与和谐。 &lt;/p&gt;
&lt;p&gt; 神创论者并不是将难题推与 “ 神 ” 然后放任不管，他们相信神是最为理智的存在，创人时人同样得到了神的智慧和理智，也就是神可以用人的理智来理解。 &lt;/p&gt;
&lt;p&gt; 引用牛顿《自然哲学的数学原理》中终章的话 “ 太阳、恒星、行星的这个极精致的结构不可能存在，除非通过一个有理智的和有权能的存在的设计和主宰 …… 他不是作为宇宙的灵魂，而是作为一切的主宰而统治所有 ……”&lt;/p&gt;
&lt;p&gt; 以上 ……&lt;/p&gt;
&lt;p&gt;( 发现最近的哲理思维果然慢了不少，写作思绪也一片混乱 ^_^)&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="creationism"></category></entry><entry><title>由记忆棒误差故障引发的关于面向对象设计的九点思考</title><link href="//farseerfc.github.io/zhs/9-thoughts-about-oop-from-wrongly-insert-memory-stick.html" rel="alternate"></link><updated>2007-09-20T14:38:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-09-20:zhs/9-thoughts-about-oop-from-wrongly-insert-memory-stick.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;p&gt; 故障描述 :
MMC Memory Stick Duo 记忆棒未经 Adapter 适配器，直接插入 SD Reader ，致使 MMC 卡入 SD Reader 中。 &lt;/p&gt;
&lt;p&gt; 栈展开：某日下午，无课。忙于数分作业，想查询用手机拍摄的板书照片。取出手机中的 MMC 。未经装配 Adapter ，直接插入 SD Reader 。 (A runtime exception was thrown.)
 尝试翻转笔记本机身，倒出 MMC ，未果。 (rethrow)
 尝试用手指甲取出，未果。 (rethrow)
 考虑到有 “ 推入反弹 ” 机制，尝试将 MMC 推入更深，反弹机制由于类型不匹配而失效，未果。 (rethrow)
(The exception spread across the border of the model.)
 电脑维修技师接手 (catch)
 技师未能发现问题所在，由我解说原委。 (Because the exception lose the information, RTTI was asked to recall the information)
 技师发现问题，尝试用镊子镊出 MMC ，未果。技师开解机箱 (expose the data structure)
 技师制作钩子，勾出 MMC(hooker link to the structure)
 取出 MMC ，故障解除 &lt;/p&gt;
&lt;p&gt; 故障总结 1. 接收到没有完全了解、或没有适当工具解决的 exception 时，不要尝试用不成熟的技术解决，应尽快寻求能解决它的代码。否则，被反复 rethrow 的 exception ，尤其是通过模块边界的 exception ，有可能由 subclass 退化为 superclass ，并因此而丧失一些信息。尽量不要让 exception 丢失信息，必要时，通过 RTTI 机制寻回信息。 &lt;/p&gt;
&lt;p&gt;2. 超负荷运转，多线程执行，这种种复杂性都有可能导致错误，应避免。无论你有多么信任你的代码或能力。 &lt;/p&gt;
&lt;p&gt;3. 在设计 class 的 interface 时，相匹配的 interface 应该满足 is-a 的关系。因此，任何能插入 SD Reader 的 object ，即任何实现了 SD interface 的 object ，都应该 is-a SD card 。这次故障中， interface 接受了 MMC ，但 MMC 不是 SD 。即使这种情况下 throw an exception ，都不能使事态缓和。能提供 compile-time error 时，尽量让错误以 compile-time error 的形式展现，并在事先解决。类型匹配问题是应该能在事先解决的问题。 &lt;/p&gt;
&lt;p&gt;4.Design patterns 中的 Adapter pattern 应该只是迫不得已情况之下的解决方案。只有当你无权改变现状时，才能使用 Adapter 。如果能改变现状，应该改变设计以符合 interface 。 &lt;/p&gt;
&lt;p&gt;5. 因为上条，所有相似功能的对象应具有相同的 interface ，不同的 interface 是本次故障的根源所在。 &lt;/p&gt;
&lt;p&gt;6. 特殊情况下，破坏封装机制并 expose the data structure 是必要的，应该有方法支持这种做法。 C 的指针和 C# 的 Reflection 技术都以不同的方式支持这种做法。其他的一些语言机制，比如 serializing( 序列化 ) 或 streaming( 流化 ) ，也可以以某种方式间接支持这一做法。当然，机制还应避免这种做法被滥用。 &lt;/p&gt;
&lt;p&gt;7. 相反功能具有相同操作的设计，容易造成使用的混乱，应适当避免。比如 SD Reader 的推入反弹设计，即插入和弹出使用同一个向里推的操作的设计。同样的设计还包括， C++ 中的 setNewHandle 使用同一个函数，同时设置和返回 handle 。以及有些书中提倡的，使用同名函数重载的方式，实现 setter/getter 的设计。 &lt;/p&gt;
&lt;p&gt;8. 特殊工具 (hooker) 对于解决特定问题，通常比手工解决有效。不要嫌麻烦而不愿意构造特殊工具。 &lt;/p&gt;
&lt;p&gt;9. 栈语义，即 FILO 顺序，总在不知不觉中影响我们。违反了 FILO 顺序的操作极易造成混乱。本故障发生时正确的处理顺序为：装配 Adapter
     插入 SD Reader
         读取数据          停用设备      拔出 SD Reader
 拆解 Adapter
 本次故障的原因就是违反了 FILO 顺序，违反了栈语义。 &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="oop"></category></entry><entry><title>Program Development in Java Preface</title><link href="//farseerfc.github.io/zhs/program-development-in-java-preface.html" rel="alternate"></link><updated>2007-09-16T13:26:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-09-16:zhs/program-development-in-java-preface.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt; 程序开发原理 &lt;/h2&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;—— 抽象、规格与面向对象设计 &lt;/h3&gt;
&lt;p&gt;Barbara Liskov  、 John Guttag  著 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 杨嘉晨等译 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt; 关于翻译风格： &lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 多年来阅读计算机类的著作及译作，感觉总体的困难在于一大堆没有标准译名的技术术语。由于通行于工业界和学术界的还是英文原名和术语，我决定保留大量的英文术语。这样的翻译风格借鉴于台湾著名的译者和作者侯捷先生。对于译与不译的权衡，主要考虑阅读的流畅，以及读者的理解能力，或许难免带有一些主观色彩。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="preface"&gt;
&lt;h2&gt; 前言 Preface&lt;/h2&gt;
&lt;p&gt; 构建产品级质量的程序 —— 可以在很长一段时间内使用的程序 —— 众所周知是极其困难的。本书的目标就是改善程序员解决这项任务的效率。我希望读者在阅读本书之后成为一名好程序员。我相信本书的成功在于改善编程技巧，因为我的学生告诉我这已经发生在他们身上。 &lt;/p&gt;
&lt;p&gt; 怎么才算是一名好程序员？是产生整个程序产品的效率。关键是要在每一阶段减少浪费掉的努力。解决的方法包括：在开始编写代码之前就仔细考虑你的实现方案，通过未雨绸缪的方法来编写代码，使用严格的测试在早期发现错误，以及仔细注意模块化编程，这样当错误出现时，只需要改动极少数代码就可以修正整个程序。本书涉及所有这些领域的技术。 &lt;/p&gt;
&lt;p&gt; 模块化编程 (Modularity) 是编写好程序的关键。把程序分解成许多小模块，每一个模块通过良好定义的狭窄接口和别的模块交互作用 (interact) 。有了模块化，可以修正一部分程序中的错误而不考虑程序的其他部分，而且可以仅仅理解一部分程序而不必理解整个程序。没有模块化，程序是一大堆有着错综复杂的相互关系的部分的拼凑。很难去领悟和修改这样一个程序，同样也很难让它正常工作。 &lt;/p&gt;
&lt;p&gt; 因此本书的重点在于创建模块化的程序：怎样把程序组织成一系列精心挑选的模块。本书认为模块化就是抽象 (abstraction) 。每一个模块意味着一个抽象，比如说指引一系列文档中的关键字的目录，或者在文档中使用目录来查找匹配某个问题的文档的过程。着重强调面向对象编程思想 —— 在程序中使用数据抽象和对象的思想。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 这本书使用 Java 作为它的编程示例的语言。我们没有假定读者已经熟悉 Java 。尽管可能没什么价值，但是本书中的思想是语言无关的，并且可以在任何语言的编程中使用。 &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="how-can-the-book-be-used"&gt;
&lt;h3&gt; 怎样使用这本书？ How Can the Book Be Used&lt;/h3&gt;
&lt;p&gt; 本书《程序开发原理》有两种使用方法。其一是作为课本教材，讲述如何用面向对象的方法来设计和实现复杂系统；其二是编程专家使用，帮助他们改善编程技能，增进他们的关于模块化和 Object-Oriented( 面向对象 ) 设计的知识。 &lt;/p&gt;
&lt;p&gt; 作为教材使用时，本书一般作为第二或第三门程序设计课程。我们已经在 MIT 使用本书很多年，给大一大二的本科生教授第二门编程课。在这一阶段，学生们已经知道怎样编写小程序。课程在两方面利用这一点：让学生更仔细地思考小程序，以及教他们如何利用小程序作为组件构建大型程序。这本书也可以在专业（如软件工程）后期教学中使用。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 建立在本书基础上的课程适合于所有计算机科学专业。尽管许多学生可能永远不会成为真正的大型程序的设计师，他们可以在开发部门工作，在那儿他们负责设计和实现能与整个结构耦合的子系统。模块化设计的子系统是这种任务中心，这对那些从事大型程序设计任务的人来说也同样重要。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-is-this-book-about"&gt;
&lt;h3&gt; 这本书讲什么？ What Is This Book About&lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 通观全篇三分之二的书致力于讨论在构建独立的程序模块时产生的问题，剩下的部分讨论怎样运用这些模块构建大型程序。 &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="program-modules"&gt;
&lt;h4&gt; 程序模块 Program Modules&lt;/h4&gt;
&lt;p&gt; 这一部分的书集中讨论抽象机制 (abstraction
mechanism) 。它讨论 procedure( 子程序 ) 和 exception( 异常 ) ，数据抽象，遍历 (iteration) 抽象，数据抽象系列 (family) 以及多态 (polymorphic) 抽象。 &lt;/p&gt;
&lt;p&gt; 在对抽象的讨论中，三个步骤是重要的。首先是决定被抽象的东西到底是什么：它提供给它的用户哪些行为。创造抽象是设计的关键，因此本书讨论如何在众多选择中挑选，以及怎样才能创造出好的抽象。 &lt;/p&gt;
&lt;p&gt; 第二步是通过为一个抽象制定一个规格 (specification) 来获取它的意义。如果没有一些描述，一个抽象就会含糊不清，而变得没有使用价值。 specification 则提供了需要的描述。本书定义了一种 specification 的格式，讨论了一份好的 specification 应有的属性，并且提供了许多示例。 &lt;/p&gt;
&lt;p&gt; 第三步是实现抽象。本书讨论怎样设计一份实现，以及在简洁性和执行性能之间怎样权衡利弊。书中强调封装 (encapsulation) 的重要性以及在一份实现中履行规格中定义的行为的重要性。书中同样提供一些技术 —— 尤其是不变式断言 (representation
invariant) 和抽象函数 (abstraction
function)—— 来帮助读者理解代码和它的原因。不变式断言和抽象函数都实现到尽可能的程度，这对于除错和调试很有用。 &lt;/p&gt;
&lt;p&gt; 关于类型层次 (type
hierarchy) 的材料注重讨论使用它作为抽象的技术 —— 一种把相关联的一组数据抽象归入同一系列的技术。这里很重要的一点是，是否应当将一个类型作为另一个类型的子类。本书定义了替换原则 —— 通过比较子类和父类的 specification ，来决定是否建立子类关系的方法 &lt;a class="reference external" href="#_ftn1"&gt;[1]&lt;/a&gt; 。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 本书同样涉及除错和调试。书中讨论怎样得到足够数量的测试情况，来准备通过黑箱和白箱测试，它同样强调了复查 (regression) 测试的重要性。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="programming-in-the-large"&gt;
&lt;h4&gt; 编写大型程序 Programming in the Large&lt;/h4&gt;
&lt;p&gt; 本书的其后部分讲解怎样用模块化的方法设计和实现大型程序。它建立在前文有关 abstraction 和 specification 的材料的基础之上。 &lt;/p&gt;
&lt;p&gt; 编写大型程序涵盖四个主要议题。首先讲解需求分析 —— 怎样才能领悟程序中需要什么。本书讨论怎样实施需求分析，也讨论书写产生的需求规格的方式，通过使用一种描述程序的抽象阶段的数据模型。使用这种模型将产生一份更为正式的 specification ，同时它也使需求检查更加严格，这样可以更好的领悟需求。 &lt;/p&gt;
&lt;p&gt; 编写大型程序的第二项议题是程序设计，这通常是一个循序渐进的过程。设计过程围绕构建有用的抽象来组织，这些抽象作为整个程序之中理想的构建组建。这些抽象在设计时被仔细的编写规格，这样当程序实现时，那些实现抽象的模块可以独立地开发。这种设计使用设计笔记编写文档，包括描述整个程序结构的模块间依赖性的图示。 &lt;/p&gt;
&lt;p&gt; 第三项议题是实现和测试。本书讨论了前置设计分析对于实现的必要性，以及怎样进行设计复审。它同样讨论了设计和实现的顺序。这一部分比较了自顶而下与自底而上的组织方式，讨论如何使用驱动程序和占位程序 &lt;a class="reference external" href="#_ftn2"&gt;[2]&lt;/a&gt;(stub) ，并且强调了制定一个事先的顺序策略的必要性，以满足开发组织和客户的需求。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 本书以一章设计模式 (design pattern) 结束。一些模式在前面的章节介绍过，比如遍历抽象是算法的主要组建。最后的章节讨论前文中没有涉及到的模式。希望它作为这一教材的介绍。有兴趣的读者可以继续阅读其它书中更完善的讨论 &lt;a class="reference external" href="#_ftn3"&gt;[3]&lt;/a&gt; 。 &lt;/div&gt;
&lt;/div&gt;
&lt;hr class="docutils"/&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref1"&gt;[1]&lt;/a&gt;
 译注：如果子类的 specification 包括了所有父类的 specification ，就是说父类的要求也是子类的要求，或者子类的要求更为严格，那么可以建立父子关系。而替换原则的说法是，对于具有父子关系的类，任何需要一个父类对象的地方，都可以替换为一个子类对象。 &lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref2"&gt;[2]&lt;/a&gt;
 译注：在测试某一组建时，由于其余组建还未实现，这一组建与其余组建的接口衔接部分无法工作。此时可以针对这一组建编写其余组建的占位程序 (stub) ，预留出接口的衔接代码。占位代码通常不做任何有价值的事情，只报告组建的衔接部位工作正常。 &lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref3"&gt;[3]&lt;/a&gt;  译注：作者指的是设计模式的开山之作 —— 《 Design
Patterns—Elements of Reusable Object-Oriented
Software 》 , 作者为设计模式界著名的 “ 四人帮 ”GoF(Gang of
Four) 。此书详尽讨论了三大类共 23 个广泛使用的设计模式的适用范围、依存关系、实现细节以及已有的应用领域等问题。书中以 C++ 和 Smalltalk 为示例语言，不过书中所涉及的模式适用于所有面向对象的语言。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="Java"></category></entry><entry><title>C++ Tricks 3.2 标号、goto，以及switch的实现</title><link href="//farseerfc.github.io/zhs/c-tricks-3-2-label-goto-and-implementation-of-switch.html" rel="alternate"></link><updated>2007-09-16T13:08:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-09-16:zhs/c-tricks-3-2-label-goto-and-implementation-of-switch.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h2&gt;3.2  标号、 goto ，以及 switch 的实现 &lt;/h2&gt;
&lt;p&gt;goto 语句及标号 (label) 是最古老的 C 语言特性，也是最早被人们抛弃的语言特性之一。像汇编语言中的 jmp 指令一样， goto 语句可以跳转到同一函数体中任何标号位置： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{int i=0;&lt;/p&gt;
&lt;p&gt;Loop: //A label&lt;/p&gt;
&lt;p&gt;++i;&lt;/p&gt;
&lt;p&gt;if(i&amp;lt;10)goto Loop; //Jump to the label&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 在原始而和谐的早期 Fortran 和 Basic 时代，我们没有 if then
else ，没有 for 和 while ，甚至没有函数的概念，一切控制结构都靠 goto( 带条件的或无条件的 ) 构件。软件工程师将这样的代码称作 “ 意大利面条 ” 代码。实践证明这样的代码极容易造成混乱。 &lt;/p&gt;
&lt;p&gt; 自从证明了结构化的程序可以做意大利面条做到的任何事情，人们就开始不遗余力地推广结构化设计思想，将 goto 像猛兽一般囚禁在牢笼，标号也因此消失。 &lt;/p&gt;
&lt;p&gt; 标号唯一散发余热的地方，是在 switch 中控制分支流程。 &lt;/p&gt;
&lt;p&gt; 很多人不甚了解 switch 存在的意义，认为它只是大型嵌套 if then
else 结构的缩略形式，并且比 if 语句多了很多 “ 不合理 ” 的限制。如果你了解到 switch 在编译器内部的实现机制，就不难理解强加在 switch 之上的诸多限制，比如 case 后只能跟一个编译期整型常量，比如用 break 结束每一个 case 。首先看一个 switch 实例： &lt;/p&gt;
&lt;p&gt;switch (shape.getAngle())&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;case 3: cout&amp;lt;&amp;lt;”Triangle”;break;&lt;/p&gt;
&lt;p&gt;case 4: cout&amp;lt;&amp;lt;”Square”;break;&lt;/p&gt;
&lt;p&gt;case 0:case1: cout&amp;lt;&amp;lt;”Not a sharp!”;break;&lt;/p&gt;
&lt;p&gt;default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 任何程序员都可以写出与之对应的 if 结构： &lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i==3) cout&amp;lt;&amp;lt;”Triangle”;&lt;/p&gt;
&lt;p&gt;else if(i==4) cout&amp;lt;&amp;lt;”Square”;&lt;/p&gt;
&lt;p&gt;else if(i==0||i==1) cout&amp;lt;&amp;lt;”Not a sharp!”;&lt;/p&gt;
&lt;p&gt;else cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt; 看起来这两段代码在语义上是完全一样的，不是么？ &lt;/p&gt;
&lt;p&gt; 不！或许代码的执行结果完全一样，但是就执行效率而言， switch 版本的更快！ &lt;/p&gt;
&lt;p&gt; 要了解为什么 switch 的更快，我们需要知道编译器是怎样生成 switch 的实现代码的： &lt;/p&gt;
&lt;p&gt; 首先，保留 switch 之后由 {} 括起来的语具体，仅将其中 case 、 default 和 break 替换为真正的标号： &lt;/p&gt;
&lt;p&gt;switch (getAngle(shape))&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 随后，对于所有出现在 case 之后的常量，列出一张只有 goto 的跳转表，其顺序按 case 后的常量排列： &lt;/p&gt;
&lt;p&gt;goto _case_0;&lt;/p&gt;
&lt;p&gt;goto _case_1;&lt;/p&gt;
&lt;p&gt;goto _case_3;&lt;/p&gt;
&lt;p&gt;goto _case_4;&lt;/p&gt;
&lt;p&gt; 然后，计算 case 之后的常量与跳转表地址之间的关系，如有需要，在跳转表中插入空缺的项目： &lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default; // 因为没有 case 2 ，所以插入此项以条转到 default&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt; 假设一个 goto 语句占用 5 个字节，那么在本例中， goto 的地址 =case 后的常量 *5+100105&lt;/p&gt;
&lt;p&gt; 之后，生成跳转代码，在其余条件下跳转至 default ，在已知范围内按照公式跳转，全部的实现如下： &lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i&amp;lt;0||i&amp;gt;=5)goto _default;&lt;/p&gt;
&lt;p&gt;i=i*5+100105; // 按照得出的公式算出跳转地址 &lt;/p&gt;
&lt;p&gt;goto i; // 伪代码， C 中不允许跳转到整数，但是汇编允许 &lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default;&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 经过这样处理整个 switch 结构，使得无论 switch 后的变量为何值，都可以通过最多两次跳转到达目标代码。相比之下 if 版本的代码则采用线性的比较和跳转，在 case 语句很多的情况下效率极低。 &lt;/p&gt;
&lt;p&gt; 由此 , 我们也可以知道 , 为什么 case 后跟的一定是编译期整型常数，因为编译器需要根据这个值制作跳转表。我们可以明白为什么 case 与 case 之间应该用 break 分隔，因为编译器不改变 switch 语句体的结构， case 其本身只是一个具有语义的标号而已，要想跳出 switch ，就必须用 break 语句。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 3.1 左值右值与常量性(lvalue，rvalue &amp; constant)</title><link href="//farseerfc.github.io/zhs/c-tricks-3-1-lvalue-rvalue-constant.html" rel="alternate"></link><updated>2007-09-16T13:07:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-09-16:zhs/c-tricks-3-1-lvalue-rvalue-constant.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h2&gt;3.1  左值右值与常量性 (lvalue ， rvalue &amp;amp; constant)&lt;/h2&gt;
&lt;p&gt; 首先要搞清楚的是，什么是左值，什么是右值。这里给出左值右值的定义： &lt;/p&gt;
&lt;p&gt;1 、左值是可以出现在等号 (=) 左边的值，右值是只能出现在等号右边的值。 &lt;/p&gt;
&lt;p&gt;2 、左值是可读可写的值，右值是只读的值。 &lt;/p&gt;
&lt;p&gt;3 、左值有地址，右值没有地址。 &lt;/p&gt;
&lt;p&gt; 根据左值右值的第二定义，值的左右性就是值的常量性 —— 常量是右值，非常量是左值。比如： &lt;/p&gt;
&lt;p&gt;1=1;//Error&lt;/p&gt;
&lt;p&gt; 这个复制操作在 C++ 中是语法错误， MSVC 给出的错误提示为 “error C2106: '=' :
left operand must be
l-value” ，就是说 ’=’ 的左操作数必须是一个左值，而字面常数 1 是一个右值。可见，严格的区分左值右值可以从语法分析的角度找出程序的逻辑错误。 &lt;/p&gt;
&lt;p&gt; 根据第二定义，一个左值也是一个右值，因为左值也可读，而一个右值不是一个左值，因为右值不可写。 &lt;/p&gt;
&lt;p&gt; 通常情况下，声明的变量是一个左值，除非你指定 const 将它变成一个右值： &lt;/p&gt;
&lt;p&gt;int lv=1;&lt;/p&gt;
&lt;p&gt;const int rv=lv;&lt;/p&gt;
&lt;p&gt; 由于右值的值在程序执行期间不能改变，所以必须用另一个右值初始化它。 &lt;/p&gt;
&lt;p&gt; 一个普通变量只能用右值初始化，如果你想传递左值，必须声明一个引用或一个指针： &lt;/p&gt;
&lt;p&gt;int &amp;amp; ref=lv;// 用引用传递左值 &lt;/p&gt;
&lt;p&gt;int * plv=&amp;amp;lv;// 传递指针以间接传递左值 &lt;/p&gt;
&lt;p&gt; 必须用左值初始化引用，然而，可以用右值初始化常量引用： &lt;/p&gt;
&lt;p&gt;int &amp;amp; r1=1; //Error!&lt;/p&gt;
&lt;p&gt;const int &amp;amp; r2=1; //OK&lt;/p&gt;
&lt;p&gt; 这实际上相当于： &lt;/p&gt;
&lt;p&gt;int _r2=1;&lt;/p&gt;
&lt;p&gt;const int &amp;amp; r2=_r2;&lt;/p&gt;
&lt;p&gt; 这样的写法在函数体内没什么作用，但是在传递函数参数时，它可以避免潜在的 ( 传递左值时的 ) 复制操作，同时又可以接受右值。 &lt;/p&gt;
&lt;p&gt; 通常情况下，函数的参数和返回值都只传回右值，除非你明确的通过引用传递左值。 &lt;/p&gt;
&lt;p&gt; 明确了左值与右值的区别，有助于我们写函数时确定什么时候应该有 const ，什么时候不该有。比如，我们写了一个代表数学中复数的类 Complex ： &lt;/p&gt;
&lt;p&gt;class Complex;&lt;/p&gt;
&lt;p&gt; 然后，我们写针对 Complex 的运算符重载： operator+ 和 operator= 。问题在于，参数和返回值应该是什么类型，可选类型有四种： Complex 、 const Complex 、 Complex&amp;amp; 、 const Complex&amp;amp; 。 &lt;/p&gt;
&lt;p&gt; 对于 operator+ ，我们不会改变参数的值，所以可以通过 const
Complex&amp;amp; 传递参数。至于返回值类型，由于 int 类型的加法返回右值，所以根据 Do
as the ints do 的原则，返回值类型为 const Complex ： &lt;/p&gt;
&lt;p&gt;const Complex operator+(const Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt; 对于 operator= ，同样要思考这些问题。我们写入第一个参数，所以第一个参数为 Complex&amp;amp; ，我们只读取第二个参数，所以第二个参数为 const
Complex&amp;amp; 。至于返回值，还是 Do as the ints
do 。 int 的赋值返回左值，不信你可以试一试： &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;(i=1)=2;&lt;/p&gt;
&lt;p&gt; 虽然比较傻，先将 i 赋为 1 ，再将其改为 2 ，但是这是被 C++ 语法支持的做法，我们就理应遵守。所以返回第一个参数的左值： &lt;/p&gt;
&lt;p&gt;Complex&amp;amp; operator=(Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt;const 是 C++ 引入的语言特性，也被 ANSI
C99 借鉴，在经典版本的 C 语言中是没有的。关于 const 的历史，有几点值得玩味。最初 Bjarne
Stroustrup 引入 const 时，可写性是和可读性分开的。那时使用关键字 readonly 和 writeonly 。这个特点被首先提交到 C 的 ANSI 标准化委员会 ( 当时还没有 C++ 标准化的计划 ) ，但是 ANSI
C 标准只接受了 readonly 的概念，并将其命名为 const 。随后，有人发现在多线程同步的环境下，有些变量的值会在编译器的预料之外改变，为了防止过度优化破坏这些变量， C++ 又引入关键字 violate 。从语义特点来看， violate 是 const 的反义词，因为 const 表示不会变的量，而 violate 表示会不按照预期自行变化的量。从语法特点而言， violate 与 const 是极为相似的，适用于 const 的一切语法规则同样适用于 violate 。 &lt;/p&gt;
&lt;p&gt; 值的常量性可以被划分为两种：编译期常量和运行期常量。 C++ 语法并没有严格区分这两种常量，导致了少许混乱： &lt;/p&gt;
&lt;p&gt;const int i=5;const int * pi=&amp;amp;i;&lt;/p&gt;
&lt;p&gt;const_cast&amp;lt;int&amp;amp;&amp;gt;i=1;// 对于运行期常量，在需要时可以去除它的常量性 &lt;/p&gt;
&lt;p&gt;int a[i];// 对于编译期常量，可以用它来指定数组大小 &lt;/p&gt;
&lt;p&gt;cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;sizeof(a)/sizeof(a[0])&amp;lt;&amp;lt;*pi;&lt;/p&gt;
&lt;p&gt; 这种将编译期与运行期常量的特性混用的方法，势必导致语义的混乱。数组 a 的大小最终是 5 ，因为采用了 i 的编译期值，而不管 i 在运行期是否被改变了值。最后一句代码将（有可能）输出 551 ，第一个 i 的值作为一种优化在编译期绑定，第二个值标明了 a 的大小，第三个值通过指针显示地输出 i 的运行期真实值。 &lt;/p&gt;
&lt;p&gt; 在 C++ 的近亲 C# 的语法中，这两种常量被严格地区分开：编译期常量由 const 指定，只能是内建类型变量；运行期常量由 readonly 指定，可以是任何类型。永远不会改变的常量，如圆周率 pi 的值，应该用 const 声明；而其它有可能改变的常量，皆由 readonly 声明。 &lt;/p&gt;
&lt;p&gt;C++ 中的 const 的特点更倾向于 C# 中的 readonly ，虽然语法上允许使用 const 的编译期常量性，但正如上文所展示的，这容易造成混乱。为了得到 C# 中 const 的语义，在 C++ 中，我们不必回归恶魔 #define 的怀抱，可以使用所谓 “ 匿名 enum 技巧 ” 。当匿名声明一个 enum 类型时，其中的枚举值就是一个 int 类型的编译期常量，比如： &lt;/p&gt;
&lt;p&gt;enum{Size=5;};&lt;/p&gt;
&lt;p&gt;int a[Size];&lt;/p&gt;
&lt;p&gt; 这种使用匿名 enum 来声明编译期常量的做法，被广泛应用于 STL 、 boost 等模板库的实现代码中。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.2 I386平台的内存布局</title><link href="//farseerfc.github.io/zhs/c-tricks-2-2-i386-memory-layout.html" rel="alternate"></link><updated>2007-08-28T14:30:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks-2-2-i386-memory-layout.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.2 I386 平台的内存布局 &lt;/h2&gt;
&lt;p&gt; 众所周知， I386 是 32 位体系结构。因此对于绝大多数 I386 平台的 C++ 编译器而言， sizeof(int)=sizeof(long)=sizeof(void*)=4 。当然 C++ 标准对此没有任何保证，我们也不应该试图编写依赖于此的代码。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;32 位指针的可寻址空间为 4GB 。为充分利用这么大的寻址空间，也是为了支持其它更先进的技术比如多任务技术或者动态链接库技术， WinNT 使用虚拟内存技术，给与每个应用程序全部 4GB 的内存空间。 4GB 的地址被一分为二，前 2GB 供应用程序自己使用，后 2GB 由系统内核分配和管理。这 2GB 的内存地址，通常被划分成 3 种内存区使用： &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;1  代码及静态数据区 &lt;/h3&gt;
&lt;p&gt; 由代码加载器从动态链接库镜像 ( 通常是 exe 或 dll 文件 ) 加载，通常定位到镜像文件中指定的基址开始的内存区。如果基址所在内存已被占用，动态连接器会将代码或数据重定向到其它可用地址。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 在 C++ 中，静态数据包括：名字空间 (namespace) 和全局 (global) 对象、函数的 static 对象、类的 static 数据成员。这些静态数据由编译器分配地址 ( 但可能被重定向 ) ，由静态连接器写入代码文件 ( 通常是 exe 或 dll) 的静态数据区段。所以标准说，这些静态数据在编译期就已经具有地址。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stack"&gt;
&lt;h3&gt;2  栈 (Stack)&lt;/h3&gt;
&lt;p&gt; 栈是最常用的动态数据存储区，所有函数的 non-static 对象和函数参数都在程序运行期在栈上分配内存。在数据结构中，术语 “ 栈 (Stack)” 意指先进后出 (FILO ， First
In Last
Out) ，与 “ 队列 (Queue)” 所指的 FIFO 相对。相对于基于堆的对象分配技术，默认使用栈的对象分配有两点优势： &lt;/p&gt;
&lt;p&gt; 一、栈的 FILO 与人的思维方式相同 &lt;/p&gt;
&lt;p&gt; 现实生活中有许多事例都使用 FILO 的方式，比如人们必须先提起话筒再拨打号码，而后挂断电话之后再放下话筒。使用 FILO 的栈，可以保证事物的销毁顺序以其诞生顺序相反的顺序进行，不会产生在挂断电话之前就放下话筒的尴尬。 &lt;/p&gt;
&lt;p&gt; 二、栈的分配管理仅需要两个额外指针：栈顶 (esp) 和栈底 (ebp) 指针 &lt;/p&gt;
&lt;p&gt; 从实现的技术层面而言，栈的管理比其它动态分配技术要简单很多。 I386 平台上的动态栈管理，仅需要栈顶和栈底两个指针。这两个指针的存储显然不能放置于栈中，置于静态数据区又有损效率。 I386 平台为管理动态栈专门预留了两个通用寄存器变量 esp 与 ebp ，分别代表栈顶 (esp,Extended
Stack Pointer) 与栈底 (Extended Bottom
Pointer) 指针。其中的 extended 代表它们是 32 位指针，以区分 16 位的 sp 和 bp 寄存器。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 栈是动态存储区的特点，表明它的内存占用将随着程序的运行而变化。 I386 平台上 WinNT 将应用程序的栈置于程序空间，向下增长。程序初始化时，由操作系统将 esp 指向系统分配的栈空间的顶部。当程序需要在栈上分配变量时，就将 esp 减去变量所需字节数，这被称作 “ 压栈 (Push)” ；随后又要销毁变量时，就将 esp 加上变量所需字节数，这被称作 “ 弹出 (Pop)” 。 esp 与 ebp 两者之间所夹的空间，就是当前函数正在使用的栈空间。由于栈向下增长， esp( 栈顶 ) 的值总是小于 ebp( 栈底 ) 的值，新分配的变量地址总是小于旧变量的地址。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="heap"&gt;
&lt;h3&gt;3  堆 (Heap) 和自由存储区 &lt;/h3&gt;
&lt;p&gt; 栈中的变量对于分配与释放的顺序有特定要求，这在一定程度上限制了栈的适用范围。面向对象 (OO ， Object
Oriented) 的程序设计思想也要求能自由地控制变量的分配与销毁。由此，现代操作系统都提供了被称作 “ 堆 (Heap)” 的自由存储区，以允许由程序员控制的对象创建和销毁过程。 C 标准库函数 malloc 和 free 则是对操作系统提供的堆操作的封装。 C++ 提供的自由存储区运算符 new 和 delete 则通常是 malloc 和 free 的又一层封装。 &lt;/p&gt;
&lt;p&gt; 操作系统经由 malloc 和 free 控制对堆的访问。堆的存储管理技术各不相同，简单的使用双链表管理，复杂的可以比拟一个完整的文件系统。 &lt;/p&gt;
&lt;p&gt; 由于额外的管理需求，使用系统提供的通用分配器在堆上分配和销毁变量的代价，无论从空间角度还是效率角度而言，都比在栈上分配对象要高昂很多。对于 sizeof 上百的大型对象，这样的高昂代价还是可以接受的，但是对于 sizeof 只有个位数的小对象，这样的代价通常是一个数量级的差距。正因为这个原因， STL 不使用 new 和 delete ，转而使用分配子 (alllocor) 分配对象。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks</title><link href="//farseerfc.github.io/zhs/c-tricks.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ Tricks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;By  FarseerFc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 从今天起，我再将在 &lt;a class="reference external" href="http://firechildren.spaces.live.com/"&gt;Live
Space&lt;/a&gt; 和 &lt;a class="reference external" href="http://76635424.qzone.qq.com/"&gt;QQZone&lt;/a&gt; 同时发表一系列文章，暂定名为 “C++Tricks” 。 &lt;/p&gt;
&lt;p&gt; 本文旨在记录和阐述一些本人学习 C++ 时所得的心得、技巧。总体来看，本文涉及的内容是每一个 C++ 程序员都应该知道的，但是很少见诸 C++ 教材。希望对各位同仁学习 C++ 有所帮助。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 也可以通过 QQ 或 MSN 向我索要此文的 DOC 版或 PDF 版，会比网页上的更新的快一点。 &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lexical-problems"&gt;
&lt;h2&gt;1       词法问题 (Lexical Problems)&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!139.entry"&gt;1.1  条件运算符 (?:)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!140.entry"&gt;1.2  逗号运算符 (,) 、逻辑运算符 (&amp;amp;&amp;amp;,||) 与运算符重载的陷阱 &lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="x86"&gt;
&lt;h3&gt;2      X86 体系结构 &lt;/h3&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!146.entry"&gt;2.1 X86 概述 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!147.entry"&gt;2.2 I386 平台的内存布局 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!148.entry"&gt;2.3 I386 平台 C 函数内部的栈分配 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!149.entry"&gt;2.4 I386 平台 C 函数调用边界的栈分配 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!150.entry"&gt;2.5 I386 平台的边界对齐 (Align)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!151.entry"&gt;2.6 I386 平台 C 函数的可变参数表 (Variable Arguments)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!152.entry"&gt;2.7 I386 平台的其它函数调用模型 &lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="id6"&gt;
&lt;h5&gt;3  过程式编程 &lt;/h5&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!154.entry"&gt;3.1  左值右值与常量性 (lvalue ， rvalue &amp;amp; constant)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!155.entry"&gt;3.2  标号、 goto ，以及 switch 的实现 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.3 I386平台C函数内部的栈分配</title><link href="//farseerfc.github.io/zhs/c-tricks-2-3-i386-stack-allocation-in-c-functions.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks-2-3-i386-stack-allocation-in-c-functions.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.3 I386 平台 C 函数内部的栈分配 &lt;/h2&gt;
&lt;p&gt; 函数使用栈来保存局部变量，传递函数参数。进入函数时，函数在栈上为函数中的变量统一预留栈空间，将 esp 减去相应字节数。当函数执行流程途径变量声明语句时，如有需要就调用相应构造函数将变量初始化。当执行流程即将离开声明所在代码块时，以初始化的顺序的相反顺序逐一调用析构函数。当执行流程离开函数体时，将 esp 加上相应字节数，归还栈空间。 &lt;/p&gt;
&lt;p&gt; 为了访问函数变量，必须有方法定位每一个变量。变量相对于栈顶 esp 的位置在进入函数体时就已确定，但是由于 esp 会在函数执行期变动，所以将 esp 的值保存在 ebp 中，并事先将 ebp 的值压栈。随后，在函数体中通过 ebp 减去偏移量来访问变量。以一个最简单的函数为例： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int a=0; //a 的地址被分配为 ebp-4&lt;/p&gt;
&lt;p&gt;char c=1; //c 的地址被分配为 ebp-8&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 产生的汇编代码为： &lt;/p&gt;
&lt;p&gt;push ebp ; 将 ebp 压栈 &lt;/p&gt;
&lt;p&gt;mov ebp,esp ;ebp=esp  用栈底备份栈顶指针 &lt;/p&gt;
&lt;p&gt;sub esp,8 ;esp-=8 ，为 a 和 c 预留空间，包括边界对齐 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],0 ;a=0&lt;/p&gt;
&lt;p&gt;mov byte ptr[ebp-8],1 ;c=1&lt;/p&gt;
&lt;p&gt;add esp,8 ;esp+=8 ，归还 a 和 c 的空间 &lt;/p&gt;
&lt;p&gt;mov esp,ebp ;esp=ebp  从栈底恢复栈顶指针 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢复 ebp&lt;/p&gt;
&lt;p&gt;ret ; 返回 &lt;/p&gt;
&lt;p&gt; 相应的内存布局是这样： &lt;/p&gt;
&lt;p&gt;09992:c=1 &amp;lt;-esp&lt;/p&gt;
&lt;p&gt;09996:a=0&lt;/p&gt;
&lt;p&gt;10000: 旧 ebp &amp;lt;-ebp&lt;/p&gt;
&lt;p&gt;10004:……&lt;/p&gt;
&lt;p&gt; 注 : 汇编中的 pop 、 push 、 call 、 ret 语句是栈操作指令，其功能可以用普通指令替换 &lt;/p&gt;
&lt;p&gt;push ebp 相当于 :&lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;mov dword ptr[esp],ebp&lt;/p&gt;
&lt;p&gt;pop ebp 相当于： &lt;/p&gt;
&lt;p&gt;mov ebp,dword ptr[esp]&lt;/p&gt;
&lt;p&gt;sub esp,4&lt;/p&gt;
&lt;p&gt;call fun_address 相当于： &lt;/p&gt;
&lt;p&gt;push eip&lt;/p&gt;
&lt;p&gt;jmp fun_address&lt;/p&gt;
&lt;p&gt;ret 相当于 &lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt; 带参数的 ret&lt;/p&gt;
&lt;p&gt;ret 8 相当于 &lt;/p&gt;
&lt;p&gt;add esp,12&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt; 所有局部变量都在栈中由函数统一分配，形成了类似逆序数组的结构，可以通过指针逐一访问。这一特点具有很多有趣性质，比如，考虑如下函数，找出其中的错误及其造成的结果： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i,a[10];&lt;/p&gt;
&lt;p&gt;for(i=0;i&amp;lt;=10;++i)a[i]=0;/An error occurs here!&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 这个函数中包含的错误，即使是 C++ 新手也很容易发现，这是老生常谈的越界访问问题。但是这个错误造成的结果，是很多人没有想到的。这次的越界访问，并不会像很多新手预料的那样造成一个 “ 非法操作 ” 消息，也不会像很多老手估计的那样会默不作声，而是导致一个，呃，死循环！ &lt;/p&gt;
&lt;p&gt; 错误的本质显而易见，我们访问了 a[10] ，但是 a[10] 并不存在。 C++ 标准对于越界访问只是说 “ 未定义操作 ” 。我们知道， a[10] 是数组 a 所在位置之后的一个位置，但问题是，是谁在这个位置上。是 i!&lt;/p&gt;
&lt;p&gt; 根据前面的讨论， i 在数组 a 之前被声明，所以在 a 之前分配在栈上。但是， I386 上栈是向下增长的，所以， a 的地址低于 i 的地址。其结果是在循环的最后， a[i] 引用到了 i 自己！接下来的事情就不难预见了， a[i] ，也就是 i ，被重置为 0 ，然后继续循环的条件仍然成立 …… 这个循环会一直继续下去，直到在你的帐单上产生高额电费，直到耗光地球电能，直到太阳停止燃烧 …… 呵呵，或者直到聪明的你把程序 Kill 了 ……&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.4 I386平台C函数调用边界的栈分配</title><link href="//farseerfc.github.io/zhs/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.4 I386 平台 C 函数调用边界的栈分配 &lt;/h2&gt;
&lt;p&gt; 当调用一个函数时，主调函数将参数以声明中相反的顺序压栈，然后将当前的代码执行指针 (eip) 压栈，然后跳转到被调函数的入口点。在被调函数中，通过将 ebp 加上一个偏移量来访问函数参数，以声明中的顺序 ( 即压栈的相反顺序 ) 来确定参数偏移量。被调函数返回时，弹出主调函数压在栈中的代码执行指针，跳回主调函数。再由主调函数恢复到调用前的栈。 &lt;/p&gt;
&lt;p&gt; 函数的返回值不同于函数参数，通过寄存器传递。如果返回值类型可以放入 32 位变量，比如 int 、 short 、 char 、指针等类型，通过 eax 寄存器传递。如果返回值类型是 64 位变量，如 _int64 ，同过 edx+eax 传递， edx 存储高 32 位， eax 存储低 32 位。如果返回值是浮点类型，如 float 和 double ，通过专用的浮点数寄存器栈的栈顶返回。如果返回值类型是用户自定义结构，或 C++ 类类型，通过修改函数签名，以引用型参数的形式传回。 &lt;/p&gt;
&lt;p&gt; 同样以最简单的函数为例： &lt;/p&gt;
&lt;p&gt;void f(){&lt;/p&gt;
&lt;p&gt;int i=g(1,2);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int g(int a,int b){&lt;/p&gt;
&lt;p&gt;int c=a+b ； &lt;/p&gt;
&lt;p&gt;return c;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 产生的汇编代码如下： &lt;/p&gt;
&lt;p&gt;f:&lt;/p&gt;
&lt;p&gt;push ebp ; 备份 ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ; 建立栈底 &lt;/p&gt;
&lt;p&gt;sub esp,4 ; 为 i 分配空间 &lt;/p&gt;
&lt;p&gt;mov eax,2 ; 准备参数 b 的值 2&lt;/p&gt;
&lt;p&gt;push eax ; 将 b 压栈 &lt;/p&gt;
&lt;p&gt;mov eax,1 ; 准备参数 a 的值 1&lt;/p&gt;
&lt;p&gt;push eax ; 将 a 压栈 &lt;/p&gt;
&lt;p&gt;call g ; 调用 g&lt;/p&gt;
&lt;p&gt;add esp,8 ; 将 a 和 b 一起弹出，恢复调用前的栈 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ; 将返回值保存进变量 i&lt;/p&gt;
&lt;p&gt;mov esp,ebp ; 恢复栈顶 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢复栈底 &lt;/p&gt;
&lt;p&gt;g:&lt;/p&gt;
&lt;p&gt;push ebp ; 备份 ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ; 建立栈底 &lt;/p&gt;
&lt;p&gt;sub esp,4 ; 为局部变量 c 在栈中分配内存 &lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp+8] ; 通过 ebp 间接读取参数 a 的值 &lt;/p&gt;
&lt;p&gt;mov ebx,dword ptr[ebp+12] ; 通过 ebp 间接读取参数 b 的值 &lt;/p&gt;
&lt;p&gt;add eax,ebx ; 将 a 和 b 的值相加，之和存在 eax 中 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ; 将和存入变量 c&lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp-4] ; 将 c 作为返回值，代码优化后会删除此句 &lt;/p&gt;
&lt;p&gt;add esp,4 ; 销毁 c 的内存 &lt;/p&gt;
&lt;p&gt;mov esp,ebp ; 恢复栈顶 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢复栈底 &lt;/p&gt;
&lt;p&gt;ret ; 返回函数 f&lt;/p&gt;
&lt;p&gt; 栈的内存布局如下： &lt;/p&gt;
&lt;p&gt;100076:c &amp;lt;- g 的 esp&lt;/p&gt;
&lt;p&gt;100080:f 的 ebp=100100 &amp;lt;- g 的 ebp&lt;/p&gt;
&lt;p&gt;100084:f 的 eip&lt;/p&gt;
&lt;p&gt;100088:a=1&lt;/p&gt;
&lt;p&gt;100092:b=2&lt;/p&gt;
&lt;p&gt;100096:i&lt;/p&gt;
&lt;p&gt;100100: 旧 ebp &amp;lt;-f 的 ebp&lt;/p&gt;
&lt;p&gt;100104:……&lt;/p&gt;
&lt;p&gt; 注意在函数 g 的汇编代码中，访问函数的局部变量和访问函数参数的区别。局部变量总是通过将 ebp 减去偏移量来访问，函数参数总是通过将 ebp 加上偏移量来访问。对于 32 位变量而言，第一个局部变量位于 ebp-4 ，第二个位于 ebp-8 ，以此类推， 32 位局部变量在栈中形成一个逆序数组；第一个函数参数位于 ebp+8 ，第二个位于 ebp+12 ，以此类推， 32 位函数参数在栈中形成一个正序数组。 &lt;/p&gt;
&lt;p&gt; 由于函数返回值通过寄存器返回，不需要空间分配等操作，所以返回值的代价很低。基于这个原因，旧的 C 语法约定，不写明返回值类型的函数，返回值类型为 int 。这一规则与现行的 C++ 语法相违背，因为 C++ 中，不写明返回值类型的函数返回值类型为 void ，表示不返回值。这种语法不兼容性是为了加强 C++ 的类型安全，但同时也带来了一些问题。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.5 I386平台的边界对齐(Align)</title><link href="//farseerfc.github.io/zhs/c-tricks-2-5-address-alignment.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks-2-5-address-alignment.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h2&gt;2.5 I386 平台的边界对齐 (Align)&lt;/h2&gt;
&lt;p&gt; 首先提问，既然 I386 上 sizeof(int)==4 、 sizeof(char)==1 ，那么如下结构 (struct)A 的 sizeof 是多少？ &lt;/p&gt;
&lt;p&gt;struct A{int i;char c;};&lt;/p&gt;
&lt;p&gt; 答案是 sizeof(A)==8……1+5=8 ？ &lt;/p&gt;
&lt;p&gt; 呵呵，这就是 I386 上的边界对齐问题。我们知道， I386 上有整整 4GB 的地址空间，不过并不是每一个字节上都可以放置任何东西的。由于内存总线带宽等等的技术原因，很多体系结构都要求内存中的变量被放置于某一个边界的地址上。如果违反这个要求，重则导致停机出错，轻则减慢运行速度。对于 I386 平台而言，类型为 T 的变量必须放置在 sizeof(T) 的整数倍的地址上， char 可以随便放置， short 必须放在 2 的整数倍的地址上， int 必须放在 4 的整数倍的地址上， double 必须放在 8 的整数倍的地址上。如果违反边界对齐要求，从内存中读取数据必须进行两次，然后将独到的两半数据拼接起来，这会严重影响效率。 &lt;/p&gt;
&lt;p&gt; 由于边界对齐问题的要求，在计算 struct 的 sizeof 的时候，编译器必须算入额外的字节填充，以保证每一个变量都能自然对齐。比如如下声明的 struct:&lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 实际上相当于声明了这样一个结构： &lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;char _filling1 [3];// 三个字节填充，保证下一个 int 的对齐 &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2 ； &lt;/p&gt;
&lt;p&gt;char _filling2 [3];// 又三个字节填充 &lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 值得注意的是尾部的 3 个字节填充，这是为了可以在一个数组中声明 WASTE 变量，并且每一个都自然对齐。因为有了这些填充，所以 sizeof(WASTE)==12 。这是一种浪费，因为只要我们重新安排变量的声明，就可以减少 sizeof ： &lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c1,c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 像这样的安排， sizeof 就减少到 8 ，只有 2 个字节的额外填充。为了与汇编代码相兼容， C 语言语法规定，编译器无权擅自安排结构体内变量的布局顺序，必须从左向右逐一排列。所以，妥当安排成员顺序以避免内存空间的浪费，就成了我们程序员的责任之一。一般的，总是将结构体的成员按照其 sizeof 从大到小排列， double 在最前， char 在最后，这样总可以将结构的字节填充降至最小。 &lt;/p&gt;
&lt;p&gt;C++ 继承了 C 语言关于结构体布局的规定，所以以上的布局准则也适用于 C++ 的 class 的成员变量。 C++ 进一步扩展了布局规定，同一访问区段 (private 、 public 、 protected) 中的变量，编译器无权重新排列，不过编译器有权排列访问区段的前后顺序。基于这个规则， C++ 中有的程序员建议给每一个成员变量放在单独区段，在每一个成员声明之前都加上 private: 、 public: 、 protected: 标志，这可以最大限度的利用编译器的决策优势。 &lt;/p&gt;
&lt;p&gt; 在栈中按顺序分配的变量，其边界也受到对齐要求的限制。与在结构中不同的是，栈中的变量还必须保证其后续变量无论是何种类型都可以自由对齐，所以在栈中的变量通常都有平台相关的对齐最小值。在 MSVC 编译器上，这个最小值可以由宏 _INTSIZEOF(T) 查询： &lt;/p&gt;
&lt;p&gt;#define _INTSIZEOF(T) ( (sizeof(T) + sizeof(int) - 1) &amp;amp; ~(sizeof(int) -
1) )&lt;/p&gt;
&lt;p&gt;_INTSIZEOF(T) 会将 sizeof(T) 进位到 sizeof(int) 的整数倍。 &lt;/p&gt;
&lt;p&gt; 由于在栈中分配变量使用 _INTSIZEOF 而不是 sizeof ，在栈上连续分配多个小变量 (sizeof 小于 int 的变量 ) 会造成内存浪费，不如使用结构 (struct) 或数组。也就是说： &lt;/p&gt;
&lt;p&gt;char c1,c2,c3,c4;// 使用 16 字节 &lt;/p&gt;
&lt;p&gt;char c[4];// 使用 4 字节 &lt;/p&gt;
&lt;p&gt; 当然，使用数组的方法在访问数组变量 ( 比如 c[1]) 时有一次额外的指针运算和提领 (dereference) 操作，这会有执行效率的损失。这又是一种空间 ( 内存占用 )vs 时间 ( 执行效率 ) 的折中，需要程序员自己根据情况权衡利弊。 &lt;/p&gt;
&lt;p&gt;sizeof 的大小可能比我们预期的大，也可能比我们预期的小。对于空类： &lt;/p&gt;
&lt;p&gt;class Empty {};&lt;/p&gt;
&lt;p&gt; 在通常情况下， sizeof(Empty) 至少为 1 。这是因为 C++ 语法规定，对于任何实体类型的两个变量，都必须具有不同的地址。为了符合语法要求，编译器会给 Empty 加入 1 字节的填充。所以 sizeof() 的值不可能出现 0 的情况。可是对于以下的类声明： &lt;/p&gt;
&lt;p&gt;class A:public Empty{vitual ~A(){}};&lt;/p&gt;
&lt;p&gt;sizeof(A) 有可能是 6 ，也有可能是 5 ，也有可能是 4 ！必不可少的四个字节是一个指向虚函数表的指针。一个可能有的字节是 Empty 的大小，这是是因为编译器在特定情况下会将 Empty 视作一个 “ 空基类 ” ，从而实施 “ 空基类优化 ” ，省掉那毫无作用的一字节填充。另一个字节是 A 的一字节填充，因为从语法上讲， A 没有成员声明，理应有 1 字节填充，而从语义上讲，编译器给 A 的声明加入了一个指向虚函数表的指针，从而 A 就不再是一个 “ 空类 ” ，是否实施这个优化，要看编译器作者对语法措词的理解。也就是说， sizeof 也会出现 4+1+1=4 的情况。具体要看编译器有没有实施 “ 空基类优化 ” 和 “ 含虚函数表的空类优化 ” 。 &lt;/p&gt;
&lt;p&gt; 结构和类的空间中可能有填充的字节，这意味着填充字节中可能有数值，虽然这数值并不影响结构的逻辑状态，但是它也可能不知不觉中影响到你。比如说，你手头正好有一组依赖于底层硬件 ( 比如多处理器 ) 的函数，他们在操纵连续字节时比手动编码要快很多，而你想充分利用这种硬件优势： &lt;/p&gt;
&lt;p&gt;bool BitCompare(void* begin,void* end,void* another);&lt;/p&gt;
&lt;p&gt; 这个函数将区间 [begin,end) 之间的字节与 another 开始的字节相比较，如果有一位不同就返回 false ，否则返回 true 。 &lt;/p&gt;
&lt;p&gt; 比如你想将这个函数用于你自己的类的 operator== 中，这样可以利用硬件加快速度。不过你在动手前要充分考虑，你的 class 是否真的要比较每一位。如果在类的成员中存在编译器填充的字节数，那么应用以上的函数就是不正确的，因为填充的字节中可以有不同的值。为了保证你可以用 Bitwise
Compare ，你必须确保填充的字节中的值也是相同的。这不仅要求你在类的构造函数中初始化类的每一 bit 而不是每一个成员，也要求你在复制初始化和复制赋值函数中也同时保证 bitwise
copy 语义，而不是编译器默认产生的 memberwise 语义。当然，你可能通过与 BitCompare 一同提供的 BitCopy 来完成这个艰巨的任务。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.6 I386平台C函数的可变参数表(Variable Arguments)</title><link href="//farseerfc.github.io/zhs/c-tricks-2-6-i386-variable-arguments.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks-2-6-i386-variable-arguments.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h2&gt;2.6 I386 平台 C 函数的可变参数表 (Variable Arguments)&lt;/h2&gt;
&lt;p&gt; 基于前文 (2.4 节 ) 分析，我们可以不通过函数签名，直接通过指针运算，来得到函数的参数。由于参数的压栈和弹出操作都由主调函数进行，所以被调函数对于参数的真实数量不需要知晓。因此，函数签名中的变量声明不是必需的。为了支持这种参数使用形式， C 语言提供可变参数表。可变参数表的语法形式是在参数表末尾添加三个句点形成的省略号 “...” ： &lt;/p&gt;
&lt;p&gt;void g(int a,char* c,...);&lt;/p&gt;
&lt;p&gt; 省略号之前的逗号是可选的，并不影响词法语法分析。上面的函数 g 可以接受 2 个或 2 个以上的参数，前两个参数的类型固定，其后的参数类型未知，参数的个数也未知。为了知道参数个数，我们必须通过其他方法，比如通过第一个参数传递： &lt;/p&gt;
&lt;p&gt;g(3,”Hello”,2,4,5);// 调用 g 并传递 5 个参数，其中后 3 个为可变参数。 &lt;/p&gt;
&lt;p&gt; 在函数的实现代码中，可以通过 2.4 节叙述的，参数在栈中的排列顺序，来访问位于可变参数表的参数。比如 :&lt;/p&gt;
&lt;p&gt;void g(int a,char* c...){&lt;/p&gt;
&lt;p&gt;void *pc=&amp;amp;c;int* pi=static_cast&amp;lt;int*&amp;gt;(pc)+1;// 将 pi 指向首个可变参数 &lt;/p&gt;
&lt;p&gt;for(int i=0;i&amp;lt;a;i++)std::cout&amp;lt;&amp;lt;pi[i]&amp;lt;&amp;lt;” ” ； &lt;/p&gt;
&lt;p&gt;std::cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;std::endl;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 我们甚至可以让一个函数的所有参数都是可变参数，只要有办法获知参数的数量即可。比如，我们约定，在传递给 addAll 的参数都是 int ，并且最后一个以 0 结束： &lt;/p&gt;
&lt;p&gt;int addAll(...);&lt;/p&gt;
&lt;p&gt;int a=f(1,4,2,5,7,0);&lt;/p&gt;
&lt;p&gt; 那么 addAll 可以这样实现： &lt;/p&gt;
&lt;p&gt;int addAll(...){&lt;/p&gt;
&lt;p&gt;int sum=0;int *p=&amp;amp;sum; //p 指向第一个局部变量 &lt;/p&gt;
&lt;p&gt;p+=3; // 跳过 sum ， ebp ， eip ，现在 p 指向第一个参数 &lt;/p&gt;
&lt;p&gt;for(;*p;++p) // 如果 p 不指向 0 就继续循环 &lt;/p&gt;
&lt;p&gt;sum+=*p;&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 可变参数表的最广泛应用是 C 的标准库函数中的格式化输入输出： printf 和 scanf 。 &lt;/p&gt;
&lt;p&gt;void printf(char *c,...);&lt;/p&gt;
&lt;p&gt;void scanf(char *c,...);&lt;/p&gt;
&lt;p&gt; 两者都通过它的首个参数指出后续参数表中的参数类型和参数数量。 &lt;/p&gt;
&lt;p&gt; 如果可变参数表中的参数类型不一样，那么操纵可变参数表就需要复杂的指针运算，并且还要时刻注意边界对齐 (align) 问题，非常令人头痛。好在 C 标准库提供了用于操纵可变参数表的宏 (macro) 和结构 (struct) ，他们被定义在库文件 stdarg.h 中 :&lt;/p&gt;
&lt;p&gt;typedef struct {char *p;int offset;} va_list;&lt;/p&gt;
&lt;p&gt;#define va_start(valist,arg)&lt;/p&gt;
&lt;p&gt;#define va_arg(valist,type)&lt;/p&gt;
&lt;p&gt;#define va_end(valist)&lt;/p&gt;
&lt;p&gt; 其中结构 va_list 用于指示参数在栈中的位置，宏 va_start 接受一个 va_list 和函数的可变参数表之前的参数，通过第一个参数初始化 va_list 中的相应数据，因此要使用 stdarg.h 中的宏，你的可变参数表的函数必须至少有一个具名参数。 va_arg 返回下一个类型为 type 的参数， va_end 结束可变参数表的使用。还是以上文的 addAll 为例，这次写出它的使用标准宏的版本： &lt;/p&gt;
&lt;p&gt;int addAll(int i,...)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;va_list vl; // 定义一个 va_list 结构 &lt;/p&gt;
&lt;p&gt;va_start(vl,i); // 用省略号之前的参数初始化 vl&lt;/p&gt;
&lt;p&gt;if(i=0)return 0; // 如果第一个参数就是 0 ，返回 &lt;/p&gt;
&lt;p&gt;int sum=i; // 将第一个参数加入 sum&lt;/p&gt;
&lt;p&gt;for(;;){&lt;/p&gt;
&lt;p&gt;i=va_arg(vl,int); // 取得下一个参数，类型是 sum&lt;/p&gt;
&lt;p&gt;if(i==0)break; // 如果参数是 0 ，跳出循环 &lt;/p&gt;
&lt;p&gt;sum+=i;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;va_end(vl);&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 可以看出，如果参数类型一致，使用标准库要多些几行代码。不过如果参数类型不一致或者未知 (printf 的情况 ) ，使用标准库就要方便很多，因为我们很难猜出编译器处置边界对齐 (align) 等汇编代码的细节。使用标准库的代码是可以移植的，而使用上文所述的其它方法操纵可变参数表都是不可移植的，仅限于在 I386 平台上使用。 &lt;/p&gt;
&lt;p&gt; 纵使可变参数表有使用上的便利性，它的缺陷也有很多，不可移植性和平台依赖性只是其一，最大的问题在于它的类型不安全性。使用可变参数表就意味着编译器不对参数作任何类型检查，这在 C 中算是一言难尽的历史遗留问题，在 C++ 中就意味着恶魔 reinterpret_cast 被你唤醒。 C 的可变参数表是 C++ 代码错误频发的根源之一，以至于 C++ 标准将可变参数表列为即将被废除的 C 语言遗留特性。 C++ 语法中的许多新特性，比如重载函数、默认参数值、模板，都可以一定程度上替代可变参数表，并且比可变参数表更加安全。 &lt;/p&gt;
&lt;p&gt; 可变参数表在 C++ 中惟一值得嘉奖的贡献，是在模板元编程 (TMP) 的 SFINAE 技术中利用可变参数表制作最差匹配重载。根据 C++ 标准中有关函数重载决议的规则，具有可变参数表的函数总是最差匹配，编译器在被逼无奈走头无路时才会选择可变参数表。利用这一点，我们可以精心制作重载函数来提取类型信息。比如，要判断一个通过模板传递来的类型是不是 int ： &lt;/p&gt;
&lt;p&gt;long isIntImp(int);&lt;/p&gt;
&lt;p&gt;char isIntImp(...);&lt;/p&gt;
&lt;p&gt;template&amp;lt;typename T&amp;gt;&lt;/p&gt;
&lt;p&gt;struct isInt&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;enum{value=sizeof(isIntImp(T()))==sizeof(long);}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 然后，在一个具有模板参数 T 的函数中，我们就可以写 &lt;/p&gt;
&lt;p&gt;if(isInt&amp;lt;T&amp;gt;::value)//...&lt;/p&gt;
&lt;p&gt; 在这个 ( 不怎么精致的 ) 例子中，如果 T 是 int ，那么 isIntImp 的第一个重载版本就会被选中，返回值类型就是 long ，这样 value 就为 1 。否则，编译器只能选中第二个具有可变参数表的重载版本，返回值类型成为 char ，这样 value 就为 0 。把它说得再明白一些，上文的代码所表达的意思是：如果类型 T 是 int ，那它就是 int ，否则它就不是 int ，呵呵简单吧。这种通过重载决议规则来提取类型信息的技术，在模板元编程中被称作 SFINAE ，它和其它模板元编程技术被广泛运用于 STL 、 Boost 等模板库的开发实现之中。 &lt;/p&gt;
&lt;p&gt; 值得注意的是，在上文 SFINAE 的运用中， isIntImp 并没有出现定义而只提供了声明，因为我们并没有实际调用 isIntImp 函数，而只是让它参与重载决议并用 sizeof 判断其返回值类型。这是 C++ 的一个设计准则的完美体现：不需要的东西可以不出现。由于这一准则，我们避免了在 C++ 中调用具有可变参数表的函数这一危险举动，而仅仅利用了可变参数表在语法分析过程中的特殊地位，这种对于危险语言特性的巧妙利用是善意而无害的。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.7 I386平台的其它函数调用模型</title><link href="//farseerfc.github.io/zhs/c-tricks-2-7-i386-calling-conventions.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:zhs/c-tricks-2-7-i386-calling-conventions.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.7 I386 平台的其它函数调用模型 &lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 上文介绍的只是 I386 平台上 C 函数调用的标准模型，被称作 __cdecl 。事实上， Microsoft Visual C++ 编译器还支持其它一些函数调用模型，所有调用模型名称皆以双下划线开头，下面列出所有函数调用模型的异同： &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="cdecl"&gt;
&lt;h3&gt;1 __cdecl&lt;/h3&gt;
&lt;p&gt; 参数压栈顺序：逆序 ( 从右至左 )&lt;/p&gt;
&lt;p&gt; 参数堆栈恢复者：主调函数 (caller)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__cdecl 明确地指出函数使用 C 函数调用模型，这是默认的调用模型。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stdcall"&gt;
&lt;h3&gt;2 __stdcall&lt;/h3&gt;
&lt;p&gt; 参数压栈顺序：逆序 ( 从右至左 )&lt;/p&gt;
&lt;p&gt; 参数堆栈恢复者：被调函数 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__stdcall 是微软所谓的标准调用模型。可惜的是它与 __cdecl 不兼容。几乎所有的 Win32API 函数使用这种函数调用模型，希望在 DLL 之间，或者在程序和 WinNT 操作系统之间传递函数指针的函数也应该使用这种模型。与 __cdecl 模型的不同之处在于， __stdcall 模型下由被调函数恢复堆栈。主调函数在 call 语句之后，不需要再加上 add 语句。而被调函数的 ret 语句则被添加一个参数，代表函数参数堆栈的长度。因此，被调函数需要明确的知晓函数参数的数量和类型，所以在 __stdcall 模型下不支持可变参数表，所有参数必须写明。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="thiscall"&gt;
&lt;h3&gt;3 __thiscall&lt;/h3&gt;
&lt;p&gt; 参数压栈顺序：逆序 ( 从右至左 ) ， this 用 ecx 传递。 &lt;/p&gt;
&lt;p&gt; 参数堆栈恢复者：被调函数 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__thiscall 是 VC 编译器中类的非静态成员函数 (non-static member functon) 的默认调用模型。但是如果此成员函数有可变参数表， VC 编译器会使用 __cdecl 。和 __stdcall 一样， __thiscall 由被调函数恢复堆栈。比较独特的是 __thiscall 会通过 ecx 寄存器传递成员函数的 this 指针，而 __cdecl 下 this 指针是通过在参数表最前面增加一个函数参数来传递的。 __thiscall 是 VC 编译器对 this 指针的使用的一种优化，大大提高了面向对象程序的效率。在 VC2003 及之前的编译器上 __thiscall 不是一个关键字，不能被显式指定。但可以给成员函数显式指定 __cdecl 来避免使用 __thiscall 。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="fastcall"&gt;
&lt;h3&gt;4 __fastcall&lt;/h3&gt;
&lt;p&gt; 参数压栈顺序：逆序 ( 从右至左 ) ，前两个 32 位函数参数放入 ecx 和 edx 中 &lt;/p&gt;
&lt;p&gt; 参数堆栈恢复者：被调函数 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 快速函数调用模型，将前两个 32 位函数参数放入 ecx 和 edx 中，其余参数再逆序压栈。使用的是和 __thiscall 类似的优化技术，加快函数调用，适合运用在小型 inline 函数上。同样使用 __stdcall 形式的被调函数恢复堆栈，所以不支持可变参数表。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pascal"&gt;
&lt;h3&gt;5 __pascal&lt;/h3&gt;
&lt;p&gt; 参数压栈顺序：正序 ( 从左至右 )&lt;/p&gt;
&lt;p&gt; 参数堆栈恢复者：被调函数 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 过程式编程语言 Pascal 所使用的函数调用模型，由此得名。也是 16 位版本的 Windows 使用的 API 模型，过时的模型，现在已经废弃且禁止使用。你会看到有些书本仍会不时提到它，所以需要注意。 __pascal 是正序压栈，这与大部分 I386 函数模型都不相同。与 __stdcall 一样，由被调者恢复堆栈，不支持可变参数表。历史上曾有过的别名 PASCAL 、 pascal 、 _pascal( 单下划线 ) ，现在都改成了 __stdcall 的别名，与 __pascal( 双下划线 ) 不同。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;6  其它函数调用模型，以及模型别名。 &lt;/h3&gt;
&lt;p&gt;__syscall ：操作系统内部使用的函数调用模型，由用户模式向核心模式跳转时使用的模型。由于用户模式和核心模式使用不同的栈，所以没办法使用栈来传递参数，所有参数通过寄存器传递，这限制了参数的数量。用户模式编程中不允许使用。 &lt;/p&gt;
&lt;p&gt;__fortran ：数学运算语言 fortran 使用的函数模型，由此得名。在 C 中调用由 fortran 编译的函数时使用。 &lt;/p&gt;
&lt;p&gt;__clrcall ：微软 .Net 框架使用的函数模型，托管 (Managed)C++ 默认使用，也可以从非托管代码调用托管函数时使用。参数在托管栈上正序 ( 从左至右 ) 压栈，不使用普通栈。 &lt;/p&gt;
&lt;p&gt;CALLBACK 、 PASCAL 、 WINAPI 、 APIENTRY 、 APIPRIVATE ： I386 平台上是 __stdcall 的别名 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;WINAPIV ： I386 平台上是 __cdecl 的别名 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;7  函数调用模型的指定 &lt;/h3&gt;
&lt;p&gt; 函数调用模型的指定方式和 inline 关键字的指定方式相同，事实上， inline 可以被看作是 C++ 语言内建的一种函数调用模型。唯一不同的是，声明函数指针时，也要指明函数调用模型，而 inline 的指针是不能指明的，根本不存在指向 inline 函数的指针。比如： &lt;/p&gt;
&lt;p&gt;int CALLBACK GetVersion();&lt;/p&gt;
&lt;p&gt;int (CALLBACK * pf)()=GetVersion;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.1 X86概述</title><link href="//farseerfc.github.io/zhs/c-tricks-2-1-x86-architecture.html" rel="alternate"></link><updated>2007-08-27T16:33:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-27:zhs/c-tricks-2-1-x86-architecture.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="x86"&gt;
&lt;h2&gt;2.1   X86 概述 &lt;/h2&gt;
&lt;p&gt; 所谓 X86 体系结构，是指以 Intel
8086 芯片为首的芯片所沿袭的 CPU 结构，一些文档中又被称作 IA32 体系结构。包括的芯片有但不限于 :Intel
8086 至 80486 ，奔腾 (Pentium) 系列处理器 1 至 4 ，赛扬系列处理器，酷睿系列处理器，以及 AMD 的相应型号产品。 X86 体系结构在早期属于 16 位处理器，自 80386 之后扩展为 32 位处理器，所以一些文档中又把 80386 之后的 32 位处理器体系称作 I386 。自 Pentium4 后期， AMD 的 Athlon64 开始， I386 被进一步扩充为 64 位处理器，含有 64 位寻址能力的 X86 体系结构被称作 X86-64 或 IA32-64 。总之，市售的个人电脑用 CPU ，除苹果的 Macintosh 之外，全部采用 X86 体系结构芯片。 &lt;/p&gt;
&lt;p&gt; 在 X86 早期， 16 位的寻址能力只支持 64KB(2^16=64K) 内存，这显然是不够的。 Intel 采用分段寻址的方法，用 4 位段位 +16 位偏移量，提供了总共 1MB(2^20=1M) 的寻址能力。所以在 X86 的 16 位编程中，有两种指针类型：长指针 (lp,long
pointer) 和短指针 (sp,short
pointer) ，长指针 (20 位 ) 提供整个内存空间寻址能力，短指针 (16 位 ) 仅支持同一段中的寻址。在 “ 古代 ”DOS 及 Win3.x 编程过程中，两种类型的指针，以及总共 1MB 的内存大小，常常把程序员们折腾得焦头烂额。 &lt;/p&gt;
&lt;p&gt; 自 I386 之后， CPU 才开始提供 32 位的寻址能力。有了整整 4GB(2^32=4G) 的寻址空间，所有指针统一为长指针 (32 位 ) 。时至今日，我们仍可以看到微软文档中指针变量的 lp 前缀。由于内存管理的需要，分段机制被保留下来，但这一次不是因为地址空间太小，而是因为地址空间远大于实际内存容量，从而采用了虚拟内存机制。 &lt;/p&gt;
&lt;p&gt; 在从 16 位结构向 32 位结构转变的过程中，由于向下兼容的历史原因，曾一度长时间出现硬件 32 位 (I386) 、软件 16 位 (Win3.x) 的情况。同样也是为了兼容 16 位软件， Win9x 操作系统 (Win95 、 Win98 、 WinME) 保留了 16 位代码和 32 位代码。混合代码的设计使得 Win9x 及其混乱和不稳定。直到完全 32 位内核的操作系统 WinNT( 以及构建于其上的 Win2000 ， WinXP ， Win2003) 的出现， X86 平台上内存布局混乱的局面才得以改善。有了从 16 位至 32 位移植的经验和准备，现今的从 32 位到 64 位的操作系统移植显得平稳顺利很多。 WinXP 和 WinVista 系统都同时发布了 32 位版本和 64 位版本，并且其 x86-64 系统都实现了对 32 位软件的无缝衔接支持。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 1.2 逗号运算符(,)、逻辑运算符(&amp;&amp;,||)与运算符重载的陷阱</title><link href="//farseerfc.github.io/zhs/c-tricks-1-2-trap-in-comma-logical-operator.html" rel="alternate"></link><updated>2007-08-22T18:06:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-22:zhs/c-tricks-1-2-trap-in-comma-logical-operator.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.2    逗号运算符 (,) 、逻辑运算符 (&amp;amp;&amp;amp;,||) 与运算符重载的陷阱 &lt;/h2&gt;
&lt;p&gt; 很多人甚至不知道逗号 (,) 也是个 C++ 运算符。与语法上要求出现的逗号 ( 比如分隔函数参数的逗号 ) 不同的是，出现在表达式中的逗号运算符在语义上表示多个表达式操作的连续执行，类似于分隔多语句的分号。比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt;(&lt;strong&gt;int&lt;/strong&gt;i=0,j=9;i&amp;lt;10;++i&lt;strong&gt;,&lt;/strong&gt;--j)std::cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;”+”&amp;lt;&amp;lt;j&amp;lt;&amp;lt;”=9\n”;&lt;/p&gt;
&lt;p&gt; 在这句语句中，出现了两个逗号，其中前者是语法上用来分隔声明的变量的，并非逗号运算符，而后者则是一个逗号运算符。根据 C++ 标准，逗号运算符的执行顺序为从左到右依次执行，返回最后一个子表达式的结果。由于只有最后一个表达式返回结果，所以对于一个语义正常的逗号表达式而言，前几个子表达式必须具有副作用。同时，从语言的定义中也可以看出，逗号表达式对求值的顺序有严格要求。 &lt;/p&gt;
&lt;p&gt; 对求值顺序有要求的，除了逗号表达式和条件表达式 ( 参见 1.1) ，在 C++ 中还有逻辑运算符 (&amp;amp;&amp;amp; 和 ||) 。逻辑运算相较于数学运算和位运算而言，有个显著的不同点：逻辑运算在计算到一半时，就有可能已经得到结果，这样继续运算另一半就不是必需的。对于 A&amp;amp;&amp;amp;B ，如果 A=false ，那么无论 B 为何值，整个的结果都是 false ；同样的 A||B ，如果 A=true ，那么不考虑 B ，结果一定是 true 。 &lt;/p&gt;
&lt;p&gt;C++ 标准规定，如果逻辑运算到一半 ( 算出 A) 时，就已经可以确定运算的结果，那么就不运算剩下的另一半 (B) 。这种执行语义被称作 “ 短路 ” 。在其它一些编程语言中，短路语义是可以选择的：在 Ada 里非短路的逻辑运算符为 and 和 or ，短路的逻辑运算符为 and_then 和 or_else 。但是在 C++ 中，逻辑运算符的短路语义是语法上强制的，我们没有非短路版本的运算符。如果确实需要非短路语义，我们总是可以通过增加一个 bool 中间变量加以解决。有时，短路对于保证正确执行是必须的，比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char&lt;/strong&gt;*p=getString();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(p&lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;*p)std::cout&amp;lt;&amp;lt;p;&lt;/p&gt;
&lt;p&gt; 这段代码在得到了一个字符串后，在字符串不为空时输出它。在 C++ 中判断一个字符串不为空需要两个步骤：判断指针是否为 0 ，以及指针不为 0 时判断指针指向的内容是否为 ’’ 。就像条件表达式中讨论到的 ( 参见 1.1) ，在 p 为空时提领 p 是个极其危险的操作。逻辑运算符的短路语义则避免了这种危险。 &lt;/p&gt;
&lt;p&gt; 以上对逗号运算符与逻辑运算符的讨论，仅限于 C++ 标准所定义的运算符语义。为什么这样说呢？这是因为在 C++ 中，运算符的语义是可以由程序员自行定义的，这种机制叫做运算符重载 (operator
overload) 。运算符重载可以将人们熟悉的运算符表达式转换成函数调用，使编程灵活而直观，是个方便的语言特性。不过有时运算符重载也会使人困扰，那就是当运算符重载遇到求值顺序问题时。 &lt;/p&gt;
&lt;p&gt;C++ 中，并不是所有合法运算符都可以被合法地重载。条件运算符虽然对求值顺序有要求，但它并不在可重载运算符之列，所以运算符重载机制对它没有影响。问题在于，逗号运算符和逻辑运算符都可以被合法地重载： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class&lt;/strong&gt; BadThing{/* Some Bad and Stupid Thing*/};&lt;/p&gt;
&lt;p&gt;BadThing&amp;amp; &lt;strong&gt;operator&lt;/strong&gt;,(BadThing&amp;amp;, BadThing&amp;amp;);// 重载了逗号运算符 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bool&lt;/strong&gt; &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(BadThing&amp;amp;, BadThing&amp;amp;);// 重载了 &amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;BadThing b1,b2;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(b1&amp;amp;&amp;amp;b2)b1,b2;// 被替换成如下形式： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(b1,b2))&lt;strong&gt;operator&lt;/strong&gt;,(b1,b2);&lt;/p&gt;
&lt;p&gt; 可以看到，重载了运算符之后，对运算符的使用被替换为相应的函数调用形式。因此，旧有的运算符的执行顺序不再适用，取而代之的是函数参数的压栈顺序。 &lt;/p&gt;
&lt;p&gt; 根据 C++ 标准规定，任何参数必须在进入函数之前压栈，所以在进入 &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp; 之前， b1 、 b2 就会被求值，这里不再有短路规则，任何依赖于短路语义的不知不觉间操作 BadThing 的代码 ( 可能通过模板 ) 都会混乱。 &lt;/p&gt;
&lt;p&gt; 短路语义只是一个方面，更重要的在于压栈顺序。鉴于执行效率和旧代码兼容性等细节问题， C++ 标准在压栈顺序上给编译器的开发者留有很大自主性。标准的说辞是，编译器可能以任何它觉得方便的顺序将参数压栈，从左到右，从右到左，甚至从中间到两边，在这一点上我们不能安全地做任何假设。在上面的例子中，编译器生成的代码可能先计算 b1 再计算 b2 ，也可能是相反的顺序。再看看编译器的实际情况，在我试过的所有基于 X86 体系结构的编译器中，参数都是以逆向压栈，即从右到左，有悖于大多数人的阅读习惯和直觉 ( 别说你是来自伊斯兰的 ……) 。 &lt;/p&gt;
&lt;p&gt; 在 C 时代使用函数调用时，压栈顺序并不是什么大问题，毕竟大多数人会在函数调用的边界稍稍小心一些。但是到了 C++ 中，事情变得有些复杂，因为简单如 a+b 的使用，就有可能被运算符重载机制替换为函数调用。更何况有模板参与之后，我们写代码时不能确定对象的真实类型，也就无法预知一个运算符是否真的被重载过，唯一稳妥的方法是，假定任何有可能被重载的运算符的使用都是函数调用。 &lt;/p&gt;
&lt;blockquote&gt;
&amp;lt;p style="margin:0;"&amp;gt;&lt;/blockquote&gt;
&lt;p&gt; 回到上文的示例中，由于 , 和 &amp;amp;&amp;amp; 都被替换为函数调用，程序的执行顺序将成为压栈顺序，在 X86 上很有可能是从右到左，与标准定义的运算符的顺序正好相反。逗号运算符原本就含有 “ 先 … 后 …” 的语义，这种颠倒的执行顺序势必造成程序和程序员的混乱。以我的经验而言，含有 &lt;strong&gt;operator&lt;/strong&gt;, 的类，完全没有办法和 STL 或者 iostream 相互协作，反而会导致巨量的错误报告 ( 什么叫巨量的错误报告有概念么？如果没有，那说明你还没玩过范式编程 (GP,
Generic
Programming) 。去玩玩 GP 吧，看看你的编译器对巨量的定义。在我手头，针对 3.5KB 的代码文件倾泻出 3.8&lt;strong&gt;MB&lt;/strong&gt; 的错误信息的编译器不在少数 ……) 。有鉴于此，我的结论是，除非你有充足的依据支持你这么做 ( 比如你的粗暴上司的键盘上只剩下逗号能用 ) ，并且你清楚的了解这么做的后果的严重性 ( 比如至少要看过此文 ) ，否则我奉劝你，永远不要碰 &lt;strong&gt;operator&lt;/strong&gt;, 、 &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp; 以及 &lt;strong&gt;operator&lt;/strong&gt;|| ！ &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 1.1 条件运算符(?:)</title><link href="//farseerfc.github.io/zhs/c-tricks-1-1-conditional-operator.html" rel="alternate"></link><updated>2007-08-22T18:05:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-22:zhs/c-tricks-1-1-conditional-operator.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.1    条件运算符 (?:)&lt;/h2&gt;
&lt;p&gt; 条件运算符 (?:) 是 C++ 中唯一的三目运算符 (trinary
operator) ，用于在表达式中作条件判断，通常可以替换 if 语句，与 Visual
Basic 中的 iif 函数、 Excel 中的 if 函数有同样的作用。语法形式如下： &lt;/p&gt;
&lt;p&gt;&lt;em&gt;condition&lt;/em&gt; ? &lt;em&gt;true_value&lt;/em&gt; : &lt;em&gt;false_value&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 其中 &lt;em&gt;condition
* 条件是任何可以转换为 bool 类型的表达式，包括但不仅限于 **bool*&lt;/em&gt; 、 &lt;strong&gt;int&lt;/strong&gt; 、指针。与 &lt;strong&gt;if&lt;/strong&gt; 和 &lt;strong&gt;while&lt;/strong&gt; 的条件部分稍显不同的是，这里不能定义变量，否则会导致语法错误。 &lt;/p&gt;
&lt;p&gt; 另外，条件语句会切实地控制执行流程，而不仅仅是控制返回值。也就是说，两个返回值表达式中永远只有一个会被求值，在表达式的执行顺序很重要时，这点尤为值得注意。比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=pi&lt;strong&gt;?&lt;/strong&gt;*pi&lt;strong&gt;:&lt;/strong&gt;0;&lt;/p&gt;
&lt;p&gt; 这里，只有当 pi 的值不为 0 时，它才会被提领 (dereference) 。这种语义保证了程序的正确性，因为提领一个空指针将导致致命的运行期错误 ( 通常是非法操作的警告 ) 。同时，正因为条件运算符控制运算流程的特点，使得它不能用类似 iif 的普通函数来模拟： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; iif(&lt;strong&gt;int&lt;/strong&gt; con,&lt;strong&gt;int&lt;/strong&gt; t,&lt;strong&gt;int&lt;/strong&gt;f){&lt;strong&gt;if&lt;/strong&gt;(c)&lt;strong&gt;return&lt;/strong&gt; t;&lt;strong&gt;return&lt;/strong&gt; f;}// 试图模拟 ?:&lt;/p&gt;
&lt;p&gt;…//in some function&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=iif(pi,*pi,0);//Error!&lt;/p&gt;
&lt;p&gt; 这段代码会导致上文提到的致命运行期错误。 C/C++ 标准规定，参数在被传递给函数之前求值，因此无论 pi 为何值，都会被提领。又因为函数传回一个空指针的情况比较少见，所以这样的错误在调试时很难被发现，一旦发生又势必造成重大灾难。这样的代码在实践中应尽量避免。 &lt;/p&gt;
&lt;p&gt; 有时，条件运算符控制流程的特点会不知不觉影响我们的代码。在 C 时代，最大值 MAX 通常用宏实现： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#define&lt;/strong&gt;MAX(a,b) ((a)&amp;gt;(b)&lt;strong&gt;?&lt;/strong&gt;(a)&lt;strong&gt;:&lt;/strong&gt;(b))&lt;/p&gt;
&lt;p&gt; 需要用额外的括号将宏参数和宏本体保护起来，以免运算符优先级扰乱逻辑，这是宏丑陋的特点之一，这里暂且不提。矛盾在于，用具有副作用的表达式调用宏时，会出现问题： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=5,j=6;//…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=MAX(++i,++j);&lt;/p&gt;
&lt;p&gt; 代码的作者原意显然是想先将 i,j 分别递增，再将其中较大的一个赋给 a 。执行这段代码，当 i=5,j=6 时， a=8 ，知道为什么吗？通过宏展开，赋值语句成这样： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=(++i)&amp;gt;(++j)&lt;strong&gt;?&lt;/strong&gt;(++i)&lt;strong&gt;:&lt;/strong&gt;(++j);// 删除了多余括号 &lt;/p&gt;
&lt;p&gt; 在判断之前， i 、 j 被分别自增一次，然后舍弃 : 之前的部分， j 又被自增一次。执行之后， i=6,j=8 。 &lt;/p&gt;
&lt;p&gt;MAX 的更正确更安全的实现，是利用模板将类型参数化。 STL 标准算法中就有一个这样的工具级模版函数 std::max 。 &lt;/p&gt;
&lt;p&gt; 条件运算符是表达式而不是语句，这使得它可以出现在任何需要表达式的地方，这扩大了它的适用范围。在那些语法上只能出现表达式而不能出现语句的地方（比如变量初始化），条件运算符有着不可替代的作用。 &lt;/p&gt;
&lt;p&gt; 条件运算符优于 &lt;strong&gt;if&lt;/strong&gt; 语句的另一个场合是 “ 模板元编程 ”(TMP, Template
MetaProgramming) 。在 TMP 这个古怪奇异的编译期运算编程技术中，一切旧有的技术和法则被全线击破，我们所能仰仗的工具，只有模板特化 (Specialization) 、 &lt;strong&gt;typedef&lt;/strong&gt;s 、函数声明 ( 无法调用它们 ) 、以及编译期常量运算。已经有人很深入地论证过，仅有以上这些，就已经形成了一个 “ 图灵完善 ” 的计算机语言。我们可以用模板特化技术，来模拟条件分支，循环迭代等一系列复杂的语言结构。由于可以参与编译期常量运算，条件运算符在 TMP 世界中很自然地扮演起重要角色。 &lt;/p&gt;
&lt;p&gt; 比如，给与类型 T 的一个变量 t ，我们想声明一个缓冲区存放 t 和一个 int ，缓冲区的大小不小于 sizeof(T) 也不小于 sizeif(int) ，我们可以这样写： &lt;/p&gt;
&lt;p&gt;char buffer[sizeof(T)&amp;gt;sizeof(int)? sizeof(T): sizeof(int)];&lt;/p&gt;
&lt;p&gt; 我们不能用一个 if 语句替换这个运算： &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;if(sizeof(T)&amp;gt;sizeof(int))i=sizeof(T);&lt;/p&gt;
&lt;p&gt;else i=sizeof(int);&lt;/p&gt;
&lt;p&gt;char buffer[i];// 语法错误 !&lt;/p&gt;
&lt;p&gt; 原因在于数组声明中的下标必须是一个编译期常量，而不是一个运行期的值，条件表达式的运算可以在编译期进行， if 语句就只能在执行期执行。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>填补信仰、唤醒良知</title><link href="//farseerfc.github.io/zhs/filling-believings-calling-conscience.html" rel="alternate"></link><updated>2006-08-07T21:36:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2006-08-07:zhs/filling-believings-calling-conscience.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 从 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  导入 &lt;/p&gt;
&lt;p&gt; 填补信仰、唤醒良知 &lt;/p&gt;
&lt;p&gt; 我们听尽了呼吁与号召，对于良知，我不必谴责丧失它的国人，不必盛赞良知的美好。我只想讨论，丧失了良知的原因 —— 空缺的信仰。 &lt;/p&gt;
&lt;p&gt; 一、空缺信仰丧失良知 &lt;/p&gt;
&lt;p&gt; 现代的国人缺少信仰，以至于丧失良知。曾几何时，中华民族由良好的信仰凝聚而成。三皇五帝时，族民们以炎黄为信仰；春秋战国时，士大夫之族以周制礼乐为信仰；汉代以后，百姓延习孔孟之说、老聃之道，以儒家学说为信仰；自大唐起，以佛教为首的现代宗教纷纷传入中原，人民开始以它们作为信仰。 &lt;/p&gt;
&lt;p&gt; 直至鸦片战争、五四运动，西方文化入侵中华，国人开始抛弃国学，转而去研究科学；文化大革命，十年文化浩劫，人们批判旧的信仰，却没有合适的新的信仰前来填补。从此，国人的信仰出现空缺，国人的良知也被一块块蚕食殆尽。 &lt;/p&gt;
&lt;p&gt; 二、信仰、科学、迷信 &lt;/p&gt;
&lt;p&gt; 在许多国人的心目中，信仰就等于迷信。从小到大的教育告诉我们，信奉宗教是愚昧而又无知的表现，科学与信仰是矛盾的。是么？ &lt;/p&gt;
&lt;p&gt; 我们无法保证社会上的每一个人都接受过良好的教育，我们无法确信最前沿的科学素养能在民众中普及。在科普与教育力不从心的社会死角，在科学技术尚不能及的文化盲区，我们依旧需要信仰的规范与限制，我们的良知需要信仰！ &lt;/p&gt;
&lt;p&gt; 信仰不等于迷信。信仰本身无所谓谜与不迷，迷信是持有信仰的人误解了信仰，盲目遵从的结果。以为烧过香就可以免遭祸患，以为捐了钱就可以升入天堂，以为引火自焚就可以功德圆满，这便是迷信了。希特勒曾经的人类完善计划，依照遗传学的原理，将科学家与运动员强行结为夫妇孕育生命，希望得到最优秀的人类种族，这便是对科学这种信仰的迷信！ &lt;/p&gt;
&lt;p&gt; 由此可见，科学与信仰并不是矛盾的硬币的两面，从某种意义而言科学本身也是信仰的一种。虽然历史上宗教往往作为科学发展的阻碍，可信奉真理的信念一直是推动科学发展的动力。牛顿就曾说过，对自然规律的探询是为了更接近上帝。由此可见，信仰与真理，与良知毫无矛盾。 &lt;/p&gt;
&lt;p&gt; 三、信仰唤醒良知 &lt;/p&gt;
&lt;p&gt; 很少有人仔细思考过，良知的缺失是由信仰的缺失造成的。信仰是人思想的寄托与依靠，是人行动处世的准则。没有了信仰的人，思想行为就缺少了约束的标准，人就更容易因为一时不成熟的冲动，背叛良知、铸成错误。 &lt;/p&gt;
&lt;p&gt; 泰国人以佛教为信仰，泰国的寺庙每天都会有成千上万人顶礼膜拜。寺庙有一个人尽皆知的不成文规定：不得穿鞋进入。于是在寺庙之外，游客们可以看到千百双各式的鞋子有序的摆放在门口。国人每每看到此景，总会诧异地问：没有人会偷鞋么？得到的答案极为简单：庙前偷鞋会遭报应。由于拥有信仰，泰国人作了坏事会受到良知的谴责，泰国商人售出假货会彻夜难眠。二战期间，无数犹太难民被天主教会收留藏匿从而侥幸逃生，这同样是出于，天主教徒们被自己信奉的教义 “ 众生生来平等 ” ，所唤醒的良知。 &lt;/p&gt;
&lt;p&gt; 天下无贼的世界，不能仅靠科普说教来营造。如果脱离了信仰，纵使是教育也无法培养良知。我问过许多修化学的同学，学习化学的意义，结论竟是为了考试。如果没有对科学的信仰，我们可以牢记公式定理，却质疑它们是真理；如果没有对社会公德的信仰，我们可以熟背交通规则，却正大光明地闯红灯；如果没有对医疗道德的信仰，医生可以放任伤口发炎，从而留住病人继续治疗 ……&lt;/p&gt;
&lt;p&gt; 国人需要信仰的约束，需要填补信仰的空白，从而唤醒那深埋于每个国人内心深处的良知！ &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</summary></entry></feed>