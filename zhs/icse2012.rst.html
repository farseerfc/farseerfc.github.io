<div class="highlight"><pre><span></span><span class="gh">ICSE 2012</span>
<span class="gh">=======================================================================</span>

<span class="nc">:slug:</span> icse2012
<span class="nc">:translation_id:</span> icse2012
<span class="nc">:lang:</span> zhs
<span class="nc">:date:</span> 2012-06-06 10:42
<span class="nc">:tags:</span> icse, software
<span class="nc">:issueid:</span> 6

<span class="p">..</span> <span class="ow">contents</span><span class="p">::</span>

<span class="gh">June 6</span>
<span class="gh">-----------------------------------------------------------------------</span>


<span class="cp">.. PELICAN_BEGIN_SUMMARY</span>

<span class="gh">Keynote 1</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
没怎么听懂，只记得讲到了finance is not money但是没听懂这个和软件有什么关系。


<span class="gh">Cost Estimation for Distributed Software Project</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
讲到他们试图改善现有的模型去更精确地评估软件开发的开销。

他们会给PM建议之前的项目的历史数据，然后对于新项目，他们建议历史上已有
的项目的数据，从而帮助PM得到更精确的评估。他们试图尽量减少项目评估对PM
的经验的需求，从而帮助即使经验很少的PM也能准确评估项目的开销。


<span class="cp">.. PELICAN_END_SUMMARY</span>

他们的观点：

        Context-specfic solutions needed!

        我们需要更上下文相关的解决方案！

        Early user paticipation is key!

        早期用户的参与是关键


<span class="gh">Characterizing Logging Practices in Open-Source Software</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
Common mistakes in logging messages

在日志记录中容易犯的错误

他们学习了历史上的log记录，然后试图找到重复修改的输出log的语句，确定log
中存在的问题。他们首先确定修改是事后修改。

通常的修改的比例（9027个修改）

=== ============================
45% 静态文本
27% 打印出的变量
26% 调试等级verbosity
2%  日志输出的位置
=== ============================

他们发现有调试等级的变化，是因为安全漏洞之类的原因，或者在开销和数据
之间的权衡。

大多数对log的变量的修改都是为了增加一个参数。他们之前的LogEnhancer是为了
解决这个问题而提出的，通过静态检查，提醒程序员是否忘记了某个参数

对text的修改是因为要改掉过时的代码信息，避免误导用户。

他们的实验是采用了基于code clone 的技术，找到所有log语句，然后找不一致
的clone，然后自动提出建议。

<span class="gh">Combine Functional and Imperative Pgrm for Multicore Sw: Scala &amp; Java</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>

趋势：到处都是多核，但是并发程序呢？

他们研究的对象是Scala和Java，因为可以编译后确认JVM字节码的语义。

<span class="m">-</span> Java:
      <span class="m">-</span>  共享内存
      <span class="m">-</span>  显示创建的线程
      <span class="m">-</span>  手动同步
      <span class="m">-</span>  Wait/Notify机制

<span class="m">-</span> Scala:
      <span class="m">-</span>  高阶函数
      <span class="m">-</span>  Actors, 消息传递
      <span class="m">-</span>  lists, filters, iterators
      <span class="m">-</span>  while
      <span class="m">-</span>  共享状态, OO
      <span class="m">-</span>  import java.* 能从java导入任何库
      <span class="m">-</span>  auto type inferance 自动类型推导

实验的参与者都经过4周的训练，实验项目是工业等级的开发项目 

结果：

scala 的项目平均比java多花38%的时间，主要都是花在Test和debug上的时间。

程序员的经验和总体时间相关，但是对test和debug没有显著影响。

scala的为了让编程更有效率的设计，导致debug更困难。比如类型推导，debug
的时候需要手动推导，来理解正在发生什么。

scala的程序比java小，中位数2.6%，平均15.2%

<span class="m">-</span> 性能比较： 
        <span class="m">-</span> 单核：scala的线性程序的性能比java好
        <span class="m">-</span> 4核： 
                <span class="m">-</span> scala 7s @ 4 threads 
                <span class="m">-</span> java 4si @ 8 threads 
                <span class="m">-</span> median 
                        <span class="m">-</span> 83s scala 
                        <span class="m">-</span> 98s java
        <span class="m">-</span> 32core: best scala 34s @ 64 threads 

<span class="m">-</span> 结论
        <span class="m">-</span> java有更好的scalability

<span class="m">-</span> scala类型推导
        <span class="m">-</span> 45%说对携带码有帮助
        <span class="m">-</span> 85%说导致程序错误

<span class="m">-</span> 调试
        <span class="m">-</span> 23%认为scala简单
        <span class="m">-</span> 77%认为java简单

multi-paradigram are better

<span class="gh">Sound Empirical Evidence in Software Testing</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
Test data generation 测试数据自动生成

Large Empirical Studies - not always possible

For open source software - big enough

<span class="gh">Identifing Linux Bug Fixing Patch</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>

<span class="m">-</span> current practice:
        <span class="m">-</span> manual
<span class="m">-</span> Current research:
        <span class="m">-</span> keywords in commits
        <span class="m">-</span> link bug reports in bugzilla

Try to solve classification problem

<span class="m">-</span> issue 
        <span class="m">-</span> pre-identified 
        <span class="m">-</span> post-identified

<span class="m">-</span> data
        <span class="m">-</span> from commit log
<span class="m">-</span> feature extraction
        <span class="m">-</span> text pre-process stemmed non-stop words
<span class="m">-</span> model learning

research questions


<span class="gh">Active Refinement of Clone Anomaly Reports</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
motivating

<span class="m">-</span> code clones, clone groups
<span class="m">-</span> clone used to detect bugs
<span class="m">-</span> anomaly : inconsistent clone group
  many anomaly clone are note bug, high false positive

approach
  - reorder by sorted bug reports  

-----------------------------------------------------------------------

<span class="gh">June7</span>
<span class="gh">-----------------------------------------------------------------------</span>

<span class="gh">Keynotes 2: Sustainability with Software - An Industrial Perspective</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
Sustainability

<span class="m">-</span> Classic View: Idenpendent view with overlap
        <span class="m">-</span> Social
        <span class="m">-</span> Environment
        <span class="m">-</span> Economic
<span class="m">-</span> Nested viw
        <span class="m">-</span> Environment
                <span class="m">-</span> Social
                        <span class="m">-</span> Economic

Triple bottom line
  - economic
        -global business, networks , global econ
  <span class="m">-</span> env
        <span class="m">-</span> natural res, climate change, population grow
  <span class="m">-</span> social
        <span class="m">-</span> awareness, connectivity, accountability

<span class="gh">Green IT</span>
<span class="gh">~~~~~~~~</span>
<span class="m">-</span> reduce IT energy
        <span class="m">-</span> more than 50% cooling - doing nothing
<span class="m">-</span> mini e-waste: not properly recycled
        <span class="m">-</span> 80% in EU
        <span class="m">-</span> 75% in US
<span class="m">-</span> foster dematerialization


In-Memory Technology: Expected Sustainable Benefits

<span class="gh">What can we do?</span>
<span class="gh">~~~~~~~~~~~~~~~</span>
      <span class="m">-</span>  consider all software lifecycle phases in your design
      <span class="m">-</span>  avoid energy expensive behavior in your codes
      <span class="m">-</span>  design lean architectures

<span class="gh">Green by IT</span>
<span class="gh">~~~~~~~~~~~</span>
        <span class="m">-</span> 2% green IT
        <span class="m">-</span> 98% green IT

<span class="gh">On How Often code is cloned across repositories</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>

Line based hashing code clone detection

never do anything harder than sorting

hashing a window of 5 lines of normalized (tokenized) code, dropping
3/4 of the hashing

把ccfinder一个月的工作缩短到了3, 4天。没有比较presion和recall。

=== =========================
14% type1
16% type2
17% type3 (not really type2)
=== =========================

<span class="gh">Graph-based analysis and prediction for sw evolution</span>
<span class="gh">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
<span class="gh">graph are everywhere</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="m">-</span> internet topology
<span class="m">-</span> social net
<span class="m">-</span> chemistry
<span class="m">-</span> biology

in sw
<span class="m">-</span> func call graph
<span class="m">-</span> module dependency graph

developer interaction graph
<span class="m">-</span> commit logs
<span class="m">-</span> bug reports

experiment 11 oss, 27~171 release, &gt; 9 years

<span class="gh">predictors</span>
<span class="gh">~~~~~~~~~~~</span>

<span class="m">-</span> NodeRank
        <span class="m">-</span> similar to pagerank of google
        <span class="m">-</span> measure relative importance of each node
        <span class="m">-</span> func call graph with noderank
                <span class="m">-</span> compare rank with severity scale on bugzilla
        <span class="m">-</span> correlation between noderank and BugSeverity
                <span class="m">-</span> func level 0.48 ~ 0.86 varies among projects. 
                <span class="m">-</span> model level &gt; func level
<span class="m">-</span> ModularityRatio
        <span class="m">-</span> cohesion/coupling ratio:  IntraDep(M)/InterDep(M)
        <span class="m">-</span> forecast mantencance effort
        <span class="m">-</span> use for
                <span class="m">-</span> identify modules that need redesign or refactoring
<span class="m">-</span> EditDistance
        <span class="m">-</span> bug-based developer collaboration graphs
        <span class="m">-</span> ED(G1,G2)=|V1|+|V2|-2|V1交V2|+|E1|+|E2|-2|E1交E2|
        <span class="m">-</span> use for
                <span class="m">-</span> release planning
                <span class="m">-</span> resource allocation

graph metrics

<span class="m">-</span> graph diameter
        <span class="m">-</span> average node degree indicates reuse
<span class="m">-</span> clustering coefficient
<span class="m">-</span> assortativity
<span class="m">-</span> num of cycles

<span class="gh">Conclusion</span>
<span class="gh">~~~~~~~~~~</span>

&quot;Actionable intelligence&quot; from graph evolution

<span class="m">-</span> studie 11 large long-live projs
<span class="m">-</span> predictors 
<span class="m">-</span> identify pivotal moments in evolution

<span class="gh">What make long term contributors: willingness and opportunity in OSS</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>

OSS don&#39;t work without contributors form community

mozilla (2000-2008)

10^2.2 LTC &lt;- 2 order -&gt; 10^4.2 new contributors &lt;- 3.5 order -&gt; 10^7.7 users 

gnome (1999-2007)

10^2.5 LTC &lt;- 1.5 order -&gt; 10^4.0 new contributors &lt;- 3.5 order -&gt; 10^6.5 users 

<span class="gh">approach</span>
<span class="gh">~~~~~~~~~</span>
<span class="m">-</span> read issues of 20 LTC and 20 non-LTC
<span class="m">-</span> suvery 56 (36 non-LTC and 20 LTC)
<span class="m">-</span> extract practices published on project web sites

<span class="gh">summeray</span>
<span class="gh">~~~~~~~~~</span>

<span class="m">-</span> Ability/Willingness distinguishes LTCs
<span class="m">-</span> Environment 
        <span class="m">-</span> macro-climate
                <span class="m">-</span> popularity
        <span class="m">-</span> micro-climate
                <span class="m">-</span> attention
                <span class="m">-</span> bumber of peers
                <span class="m">-</span> performance of peers

regression model

newcomers to LTC conversion drops

actions in first month predicts LTCs
        - 24% recall 
        <span class="m">-</span> 37% precision

<span class="gh">develop of auxiliary functions: should you be agile?</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>

a empirial assessment of pair programming and test-first programming

can agile help auxiliary functions?

<span class="gh">experiment</span>
<span class="gh">~~~~~~~~~~~</span>

<span class="m">-</span> pair vs solo 
<span class="m">-</span> test-first vs test-last
<span class="m">-</span> students vs professors

<span class="gh">research questions</span>
<span class="gh">~~~~~~~~~~~~~~~~~~~~~</span>

<span class="m">-</span> r1: can pair help obtain more correct impl
<span class="m">-</span> r2: can test-first 
<span class="m">-</span> r3: dst test1 encourage the impl or more test cases?
<span class="m">-</span> r4: does test1 course more coverage

<span class="gh">result</span>
<span class="gh">~~~~~~~~</span>
<span class="m">-</span> test-first
        <span class="m">-</span> higher coverage
        <span class="m">-</span>  non change with correctness
<span class="m">-</span> pair
        <span class="m">-</span> improve on correctness
        <span class="m">-</span> longer total programming time 

<span class="gh">Static Detection of Resource Contention Problems in Server-side script</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
Addressed the race condition of accessing database or filesystem of PHP

<span class="gh">Amplifying Tests to Validate Exception Handling Code</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
异常处理的代码不但难写，而且难以验证。各种组合情况难以估计，尤其是手机
系统上。

<span class="gh">A tactic-centric approach automating traceability of quality concerns</span>
<span class="gh">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
tactic traceability information models
</pre></div>
