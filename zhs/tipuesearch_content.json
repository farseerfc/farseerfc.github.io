{"pages":[{"loc":"//farseerfc.github.io/zhs/pages/about.html","title":"About","text":"关于这个 Blog 我会尽量用中文 (Chinese, zh) ，日语 (Japanese, jp) ，英语 (English, en) 这三门语言同时写这个 blog ，在有意义的情况下。中文有繁体 (zh) 与简体 (zhs) 之分，我以繁体撰写，再以 OpenCC 将繁体转化为对应的简体。 近况 我叫 杨嘉晨 1989 年 6 月生 目前就读于 大阪大学大学院情报科学研究科 计算机科学专攻 博士 2 年级 ( http://sdl.ist.osaka-u.ac.jp/ ) 本科毕业于 上海交通大学软件学院 软件工程专业 F0703701 班 ( http://se.sjtu.edu.cn/ ) 联系方式 生活中你可以通过这些方式找到我： 手机（ softbank ） : 080-3853-2770 手机邮箱 : jc-yang@softbank.ne.jp 网络上你可以通过这些方式找到我： Skype: farseerfc GTalk: farseerfc@gmail.com MSN : firechildren@hotmail.com Tencent QQ : 76635424 ( farseerfc@qq.com ) twitter: http://twitter.com/farseerfc Github: https://github.com/farseerfc weibo( 微博 ): http://weibo.com/farseerfc facebook: http://www.facebook.com/farseerfc renren （人人） : http://renren.com/farseer","tags":"pages"},{"loc":"//farseerfc.github.io/zhs/from-unbuffered-stdin-to-history-of-linux-tty.html","title":"从非缓冲输入流到 Linux 控制台的历史","text":"这篇也是源自于水源 C 板上板友的一个问题，涉及 Linux 上的控制台的实现方式和历史原因。因为内容比较长，所以在这里再排版一下发出来。 原帖在这里 。 可以设置不带缓冲的标准输入流吗？ WaterElement(UnChanged) 于 2014 年 12 月 09 日 23:29:51 星期二 问到： 请问对于标准输入流可以设置不带缓冲吗？比如以下程序 #include <stdio.h> #include <unistd.h> int main ( int argc , char * argv []) { FILE * fp = fdopen ( STDIN_FILENO , \"r\" ); setvbuf ( fp , NULL , _IONBF , 0 ); char buffer [ 20 ]; buffer [ 0 ] = 0 ; fgets ( buffer , 20 , fp ); printf ( \"buffer is:%s\" , buffer ); return 0 ; } 似乎还是需要在命令行输入后按回车才会让 fgets 返回，不带缓冲究竟体现在哪里？ 这和缓存无关，是控制台的实现方式的问题。 再讲细节一点，这里有很多个程序和设备。以下按 linux 的情况讲： 终端模拟器窗口（比如 xterm ）收到键盘事件 终端模拟器 (xterm) 把键盘事件发给虚拟终端 pty1 pty1 检查目前的输入状态，把键盘事件转换成 stdin 的输入，发给你的程序 你的程序的 c 库从 stdin 读入一个输入，处理 标准库说的输入缓存是在 4 的这一步进行的。而行输入是在 3 的这一步被缓存起来的。 终端 pty 有多种状态，一般控制台程序所在的状态叫「回显行缓存」状态，这个状态的意思是 : 所有普通字符的按键，会回显到屏幕上，同时记录在行缓存区里。 处理退格 ( BackSpace ) ，删除 ( Delete ) 按键为删掉字符，左右按键移动光标。 收到回车的时候把整个一行的内容发给 stdin 。 参考： http://en.wikipedia.org/wiki/Cooked_mode 同时在 Linux/Unix 下可以发特殊控制符号给 pty 让它进入「 raw 」状态，这种状态下按键不会被回显，显示什么内容都靠你程序自己控制。如果你想得到每一个按键事件需要用 raw 状态，这需要自己控制回显自己处理缓冲，简单点的方法是用 readline 这样的库（基本就是「回显行缓存」的高级扩展，支持了 Home/End ，支持历史）或者 ncurses 这样的库（在 raw 状态下实现了一个简单的窗口 / 事件处理框架）。 参考： http://en.wikipedia.org/wiki/POSIX_terminal_interface#History 除此之外， Ctrl-C 转换到 SIGINT ， Ctrl-D 转换到 EOF 这种也是在 3 这一步做的。 以及，有些终端模拟器提供的 Ctrl-Shift-C 表示复制这种是在 2 这一步做的。 以上是 Linux/unix 的方式。 Windows 的情况大体类似，只是细节上有很多地方不一样： 窗口事件的接收者是创建 cmd 窗口的 Win32 子系统。 Win32 子系统接收到事件之后，传递给位于命令行子系统的 cmd 程序 cmd 程序再传递给你的程序。 Windows 上同样有类似行缓存模式和 raw 模式的区别，只不过实现细节不太一样。 strace 查看了下 WaterElement(UnChanged) 于 2014 年 12 月 10 日 21:53:54 星期三 回复： 感谢 FC 的详尽解答。 用 strace 查看了下，设置标准输入没有缓存的话读每个字符都会调用一次 read 系统调用， 比如输入 abc ： read(0, abc \"a\", 1) = 1 read(0, \"b\", 1) = 1 read(0, \"c\", 1) = 1 read(0, \"\\n\", 1) = 1 如果有缓存的话就只调用一次了 read 系统调用了： read(0, abc \"abc\\n\", 1024) = 4 如果想感受一下 raw mode 没错，这个是你的进程内 C 库做的缓存， tty 属于字符设备所以是一个一个字符塞给你的 程序的。 如果想感受一下 raw mode 可以试试下面这段程序（没有检测错误返回值） #include <stdio.h> #include <unistd.h> #include <termios.h> static int ttyfd = STDIN_FILENO ; static struct termios orig_termios ; /* reset tty - useful also for restoring the terminal when this process wishes to temporarily relinquish the tty */ int tty_reset ( void ){ /* flush and reset */ if ( tcsetattr ( ttyfd , TCSAFLUSH , & orig_termios ) < 0 ) return - 1 ; return 0 ; } /* put terminal in raw mode - see termio(7I) for modes */ void tty_raw ( void ) { struct termios raw ; raw = orig_termios ; /* copy original and then modify below */ /* input modes - clear indicated ones giving: no break, no CR to NL, no parity check, no strip char, no start/stop output (sic) control */ raw . c_iflag &= ~ ( BRKINT | ICRNL | INPCK | ISTRIP | IXON ); /* output modes - clear giving: no post processing such as NL to CR+NL */ raw . c_oflag &= ~ ( OPOST ); /* control modes - set 8 bit chars */ raw . c_cflag |= ( CS8 ); /* local modes - clear giving: echoing off, canonical off (no erase with backspace, &#94;U,...), no extended functions, no signal chars (&#94;Z,&#94;C) */ raw . c_lflag &= ~ ( ECHO | ICANON | IEXTEN | ISIG ); /* control chars - set return condition: min number of bytes and timer */ raw . c_cc [ VMIN ] = 5 ; raw . c_cc [ VTIME ] = 8 ; /* after 5 bytes or .8 seconds after first byte seen */ raw . c_cc [ VMIN ] = 0 ; raw . c_cc [ VTIME ] = 0 ; /* immediate - anything */ raw . c_cc [ VMIN ] = 2 ; raw . c_cc [ VTIME ] = 0 ; /* after two bytes, no timer */ raw . c_cc [ VMIN ] = 0 ; raw . c_cc [ VTIME ] = 8 ; /* after a byte or .8 seconds */ /* put terminal in raw mode after flushing */ tcsetattr ( ttyfd , TCSAFLUSH , & raw ); } int main ( int argc , char * argv []) { atexit ( tty_reset ); tty_raw (); FILE * fp = fdopen ( ttyfd , \"r\" ); setvbuf ( fp , NULL , _IONBF , 0 ); char buffer [ 20 ]; buffer [ 0 ] = 0 ; fgets ( buffer , 20 , fp ); printf ( \"buffer is:%s\" , buffer ); return 0 ; } 终端上的字符编程 vander( 大青蛙 ) 于 2014 年 12 月 12 日 08:52:20 星期五 问到： 学习了！ 进一步想请教一下 fc 大神。如果我在 Linux 上做终端上的字符编程，是否除了用 ncurses 库之外，也可以不用该库而直接与终端打交道，就是你所说的直接在 raw 模式？另外，终端类型 vt100 和 linux 的差别在哪里？为什么 Kevin Boone 的 KBox 配置手册里面说必须把终端类型设成 linux ，而且要加上 terminfo 文件，才能让终端上的 vim 正常工作？ term info 文件又是干什么的？ Linux 控制台的历史 嗯理论上可以不用 ncurses 库直接在 raw 模式操纵终端。 这里稍微聊一下 terminfo/termcap 的历史，详细的历史和吐槽参考 Unix hater's Handbook 第 6 章 Terminal Insanity 。 首先一个真正意义上的终端就是一个输入设备（通常是键盘）加上一个输出设备（打印机或者显示器）。很显然不同的终端的能力不同，比如如果输出设备是打印机的话，显示出来的字符就不能删掉了（但是能覆盖），而且输出了一行之后就不能回到那一行了。再比如显示器终端有的支持粗体和下划线，有的支持颜色，而有的什么都不支持。早期 Unix 工作在电传打字机（ TeleTYpe ）终端上，后来 Unix 被 port 到越来越多的机器上，然后越来越多类型的终端会被连到 Unix 上，很可能同一台 Unix 主机连了多个不同类型的终端。由于是不同厂商提供的不同的终端，能力各有不同，自然控制他们工作的方式也是不一样的。所有终端都支持回显行编辑模式，所以一般的面向行的程序还比较好写，但是那时候要撰写支持所有终端的「全屏」程序就非常痛苦，这种情况就像现在浏览器没有统一标准下写 HTML 要测试各种浏览器兼容性一样。 通常的做法是 使用最小功能子集 假设终端是某个特殊设备，不管别的设备。 水源的代码源头 Firebird2000 就是那样的一个程序，只支持固定大小的 vt102 终端。 这时有一个划时代意义的程序出现了，就是 vi ，试图要做到「全屏可视化编辑」。这在现在看起来很简单，但是在当时基本是天方夜谭。 vi 的做法是提出一层抽象，记录它所需要的所有终端操作，然后有一个终端类型数据库，把那些操作映射到终端类型的具体指令上。当然并不是所有操作在所有终端类型上都支持，所以会有一堆 fallback ，比如要「强调」某段文字，在彩色终端上可能 fallback 到红色，在黑白终端上可能 fallback 到粗体。 vi 一出现大家都觉得好顶赞，然后想要写更多类似 vi 这样的全屏程序。然后 vi 的作者就把终端抽象的这部分数据库放出来形成一个单独的项目，叫 termcap （ Terminal Capibility ），对应的描述终端的数据库就是 termcap 格式。然后 termcap 只是一个数据库（所以无状态）还不够方便易用，所以后来又有人用 termcap 实现了 curses 。 再后来大家用 curses/termcap 的时候渐渐发现这个数据库有一点不足：它是为 vi 设计的，所以只实现了 vi 需要的那部分终端能力。然后对它改进的努力就形成了新的 terminfo 数据库和 pcurses 和后来的 ncurses 。然后 VIM 出现了自然也用 terminfo 实现这部分终端操作。 然后么就是 X 出现了， xterm 出现了，大家都用显示器了，然后 xterm 为了兼容各种老程序加入了各种老终端的模拟模式。不过因为最普及的终端是 vt100 所以 xterm 默认是工作在兼容 vt100 的模式下。然后接下来各种新程序（偷懒不用 *curses 的那些）都以 xterm/vt100 的方式写。 嗯到此为止是 Unix 世界的黑历史。 知道这段历史的话就可以明白为什么需要 TERM 变量配合 terminfo 数据库才能用一些 Unix 下的全屏程序了。类比一下的话这就是现代浏览器的 user-agent 。 然后话题回到 Linux 。大家知道 Linux 早期代码不是一个 OS ，而是 Linus 大神想在他的崭新蹭亮的 386- PC 上远程登录他学校的 Unix 主机，接收邮件和逛水源（咳咳）。于是 Linux 最早的那部分代码并不是一个通用 OS 而只是一个 bootloader 加一个终端模拟器。所以现在 Linux 内核里还留有他当年实现的终端模拟器的部分代码，而这个终端模拟器的终端类型就是 linux 啦。然后他当时是为了逛水源嘛所以 linux 终端基本上是 vt102 的一个接近完整子集。 说到这里脉络大概应该清晰了， xterm 终端类型基本模拟 vt100 ， linux 终端类型基本模拟 vt102 。这两个的区别其实很细微，都是同一个厂商的两代产品嘛。有差别的地方差不多就是 Home / End / PageUp / PageDown / Delete 这些不在 ASCII 控制字符表里的按键的映射关系不同。 嗯这也就解释了为什么在 linux 环境的图形界面的终端里 telnet 上水源的话，上面这些按键会错乱 …… 如果设置终端类型是 linux/vt102 的话就不会乱了。在 linux 的 TTY 里 telnet 也不会乱的样子。 写到这里才发现貌似有点长 …… 总之可以参考 Unix hater's Handbook 里的相关历史评论和吐槽，那一段非常有意思。","tags":"linux"},{"loc":"//farseerfc.github.io/zhs/jumping-kde5-plasma-activities-button.html","title":"KDE5 Plasma 之跳动卖萌的活动按钮","text":"今天尝试 KDE5 Plasma 的活动的时候无意间发现这个现象。只要把活动按钮拖出桌面，它就会在桌面边缘来回跳动。 视频如下： 当然你可以把它再拖回来，所以这个问题还无伤大雅，只是卖萌。 比比之前 Gnome3 那个跳动的界面真是好太多了： 顺便，今天还看到一个卖萌的 KDE5 Plasma 静音图标的翻译： KDE5 のミュート画面の中国语翻訳、「静音」のはずだが「镜音」になっている。 Vocaloid ファンのネタだか、単なる入力ミスだか分からない。 pic.twitter.com/ipyHjXMscR — Jiachen YANG (@farseerfc) 2014 12 月 8 日","tags":"linux"},{"loc":"//farseerfc.github.io/zhs/marry-me.html","title":"嫁给我好么","text":"上面那个是装饰 …… 可以玩的是下面这个： * 用 WASD ←→ 移动，需要 WebGL 支持","tags":"life"},{"loc":"//farseerfc.github.io/zhs/icse2012.html","title":"ICSE 2012","text":"June 6 Keynote 1 没怎么听懂，只记得讲到了 finance is not money 但是没听懂这个和软件有什么关系。 Cost Estimation for Distributed Software Project 讲到他们试图改善现有的模型去更精确地评估软件开发的开销。 他们会给 PM 建议之前的项目的历史数据，然后对于新项目，他们建议历史上已有的项目的数据，从而帮助 PM 得到更精确的评估。他们试图尽量减少项目评估对 PM 的经验的需求，从而帮助即使经验很少的 PM 也能准确评估项目的开销。 他们的观点： Context-specfic solutions needed! 我们需要更上下文相关的解决方案！ Early user paticipation is key! 早期用户的参与是关键 Characterizing Logging Practices in Open-Source Software Common mistakes in logging messages 在日志记录中容易犯的错误 他们学习了历史上的 log 记录，然后试图找到重复修改的输出 log 的语句，确定 log 中存在的问题。他们首先确定修改是事后修改。 通常的修改的比例（ 9027 个修改） 45% 静态文本 27% 打印出的变量 26% 调试等级 verbosity 2% 日志输出的位置 他们发现有调试等级的变化，是因为安全漏洞之类的原因，或者在开销和数据 之间的权衡。 大多数对 log 的变量的修改都是为了增加一个参数。他们之前的 LogEnhancer 是为了 解决这个问题而提出的，通过静态检查，提醒程序员是否忘记了某个参数 对 text 的修改是因为要改掉过时的代码信息，避免误导用户。 他们的实验是采用了基于 code clone 的技术，找到所有 log 语句，然后找不一致 的 clone ，然后自动提出建议。 Combine Functional and Imperative Pgrm for Multicore Sw: Scala & Java 趋势：到处都是多核，但是并发程序呢？ 他们研究的对象是 Scala 和 Java ，因为可以编译后确认 JVM 字节码的语义。 Java: 共享内存 显示创建的线程 手动同步 Wait/Notify 机制 Scala: 高阶函数 Actors, 消息传递 lists, filters, iterators while 共享状态 , OO import java.* 能从 java 导入任何库 auto type inferance 自动类型推导 实验的参与者都经过 4 周的训练，实验项目是工业等级的开发项目 结果： scala 的项目平均比 java 多花 38% 的时间，主要都是花在 Test 和 debug 上的时间。 程序员的经验和总体时间相关，但是对 test 和 debug 没有显著影响。 scala 的为了让编程更有效率的设计，导致 debug 更困难。比如类型推导， debug 的时候需要手动推导，来理解正在发生什么。 scala 的程序比 java 小，中位数 2.6% ，平均 15.2% 性能比较： 单核： scala 的线性程序的性能比 java 好 4 核： scala 7s @ 4 threads java 4si @ 8 threads median 83s scala 98s java 32core: best scala 34s @ 64 threads 结论 java 有更好的 scalability scala 类型推导 45% 说对携带码有帮助 85% 说导致程序错误 调试 23% 认为 scala 简单 77% 认为 java 简单 multi-paradigram are better Sound Empirical Evidence in Software Testing Test data generation 测试数据自动生成 Large Empirical Studies - not always possible For open source software - big enough Identifing Linux Bug Fixing Patch current practice: manual Current research: keywords in commits link bug reports in bugzilla Try to solve classification problem issue pre-identified post-identified data from commit log feature extraction text pre-process stemmed non-stop words model learning research questions Active Refinement of Clone Anomaly Reports motivating code clones, clone groups clone used to detect bugs anomaly : inconsistent clone group many anomaly clone are note bug, high false positive approach reorder by sorted bug reports June7 Keynotes 2: Sustainability with Software - An Industrial Perspective Sustainability Classic View: Idenpendent view with overlap Social Environment Economic Nested viw Environment Social Economic Triple bottom line economic -global business, networks , global econ env natural res, climate change, population grow social awareness, connectivity, accountability Green IT reduce IT energy more than 50% cooling - doing nothing mini e-waste: not properly recycled 80% in EU 75% in US foster dematerialization In-Memory Technology: Expected Sustainable Benefits What can we do? consider all software lifecycle phases in your design avoid energy expensive behavior in your codes design lean architectures Green by IT 2% green IT 98% green IT On How Often code is cloned across repositories Line based hashing code clone detection never do anything harder than sorting hashing a window of 5 lines of normalized (tokenized) code, dropping 3/4 of the hashing 把 ccfinder 一个月的工作缩短到了 3, 4 天。没有比较 presion 和 recall 。 14% type1 16% type2 17% type3 (not really type2) Graph-based analysis and prediction for sw evolution graph are everywhere internet topology social net chemistry biology in sw - func call graph - module dependency graph developer interaction graph - commit logs - bug reports experiment 11 oss, 27~171 release, > 9 years predictors NodeRank similar to pagerank of google measure relative importance of each node func call graph with noderank compare rank with severity scale on bugzilla correlation between noderank and BugSeverity func level 0.48 ~ 0.86 varies among projects. model level > func level ModularityRatio cohesion/coupling ratio: IntraDep(M)/InterDep(M) forecast mantencance effort use for identify modules that need redesign or refactoring EditDistance bug-based developer collaboration graphs ED (G1,G2)=|V1|+|V2|-2|V1 交 V2|+|E1|+|E2|-2|E1 交 E2| use for release planning resource allocation graph metrics graph diameter average node degree indicates reuse clustering coefficient assortativity num of cycles Conclusion \"Actionable intelligence\" from graph evolution studie 11 large long-live projs predictors identify pivotal moments in evolution What make long term contributors: willingness and opportunity in OSS OSS don't work without contributors form community mozilla (2000-2008) 10&#94;2.2 LTC <- 2 order -> 10&#94;4.2 new contributors <- 3.5 order -> 10&#94;7.7 users gnome (1999-2007) 10&#94;2.5 LTC <- 1.5 order -> 10&#94;4.0 new contributors <- 3.5 order -> 10&#94;6.5 users approach read issues of 20 LTC and 20 non- LTC suvery 56 (36 non- LTC and 20 LTC ) extract practices published on project web sites summeray Ability/Willingness distinguishes LTCs Environment macro-climate popularity micro-climate attention bumber of peers performance of peers regression model newcomers to LTC conversion drops actions in first month predicts LTCs 24% recall 37% precision develop of auxiliary functions: should you be agile? a empirial assessment of pair programming and test-first programming can agile help auxiliary functions? experiment pair vs solo test-first vs test-last students vs professors research questions r1: can pair help obtain more correct impl r2: can test-first r3: dst test1 encourage the impl or more test cases? r4: does test1 course more coverage result test-first higher coverage non change with correctness pair improve on correctness longer total programming time Static Detection of Resource Contention Problems in Server-side script Addressed the race condition of accessing database or filesystem of PHP Amplifying Tests to Validate Exception Handling Code 异常处理的代码不但难写，而且难以验证。各种组合情况难以估计，尤其是手机 系统上。 A tactic-centric approach automating traceability of quality concerns tactic traceability information models","tags":"life"},{"loc":"//farseerfc.github.io/zhs/msr2012.html","title":"MSR 2012 @ ICSE","text":"Mining Software Repository 2012 @ ICSE 参加了今年的 MSR ，会场在 University of Zurich 。一大早来到大学，注册有点小插曲，显然瑞士人搞不清楚中国人的名字， 3 个杨（ Yang ）姓的中国人的名牌被搞错了。然后堀田学长的所属被写作了 \"Japan, Japan\" ，成为了全日本的代表。 MSR (MicroSoft Research) talk @ MSR (Mining Software Repositories) 首先是来自微软亚洲研究院（ MicroSoft Research @ Asia, MSR Asia ）的 Keynots ，于是就变成了 MSR 在 MSR 的演讲。 MSR 的张冬梅（ Dongmei Zhang ）女士的演讲分为关于 Software Analysis 和 XIAO 的两部分。 XIAO 是 MSRA 开发的 Code Clone Detector ，似乎我要给井上研做的就是这个。想更多了解 Xiao 的细节，不过张女士 演讲结束的时候的鼓掌导致了话筒的小故障。 Towards Improving BTS with Game Mechanisms 感觉这篇的内容基本上就是关于 http://www.joelonsoftware.com/items/2008/09/15.html 这里写到的东西，然后说同样的理论是否可以用于 Issue Tracking 之类的事情上。个人感觉这个意义不大， stackoverflow 之所以成功是因为它把开源社区本身就具有的名誉体系具现化了，本着大家都喜欢被别人奉为大牛的心态，就如同 wikipedia 一样。同样的理论如果用于公司内部的 Issue Tracking 系统上，会得到完全不同的东西吧。就像 MSDN 的组织方式虽然和 wikipedia 是一样的，但是在 MSDN 里找信息的感觉和在 wikipedia 完全不一样。个人不太看好这个方向。 GHTorrent 这篇的 slide 在这里可以看到： http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524 Data exporter for github. Github 的主要数据，代码，已经可以通过 git 接口获得了， wiki 是 git 的形式保存的。所以这个项目的目的就是暴露别的数据，主要是 issue tracking ， code comments ，这种。代码访问 github api ，然后用分布式实现以克服 api 的限制，然后提供 torrents 形式的 history 下载。 github api 获得的 json 数据以 bson 的形式保存在 MongoDB 里，解析过的有了 Schema 之后的数据保存 在 MySQL 里并可以导出 SQL 。 个人的想法，觉得数据如果能够更统一，全部存在 Git 里或许更好，像 Wiki 一样。同样是要暴露全部历史记录的目的，用 Torrent 自己实现的历史远不如用 Git 的接口实现的历史记录方便吧， git blame 之类的也更方便追踪 code comment 之类的作者信息。当然对 git 的 raw date 直接读写，需要对 git 的内部原理有足够的理解， 或许只有 github 的人有这种能力了。 Topic Mining 用得两个参数， DE 和 AIC ，完全不能理解，过后研究。实验针对了 Firefox, Mylyn, Eclipse 三个软件。试图从 Repo 中分析源代码的 identifier 和 comments ，找到 topic 和 bug 之间的关系，比如怎样的 topic 更容易导致 bug 。得出的结论似乎也很暧昧，只是说核心功能被报告的 bug 更多，但是不知道原因。这只能表示核心 功能受到更多关注和更多测试吧，并不能说明核心功能就容易产生 bug 。 不过这个的 Slide 做得很漂亮，很容易理解。 SeCold A linked data platform for mining software repositories 没听懂这个项目的目的。 The evolution of software 第二天的 Keynotes ，关于将 Social Media 和 Software Development 相结合的想法。或许就是 Github 赖以成功的基础。讲到代码中的 comment, Tags, uBlog, blog 之类 的 social 的特性和 IDE 的融合的趋势。 Do Faster Releases Imporve Software Quality? 使用 Firefox 作为例子。 结论是快速发布导致 bug 更多，更容易 crash ，但是 bug 更快得到修复，并且用户 更快转向新的发布。 Security vs Performance Bugs in Firefox Performance bugs are regression, blocks release. 一些感想 基于自然语义分析的 commit 分割 经常工具（比如 git ）的使用者并没有按照工具设计者的意图使用工具，这给 MSR 带来很多困难。举个例子， git 有非常完美的 branch 系统，通常期望 git 的使用者能够在一次 commit 里 commit 一个功能，比如一个 bug 的修复，或者一个 feature 的 添加，但是事实上经常有很多逻辑上的 commit 被合并在一个里面了。 或许这不是使用者的错，而是工具仍然不够人性的表现。或许我们可以自动把 一次的 commit 按照语义分割成多个。 分割之后，可以更容易地把 issue 和 commit 关联，也更容易组织更多的研究。 关于这次发表中大家用的 slides 系统 题目为 \"Incorporating Version Histories in Information Retrieval Based Bug Localization\" 的人用的 slide 是 beamer 的。公式很多， overlay 很多，列表很多，图片很少，典型的 beamer 做出的 slide 。思维导图用得很不错。今天一天 有至少 3 个 slide 是用 beamer 做的。 题目为 \"Towards Improving Bug Tracking Systems with Game Mechanisms\" 的人用了 prezi ，图片很多，过度很多。但是比如没有页号没有页眉页脚，正式 会议的场合不太方便。 至少有六个以上用了 Apple Keynotes ， Keynotes 做出来的东西真的和 Powerpoint 做出来的很难区别，其中两个人用了初始的主题所以才看出来。 剩下的自然是 PPT 。 MSRA 的张女士做的虽然是 PPT ，倒是有很多 beamer 的感觉，比如页眉页脚和 overlay 的用法。这些如果都是 PPT 做出来的，会多很多额外的 人力吧。 值得一提的是有一个题目为 \"Green Mining: A Methodology of Relating Software Change to Power Consumption\" 的人的 slide 全是 \" 劣质 \" 的手绘漫画，效果意外地好，很低碳很环保很绿色很可爱。具体效果可以参考下面的动画，虽然 现场看到的不是一个版本： http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv 微软是个腹黑娘！ 嘛虽然这也不是什么新闻了。 MSR2012 的 Mining Challenge 的赞助商是微软，管理 组织者来自微软研究院，奖品是 Xbox 和 Kinect 。然后今年的题目是： Mining Android Bug 我看到了微软满满的怨气 ……","tags":"life"},{"loc":"//farseerfc.github.io/zhs/pyssy.html","title":"Pyssy 项目","text":"简介 Pyssy 是用于 上海交通大学饮水思源站 的一系列 Python 脚本和工具。 Pyssy 被有意设计为既可以托管寄宿在 SAE [1] 上，也可以在单机上独立使用。 项目地址： http://pyssy.sinaapp.com/ Github 上的源代码地址： https://github.com/yssy-d3/pyssy [1] Sina App Engine ，新浪云平台，类似 Google App Engine 的东西。 依赖关系 Pyssy 使用 Flask 作为网页服务器，并且使用 Memcached 或者 Redis 作为抓取 水源 Web 的缓存。 SAE Python 环境下请开启 Memcached 支持。 本地环境下请安装 Redis-py 并运行 redis-server 服务器程序。","tags":"python"},{"loc":"//farseerfc.github.io/zhs/mix-ruby.html","title":"PyRuby","text":"今天在 GitHub 上闲逛的时候看到一个叫做 PyRuby 的项目。项目的 Readme 说得很好： PyRuby - Some Ruby for your Python! PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful. Usage All you have to do is import the ruby module: import ruby From now on you should be able to write Ruby code within a regular Python module. An example: 1.upto(10) { |n| puts n } 甚至 PyPI 上还有这个项目的包。 一开始我还以为这又是一个野心勃勃的基于 PyPy 的 Ruby 实现，或者某种 trick 在 Python 里面直接调用 Ruby 解释器。 然后我想看看这个的源代码 只有一个 ruby.py 文件，内容是： # -*- coding: utf-8 -*- print ( \"\"\" `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:` .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms. `:ohmdys+//::/::--::::////:-.```......`````.://:-` `/dNs. .+hNds:`-:-:///::------::///++///:--....--::///::-`.///. `oMm/ /hNmo.` `` `....``````````` ...------:::-:/+/-.:/:` /NMs oMd/` `::::--.---://+` //` `````-:::::+/-`::.` :NM+ yN` -+.` `/` o. ``::.-:. `` :NN: :Nm - ./ : `.-://///:-. `-` `` :NN- /NM/ .-:::-.` `/ `:sdmdhyMMMMMMNNmy/` :mNo` :hMd: /dmddddNNmdy+-. `smmy/-```hMMMMMMMhydm/ `-.`` `...:mMm+. -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+- dMN-`-+hmmmmdhhhhdddmMN-`-/o: .-::::/oydms- oNMo:+/::. ``...--:/+ohNMNhs- :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms. .MMo:/`o:.:+sso+:-` sM+ ./-` /mNh+-....-/ymNNdo::--/shd+` -`:mm: /MM-o ./ ohhsooohNmy::sh. `yM/ `:oyyyyyyhys+:.` hy `/Nh` : -NN. -MM// -: `` y: odddhh+ -omNh- `--.` `` ```` .:ohMMs. +Ms / yMo hMoo .+. :Mh ```` `/hNd/.` ohdddy::...`..` `-/sdmdyo+NMNh+- :Mh / sMs .mmh:..:. :NMm `-/dMNM+ ./+++/:`.hM:`.````.` `-/shmNmh+-` /Mmooso.hM/ .: `mM/ .mNs://: .NMNMs- -:-.`/+-sms. ` `shyyyhy`sNd` `.:+sdmmmdMM-. .oNM+ :m/ `s``yMh -mMo . sMNdMNNh+-. .ydyoyy` ``+o::+shdddhs+:-.:MM.`.-+hNMMh- `.`-/::dNs` -NM- mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.` `/mMMdmmddNMm+` ..-/hNh- sMy NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs `..:+ymMMMMd+--yNh. `+hNh: -Mm NMMM/yMh -NM-`..--:NMo:--.`+My :MNoydmNMMNmhdMh` -dNs` `yMd: `MN mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/ yMy` MN yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-. `yMMNs. /My `MN :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM- ./hNNy- /Nd` -Mh dMydMmsNMNdNNMMmmmNMMMdddhys+yMo`` /Nm: `:yNNdo. .sNd. +Ms .mMsMN::NN:.:MN: `.+NM. +Mo +Mm+ymNdo- .omm+` yM: .hNMd+:sMN. oMm. oMo +Mh ```.:+shMNmy+-``.-:-..-//-`:yNmo` mM. :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/` .Mm `` .-:/+osyyhhddddddddddhhyysoo+/:-. `./+//--+oo/--+ymmy/. :Mh .: `+:` `.------------` ```-////:/++/:../ydNdo:` +Ms `/` :+o+:-``` ``..-::///++///:-.`-+ydNdo:` oMs :/:.`` `..---.``` ````````..-:/:::---.` `-ohmmh+:` /Mh .://///:::-----.-----.......` `-+hmmy+- sMy` ``````-+ydmy+- /mNs-` `./ohmNMNNNmy+- /yNmho/:.``````````.-:/+syhdNmdyso+/-.` `:+ydmNMNNNNNNNNNmdhys+/:.` ``.....` LOL U MAD? \"\"\" ) import sys sys . exit ( 1 ) 是的 …… 的确 …… 这种尝试把 Python 和 Ruby 放在一起的想法绝对是疯了 ……","tags":"python"},{"loc":"//farseerfc.github.io/zhs/discuss-cpp-template-downcast.html","title":"关于C++模板的类型转换的讨论","text":"这两天在饮水思源的 C 板，关于 C++ 模板的类型转换的一个讨论，后面是我的解答。 讨论地址 http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html 原问题 今天在书上看到模板演绎的时候可以允许 cast-down ，于是我写了个东西： template < bool _Test , class _Type = void > struct enable_if { }; template < class _Type > struct enable_if < true , _Type > { typedef _Type type ; }; class A { }; class B : A { }; template < typename T > struct traits { static int const value = false ; }; template <> struct traits < A > { static int const value = true ; }; template < typename T > void f ( T , typename enable_if < traits < T >:: value >:: type * = 0 ) { } template <> void f < A > ( A , enable_if < traits < A >:: value >:: type * ) { } template < typename T > class BB {}; template < typename T > class DD : public BB < T > {}; template < typename T > void ff ( BB < T > ) {}; int main ( int argc , char * argv []) { A a ; B b ; DD < long > dd ; //f(b); ff ( dd ); } 奇怪的是重载决议的时候， f 的情况下它就不让我特化的 f<A> 进来。 但是在 ff 的情况下， ff<BB<long>> 却进来了。 在 VC10 和 GCC3.4 下测试 我的解答 我们来设身处地地作为编译器，看一遍到底发生了什么。 约定符号 # : A#B 是把 B 带入 A<T> 的参数 T 之后实例化得到的结果。 首先看 ff 的情况。 DD < long > dd ; 处理到这句的时候，编译器看到了 DD<long> 的实例化，于是去实例化 DD#long ，继而实例化了 BB#long 。 ff ( dd ); 这句，首先计算重载函数集合。 第一步，需要从参数 DD#long -> BB<T> 推断 ff<T> 的 T 。根据函数模板参数推断规则： :code:`class_template_name<T>` 类型的参数，可以用于推断 :code:`T` 。 于是编译器推断 T 为 long 。这里就算不是 BB 而是完全无关的 CC 都可以推断成功，只要 CC 也是一个 CC<T> 形式的模板。 第二步，模板特化匹配。因为只有一个模板，所以匹配了最泛化的 ff<T> 。 第三步，模板实例化。 推断了 long -> T 之后，编译器实例化 ff#long 。 重载函数集合： {ff#long} 然后重载抉择找到唯一的可匹配的实例 ff#long ，检查实际参数 DD#long 可以隐式转换到形式参数 BB#long ，从而生成了这次函数调用。 再来看 f 的情况。 f ( b ); 计算候选重载函数集合。 第一步，对所有 f 模板推断实参。根据函数模板参数推断规则： 带有 :code:`T` 类型的参数，可以用于推断 :code:`T` 。 于是 B -> T 被推断出来了。 第二步，模板特化匹配。 这里 B 不是 A ，所以不能用 f<A> 特化，只能用 f<T> 模板。 第三步，模板实例化。 B 带入 f<T> 实例化成 f#B 的过程中，实例化 traits#B 。 由于没有针对 B 的特化，所以用 traits<T> 模板， traits#B::value=false ，进而 enable_if#false 没有 type ，出错。 唯一的模板匹配出错，重载函数集合为空， SFINAE 原则不能找到合适的匹配，于是报错。","tags":"c"},{"loc":"//farseerfc.github.io/zhs/try-pelican.html","title":"尝试一下 Pelican","text":"似乎一夜之间所有的 极客们 都 有了 自己 的 Github 主页 和 Octopress 博客。就像所有人在他们的博客中指出的，静态博客的确比传统的 WordPress 方式具有更多优势。自从看到这些我就一直在想着自己搭一个 Octopress 。 但是似乎 Octopress 不适合我 一上手就被 Octopress 的搭建步骤 烦到了。 RVM 是什么？ rbenv 又是什么？看来 Ruby 社区的快节奏发展已经超过了我的想象，他们似乎需要一套发行版管理器来调和不同版本之间的 Ruby 的兼容性问题。虽然同样的兼容性问题在 Python 社区也有 [1] ，不过总觉得 Python 至少还没到需要一个发行版管理器的程度 [2] 。 真正的问题是我手上还没有一个可以让我随便玩的 Linux 环境（真的想要 …… ）。而无论是 RVM 还是 rbenv 似乎都只支持 Unix/Linux/MacOSX 。身为极客就注定不能用 Windows 么？（或许是的 …… ）。 剩下的问题就是 Ruby 和 Python 两大阵营的对立问题了。我不熟悉 Markdown ，相对来说比较喜欢 ReST 。似乎无论哪边都要依赖 Pygments 作为代码着色器，那么其实 Rubyist 也至少需要安装 Python 。我倾向于不依赖任何 Ruby 组件，最好没有 C 扩展的纯 Python 实现。 于是我开始在 Github 上找 Python 的静态博客引擎。 Flask 的作者 mitsuhiko 写的 rstblog 看起来不错，不过似乎没有多少人在用。 Hyde 似乎很完善，不过默认的标记语言是 MarkDown ，又依赖于几个 Ruby 组建，而且官方网站的设计实在太前卫。最终我看到了 Pelican 。 [1] 比如 Python 2.x 与 3.x 之间看似难以跨越的鸿沟，以及 PyPy 、 CPython 、 Stackless 、 Cython 等各个实现之间的微妙差别。 [2] 是的，我们有 easy_install ，我们有 pip ，不过这些都是包管理器，都是装好特定的 Python 实现之后的事情。 Python 实现本身还不需要包管理器来管理。 Python 的版本问题基本上也只需要 2to3.py 和 3to2.py 这样的轻量级转换器就可以了，你不需要为了安装多个软件而在硬盘里留下多个不同版本的 Python 。如果为了引用的稳定性，你可以用 virtualenv ，不过这又是另一回事情了。 那么就 Pelican 吧 对我而言， Pelican 相比于 Octopress 有几个好处： 纯 Python 实现。这意味着我可以换用任何 Python 解释器而不必担心兼容性问题。比如我就换成了 PyPy 。 多语言支持。因为 Pelican 的作者似乎是个法国人。不过这个似乎大部分人不需要 …… 我是想尽量把一篇博客写成三种语言作为锻炼吧。 ReST 。这样我就可以用 Leo 的 @auto-rst 直接写 ReST 了。简单方便快捷有效。 不过似乎 Pelican 的关注度不如 Octopress 那么高，现在一些部分还有细微的问题： pelican-import 从 WordPress 导入的时候对中文、日文的支持似乎很成问题。 日期格式、时区、字符集、和多语言功能的结合度还不够。 我在尝试改善它。 模板还不够丰富。 插件也不够多 …… 希望这么优秀的工具能够受到更多关注，以上这些问题都是增加关注度之后很快就能解决的问题。 我的设置 settings.py 安装 Pelican 很容易，一句话就够了： $ pip install pelican 然后把文章写成 ReST 的格式，放在 `pages` 文件夹里面。 ( 重新 ) 生成只要： $ pelican -s settings.py 上传到 Github: $ git commit -am \"Commit message\" $ git push 就这么简单。附上我的配置文件： # -*- coding: utf-8 -*- TIMEZONE = 'Asia/Tokyo' DATE_FORMATS = { 'en' :( 'usa' , '%a, %d %b %Y' ), 'zh' :( 'chs' , '%Y-%m- %d , %a' ), 'jp' :( 'jpn' , '%Y/%m/ %d (%a)' ), } # windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx LOCALE = [ 'usa' , 'chs' , 'jpn' , # windows 'en_US' , 'zh_CN' , 'ja_JP' ] # Unix/Linux DEFAULT_LANG = 'zh' SITENAME = 'Farseerfc Blog' AUTHOR = 'Jiachen Yang' DISQUS_SITENAME = 'farseerfcgithub' GITHUB_URL = 'https://github.com/farseerfc' SITEURL = 'http://farseerfc.github.com' TAG_FEED = 'feeds/ %s .atom.xml' SOCIAL = (( 'twitter' , 'http://twitter.com/farseerfc' ), ( 'github' , 'https://github.com/farseerfc' ), ( 'facebook' , 'http://www.facebook.com/farseerfc' ), ( 'weibo' , 'http://weibo.com/farseerfc' ), ( 'renren' , 'http://www.renren.com/farseer' ), ) TWITTER_USERNAME = 'farseerfc' THEME = 'notmyidea' CSS_FILE = \"wide.css\" DEFAULT_CATEGORY = 'Others' OUTPUT_PATH = '.' PATH = 'posts'","tags":"python"},{"loc":"//farseerfc.github.io/zhs/about-my-blogs.html","title":"关于我的Blogs","text":"从 farseerfc.wordpress.com 导入 很久没有写过 blog 或者之类的东西了。这边一直荒废着。 由于国内被墙的原因，另一个 wordpress ： http://fchome.sinaapp.com/ 应该会同步更新这里的内容。 抽空写点什么吧。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/if-we-do-this-work.html","title":"\"…if we do this work … \" —Bill Gates","text":"导入自 renren From: Bill Gates '— Sent: Sunday, January 24, 1999 8:41 AM Jeff Westorinon; Ben Fathi ; TO : Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder Subject: ACPI extensions One thing I find myself wondering about is whether we shouldn't try and make the \" ACPI \" extensions somehow Windows specific. It seems unfortunate if we do this work and get our partners to do the work and the result is that Linux works great without having to do the work . Maybe there is no way to avoid this problem but it does bother me. Maybe we could define the APIs so that they work well with NT and not the others even if they are open. Or maybe we could patent something relaled to this. From: http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/ PX03020 .pdf 如果这就是我至今在 Xen4.0 上得不到 ACPI 3.0 的完善支持的原因，那么我诅咒 Bill Gates ！","tags":"import"},{"loc":"//farseerfc.github.io/zhs/zz-introducing-scholarzhang.html","title":"[zz]\"西厢计划\"原理小解","text":"从 farseerfc.wordpress.com 导入 好神奇的想法，先存着，以后慢慢研究 原文： http://blog.youxu.info/2010/03/14/west- chamber/ 待月西厢下，迎风户半开。隔墙花影动，疑是玉人来。 最近推上最流行的一个关键词是 \" 西厢计划 \", 这个计划名字取得很浪漫，客户端叫做张生，对，就是西厢记里面那个翻墙去见崔莺莺小姐的张生；显然，服务器端必然叫做崔莺莺。客户端的张生是最重要的部件，可以不依赖于服务端工作。因为西厢计划的作者只是简要的介绍了一下原理，其他报道又语焉不详，我当时就觉得很好奇，花了昨天一个晚上详细读了一下源代码，终于知道怎么回事了，觉得原理非常漂亮，所以写篇文章介绍总结一下。 先说大方向。大家都知道，连接被重置的本质，是因为收到了破坏连接的一个 TCP Reset 包。以前剑桥大学有人实验过，客户端和服务器都忽略 Reset, 则通信可以不受影响。但是这个方法其实只有理论价值，因为绝大多数服务器都不可能忽略 Reset 的 ( 比如 Linux, 需要 root 权限配置 iptables, 而且这本身也把正常的 Reset 给忽略了 ) 。只要服务器不忽略 Reset, 客户端再怎么弄都没用，因为服务器会停止发送数据， Reset 这条连接。所以，很多报道说西厢计划是忽略 Reset, 我从源代码来看应该不是这样。在我看来，西厢计划是利用了墙的一个可能的弱点 – 墙只在连接发起的时候把一个 TCP 连接加入监听序列，如果墙认为这个连接终止了，就会从监听序列中去掉这条记录，这样，这条连接上后续的包就不会被监听。西厢计划就是让墙 \" 认为 \" 这个连接终止的一个绝妙的方法。只要墙认为这个连接两端都是死老虎，墙就不会触发关键词检测，其后所有的数据，都不存在连接被重置的问题了。 如何让一个连接置之死地而后生，就是西厢计划那帮黑客神奇的地方了。这也不是一日之功。首先，这帮牛人发现，墙的是一个入侵检测系统，把含有关键字的包当成一种 \" 入侵 \" 来对待。采取这种设计有很多好处，但缺点是入侵检测系统可能具有的问题，墙都可能有。西厢计划主页上那篇著名的论文就是讲这些七七八八的漏洞的。可以说处理这些七七八八的漏洞是非常困难的，迫使墙的设计者 \" 拆东墙，补西墙 \" 。这样补来补去，外表看起来好像很牛逼的墙，其实有很多本质上无法简单修补的漏洞，其中有一个致命的，就是 TCP 连接状态的判定问题。出于入侵检测系统这种设计的局限，墙没有，也没办法准确判定一条 TCP 连接的状态，而只是根据两边收到的数据来 \" 推测 \" 连接的状态。而所有的关键词检测功能，都是基于 \" 连接还活着 \" 的这个推测的结果的。因为墙的规则是在连接发起的时候开始对这条连接的检测，在连接终止的时候停止对这条连接的检测，所以，一旦对连接的状态推测错误，把还活着的连接当成已经关闭的连接，墙就会放弃对这条连接上随后所有的包的检测，他们都会都透明的穿过墙的入侵检测。 上面只是想法，具体到 TCP 协议实现这一层，就要只迷惑墙，还不能触及我要通信的服务器。最理想的情况下，在任何有效通信之前，就能让墙出现错误判断，这些，就需要对 TCP 协议有深刻理解了。西厢计划的那帮黑客，居然真的去读 TCP 几百页的 RFC ，还居然就发现了方法（这里我假设读者都知道 TCP 的三次握手过程和序列号每次加一的规则）。我们都知道，三次握手的时候，在收到服务器的 SYN / ACK 的时候，客户端如果发送 ACK 并且序列号 +1 就算建立连接了，但是客户端如果发送一个序列号没 +1 的 FIN （表示连接终止，但是服务器知道，这时候连接还没建立呢， FIN 这个包状态是错的，加上序列号也是错的，服务器自己一判断，就知道这个包是坏包，按照标准协议，服务器随手丢弃了这个包） , 但这个包，过墙的时候，在墙看来，是表示连接终止的 ( 墙是 ma de in china, 是比较山寨的，不维护连接状态，并且，墙并没有记下刚才服务器出去的 SYN / ACK 的序列号，所以墙不知道序列号错了）。所以，墙很高兴的理解为连接终止，舒了一口气去重置其他连接了， 而这个连接，就成了僵尸，墙不管你客户端了，而这时候，好戏才刚刚开始。 事实上，墙是双向检测的（或者说对每个包都检测的），因此，对服务器和客户端实现相同的对待方法，所以，墙不管客户端还不行，假如服务端有关键词传给客户端，墙还是有可能要发飙的（这里说有可能，因为我也不知道）。所以，最好的办法就是，让服务端也给墙一个终止连接的标志就好了。可是这个说起来简单，做起来难，怎么能让不受自己控制的服务器发一个自己想要的包呢？西厢计划的那帮黑客，再次去读几百页的 RFC , 令人惊讶的发现，他们居然在 RFC 上发现了一个可以用的特性。我们上面说了，三次握手的时候，在收到 SYN / ACK 后，客户端要给服务器发送一个序列号 +1 的 ACK ，可是，假如我不 +1 呢，直接发 ACK 包给服务器。墙已经认为你客户端是死老虎了，不理你了，不知道你搞什么飞机，让这个 ACK 过了。可是服务器一看，不对啊，你给我的不是我期待的那个序列号， RFC 上说了， TCP 包如果序列号错了的话，就回复一个 Reset. 所以，服务器就回复了一个 Reset 。这个 Reset 过墙的时候，墙一看乐了，服务器也终止连接了，好吧，两边都是死老虎了，我就不监听这条连接了。而至于客户端，这个服务器过来的 Reset 非常好识别，忽略就是。随后，客户端开始正确的发送 ACK , 至此，三次握手成功，真正的好戏开始，而墙则认为客户端和服务器都是死老虎，直接放过。所以，张生就这样透明的过了墙。 至于过墙以后所有的事情，《西厢记》里面都有记载，各位读者自行买书学习。 现在的西厢计划客户端，即 \" 张生 \" 模块的防连接重置的原理就是这样，服务器端，即莺莺模块的实现也是类似的。防 DNS 那个，不懂 DNS 协议，所以看不懂。我猜想，因为开发人员都是黑客，所以自然喜欢用最经得起折腾和高度定制的 Linux 开发。现在看西厢计划的实现，因为依赖于 Linux 内核模块 netfilter, 在 Linux 上如鱼得水，但往其他平台的移植可能是个亟待解决的问题。我觉得，在其他平台上，可以通过 libpcap 和 libnet ，在用户态实现相同的功能，就是有点麻烦而已，有兴趣的懂网络的可以照西厢计划原理，在家自行做出此功能；当然，全中国人民都用 Linux 最好 :) PS 1: 据说是西厢计划一个作者画的原理图： http://img.ly/DIi PS 2: 我对 TCP 的理解仅限于课本，如果上面的对技术的理解有错，请大家指出。 PS 3: 有些漏洞，可能是设计上本质缺陷，不是那么容易修复的。 PS 4: 除了最后一个图，本文没有其他相关链接，如需相关资料，自行 Google 。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/sine-cpu.html","title":"写程序让CPU占用率保持正弦函数","text":"导入自 renren 据说是一道微软的面试题。如题，写程序，让 Windows 的任务管理器中的性能监视器呈现正弦曲线。 潜心钻研良久，得代码：（ java ） public class sincpu { private static final int cycle = 1024 , tick = 256 ; public static void main ( String [] args ) throws InterruptedException { for ( int i = 0 ;; i ++){ work ( calcNextSleep ( i % cycle )); sleep ( tick - calcNextSleep ( i % cycle )); } } private static long calcNextSleep ( long i ){ return ( int )( Math . sin (( double ) i * 2 * Math . PI / cycle ) * tick + tick ) / 2 ; } private static void sleep ( long sleepTime ) throws InterruptedException { if ( sleepTime < 2 ) Thread . yield (); else Thread . sleep ( sleepTime ); } private static void work ( long period ) { long start = System . currentTimeMillis (); for (;;){ Math . sin ( 1 ); if ( System . currentTimeMillis () - start >= period ) break ; } } } 多核 CPU 上测试时要注意关掉一个 CPU ：","tags":"import"},{"loc":"//farseerfc.github.io/zhs/some-thought-on-creationism.html","title":"关于神创论的一些见解","text":"导入自 renren 看到陈骉同学很有感想的一篇神创论与命运日志，觉得近日很久没有看到这样的评论了。想说几句自己的观点。 首先我认为，神创论与宿命论没有多少关联，甚至进化论者相较于神创论者更容易接受宿命论的观点。因为神创论主张意志的存在，人所具有的个体意志与神的意志，因此在神创论者的眼中事件的结果是可以通过意志来改变的，亦即如果我从物理楼 11 楼跳下，那么我就可以改变自己死亡时间的宿命。上帝的意志同样可以左右事件的结果，也就是所谓的宿命不复存在。而进化论者不承认意志独立于物质世界的存在，你我的思考、行为，都受到物理学法则诸如量子力学的约束，这就引出了北大物理系教授的那句 \" 宇宙中的一切都是可以计算的 \" ，亦即宿命论。如我我选择现在从物理楼上跳下，我这一行为并不是处于个人的独立意志，乃是想证明这一点，亦即我跳楼这一举动是有其背后的动机与原因的，就如同计算机的输入必然导致了输出，宿命的必然终结于此。 其次，关于事件的复杂度所导致的随机化，在大量混沌随机中也存在着如统计学和随机分形学这样的规律，并不是否认宿命的充分理由。 关于神创论的合理性问题。我认为是否相信神的存在只是一个 boolean 二值问题，它为 true 为 false 本身并不重要，重要的是确定它的取值之后得到的推论与结果。如果否认神的存在，如现代数学这样的完美又何以存在，进化论者的解释是事物最终会向着更好更高级的方向发展，产生现代数学乃至现代科学是发展的必然。而这种论调显然有悖于物理中以热力学第二定律为首的，预言事物会随时间推演愈发混乱的论断。更进一步，甚至整个人类、整个生物系统的存在都是有悖于热力学推论的现象，是某种理论只能以 \" 小概率事件 \" 解释的现象。 神创论的核心观点之一，是神的唯一存在性，按照邹恒明的比喻，这就如同数学中集合中元素的的唯一性一般至关重要。数学乃至近代科学的发展，其起源在于这种对神性的探求，而不仅仅是好奇心就可以解释的。反观东方文化中数学的发展，开始时领先于西方科学千余每年，但是始终作为一种 craft-oriented 的实用主义学科。可以说没有了神的唯一性支持，人们就不能确信自己能找到这样一种完美高效的学科，只能在实用的基础上发展其基础算数。可以想象，没有神的完美与唯一性，数学必将发展成现代化学或者微软软件这样，庞大而充满特例，到处都是修补与查表，怎么会像现在的完美、简洁与和谐。 神创论者并不是将难题推与 \" 神 \" 然后放任不管，他们相信神是最为理智的存在，创人时人同样得到了神的智慧和理智，也就是神可以用人的理智来理解。 引用牛顿《自然哲学的数学原理》中终章的话 \" 太阳、恒星、行星的这个极精致的结构不可能存在，除非通过一个有理智的和有权能的存在的设计和主宰 …… 他不是作为宇宙的灵魂，而是作为一切的主宰而统治所有 ……\" 以上 …… ( 发现最近的哲理思维果然慢了不少，写作思绪也一片混乱 &#94;_&#94;)","tags":"import"},{"loc":"//farseerfc.github.io/zhs/9-thoughts-about-oop-from-wrongly-insert-memory-stick.html","title":"由记忆棒误差故障引发的关于面向对象设计的九点思考","text":"从 farseerfc.wordpress.com 导入 故障描述 : MMC Memory Stick Duo 记忆棒未经 Adapter 适配器，直接插入 SD Reader ，致使 MMC 卡入 SD Reader 中。 栈展开：某日下午，无课。忙于数分作业，想查询用手机拍摄的板书照片。取出手机中的 MMC 。未经装配 Adapter ，直接插入 SD Reader 。 (A runtime exception was thrown.) 尝试翻转笔记本机身，倒出 MMC ，未果。 (rethrow) 尝试用手指甲取出，未果。 (rethrow) 考虑到有 \" 推入反弹 \" 机制，尝试将 MMC 推入更深，反弹机制由于类型不匹配而失效，未果。 (rethrow) (The exception spread across the border of the model.) 电脑维修技师接手 (catch) 技师未能发现问题所在，由我解说原委。 (Because the exception lose the information, RTTI was asked to recall the information) 技师发现问题，尝试用镊子镊出 MMC ，未果。技师开解机箱 (expose the data structure) 技师制作钩子，勾出 MMC(hooker link to the structure) 取出 MMC ，故障解除 故障总结 1. 接收到没有完全了解、或没有适当工具解决的 exception 时，不要尝试用不成熟的技术解决，应尽快寻求能解决它的代码。否则，被反复 rethrow 的 exception ，尤其是通过模块边界的 exception ，有可能由 subclass 退化为 superclass ，并因此而丧失一些信息。尽量不要让 exception 丢失信息，必要时，通过 RTTI 机制寻回信息。 2. 超负荷运转，多线程执行，这种种复杂性都有可能导致错误，应避免。无论你有多么信任你的代码或能力。 3. 在设计 class 的 interface 时，相匹配的 interface 应该满足 is-a 的关系。因此，任何能插入 SD Reader 的 object ，即任何实现了 SD interface 的 object ，都应该 is-a SD card 。这次故障中， interface 接受了 MMC ，但 MMC 不是 SD 。即使这种情况下 throw an exception ，都不能使事态缓和。能提供 compile-time error 时，尽量让错误以 compile-time error 的形式展现，并在事先解决。类型匹配问题是应该能在事先解决的问题。 4.Design patterns 中的 Adapter pattern 应该只是迫不得已情况之下的解决方案。只有当你无权改变现状时，才能使用 Adapter 。如果能改变现状，应该改变设计以符合 interface 。 5. 因为上条，所有相似功能的对象应具有相同的 interface ，不同的 interface 是本次故障的根源所在。 6. 特殊情况下，破坏封装机制并 expose the data structure 是必要的，应该有方法支持这种做法。 C 的指针和 C# 的 Reflection 技术都以不同的方式支持这种做法。其他的一些语言机制，比如 serializing( 序列化 ) 或 streaming( 流化 ) ，也可以以某种方式间接支持这一做法。当然，机制还应避免这种做法被滥用。 7. 相反功能具有相同操作的设计，容易造成使用的混乱，应适当避免。比如 SD Reader 的推入反弹设计，即插入和弹出使用同一个向里推的操作的设计。同样的设计还包括， C++ 中的 setNewHandle 使用同一个函数，同时设置和返回 handle 。以及有些书中提倡的，使用同名函数重载的方式，实现 setter/getter 的设计。 8. 特殊工具 (hooker) 对于解决特定问题，通常比手工解决有效。不要嫌麻烦而不愿意构造特殊工具。 9. 栈语义，即 FILO 顺序，总在不知不觉中影响我们。违反了 FILO 顺序的操作极易造成混乱。本故障发生时正确的处理顺序为：装配 Adapter 插入 SD Reader 读取数据 停用设备 拔出 SD Reader 拆解 Adapter 本次故障的原因就是违反了 FILO 顺序，违反了栈语义。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/program-development-in-java-preface.html","title":"Program Development in Java Preface","text":"从 farseerfc.wordpress.com 导入 程序开发原理 —— 抽象、规格与面向对象设计 Barbara Liskov 、 John Guttag 著 杨嘉晨等译 关于翻译风格： 多年来阅读计算机类的著作及译作，感觉总体的困难在于一大堆没有标准译名的技术术语。由于通行于工业界和学术界的还是英文原名和术语，我决定保留大量的英文术语。这样的翻译风格借鉴于台湾著名的译者和作者侯捷先生。对于译与不译的权衡，主要考虑阅读的流畅，以及读者的理解能力，或许难免带有一些主观色彩。 前言 Preface 构建产品级质量的程序 —— 可以在很长一段时间内使用的程序 —— 众所周知是极其困难的。本书的目标就是改善程序员解决这项任务的效率。我希望读者在阅读本书之后成为一名好程序员。我相信本书的成功在于改善编程技巧，因为我的学生告诉我这已经发生在他们身上。 怎么才算是一名好程序员？是产生整个程序产品的效率。关键是要在每一阶段减少浪费掉的努力。解决的方法包括：在开始编写代码之前就仔细考虑你的实现方案，通过未雨绸缪的方法来编写代码，使用严格的测试在早期发现错误，以及仔细注意模块化编程，这样当错误出现时，只需要改动极少数代码就可以修正整个程序。本书涉及所有这些领域的技术。 模块化编程 (Modularity) 是编写好程序的关键。把程序分解成许多小模块，每一个模块通过良好定义的狭窄接口和别的模块交互作用 (interact) 。有了模块化，可以修正一部分程序中的错误而不考虑程序的其他部分，而且可以仅仅理解一部分程序而不必理解整个程序。没有模块化，程序是一大堆有着错综复杂的相互关系的部分的拼凑。很难去领悟和修改这样一个程序，同样也很难让它正常工作。 因此本书的重点在于创建模块化的程序：怎样把程序组织成一系列精心挑选的模块。本书认为模块化就是抽象 (abstraction) 。每一个模块意味着一个抽象，比如说指引一系列文档中的关键字的目录，或者在文档中使用目录来查找匹配某个问题的文档的过程。着重强调面向对象编程思想 —— 在程序中使用数据抽象和对象的思想。 这本书使用 Java 作为它的编程示例的语言。我们没有假定读者已经熟悉 Java 。尽管可能没什么价值，但是本书中的思想是语言无关的，并且可以在任何语言的编程中使用。 怎样使用这本书？ How Can the Book Be Used 本书《程序开发原理》有两种使用方法。其一是作为课本教材，讲述如何用面向对象的方法来设计和实现复杂系统；其二是编程专家使用，帮助他们改善编程技能，增进他们的关于模块化和 Object-Oriented( 面向对象 ) 设计的知识。 作为教材使用时，本书一般作为第二或第三门程序设计课程。我们已经在 MIT 使用本书很多年，给大一大二的本科生教授第二门编程课。在这一阶段，学生们已经知道怎样编写小程序。课程在两方面利用这一点：让学生更仔细地思考小程序，以及教他们如何利用小程序作为组件构建大型程序。这本书也可以在专业（如软件工程）后期教学中使用。 建立在本书基础上的课程适合于所有计算机科学专业。尽管许多学生可能永远不会成为真正的大型程序的设计师，他们可以在开发部门工作，在那儿他们负责设计和实现能与整个结构耦合的子系统。模块化设计的子系统是这种任务中心，这对那些从事大型程序设计任务的人来说也同样重要。 这本书讲什么？ What Is This Book About 通观全篇三分之二的书致力于讨论在构建独立的程序模块时产生的问题，剩下的部分讨论怎样运用这些模块构建大型程序。 程序模块 Program Modules 这一部分的书集中讨论抽象机制 (abstraction mechanism) 。它讨论 procedure( 子程序 ) 和 exception( 异常 ) ，数据抽象，遍历 (iteration) 抽象，数据抽象系列 (family) 以及多态 (polymorphic) 抽象。 在对抽象的讨论中，三个步骤是重要的。首先是决定被抽象的东西到底是什么：它提供给它的用户哪些行为。创造抽象是设计的关键，因此本书讨论如何在众多选择中挑选，以及怎样才能创造出好的抽象。 第二步是通过为一个抽象制定一个规格 (specification) 来获取它的意义。如果没有一些描述，一个抽象就会含糊不清，而变得没有使用价值。 specification 则提供了需要的描述。本书定义了一种 specification 的格式，讨论了一份好的 specification 应有的属性，并且提供了许多示例。 第三步是实现抽象。本书讨论怎样设计一份实现，以及在简洁性和执行性能之间怎样权衡利弊。书中强调封装 (encapsulation) 的重要性以及在一份实现中履行规格中定义的行为的重要性。书中同样提供一些技术 —— 尤其是不变式断言 (representation invariant) 和抽象函数 (abstraction function)—— 来帮助读者理解代码和它的原因。不变式断言和抽象函数都实现到尽可能的程度，这对于除错和调试很有用。 关于类型层次 (type hierarchy) 的材料注重讨论使用它作为抽象的技术 —— 一种把相关联的一组数据抽象归入同一系列的技术。这里很重要的一点是，是否应当将一个类型作为另一个类型的子类。本书定义了替换原则 —— 通过比较子类和父类的 specification ，来决定是否建立子类关系的方法 [1] 。 本书同样涉及除错和调试。书中讨论怎样得到足够数量的测试情况，来准备通过黑箱和白箱测试，它同样强调了复查 (regression) 测试的重要性。 编写大型程序 Programming in the Large 本书的其后部分讲解怎样用模块化的方法设计和实现大型程序。它建立在前文有关 abstraction 和 specification 的材料的基础之上。 编写大型程序涵盖四个主要议题。首先讲解需求分析 —— 怎样才能领悟程序中需要什么。本书讨论怎样实施需求分析，也讨论书写产生的需求规格的方式，通过使用一种描述程序的抽象阶段的数据模型。使用这种模型将产生一份更为正式的 specification ，同时它也使需求检查更加严格，这样可以更好的领悟需求。 编写大型程序的第二项议题是程序设计，这通常是一个循序渐进的过程。设计过程围绕构建有用的抽象来组织，这些抽象作为整个程序之中理想的构建组建。这些抽象在设计时被仔细的编写规格，这样当程序实现时，那些实现抽象的模块可以独立地开发。这种设计使用设计笔记编写文档，包括描述整个程序结构的模块间依赖性的图示。 第三项议题是实现和测试。本书讨论了前置设计分析对于实现的必要性，以及怎样进行设计复审。它同样讨论了设计和实现的顺序。这一部分比较了自顶而下与自底而上的组织方式，讨论如何使用驱动程序和占位程序 [2] (stub) ，并且强调了制定一个事先的顺序策略的必要性，以满足开发组织和客户的需求。 本书以一章设计模式 (design pattern) 结束。一些模式在前面的章节介绍过，比如遍历抽象是算法的主要组建。最后的章节讨论前文中没有涉及到的模式。希望它作为这一教材的介绍。有兴趣的读者可以继续阅读其它书中更完善的讨论 [3] 。 [1] 译注：如果子类的 specification 包括了所有父类的 specification ，就是说父类的要求也是子类的要求，或者子类的要求更为严格，那么可以建立父子关系。而替换原则的说法是，对于具有父子关系的类，任何需要一个父类对象的地方，都可以替换为一个子类对象。 [2] 译注：在测试某一组建时，由于其余组建还未实现，这一组建与其余组建的接口衔接部分无法工作。此时可以针对这一组建编写其余组建的占位程序 (stub) ，预留出接口的衔接代码。占位代码通常不做任何有价值的事情，只报告组建的衔接部位工作正常。 [3] 译注：作者指的是设计模式的开山之作 —— 《 Design Patterns—Elements of Reusable Object-Oriented Software 》 , 作者为设计模式界著名的 \" 四人帮 \"GoF(Gang of Four) 。此书详尽讨论了三大类共 23 个广泛使用的设计模式的适用范围、依存关系、实现细节以及已有的应用领域等问题。书中以 C++ 和 Smalltalk 为示例语言，不过书中所涉及的模式适用于所有面向对象的语言。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/c-tricks-3-2-label-goto-and-implementation-of-switch.html","title":"C++ Tricks 3.2 标号、goto，以及switch的实现","text":"从 farseerfc.wordpress.com 导入 3.2 标号、 goto ，以及 switch 的实现 goto 语句及标号 (label) 是最古老的 C 语言特性，也是最早被人们抛弃的语言特性之一。像汇编语言中的 jmp 指令一样， goto 语句可以跳转到同一函数体中任何标号位置： void f() {int i=0; Loop: //A label ++i; if(i<10)goto Loop; //Jump to the label } 在原始而和谐的早期 Fortran 和 Basic 时代，我们没有 if then else ，没有 for 和 while ，甚至没有函数的概念，一切控制结构都靠 goto( 带条件的或无条件的 ) 构件。软件工程师将这样的代码称作 \" 意大利面条 \" 代码。实践证明这样的代码极容易造成混乱。 自从证明了结构化的程序可以做意大利面条做到的任何事情，人们就开始不遗余力地推广结构化设计思想，将 goto 像猛兽一般囚禁在牢笼，标号也因此消失。 标号唯一散发余热的地方，是在 switch 中控制分支流程。 很多人不甚了解 switch 存在的意义，认为它只是大型嵌套 if then else 结构的缩略形式，并且比 if 语句多了很多 \" 不合理 \" 的限制。如果你了解到 switch 在编译器内部的实现机制，就不难理解强加在 switch 之上的诸多限制，比如 case 后只能跟一个编译期整型常量，比如用 break 结束每一个 case 。首先看一个 switch 实例： switch (shape.getAngle()) { case 3: cout<<\"Triangle\";break; case 4: cout<<\"Square\";break; case 0:case1: cout<<\"Not a sharp!\";break; default: cout<<\"Polygon\"; } 任何程序员都可以写出与之对应的 if 结构： int i= getAngle(shape); if (i==3) cout<<\"Triangle\"; else if(i==4) cout<<\"Square\"; else if(i==0||i==1) cout<<\"Not a sharp!\"; else cout<<\"Polygon\"; 看起来这两段代码在语义上是完全一样的，不是么？ 不！或许代码的执行结果完全一样，但是就执行效率而言， switch 版本的更快！ 要了解为什么 switch 的更快，我们需要知道编译器是怎样生成 switch 的实现代码的： 首先，保留 switch 之后由 {} 括起来的语具体，仅将其中 case 、 default 和 break 替换为真正的标号： switch (getAngle(shape)) { _case_3: cout<<\"Triangle\";goto _break; _case_4: cout<<\"Square\"; goto _break; _case_0:_case_1: cout<<\"Not a sharp!\"; goto _break; _default: cout<<\"Polygon\"; _break: } 随后，对于所有出现在 case 之后的常量，列出一张只有 goto 的跳转表，其顺序按 case 后的常量排列： goto _case_0; goto _case_1; goto _case_3; goto _case_4; 然后，计算 case 之后的常量与跳转表地址之间的关系，如有需要，在跳转表中插入空缺的项目： 100105: goto _case_0; 100110: goto _case_1; 100115: goto _default; // 因为没有 case 2 ，所以插入此项以条转到 default 100120: goto _case_3; 100125: goto _case_4; 假设一个 goto 语句占用 5 个字节，那么在本例中， goto 的地址 =case 后的常量 *5+100105 之后，生成跳转代码，在其余条件下跳转至 default ，在已知范围内按照公式跳转，全部的实现如下： { int i= getAngle(shape); if (i<0||i>=5)goto _default; i=i*5+100105; // 按照得出的公式算出跳转地址 goto i; // 伪代码， C 中不允许跳转到整数，但是汇编允许 100105: goto _case_0; 100110: goto _case_1; 100115: goto _default; 100120: goto _case_3; 100125: goto _case_4; _case_3: cout<<\"Triangle\";goto _break; _case_4: cout<<\"Square\"; goto _break; _case_0:_case_1: cout<<\"Not a sharp!\"; goto _break; _default: cout<<\"Polygon\"; _break: } 经过这样处理整个 switch 结构，使得无论 switch 后的变量为何值，都可以通过最多两次跳转到达目标代码。相比之下 if 版本的代码则采用线性的比较和跳转，在 case 语句很多的情况下效率极低。 由此 , 我们也可以知道 , 为什么 case 后跟的一定是编译期整型常数，因为编译器需要根据这个值制作跳转表。我们可以明白为什么 case 与 case 之间应该用 break 分隔，因为编译器不改变 switch 语句体的结构， case 其本身只是一个具有语义的标号而已，要想跳出 switch ，就必须用 break 语句。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/c-tricks-3-1-lvalue-rvalue-constant.html","title":"C++ Tricks 3.1 左值右值与常量性(lvalue，rvalue & constant)","text":"从 farseerfc.wordpress.com 导入 3.1 左值右值与常量性 (lvalue ， rvalue & constant) 首先要搞清楚的是，什么是左值，什么是右值。这里给出左值右值的定义： 1 、左值是可以出现在等号 (=) 左边的值，右值是只能出现在等号右边的值。 2 、左值是可读可写的值，右值是只读的值。 3 、左值有地址，右值没有地址。 根据左值右值的第二定义，值的左右性就是值的常量性 —— 常量是右值，非常量是左值。比如： 1=1;//Error 这个复制操作在 C++ 中是语法错误， MSVC 给出的错误提示为 \"error C2106: ‘=' : left operand must be l-value\" ，就是说 '=' 的左操作数必须是一个左值，而字面常数 1 是一个右值。可见，严格的区分左值右值可以从语法分析的角度找出程序的逻辑错误。 根据第二定义，一个左值也是一个右值，因为左值也可读，而一个右值不是一个左值，因为右值不可写。 通常情况下，声明的变量是一个左值，除非你指定 const 将它变成一个右值： int lv=1; const int rv=lv; 由于右值的值在程序执行期间不能改变，所以必须用另一个右值初始化它。 一个普通变量只能用右值初始化，如果你想传递左值，必须声明一个引用或一个指针： int & ref=lv;// 用引用传递左值 int * plv=&lv;// 传递指针以间接传递左值 必须用左值初始化引用，然而，可以用右值初始化常量引用： int & r1=1; //Error! const int & r2=1; // OK 这实际上相当于： int _r2=1; const int & r2=_r2; 这样的写法在函数体内没什么作用，但是在传递函数参数时，它可以避免潜在的 ( 传递左值时的 ) 复制操作，同时又可以接受右值。 通常情况下，函数的参数和返回值都只传回右值，除非你明确的通过引用传递左值。 明确了左值与右值的区别，有助于我们写函数时确定什么时候应该有 const ，什么时候不该有。比如，我们写了一个代表数学中复数的类 Complex ： class Complex; 然后，我们写针对 Complex 的运算符重载： operator+ 和 operator= 。问题在于，参数和返回值应该是什么类型，可选类型有四种： Complex 、 const Complex 、 Complex& 、 const Complex& 。 对于 operator+ ，我们不会改变参数的值，所以可以通过 const Complex& 传递参数。至于返回值类型，由于 int 类型的加法返回右值，所以根据 Do as the ints do 的原则，返回值类型为 const Complex ： const Complex operator+(const Complex&,const Complex&); 对于 operator= ，同样要思考这些问题。我们写入第一个参数，所以第一个参数为 Complex& ，我们只读取第二个参数，所以第二个参数为 const Complex& 。至于返回值，还是 Do as the ints do 。 int 的赋值返回左值，不信你可以试一试： int i; (i=1)=2; 虽然比较傻，先将 i 赋为 1 ，再将其改为 2 ，但是这是被 C++ 语法支持的做法，我们就理应遵守。所以返回第一个参数的左值： Complex& operator=(Complex&,const Complex&); const 是 C++ 引入的语言特性，也被 ANSI C99 借鉴，在经典版本的 C 语言中是没有的。关于 const 的历史，有几点值得玩味。最初 Bjarne Stroustrup 引入 const 时，可写性是和可读性分开的。那时使用关键字 readonly 和 writeonly 。这个特点被首先提交到 C 的 ANSI 标准化委员会 ( 当时还没有 C++ 标准化的计划 ) ，但是 ANSI C 标准只接受了 readonly 的概念，并将其命名为 const 。随后，有人发现在多线程同步的环境下，有些变量的值会在编译器的预料之外改变，为了防止过度优化破坏这些变量， C++ 又引入关键字 violate 。从语义特点来看， violate 是 const 的反义词，因为 const 表示不会变的量，而 violate 表示会不按照预期自行变化的量。从语法特点而言， violate 与 const 是极为相似的，适用于 const 的一切语法规则同样适用于 violate 。 值的常量性可以被划分为两种：编译期常量和运行期常量。 C++ 语法并没有严格区分这两种常量，导致了少许混乱： const int i=5;const int * pi=&i; const_cast<int&>i=1;// 对于运行期常量，在需要时可以去除它的常量性 int a[i];// 对于编译期常量，可以用它来指定数组大小 cout<<i<<sizeof(a)/sizeof(a[0])<<*pi; 这种将编译期与运行期常量的特性混用的方法，势必导致语义的混乱。数组 a 的大小最终是 5 ，因为采用了 i 的编译期值，而不管 i 在运行期是否被改变了值。最后一句代码将（有可能）输出 551 ，第一个 i 的值作为一种优化在编译期绑定，第二个值标明了 a 的大小，第三个值通过指针显示地输出 i 的运行期真实值。 在 C++ 的近亲 C# 的语法中，这两种常量被严格地区分开：编译期常量由 const 指定，只能是内建类型变量；运行期常量由 readonly 指定，可以是任何类型。永远不会改变的常量，如圆周率 pi 的值，应该用 const 声明；而其它有可能改变的常量，皆由 readonly 声明。 C++ 中的 const 的特点更倾向于 C# 中的 readonly ，虽然语法上允许使用 const 的编译期常量性，但正如上文所展示的，这容易造成混乱。为了得到 C# 中 const 的语义，在 C++ 中，我们不必回归恶魔 #define 的怀抱，可以使用所谓 \" 匿名 enum 技巧 \" 。当匿名声明一个 enum 类型时，其中的枚举值就是一个 int 类型的编译期常量，比如： enum{Size=5;}; int a[Size]; 这种使用匿名 enum 来声明编译期常量的做法，被广泛应用于 STL 、 boost 等模板库的实现代码中。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/c-tricks-2-2-i386-memory-layout.html","title":"C++ Tricks 2.2 I386平台的内存布局","text":"从 farseerfc.wordpress.com 导入 2.2 I386 平台的内存布局 众所周知， I386 是 32 位体系结构。因此对于绝大多数 I386 平台的 C++ 编译器而言， sizeof(int)=sizeof(long)=sizeof(void*)=4 。当然 C++ 标准对此没有任何保证，我们也不应该试图编写依赖于此的代码。 32 位指针的可寻址空间为 4GB 。为充分利用这么大的寻址空间，也是为了支持其它更先进的技术比如多任务技术或者动态链接库技术， WinNT 使用虚拟内存技术，给与每个应用程序全部 4GB 的内存空间。 4GB 的地址被一分为二，前 2GB 供应用程序自己使用，后 2GB 由系统内核分配和管理。这 2GB 的内存地址，通常被划分成 3 种内存区使用： 1 代码及静态数据区 由代码加载器从动态链接库镜像 ( 通常是 exe 或 dll 文件 ) 加载，通常定位到镜像文件中指定的基址开始的内存区。如果基址所在内存已被占用，动态连接器会将代码或数据重定向到其它可用地址。 在 C++ 中，静态数据包括：名字空间 (namespace) 和全局 (global) 对象、函数的 static 对象、类的 static 数据成员。这些静态数据由编译器分配地址 ( 但可能被重定向 ) ，由静态连接器写入代码文件 ( 通常是 exe 或 dll) 的静态数据区段。所以标准说，这些静态数据在编译期就已经具有地址。 2 栈 (Stack) 栈是最常用的动态数据存储区，所有函数的 non-static 对象和函数参数都在程序运行期在栈上分配内存。在数据结构中，术语 \" 栈 (Stack)\" 意指先进后出 ( FILO ， First In Last Out) ，与 \" 队列 (Queue)\" 所指的 FIFO 相对。相对于基于堆的对象分配技术，默认使用栈的对象分配有两点优势： 一、栈的 FILO 与人的思维方式相同 现实生活中有许多事例都使用 FILO 的方式，比如人们必须先提起话筒再拨打号码，而后挂断电话之后再放下话筒。使用 FILO 的栈，可以保证事物的销毁顺序以其诞生顺序相反的顺序进行，不会产生在挂断电话之前就放下话筒的尴尬。 二、栈的分配管理仅需要两个额外指针：栈顶 (esp) 和栈底 (ebp) 指针 从实现的技术层面而言，栈的管理比其它动态分配技术要简单很多。 I386 平台上的动态栈管理，仅需要栈顶和栈底两个指针。这两个指针的存储显然不能放置于栈中，置于静态数据区又有损效率。 I386 平台为管理动态栈专门预留了两个通用寄存器变量 esp 与 ebp ，分别代表栈顶 (esp,Extended Stack Pointer) 与栈底 (Extended Bottom Pointer) 指针。其中的 extended 代表它们是 32 位指针，以区分 16 位的 sp 和 bp 寄存器。 栈是动态存储区的特点，表明它的内存占用将随着程序的运行而变化。 I386 平台上 WinNT 将应用程序的栈置于程序空间，向下增长。程序初始化时，由操作系统将 esp 指向系统分配的栈空间的顶部。当程序需要在栈上分配变量时，就将 esp 减去变量所需字节数，这被称作 \" 压栈 (Push)\" ；随后又要销毁变量时，就将 esp 加上变量所需字节数，这被称作 \" 弹出 (Pop)\" 。 esp 与 ebp 两者之间所夹的空间，就是当前函数正在使用的栈空间。由于栈向下增长， esp( 栈顶 ) 的值总是小于 ebp( 栈底 ) 的值，新分配的变量地址总是小于旧变量的地址。 3 堆 (Heap) 和自由存储区 栈中的变量对于分配与释放的顺序有特定要求，这在一定程度上限制了栈的适用范围。面向对象 ( OO ， Object Oriented) 的程序设计思想也要求能自由地控制变量的分配与销毁。由此，现代操作系统都提供了被称作 \" 堆 (Heap)\" 的自由存储区，以允许由程序员控制的对象创建和销毁过程。 C 标准库函数 malloc 和 free 则是对操作系统提供的堆操作的封装。 C++ 提供的自由存储区运算符 new 和 delete 则通常是 malloc 和 free 的又一层封装。 操作系统经由 malloc 和 free 控制对堆的访问。堆的存储管理技术各不相同，简单的使用双链表管理，复杂的可以比拟一个完整的文件系统。 由于额外的管理需求，使用系统提供的通用分配器在堆上分配和销毁变量的代价，无论从空间角度还是效率角度而言，都比在栈上分配对象要高昂很多。对于 sizeof 上百的大型对象，这样的高昂代价还是可以接受的，但是对于 sizeof 只有个位数的小对象，这样的代价通常是一个数量级的差距。正因为这个原因， STL 不使用 new 和 delete ，转而使用分配子 (alllocor) 分配对象。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/c-tricks.html","title":"C++ Tricks","text":"从 farseerfc.wordpress.com 导入 C++ Tricks By FarseerFc 从今天起，我再将在 Live Space 和 QQZone 同时发表一系列文章，暂定名为 \"C++Tricks\" 。 本文旨在记录和阐述一些本人学习 C++ 时所得的心得、技巧。总体来看，本文涉及的内容是每一个 C++ 程序员都应该知道的，但是很少见诸 C++ 教材。希望对各位同仁学习 C++ 有所帮助。 也可以通过 QQ 或 MSN 向我索要此文的 DOC 版或 PDF 版，会比网页上的更新的快一点。 1 词法问题 (Lexical Problems) 1.1 条件运算符 (?:) 1.2 逗号运算符 (,) 、逻辑运算符 (&&,||) 与运算符重载的陷阱 2 X86 体系结构 2.1 X86 概述 2.2 I386 平台的内存布局 2.3 I386 平台 C 函数内部的栈分配 2.4 I386 平台 C 函数调用边界的栈分配 2.5 I386 平台的边界对齐 (Align) 2.6 I386 平台 C 函数的可变参数表 (Variable Arguments) 2.7 I386 平台的其它函数调用模型 3 过程式编程 3.1 左值右值与常量性 (lvalue ， rvalue & constant) 3.2 标号、 goto ，以及 switch 的实现","tags":"import"},{"loc":"//farseerfc.github.io/zhs/c-tricks-2-3-i386-stack-allocation-in-c-functions.html","title":"C++ Tricks 2.3 I386平台C函数内部的栈分配","text":"从 farseerfc.wordpress.com 导入 2.3 I386 平台 C 函数内部的栈分配 函数使用栈来保存局部变量，传递函数参数。进入函数时，函数在栈上为函数中的变量统一预留栈空间，将 esp 减去相应字节数。当函数执行流程途径变量声明语句时，如有需要就调用相应构造函数将变量初始化。当执行流程即将离开声明所在代码块时，以初始化的顺序的相反顺序逐一调用析构函数。当执行流程离开函数体时，将 esp 加上相应字节数，归还栈空间。 为了访问函数变量，必须有方法定位每一个变量。变量相对于栈顶 esp 的位置在进入函数体时就已确定，但是由于 esp 会在函数执行期变动，所以将 esp 的值保存在 ebp 中，并事先将 ebp 的值压栈。随后，在函数体中通过 ebp 减去偏移量来访问变量。以一个最简单的函数为例： void f() { int a=0; //a 的地址被分配为 ebp-4 char c=1; //c 的地址被分配为 ebp-8 } 产生的汇编代码为： push ebp ; 将 ebp 压栈 mov ebp,esp ;ebp=esp 用栈底备份栈顶指针 sub esp,8 ;esp-=8 ，为 a 和 c 预留空间，包括边界对齐 mov dword ptr[ebp-4],0 ;a=0 mov byte ptr[ebp-8],1 ;c=1 add esp,8 ;esp+=8 ，归还 a 和 c 的空间 mov esp,ebp ;esp=ebp 从栈底恢复栈顶指针 pop ebp ; 恢复 ebp ret ; 返回 相应的内存布局是这样： 09992:c=1 <-esp 09996:a=0 10000: 旧 ebp <-ebp 10004:…… 注 : 汇编中的 pop 、 push 、 call 、 ret 语句是栈操作指令，其功能可以用普通指令替换 push ebp 相当于 : add esp,4 mov dword ptr[esp],ebp pop ebp 相当于： mov ebp,dword ptr[esp] sub esp,4 call fun_address 相当于： push eip jmp fun_address ret 相当于 add esp,4 jmp dword ptr[esp-4] 带参数的 ret ret 8 相当于 add esp,12 jmp dword ptr[esp-4] 所有局部变量都在栈中由函数统一分配，形成了类似逆序数组的结构，可以通过指针逐一访问。这一特点具有很多有趣性质，比如，考虑如下函数，找出其中的错误及其造成的结果： void f() { int i,a[10]; for(i=0;i<=10;++i)a[i]=0;/An error occurs here! } 这个函数中包含的错误，即使是 C++ 新手也很容易发现，这是老生常谈的越界访问问题。但是这个错误造成的结果，是很多人没有想到的。这次的越界访问，并不会像很多新手预料的那样造成一个 \" 非法操作 \" 消息，也不会像很多老手估计的那样会默不作声，而是导致一个，呃，死循环！ 错误的本质显而易见，我们访问了 a[10] ，但是 a[10] 并不存在。 C++ 标准对于越界访问只是说 \" 未定义操作 \" 。我们知道， a[10] 是数组 a 所在位置之后的一个位置，但问题是，是谁在这个位置上。是 i! 根据前面的讨论， i 在数组 a 之前被声明，所以在 a 之前分配在栈上。但是， I386 上栈是向下增长的，所以， a 的地址低于 i 的地址。其结果是在循环的最后， a[i] 引用到了 i 自己！接下来的事情就不难预见了， a[i] ，也就是 i ，被重置为 0 ，然后继续循环的条件仍然成立 …… 这个循环会一直继续下去，直到在你的帐单上产生高额电费，直到耗光地球电能，直到太阳停止燃烧 …… 呵呵，或者直到聪明的你把程序 Kill 了 ……","tags":"import"},{"loc":"//farseerfc.github.io/zhs/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html","title":"C++ Tricks 2.4 I386平台C函数调用边界的栈分配","text":"从 farseerfc.wordpress.com 导入 2.4 I386 平台 C 函数调用边界的栈分配 当调用一个函数时，主调函数将参数以声明中相反的顺序压栈，然后将当前的代码执行指针 (eip) 压栈，然后跳转到被调函数的入口点。在被调函数中，通过将 ebp 加上一个偏移量来访问函数参数，以声明中的顺序 ( 即压栈的相反顺序 ) 来确定参数偏移量。被调函数返回时，弹出主调函数压在栈中的代码执行指针，跳回主调函数。再由主调函数恢复到调用前的栈。 函数的返回值不同于函数参数，通过寄存器传递。如果返回值类型可以放入 32 位变量，比如 int 、 short 、 char 、指针等类型，通过 eax 寄存器传递。如果返回值类型是 64 位变量，如 _int64 ，同过 edx+eax 传递， edx 存储高 32 位， eax 存储低 32 位。如果返回值是浮点类型，如 float 和 double ，通过专用的浮点数寄存器栈的栈顶返回。如果返回值类型是用户自定义结构，或 C++ 类类型，通过修改函数签名，以引用型参数的形式传回。 同样以最简单的函数为例： void f(){ int i=g(1,2); } int g(int a,int b){ int c=a+b ； return c; } 产生的汇编代码如下： f: push ebp ; 备份 ebp mov ebp,esp ; 建立栈底 sub esp,4 ; 为 i 分配空间 mov eax,2 ; 准备参数 b 的值 2 push eax ; 将 b 压栈 mov eax,1 ; 准备参数 a 的值 1 push eax ; 将 a 压栈 call g ; 调用 g add esp,8 ; 将 a 和 b 一起弹出，恢复调用前的栈 mov dword ptr[ebp-4],eax ; 将返回值保存进变量 i mov esp,ebp ; 恢复栈顶 pop ebp ; 恢复栈底 g: push ebp ; 备份 ebp mov ebp,esp ; 建立栈底 sub esp,4 ; 为局部变量 c 在栈中分配内存 mov eax,dword ptr[ebp+8] ; 通过 ebp 间接读取参数 a 的值 mov ebx,dword ptr[ebp+12] ; 通过 ebp 间接读取参数 b 的值 add eax,ebx ; 将 a 和 b 的值相加，之和存在 eax 中 mov dword ptr[ebp-4],eax ; 将和存入变量 c mov eax,dword ptr[ebp-4] ; 将 c 作为返回值，代码优化后会删除此句 add esp,4 ; 销毁 c 的内存 mov esp,ebp ; 恢复栈顶 pop ebp ; 恢复栈底 ret ; 返回函数 f 栈的内存布局如下： 100076:c <- g 的 esp 100080:f 的 ebp=100100 <- g 的 ebp 100084:f 的 eip 100088:a=1 100092:b=2 100096:i 100100: 旧 ebp <-f 的 ebp 100104:…… 注意在函数 g 的汇编代码中，访问函数的局部变量和访问函数参数的区别。局部变量总是通过将 ebp 减去偏移量来访问，函数参数总是通过将 ebp 加上偏移量来访问。对于 32 位变量而言，第一个局部变量位于 ebp-4 ，第二个位于 ebp-8 ，以此类推， 32 位局部变量在栈中形成一个逆序数组；第一个函数参数位于 ebp+8 ，第二个位于 ebp+12 ，以此类推， 32 位函数参数在栈中形成一个正序数组。 由于函数返回值通过寄存器返回，不需要空间分配等操作，所以返回值的代价很低。基于这个原因，旧的 C 语法约定，不写明返回值类型的函数，返回值类型为 int 。这一规则与现行的 C++ 语法相违背，因为 C++ 中，不写明返回值类型的函数返回值类型为 void ，表示不返回值。这种语法不兼容性是为了加强 C++ 的类型安全，但同时也带来了一些问题。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/c-tricks-2-5-address-alignment.html","title":"C++ Tricks 2.5 I386平台的边界对齐(Align)","text":"从 farseerfc.wordpress.com 导入 2.5 I386 平台的边界对齐 (Align) 首先提问，既然 I386 上 sizeof(int)==4 、 sizeof(char)==1 ，那么如下结构 (struct)A 的 sizeof 是多少？ struct A{int i;char c;}; 答案是 sizeof(A)==8……1+5=8 ？ 呵呵，这就是 I386 上的边界对齐问题。我们知道， I386 上有整整 4GB 的地址空间，不过并不是每一个字节上都可以放置任何东西的。由于内存总线带宽等等的技术原因，很多体系结构都要求内存中的变量被放置于某一个边界的地址上。如果违反这个要求，重则导致停机出错，轻则减慢运行速度。对于 I386 平台而言，类型为 T 的变量必须放置在 sizeof(T) 的整数倍的地址上， char 可以随便放置， short 必须放在 2 的整数倍的地址上， int 必须放在 4 的整数倍的地址上， double 必须放在 8 的整数倍的地址上。如果违反边界对齐要求，从内存中读取数据必须进行两次，然后将独到的两半数据拼接起来，这会严重影响效率。 由于边界对齐问题的要求，在计算 struct 的 sizeof 的时候，编译器必须算入额外的字节填充，以保证每一个变量都能自然对齐。比如如下声明的 struct: struct WASTE { char c1; int i; char c2; } 实际上相当于声明了这样一个结构： struct WASTE { char c1; char _filling1 [3];// 三个字节填充，保证下一个 int 的对齐 int i; char c2 ； char _filling2 [3];// 又三个字节填充 } 值得注意的是尾部的 3 个字节填充，这是为了可以在一个数组中声明 WASTE 变量，并且每一个都自然对齐。因为有了这些填充，所以 sizeof( WASTE )==12 。这是一种浪费，因为只要我们重新安排变量的声明，就可以减少 sizeof ： struct WASTE { int i; char c1,c2; } 像这样的安排， sizeof 就减少到 8 ，只有 2 个字节的额外填充。为了与汇编代码相兼容， C 语言语法规定，编译器无权擅自安排结构体内变量的布局顺序，必须从左向右逐一排列。所以，妥当安排成员顺序以避免内存空间的浪费，就成了我们程序员的责任之一。一般的，总是将结构体的成员按照其 sizeof 从大到小排列， double 在最前， char 在最后，这样总可以将结构的字节填充降至最小。 C++ 继承了 C 语言关于结构体布局的规定，所以以上的布局准则也适用于 C++ 的 class 的成员变量。 C++ 进一步扩展了布局规定，同一访问区段 (private 、 public 、 protected) 中的变量，编译器无权重新排列，不过编译器有权排列访问区段的前后顺序。基于这个规则， C++ 中有的程序员建议给每一个成员变量放在单独区段，在每一个成员声明之前都加上 private: 、 public: 、 protected: 标志，这可以最大限度的利用编译器的决策优势。 在栈中按顺序分配的变量，其边界也受到对齐要求的限制。与在结构中不同的是，栈中的变量还必须保证其后续变量无论是何种类型都可以自由对齐，所以在栈中的变量通常都有平台相关的对齐最小值。在 MSVC 编译器上，这个最小值可以由宏 _INTSIZEOF(T) 查询： #define _INTSIZEOF(T) ( (sizeof(T) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) _INTSIZEOF(T) 会将 sizeof(T) 进位到 sizeof(int) 的整数倍。 由于在栈中分配变量使用 _INTSIZEOF 而不是 sizeof ，在栈上连续分配多个小变量 (sizeof 小于 int 的变量 ) 会造成内存浪费，不如使用结构 (struct) 或数组。也就是说： char c1,c2,c3,c4;// 使用 16 字节 char c[4];// 使用 4 字节 当然，使用数组的方法在访问数组变量 ( 比如 c[1]) 时有一次额外的指针运算和提领 (dereference) 操作，这会有执行效率的损失。这又是一种空间 ( 内存占用 )vs 时间 ( 执行效率 ) 的折中，需要程序员自己根据情况权衡利弊。 sizeof 的大小可能比我们预期的大，也可能比我们预期的小。对于空类： class Empty {}; 在通常情况下， sizeof(Empty) 至少为 1 。这是因为 C++ 语法规定，对于任何实体类型的两个变量，都必须具有不同的地址。为了符合语法要求，编译器会给 Empty 加入 1 字节的填充。所以 sizeof() 的值不可能出现 0 的情况。可是对于以下的类声明： class A:public Empty{vitual ~A(){}}; sizeof(A) 有可能是 6 ，也有可能是 5 ，也有可能是 4 ！必不可少的四个字节是一个指向虚函数表的指针。一个可能有的字节是 Empty 的大小，这是是因为编译器在特定情况下会将 Empty 视作一个 \" 空基类 \" ，从而实施 \" 空基类优化 \" ，省掉那毫无作用的一字节填充。另一个字节是 A 的一字节填充，因为从语法上讲， A 没有成员声明，理应有 1 字节填充，而从语义上讲，编译器给 A 的声明加入了一个指向虚函数表的指针，从而 A 就不再是一个 \" 空类 \" ，是否实施这个优化，要看编译器作者对语法措词的理解。也就是说， sizeof 也会出现 4+1+1=4 的情况。具体要看编译器有没有实施 \" 空基类优化 \" 和 \" 含虚函数表的空类优化 \" 。 结构和类的空间中可能有填充的字节，这意味着填充字节中可能有数值，虽然这数值并不影响结构的逻辑状态，但是它也可能不知不觉中影响到你。比如说，你手头正好有一组依赖于底层硬件 ( 比如多处理器 ) 的函数，他们在操纵连续字节时比手动编码要快很多，而你想充分利用这种硬件优势： bool BitCompare(void* begin,void* end,void* another); 这个函数将区间 [begin,end) 之间的字节与 another 开始的字节相比较，如果有一位不同就返回 false ，否则返回 true 。 比如你想将这个函数用于你自己的类的 operator== 中，这样可以利用硬件加快速度。不过你在动手前要充分考虑，你的 class 是否真的要比较每一位。如果在类的成员中存在编译器填充的字节数，那么应用以上的函数就是不正确的，因为填充的字节中可以有不同的值。为了保证你可以用 Bitwise Compare ，你必须确保填充的字节中的值也是相同的。这不仅要求你在类的构造函数中初始化类的每一 bit 而不是每一个成员，也要求你在复制初始化和复制赋值函数中也同时保证 bitwise copy 语义，而不是编译器默认产生的 memberwise 语义。当然，你可能通过与 BitCompare 一同提供的 BitCopy 来完成这个艰巨的任务。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/c-tricks-2-6-i386-variable-arguments.html","title":"C++ Tricks 2.6 I386平台C函数的可变参数表(Variable Arguments)","text":"从 farseerfc.wordpress.com 导入 2.6 I386 平台 C 函数的可变参数表 (Variable Arguments) 基于前文 (2.4 节 ) 分析，我们可以不通过函数签名，直接通过指针运算，来得到函数的参数。由于参数的压栈和弹出操作都由主调函数进行，所以被调函数对于参数的真实数量不需要知晓。因此，函数签名中的变量声明不是必需的。为了支持这种参数使用形式， C 语言提供可变参数表。可变参数表的语法形式是在参数表末尾添加三个句点形成的省略号 \"…\" ： void g(int a,char* c,…); 省略号之前的逗号是可选的，并不影响词法语法分析。上面的函数 g 可以接受 2 个或 2 个以上的参数，前两个参数的类型固定，其后的参数类型未知，参数的个数也未知。为了知道参数个数，我们必须通过其他方法，比如通过第一个参数传递： g(3,\"Hello\",2,4,5);// 调用 g 并传递 5 个参数，其中后 3 个为可变参数。 在函数的实现代码中，可以通过 2.4 节叙述的，参数在栈中的排列顺序，来访问位于可变参数表的参数。比如 : void g(int a,char* c…){ void *pc=&c;int* pi=static_cast<int*>(pc)+1;// 将 pi 指向首个可变参数 for(int i=0;i<a;i++)std::cout<<pi[i]<<\" \" ； std::cout<<c<<std::endl; } 我们甚至可以让一个函数的所有参数都是可变参数，只要有办法获知参数的数量即可。比如，我们约定，在传递给 addAll 的参数都是 int ，并且最后一个以 0 结束： int addAll(…); int a=f(1,4,2,5,7,0); 那么 addAll 可以这样实现： int addAll(…){ int sum=0;int *p=&sum; //p 指向第一个局部变量 p+=3; // 跳过 sum ， ebp ， eip ，现在 p 指向第一个参数 for(;*p;++p) // 如果 p 不指向 0 就继续循环 sum+=*p; return sum; } 可变参数表的最广泛应用是 C 的标准库函数中的格式化输入输出： printf 和 scanf 。 void printf(char *c,…); void scanf(char *c,…); 两者都通过它的首个参数指出后续参数表中的参数类型和参数数量。 如果可变参数表中的参数类型不一样，那么操纵可变参数表就需要复杂的指针运算，并且还要时刻注意边界对齐 (align) 问题，非常令人头痛。好在 C 标准库提供了用于操纵可变参数表的宏 (macro) 和结构 (struct) ，他们被定义在库文件 stdarg.h 中 : typedef struct {char *p;int offset;} va_list; #define va_start(valist,arg) #define va_arg(valist,type) #define va_end(valist) 其中结构 va_list 用于指示参数在栈中的位置，宏 va_start 接受一个 va_list 和函数的可变参数表之前的参数，通过第一个参数初始化 va_list 中的相应数据，因此要使用 stdarg.h 中的宏，你的可变参数表的函数必须至少有一个具名参数。 va_arg 返回下一个类型为 type 的参数， va_end 结束可变参数表的使用。还是以上文的 addAll 为例，这次写出它的使用标准宏的版本： int addAll(int i,…) { va_list vl; // 定义一个 va_list 结构 va_start(vl,i); // 用省略号之前的参数初始化 vl if(i=0)return 0; // 如果第一个参数就是 0 ，返回 int sum=i; // 将第一个参数加入 sum for(;;){ i=va_arg(vl,int); // 取得下一个参数，类型是 sum if(i==0)break; // 如果参数是 0 ，跳出循环 sum+=i; } va_end(vl); return sum; } 可以看出，如果参数类型一致，使用标准库要多些几行代码。不过如果参数类型不一致或者未知 (printf 的情况 ) ，使用标准库就要方便很多，因为我们很难猜出编译器处置边界对齐 (align) 等汇编代码的细节。使用标准库的代码是可以移植的，而使用上文所述的其它方法操纵可变参数表都是不可移植的，仅限于在 I386 平台上使用。 纵使可变参数表有使用上的便利性，它的缺陷也有很多，不可移植性和平台依赖性只是其一，最大的问题在于它的类型不安全性。使用可变参数表就意味着编译器不对参数作任何类型检查，这在 C 中算是一言难尽的历史遗留问题，在 C++ 中就意味着恶魔 reinterpret_cast 被你唤醒。 C 的可变参数表是 C++ 代码错误频发的根源之一，以至于 C++ 标准将可变参数表列为即将被废除的 C 语言遗留特性。 C++ 语法中的许多新特性，比如重载函数、默认参数值、模板，都可以一定程度上替代可变参数表，并且比可变参数表更加安全。 可变参数表在 C++ 中惟一值得嘉奖的贡献，是在模板元编程 ( TMP ) 的 SFINAE 技术中利用可变参数表制作最差匹配重载。根据 C++ 标准中有关函数重载决议的规则，具有可变参数表的函数总是最差匹配，编译器在被逼无奈走头无路时才会选择可变参数表。利用这一点，我们可以精心制作重载函数来提取类型信息。比如，要判断一个通过模板传递来的类型是不是 int ： long isIntImp(int); char isIntImp(…); template<typename T> struct isInt { enum{value=sizeof(isIntImp(T()))==sizeof(long);} } 然后，在一个具有模板参数 T 的函数中，我们就可以写 if(isInt<T>::value)//… 在这个 ( 不怎么精致的 ) 例子中，如果 T 是 int ，那么 isIntImp 的第一个重载版本就会被选中，返回值类型就是 long ，这样 value 就为 1 。否则，编译器只能选中第二个具有可变参数表的重载版本，返回值类型成为 char ，这样 value 就为 0 。把它说得再明白一些，上文的代码所表达的意思是：如果类型 T 是 int ，那它就是 int ，否则它就不是 int ，呵呵简单吧。这种通过重载决议规则来提取类型信息的技术，在模板元编程中被称作 SFINAE ，它和其它模板元编程技术被广泛运用于 STL 、 Boost 等模板库的开发实现之中。 值得注意的是，在上文 SFINAE 的运用中， isIntImp 并没有出现定义而只提供了声明，因为我们并没有实际调用 isIntImp 函数，而只是让它参与重载决议并用 sizeof 判断其返回值类型。这是 C++ 的一个设计准则的完美体现：不需要的东西可以不出现。由于这一准则，我们避免了在 C++ 中调用具有可变参数表的函数这一危险举动，而仅仅利用了可变参数表在语法分析过程中的特殊地位，这种对于危险语言特性的巧妙利用是善意而无害的。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/c-tricks-2-7-i386-calling-conventions.html","title":"C++ Tricks 2.7 I386平台的其它函数调用模型","text":"从 farseerfc.wordpress.com 导入 2.7 I386 平台的其它函数调用模型 上文介绍的只是 I386 平台上 C 函数调用的标准模型，被称作 __cdecl 。事实上， Microsoft Visual C++ 编译器还支持其它一些函数调用模型，所有调用模型名称皆以双下划线开头，下面列出所有函数调用模型的异同： 1 __cdecl 参数压栈顺序：逆序 ( 从右至左 ) 参数堆栈恢复者：主调函数 (caller) __cdecl 明确地指出函数使用 C 函数调用模型，这是默认的调用模型。 2 __stdcall 参数压栈顺序：逆序 ( 从右至左 ) 参数堆栈恢复者：被调函数 (callee) __stdcall 是微软所谓的标准调用模型。可惜的是它与 __cdecl 不兼容。几乎所有的 Win32API 函数使用这种函数调用模型，希望在 DLL 之间，或者在程序和 WinNT 操作系统之间传递函数指针的函数也应该使用这种模型。与 __cdecl 模型的不同之处在于， __stdcall 模型下由被调函数恢复堆栈。主调函数在 call 语句之后，不需要再加上 add 语句。而被调函数的 ret 语句则被添加一个参数，代表函数参数堆栈的长度。因此，被调函数需要明确的知晓函数参数的数量和类型，所以在 __stdcall 模型下不支持可变参数表，所有参数必须写明。 3 __thiscall 参数压栈顺序：逆序 ( 从右至左 ) ， this 用 ecx 传递。 参数堆栈恢复者：被调函数 (callee) __thiscall 是 VC 编译器中类的非静态成员函数 (non-static member functon) 的默认调用模型。但是如果此成员函数有可变参数表， VC 编译器会使用 __cdecl 。和 __stdcall 一样， __thiscall 由被调函数恢复堆栈。比较独特的是 __thiscall 会通过 ecx 寄存器传递成员函数的 this 指针，而 __cdecl 下 this 指针是通过在参数表最前面增加一个函数参数来传递的。 __thiscall 是 VC 编译器对 this 指针的使用的一种优化，大大提高了面向对象程序的效率。在 VC2003 及之前的编译器上 __thiscall 不是一个关键字，不能被显式指定。但可以给成员函数显式指定 __cdecl 来避免使用 __thiscall 。 4 __fastcall 参数压栈顺序：逆序 ( 从右至左 ) ，前两个 32 位函数参数放入 ecx 和 edx 中 参数堆栈恢复者：被调函数 (callee) 快速函数调用模型，将前两个 32 位函数参数放入 ecx 和 edx 中，其余参数再逆序压栈。使用的是和 __thiscall 类似的优化技术，加快函数调用，适合运用在小型 inline 函数上。同样使用 __stdcall 形式的被调函数恢复堆栈，所以不支持可变参数表。 5 __pascal 参数压栈顺序：正序 ( 从左至右 ) 参数堆栈恢复者：被调函数 (callee) 过程式编程语言 Pascal 所使用的函数调用模型，由此得名。也是 16 位版本的 Windows 使用的 API 模型，过时的模型，现在已经废弃且禁止使用。你会看到有些书本仍会不时提到它，所以需要注意。 __pascal 是正序压栈，这与大部分 I386 函数模型都不相同。与 __stdcall 一样，由被调者恢复堆栈，不支持可变参数表。历史上曾有过的别名 PASCAL 、 pascal 、 _pascal( 单下划线 ) ，现在都改成了 __stdcall 的别名，与 __pascal( 双下划线 ) 不同。 6 其它函数调用模型，以及模型别名。 __syscall ：操作系统内部使用的函数调用模型，由用户模式向核心模式跳转时使用的模型。由于用户模式和核心模式使用不同的栈，所以没办法使用栈来传递参数，所有参数通过寄存器传递，这限制了参数的数量。用户模式编程中不允许使用。 __fortran ：数学运算语言 fortran 使用的函数模型，由此得名。在 C 中调用由 fortran 编译的函数时使用。 __clrcall ：微软 .Net 框架使用的函数模型，托管 (Managed)C++ 默认使用，也可以从非托管代码调用托管函数时使用。参数在托管栈上正序 ( 从左至右 ) 压栈，不使用普通栈。 CALLBACK 、 PASCAL 、 WINAPI 、 APIENTRY 、 APIPRIVATE ： I386 平台上是 __stdcall 的别名 WINAPIV ： I386 平台上是 __cdecl 的别名 7 函数调用模型的指定 函数调用模型的指定方式和 inline 关键字的指定方式相同，事实上， inline 可以被看作是 C++ 语言内建的一种函数调用模型。唯一不同的是，声明函数指针时，也要指明函数调用模型，而 inline 的指针是不能指明的，根本不存在指向 inline 函数的指针。比如： int CALLBACK GetVersion(); int ( CALLBACK * pf)()=GetVersion;","tags":"import"},{"loc":"//farseerfc.github.io/zhs/c-tricks-2-1-x86-architecture.html","title":"C++ Tricks 2.1 X86概述","text":"从 farseerfc.wordpress.com 导入 2.1 X86 概述 所谓 X86 体系结构，是指以 Intel 8086 芯片为首的芯片所沿袭的 CPU 结构，一些文档中又被称作 IA32 体系结构。包括的芯片有但不限于 :Intel 8086 至 80486 ，奔腾 (Pentium) 系列处理器 1 至 4 ，赛扬系列处理器，酷睿系列处理器，以及 AMD 的相应型号产品。 X86 体系结构在早期属于 16 位处理器，自 80386 之后扩展为 32 位处理器，所以一些文档中又把 80386 之后的 32 位处理器体系称作 I386 。自 Pentium4 后期， AMD 的 Athlon64 开始， I386 被进一步扩充为 64 位处理器，含有 64 位寻址能力的 X86 体系结构被称作 X86-64 或 IA32-64 。总之，市售的个人电脑用 CPU ，除苹果的 Macintosh 之外，全部采用 X86 体系结构芯片。 在 X86 早期， 16 位的寻址能力只支持 64KB(2&#94;16=64K) 内存，这显然是不够的。 Intel 采用分段寻址的方法，用 4 位段位 +16 位偏移量，提供了总共 1MB(2&#94;20=1M) 的寻址能力。所以在 X86 的 16 位编程中，有两种指针类型：长指针 (lp,long pointer) 和短指针 (sp,short pointer) ，长指针 (20 位 ) 提供整个内存空间寻址能力，短指针 (16 位 ) 仅支持同一段中的寻址。在 \" 古代 \"DOS 及 Win3.x 编程过程中，两种类型的指针，以及总共 1MB 的内存大小，常常把程序员们折腾得焦头烂额。 自 I386 之后， CPU 才开始提供 32 位的寻址能力。有了整整 4GB(2&#94;32=4G) 的寻址空间，所有指针统一为长指针 (32 位 ) 。时至今日，我们仍可以看到微软文档中指针变量的 lp 前缀。由于内存管理的需要，分段机制被保留下来，但这一次不是因为地址空间太小，而是因为地址空间远大于实际内存容量，从而采用了虚拟内存机制。 在从 16 位结构向 32 位结构转变的过程中，由于向下兼容的历史原因，曾一度长时间出现硬件 32 位 (I386) 、软件 16 位 (Win3.x) 的情况。同样也是为了兼容 16 位软件， Win9x 操作系统 (Win95 、 Win98 、 WinME) 保留了 16 位代码和 32 位代码。混合代码的设计使得 Win9x 及其混乱和不稳定。直到完全 32 位内核的操作系统 WinNT( 以及构建于其上的 Win2000 ， WinXP ， Win2003) 的出现， X86 平台上内存布局混乱的局面才得以改善。有了从 16 位至 32 位移植的经验和准备，现今的从 32 位到 64 位的操作系统移植显得平稳顺利很多。 WinXP 和 WinVista 系统都同时发布了 32 位版本和 64 位版本，并且其 x86-64 系统都实现了对 32 位软件的无缝衔接支持。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/c-tricks-1-2-trap-in-comma-logical-operator.html","title":"C++ Tricks 1.2 逗号运算符(,)、逻辑运算符(&&,||)与运算符重载的陷阱","text":"从 farseerfc.wordpress.com 导入 1.2 逗号运算符 (,) 、逻辑运算符 (&&,||) 与运算符重载的陷阱 很多人甚至不知道逗号 (,) 也是个 C++ 运算符。与语法上要求出现的逗号 ( 比如分隔函数参数的逗号 ) 不同的是，出现在表达式中的逗号运算符在语义上表示多个表达式操作的连续执行，类似于分隔多语句的分号。比如： for ( int i=0,j=9;i<10;++i , —j)std::cout<<i<<\"+\"<<j<<\"=9\\n\"; 在这句语句中，出现了两个逗号，其中前者是语法上用来分隔声明的变量的，并非逗号运算符，而后者则是一个逗号运算符。根据 C++ 标准，逗号运算符的执行顺序为从左到右依次执行，返回最后一个子表达式的结果。由于只有最后一个表达式返回结果，所以对于一个语义正常的逗号表达式而言，前几个子表达式必须具有副作用。同时，从语言的定义中也可以看出，逗号表达式对求值的顺序有严格要求。 对求值顺序有要求的，除了逗号表达式和条件表达式 ( 参见 1.1) ，在 C++ 中还有逻辑运算符 (&& 和 ||) 。逻辑运算相较于数学运算和位运算而言，有个显著的不同点：逻辑运算在计算到一半时，就有可能已经得到结果，这样继续运算另一半就不是必需的。对于 A&&B ，如果 A=false ，那么无论 B 为何值，整个的结果都是 false ；同样的 A||B ，如果 A=true ，那么不考虑 B ，结果一定是 true 。 C++ 标准规定，如果逻辑运算到一半 ( 算出 A) 时，就已经可以确定运算的结果，那么就不运算剩下的另一半 (B) 。这种执行语义被称作 \" 短路 \" 。在其它一些编程语言中，短路语义是可以选择的：在 Ada 里非短路的逻辑运算符为 and 和 or ，短路的逻辑运算符为 and_then 和 or_else 。但是在 C++ 中，逻辑运算符的短路语义是语法上强制的，我们没有非短路版本的运算符。如果确实需要非短路语义，我们总是可以通过增加一个 bool 中间变量加以解决。有时，短路对于保证正确执行是必须的，比如： char *p=getString(); if (p && *p)std::cout<<p; 这段代码在得到了一个字符串后，在字符串不为空时输出它。在 C++ 中判断一个字符串不为空需要两个步骤：判断指针是否为 0 ，以及指针不为 0 时判断指针指向的内容是否为 '' 。就像条件表达式中讨论到的 ( 参见 1.1) ，在 p 为空时提领 p 是个极其危险的操作。逻辑运算符的短路语义则避免了这种危险。 以上对逗号运算符与逻辑运算符的讨论，仅限于 C++ 标准所定义的运算符语义。为什么这样说呢？这是因为在 C++ 中，运算符的语义是可以由程序员自行定义的，这种机制叫做运算符重载 (operator overload) 。运算符重载可以将人们熟悉的运算符表达式转换成函数调用，使编程灵活而直观，是个方便的语言特性。不过有时运算符重载也会使人困扰，那就是当运算符重载遇到求值顺序问题时。 C++ 中，并不是所有合法运算符都可以被合法地重载。条件运算符虽然对求值顺序有要求，但它并不在可重载运算符之列，所以运算符重载机制对它没有影响。问题在于，逗号运算符和逻辑运算符都可以被合法地重载： class BadThing{/* Some Bad and Stupid Thing*/}; BadThing& operator ,(BadThing&, BadThing&);// 重载了逗号运算符 bool operator &&(BadThing&, BadThing&);// 重载了 && BadThing b1,b2; if (b1&&b2)b1,b2;// 被替换成如下形式： if ( operator &&(b1,b2)) operator ,(b1,b2); 可以看到，重载了运算符之后，对运算符的使用被替换为相应的函数调用形式。因此，旧有的运算符的执行顺序不再适用，取而代之的是函数参数的压栈顺序。 根据 C++ 标准规定，任何参数必须在进入函数之前压栈，所以在进入 operator && 之前， b1 、 b2 就会被求值，这里不再有短路规则，任何依赖于短路语义的不知不觉间操作 BadThing 的代码 ( 可能通过模板 ) 都会混乱。 短路语义只是一个方面，更重要的在于压栈顺序。鉴于执行效率和旧代码兼容性等细节问题， C++ 标准在压栈顺序上给编译器的开发者留有很大自主性。标准的说辞是，编译器可能以任何它觉得方便的顺序将参数压栈，从左到右，从右到左，甚至从中间到两边，在这一点上我们不能安全地做任何假设。在上面的例子中，编译器生成的代码可能先计算 b1 再计算 b2 ，也可能是相反的顺序。再看看编译器的实际情况，在我试过的所有基于 X86 体系结构的编译器中，参数都是以逆向压栈，即从右到左，有悖于大多数人的阅读习惯和直觉 ( 别说你是来自伊斯兰的 ……) 。 在 C 时代使用函数调用时，压栈顺序并不是什么大问题，毕竟大多数人会在函数调用的边界稍稍小心一些。但是到了 C++ 中，事情变得有些复杂，因为简单如 a+b 的使用，就有可能被运算符重载机制替换为函数调用。更何况有模板参与之后，我们写代码时不能确定对象的真实类型，也就无法预知一个运算符是否真的被重载过，唯一稳妥的方法是，假定任何有可能被重载的运算符的使用都是函数调用。 <p style=\"margin:0;\"> 回到上文的示例中，由于 , 和 && 都被替换为函数调用，程序的执行顺序将成为压栈顺序，在 X86 上很有可能是从右到左，与标准定义的运算符的顺序正好相反。逗号运算符原本就含有 \" 先 … 后 …\" 的语义，这种颠倒的执行顺序势必造成程序和程序员的混乱。以我的经验而言，含有 operator , 的类，完全没有办法和 STL 或者 iostream 相互协作，反而会导致巨量的错误报告 ( 什么叫巨量的错误报告有概念么？如果没有，那说明你还没玩过范式编程 ( GP , Generic Programming) 。去玩玩 GP 吧，看看你的编译器对巨量的定义。在我手头，针对 3.5KB 的代码文件倾泻出 3.8 MB 的错误信息的编译器不在少数 ……) 。有鉴于此，我的结论是，除非你有充足的依据支持你这么做 ( 比如你的粗暴上司的键盘上只剩下逗号能用 ) ，并且你清楚的了解这么做的后果的严重性 ( 比如至少要看过此文 ) ，否则我奉劝你，永远不要碰 operator , 、 operator && 以及 operator || ！","tags":"import"},{"loc":"//farseerfc.github.io/zhs/c-tricks-1-1-conditional-operator.html","title":"C++ Tricks 1.1 条件运算符(?:)","text":"从 farseerfc.wordpress.com 导入 1.1 条件运算符 (?:) 条件运算符 (?:) 是 C++ 中唯一的三目运算符 (trinary operator) ，用于在表达式中作条件判断，通常可以替换 if 语句，与 Visual Basic 中的 iif 函数、 Excel 中的 if 函数有同样的作用。语法形式如下： condition ? true_value : false_value 其中 condition * 条件是任何可以转换为 bool 类型的表达式，包括但不仅限于 **bool* 、 int 、指针。与 if 和 while 的条件部分稍显不同的是，这里不能定义变量，否则会导致语法错误。 另外，条件语句会切实地控制执行流程，而不仅仅是控制返回值。也就是说，两个返回值表达式中永远只有一个会被求值，在表达式的执行顺序很重要时，这点尤为值得注意。比如： int *pi=getInt(); int i=pi ? *pi : 0; 这里，只有当 pi 的值不为 0 时，它才会被提领 (dereference) 。这种语义保证了程序的正确性，因为提领一个空指针将导致致命的运行期错误 ( 通常是非法操作的警告 ) 。同时，正因为条件运算符控制运算流程的特点，使得它不能用类似 iif 的普通函数来模拟： int iif( int con, int t, int f){ if (c) return t; return f;}// 试图模拟 ?: …//in some function int *pi=getInt(); int i=iif(pi,*pi,0);//Error! 这段代码会导致上文提到的致命运行期错误。 C/C++ 标准规定，参数在被传递给函数之前求值，因此无论 pi 为何值，都会被提领。又因为函数传回一个空指针的情况比较少见，所以这样的错误在调试时很难被发现，一旦发生又势必造成重大灾难。这样的代码在实践中应尽量避免。 有时，条件运算符控制流程的特点会不知不觉影响我们的代码。在 C 时代，最大值 MAX 通常用宏实现： #define MAX (a,b) ((a)>(b) ? (a) : (b)) 需要用额外的括号将宏参数和宏本体保护起来，以免运算符优先级扰乱逻辑，这是宏丑陋的特点之一，这里暂且不提。矛盾在于，用具有副作用的表达式调用宏时，会出现问题： int i=5,j=6;//… int a= MAX (++i,++j); 代码的作者原意显然是想先将 i,j 分别递增，再将其中较大的一个赋给 a 。执行这段代码，当 i=5,j=6 时， a=8 ，知道为什么吗？通过宏展开，赋值语句成这样： int a=(++i)>(++j) ? (++i) : (++j);// 删除了多余括号 在判断之前， i 、 j 被分别自增一次，然后舍弃 : 之前的部分， j 又被自增一次。执行之后， i=6,j=8 。 MAX 的更正确更安全的实现，是利用模板将类型参数化。 STL 标准算法中就有一个这样的工具级模版函数 std::max 。 条件运算符是表达式而不是语句，这使得它可以出现在任何需要表达式的地方，这扩大了它的适用范围。在那些语法上只能出现表达式而不能出现语句的地方（比如变量初始化），条件运算符有着不可替代的作用。 条件运算符优于 if 语句的另一个场合是 \" 模板元编程 \"( TMP , Template MetaProgramming) 。在 TMP 这个古怪奇异的编译期运算编程技术中，一切旧有的技术和法则被全线击破，我们所能仰仗的工具，只有模板特化 (Specialization) 、 typedef s 、函数声明 ( 无法调用它们 ) 、以及编译期常量运算。已经有人很深入地论证过，仅有以上这些，就已经形成了一个 \" 图灵完善 \" 的计算机语言。我们可以用模板特化技术，来模拟条件分支，循环迭代等一系列复杂的语言结构。由于可以参与编译期常量运算，条件运算符在 TMP 世界中很自然地扮演起重要角色。 比如，给与类型 T 的一个变量 t ，我们想声明一个缓冲区存放 t 和一个 int ，缓冲区的大小不小于 sizeof(T) 也不小于 sizeif(int) ，我们可以这样写： char buffer[sizeof(T)>sizeof(int)? sizeof(T): sizeof(int)]; 我们不能用一个 if 语句替换这个运算： int i; if(sizeof(T)>sizeof(int))i=sizeof(T); else i=sizeof(int); char buffer[i];// 语法错误 ! 原因在于数组声明中的下标必须是一个编译期常量，而不是一个运行期的值，条件表达式的运算可以在编译期进行， if 语句就只能在执行期执行。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/filling-believings-calling-conscience.html","title":"填补信仰、唤醒良知","text":"从 farseerfc.wordpress.com 导入 填补信仰、唤醒良知 我们听尽了呼吁与号召，对于良知，我不必谴责丧失它的国人，不必盛赞良知的美好。我只想讨论，丧失了良知的原因 —— 空缺的信仰。 一、空缺信仰丧失良知 现代的国人缺少信仰，以至于丧失良知。曾几何时，中华民族由良好的信仰凝聚而成。三皇五帝时，族民们以炎黄为信仰；春秋战国时，士大夫之族以周制礼乐为信仰；汉代以后，百姓延习孔孟之说、老聃之道，以儒家学说为信仰；自大唐起，以佛教为首的现代宗教纷纷传入中原，人民开始以它们作为信仰。 直至鸦片战争、五四运动，西方文化入侵中华，国人开始抛弃国学，转而去研究科学；文化大革命，十年文化浩劫，人们批判旧的信仰，却没有合适的新的信仰前来填补。从此，国人的信仰出现空缺，国人的良知也被一块块蚕食殆尽。 二、信仰、科学、迷信 在许多国人的心目中，信仰就等于迷信。从小到大的教育告诉我们，信奉宗教是愚昧而又无知的表现，科学与信仰是矛盾的。是么？ 我们无法保证社会上的每一个人都接受过良好的教育，我们无法确信最前沿的科学素养能在民众中普及。在科普与教育力不从心的社会死角，在科学技术尚不能及的文化盲区，我们依旧需要信仰的规范与限制，我们的良知需要信仰！ 信仰不等于迷信。信仰本身无所谓谜与不迷，迷信是持有信仰的人误解了信仰，盲目遵从的结果。以为烧过香就可以免遭祸患，以为捐了钱就可以升入天堂，以为引火自焚就可以功德圆满，这便是迷信了。希特勒曾经的人类完善计划，依照遗传学的原理，将科学家与运动员强行结为夫妇孕育生命，希望得到最优秀的人类种族，这便是对科学这种信仰的迷信！ 由此可见，科学与信仰并不是矛盾的硬币的两面，从某种意义而言科学本身也是信仰的一种。虽然历史上宗教往往作为科学发展的阻碍，可信奉真理的信念一直是推动科学发展的动力。牛顿就曾说过，对自然规律的探询是为了更接近上帝。由此可见，信仰与真理，与良知毫无矛盾。 三、信仰唤醒良知 很少有人仔细思考过，良知的缺失是由信仰的缺失造成的。信仰是人思想的寄托与依靠，是人行动处世的准则。没有了信仰的人，思想行为就缺少了约束的标准，人就更容易因为一时不成熟的冲动，背叛良知、铸成错误。 泰国人以佛教为信仰，泰国的寺庙每天都会有成千上万人顶礼膜拜。寺庙有一个人尽皆知的不成文规定：不得穿鞋进入。于是在寺庙之外，游客们可以看到千百双各式的鞋子有序的摆放在门口。国人每每看到此景，总会诧异地问：没有人会偷鞋么？得到的答案极为简单：庙前偷鞋会遭报应。由于拥有信仰，泰国人作了坏事会受到良知的谴责，泰国商人售出假货会彻夜难眠。二战期间，无数犹太难民被天主教会收留藏匿从而侥幸逃生，这同样是出于，天主教徒们被自己信奉的教义 \" 众生生来平等 \" ，所唤醒的良知。 天下无贼的世界，不能仅靠科普说教来营造。如果脱离了信仰，纵使是教育也无法培养良知。我问过许多修化学的同学，学习化学的意义，结论竟是为了考试。如果没有对科学的信仰，我们可以牢记公式定理，却质疑它们是真理；如果没有对社会公德的信仰，我们可以熟背交通规则，却正大光明地闯红灯；如果没有对医疗道德的信仰，医生可以放任伤口发炎，从而留住病人继续治疗 …… 国人需要信仰的约束，需要填补信仰的空白，从而唤醒那深埋于每个国人内心深处的良知！","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../from-unbuffered-stdin-to-history-of-linux-tty.html","title":"從非緩衝輸入流到 Linux 控制檯的歷史","text":"這篇也是源自於水源 C 板上板友的一個問題，涉及 Linux 上的控制檯的實現方式和歷史原因。因爲內容比較長，所以在這裏再排版一下發出來。 原帖在這裏 。 可以設置不帶緩衝的標準輸入流嗎？ WaterElement(UnChanged) 於 2014 年 12 月 09 日 23:29:51 星期二 問到： 請問對於標準輸入流可以設置不帶緩衝嗎？比如以下程序 #include <stdio.h> #include <unistd.h> int main ( int argc , char * argv []) { FILE * fp = fdopen ( STDIN_FILENO , \"r\" ); setvbuf ( fp , NULL , _IONBF , 0 ); char buffer [ 20 ]; buffer [ 0 ] = 0 ; fgets ( buffer , 20 , fp ); printf ( \"buffer is:%s\" , buffer ); return 0 ; } 似乎還是需要在命令行輸入後按回車纔會讓 fgets 返回，不帶緩衝究竟體現在哪裏？ 這和緩存無關，是控制檯的實現方式的問題。 再講細節一點，這裏有很多個程序和設備。以下按 linux 的情況講： 終端模擬器窗口（比如 xterm ）收到鍵盤事件 終端模擬器 (xterm) 把鍵盤事件發給虛擬終端 pty1 pty1 檢查目前的輸入狀態，把鍵盤事件轉換成 stdin 的輸入，發給你的程序 你的程序的 c 庫從 stdin 讀入一個輸入，處理 標準庫說的輸入緩存是在 4 的這一步進行的。而行輸入是在 3 的這一步被緩存起來的。 終端 pty 有多種狀態，一般控制檯程序所在的狀態叫「回顯行緩存」狀態，這個狀態的意思是 : 所有普通字符的按鍵，會回顯到屏幕上，同時記錄在行緩存區裏。 處理退格 ( BackSpace ) ，刪除 ( Delete ) 按鍵爲刪掉字符，左右按鍵移動光標。 收到回車的時候把整個一行的內容發給 stdin 。 參考： http://en.wikipedia.org/wiki/Cooked_mode 同時在 Linux/Unix 下可以發特殊控制符號給 pty 讓它進入「 raw 」狀態，這種狀態下按鍵不會被回顯，顯示什麼內容都靠你程序自己控制。如果你想得到每一個按鍵事件需要用 raw 狀態，這需要自己控制回顯自己處理緩衝，簡單點的方法是用 readline 這樣的庫（基本就是「回顯行緩存」的高級擴展，支持了 Home/End ，支持歷史）或者 ncurses 這樣的庫（在 raw 狀態下實現了一個簡單的窗口 / 事件處理框架）。 參考： http://en.wikipedia.org/wiki/POSIX_terminal_interface#History 除此之外， Ctrl-C 轉換到 SIGINT ， Ctrl-D 轉換到 EOF 這種也是在 3 這一步做的。 以及，有些終端模擬器提供的 Ctrl-Shift-C 表示複製這種是在 2 這一步做的。 以上是 Linux/unix 的方式。 Windows 的情況大體類似，只是細節上有很多地方不一樣： 窗口事件的接收者是創建 cmd 窗口的 Win32 子系統。 Win32 子系統接收到事件之後，傳遞給位於命令行子系統的 cmd 程序 cmd 程序再傳遞給你的程序。 Windows 上同樣有類似行緩存模式和 raw 模式的區別，只不過實現細節不太一樣。 strace 查看了下 WaterElement(UnChanged) 於 2014 年 12 月 10 日 21:53:54 星期三 回復： 感謝 FC 的詳盡解答。 用 strace 查看了下，設置標準輸入沒有緩存的話讀每個字符都會調用一次 read 系統調用， 比如輸入 abc ： read(0, abc \"a\", 1) = 1 read(0, \"b\", 1) = 1 read(0, \"c\", 1) = 1 read(0, \"\\n\", 1) = 1 如果有緩存的話就只調用一次了 read 系統調用了： read(0, abc \"abc\\n\", 1024) = 4 如果想感受一下 raw mode 沒錯，這個是你的進程內 C 庫做的緩存， tty 屬於字符設備所以是一個一個字符塞給你的 程序的。 如果想感受一下 raw mode 可以試試下面這段程序（沒有檢測錯誤返回值） #include <stdio.h> #include <unistd.h> #include <termios.h> static int ttyfd = STDIN_FILENO ; static struct termios orig_termios ; /* reset tty - useful also for restoring the terminal when this process wishes to temporarily relinquish the tty */ int tty_reset ( void ){ /* flush and reset */ if ( tcsetattr ( ttyfd , TCSAFLUSH , & orig_termios ) < 0 ) return - 1 ; return 0 ; } /* put terminal in raw mode - see termio(7I) for modes */ void tty_raw ( void ) { struct termios raw ; raw = orig_termios ; /* copy original and then modify below */ /* input modes - clear indicated ones giving: no break, no CR to NL, no parity check, no strip char, no start/stop output (sic) control */ raw . c_iflag &= ~ ( BRKINT | ICRNL | INPCK | ISTRIP | IXON ); /* output modes - clear giving: no post processing such as NL to CR+NL */ raw . c_oflag &= ~ ( OPOST ); /* control modes - set 8 bit chars */ raw . c_cflag |= ( CS8 ); /* local modes - clear giving: echoing off, canonical off (no erase with backspace, &#94;U,...), no extended functions, no signal chars (&#94;Z,&#94;C) */ raw . c_lflag &= ~ ( ECHO | ICANON | IEXTEN | ISIG ); /* control chars - set return condition: min number of bytes and timer */ raw . c_cc [ VMIN ] = 5 ; raw . c_cc [ VTIME ] = 8 ; /* after 5 bytes or .8 seconds after first byte seen */ raw . c_cc [ VMIN ] = 0 ; raw . c_cc [ VTIME ] = 0 ; /* immediate - anything */ raw . c_cc [ VMIN ] = 2 ; raw . c_cc [ VTIME ] = 0 ; /* after two bytes, no timer */ raw . c_cc [ VMIN ] = 0 ; raw . c_cc [ VTIME ] = 8 ; /* after a byte or .8 seconds */ /* put terminal in raw mode after flushing */ tcsetattr ( ttyfd , TCSAFLUSH , & raw ); } int main ( int argc , char * argv []) { atexit ( tty_reset ); tty_raw (); FILE * fp = fdopen ( ttyfd , \"r\" ); setvbuf ( fp , NULL , _IONBF , 0 ); char buffer [ 20 ]; buffer [ 0 ] = 0 ; fgets ( buffer , 20 , fp ); printf ( \"buffer is:%s\" , buffer ); return 0 ; } 終端上的字符編程 vander( 大青蛙 ) 於 2014 年 12 月 12 日 08:52:20 星期五 問到： 學習了！ 進一步想請教一下 fc 大神。如果我在 Linux 上做終端上的字符編程，是否除了用 ncurses 庫之外，也可以不用該庫而直接與終端打交道，就是你所說的直接在 raw 模式？另外，終端類型 vt100 和 linux 的差別在哪裏？爲什麼 Kevin Boone 的 KBox 配置手冊裏面說必須把終端類型設成 linux ，而且要加上 terminfo 文件，才能讓終端上的 vim 正常工作？ term info 文件又是幹什麼的？ Linux 控制檯的歷史 嗯理論上可以不用 ncurses 庫直接在 raw 模式操縱終端。 這裏稍微聊一下 terminfo/termcap 的歷史，詳細的歷史和吐槽參考 Unix hater's Handbook 第 6 章 Terminal Insanity 。 首先一個真正意義上的終端就是一個輸入設備（通常是鍵盤）加上一個輸出設備（打印機或者顯示器）。很顯然不同的終端的能力不同，比如如果輸出設備是打印機的話，顯示出來的字符就不能刪掉了（但是能覆蓋），而且輸出了一行之後就不能回到那一行了。再比如顯示器終端有的支持粗體和下劃線，有的支持顏色，而有的什麼都不支持。早期 Unix 工作在電傳打字機（ TeleTYpe ）終端上，後來 Unix 被 port 到越來越多的機器上，然後越來越多類型的終端會被連到 Unix 上，很可能同一臺 Unix 主機連了多個不同類型的終端。由於是不同廠商提供的不同的終端，能力各有不同，自然控制他們工作的方式也是不一樣的。所有終端都支持回顯行編輯模式，所以一般的面向行的程序還比較好寫，但是那時候要撰寫支持所有終端的「全屏」程序就非常痛苦，這種情況就像現在瀏覽器沒有統一標準下寫 HTML 要測試各種瀏覽器兼容性一樣。 通常的做法是 使用最小功能子集 假設終端是某個特殊設備，不管別的設備。 水源的代碼源頭 Firebird2000 就是那樣的一個程序，只支持固定大小的 vt102 終端。 這時有一個劃時代意義的程序出現了，就是 vi ，試圖要做到「全屏可視化編輯」。這在現在看起來很簡單，但是在當時基本是天方夜譚。 vi 的做法是提出一層抽象，記錄它所需要的所有終端操作，然後有一個終端類型數據庫，把那些操作映射到終端類型的具體指令上。當然並不是所有操作在所有終端類型上都支持，所以會有一堆 fallback ，比如要「強調」某段文字，在彩色終端上可能 fallback 到紅色，在黑白終端上可能 fallback 到粗體。 vi 一出現大家都覺得好頂讚，然後想要寫更多類似 vi 這樣的全屏程序。然後 vi 的作者就把終端抽象的這部分數據庫放出來形成一個單獨的項目，叫 termcap （ Terminal Capibility ），對應的描述終端的數據庫就是 termcap 格式。然後 termcap 只是一個數據庫（所以無狀態）還不夠方便易用，所以後來又有人用 termcap 實現了 curses 。 再後來大家用 curses/termcap 的時候漸漸發現這個數據庫有一點不足：它是爲 vi 設計的，所以只實現了 vi 需要的那部分終端能力。然後對它改進的努力就形成了新的 terminfo 數據庫和 pcurses 和後來的 ncurses 。然後 VIM 出現了自然也用 terminfo 實現這部分終端操作。 然後麼就是 X 出現了， xterm 出現了，大家都用顯示器了，然後 xterm 爲了兼容各種老程序加入了各種老終端的模擬模式。不過因爲最普及的終端是 vt100 所以 xterm 默認是工作在兼容 vt100 的模式下。然後接下來各種新程序（偷懶不用 *curses 的那些）都以 xterm/vt100 的方式寫。 嗯到此爲止是 Unix 世界的黑歷史。 知道這段歷史的話就可以明白爲什麼需要 TERM 變量配合 terminfo 數據庫纔能用一些 Unix 下的全屏程序了。類比一下的話這就是現代瀏覽器的 user-agent 。 然後話題回到 Linux 。大家知道 Linux 早期代碼不是一個 OS ，而是 Linus 大神想在他的嶄新蹭亮的 386- PC 上遠程登錄他學校的 Unix 主機，接收郵件和逛水源（咳咳）。於是 Linux 最早的那部分代碼並不是一個通用 OS 而只是一個 bootloader 加一個終端模擬器。所以現在 Linux 內核裏還留有他當年實現的終端模擬器的部分代碼，而這個終端模擬器的終端類型就是 linux 啦。然後他當時是爲了逛水源嘛所以 linux 終端基本上是 vt102 的一個接近完整子集。 說到這裏脈絡大概應該清晰了， xterm 終端類型基本模擬 vt100 ， linux 終端類型基本模擬 vt102 。這兩個的區別其實很細微，都是同一個廠商的兩代產品嘛。有差別的地方差不多就是 Home / End / PageUp / PageDown / Delete 這些不在 ASCII 控制字符表裏的按鍵的映射關係不同。 嗯這也就解釋了爲什麼在 linux 環境的圖形界面的終端裏 telnet 上水源的話，上面這些按鍵會錯亂 …… 如果設置終端類型是 linux/vt102 的話就不會亂了。在 linux 的 TTY 裏 telnet 也不會亂的樣子。 寫到這裏纔發現貌似有點長 …… 總之可以參考 Unix hater's Handbook 裏的相關歷史評論和吐槽，那一段非常有意思。","tags":"linux"},{"loc":"//farseerfc.github.io/zhs/../en/jumping-kde5-plasma-activities-button.html","title":"Jumping KDE5 Plasma Activities Button","text":"I found this when using activities under KDE5 today. One can drag the activities button out of the edge of the screen, then it will jump back and forth at the edge. Here is a video: Of course you can drag it back, so it is not a serious problem. It is just so cute that I had to note this. By comparison, the jumping window in Gnome3 is far worse than this: BTW , I saw another cute translation error of mute screen in KDE5 : KDE5 のミュート画面の中国語翻訳、「静音」のはずだが「镜音」になっている。 Vocaloid ファンのネタだか、単なる入力ミスだか分からない。 pic.twitter.com/ipyHjXMscR — Jiachen YANG (@farseerfc) 2014 12 月 8 日","tags":"linux"},{"loc":"//farseerfc.github.io/zhs/../jp/jumping-kde5-plasma-activities-button.html","title":"KDE5 Plasma の踊る活動ボタン","text":"今日 KDE5 Plasma の「活動」を切り替えている際に偶々この現象を発見しました。この活動ボタンを画面の外に持ち出すと、デスクトップの縁で踊り出します。 ビデオはこちらに： 勿論画面の中に引っ張ってきたら問題はなくなるので、大したバグではない。単なる面白い現象です。 この前に Gnome3 にも画面がおかしくなるバグがありました。それを比べて KDE5 のほうはよぽと増しと思います。 ちなみにですが、 KDE5 Plasma のミュート画面の中国語翻訳もなかなか面白いミスがございます： KDE5 のミュート画面の中国語翻訳、「静音」のはずだが「镜音」になっている。 Vocaloid ファンのネタだか、単なる入力ミスだか分からない。 pic.twitter.com/ipyHjXMscR — Jiachen YANG (@farseerfc) 2014 12 月 8 日","tags":"linux"},{"loc":"//farseerfc.github.io/zhs/../jumping-kde5-plasma-activities-button.html","title":"KDE5 Plasma 之跳動賣萌的活動按鈕","text":"今天嘗試 KDE5 Plasma 的活動的時候無意間發現這個現象。只要把活動按鈕拖出桌面，它就會在桌面邊緣來回跳動。 視頻如下： 當然你可以把它再拖回來，所以這個問題還無傷大雅，只是賣萌。 比比之前 Gnome3 那個跳動的界面真是好太多了： 順便，今天還看到一個賣萌的 KDE5 Plasma 靜音圖標的翻譯： KDE5 のミュート画面の中国語翻訳、「静音」のはずだが「镜音」になっている。 Vocaloid ファンのネタだか、単なる入力ミスだか分からない。 pic.twitter.com/ipyHjXMscR — Jiachen YANG (@farseerfc) 2014 12 月 8 日","tags":"linux"},{"loc":"//farseerfc.github.io/zhs/../en/marry-me.html","title":"Will You Marry Me?","text":"Above is a image, the playable version is below: * Use WASD ←→ to move ， need WebGL support","tags":"life"},{"loc":"//farseerfc.github.io/zhs/../jp/marry-me.html","title":"嫁になってくれませんか？","text":"上のは飾りだけ、遊べるのはこれ： * WASD ←→ で移動する， WebGL が必要","tags":"life"},{"loc":"//farseerfc.github.io/zhs/../marry-me.html","title":"嫁給我好麼","text":"上面那個是裝飾 …… 可以玩的是下面這個： * 用 WASD ←→ 移動，需要 WebGL 支持","tags":"life"},{"loc":"//farseerfc.github.io/zhs/../icse2012.html","title":"ICSE 2012","text":"June 6 Keynote 1 沒怎麼聽懂，只記得講到了 finance is not money 但是沒聽懂這個和軟件有什麼關係。 Cost Estimation for Distributed Software Project 講到他們試圖改善現有的模型去更精確地評估軟件開發的開銷。 他們會給 PM 建議之前的項目的歷史數據，然後對於新項目，他們建議歷史上已有的項目的數據，從而幫助 PM 得到更精確的評估。他們試圖儘量減少項目評估對 PM 的經驗的需求，從而幫助即使經驗很少的 PM 也能準確評估項目的開銷。 他們的觀點： Context-specfic solutions needed! 我們需要更上下文相關的解決方案！ Early user paticipation is key! 早期用戶的參與是關鍵 Characterizing Logging Practices in Open-Source Software Common mistakes in logging messages 在日誌記錄中容易犯的錯誤 他們學習了歷史上的 log 記錄，然後試圖找到重複修改的輸出 log 的語句，確定 log 中存在的問題。他們首先確定修改是事後修改。 通常的修改的比例（ 9027 個修改） 45% 靜態文本 27% 打印出的變量 26% 調試等級 verbosity 2% 日誌輸出的位置 他們發現有調試等級的變化，是因爲安全漏洞之類的原因，或者在開銷和數據 之間的權衡。 大多數對 log 的變量的修改都是爲了增加一個參數。他們之前的 LogEnhancer 是爲了 解決這個問題而提出的，通過靜態檢查，提醒程序員是否忘記了某個參數 對 text 的修改是因爲要改掉過時的代碼信息，避免誤導用戶。 他們的實驗是採用了基於 code clone 的技術，找到所有 log 語句，然後找不一致 的 clone ，然後自動提出建議。 Combine Functional and Imperative Pgrm for Multicore Sw: Scala & Java 趨勢：到處都是多核，但是併發程序呢？ 他們研究的對象是 Scala 和 Java ，因爲可以編譯後確認 JVM 字節碼的語義。 Java: 共享內存 顯示創建的線程 手動同步 Wait/Notify 機制 Scala: 高階函數 Actors, 消息傳遞 lists, filters, iterators while 共享狀態 , OO import java.* 能從 java 導入任何庫 auto type inferance 自動類型推導 實驗的參與者都經過 4 周的訓練，實驗項目是工業等級的開發項目 結果： scala 的項目平均比 java 多花 38% 的時間，主要都是花在 Test 和 debug 上的時間。 程序員的經驗和總體時間相關，但是對 test 和 debug 沒有顯著影響。 scala 的爲了讓編程更有效率的設計，導致 debug 更困難。比如類型推導， debug 的時候需要手動推導，來理解正在發生什麼。 scala 的程序比 java 小，中位數 2.6% ，平均 15.2% 性能比較： 單核： scala 的線性程序的性能比 java 好 4 核： scala 7s @ 4 threads java 4si @ 8 threads median 83s scala 98s java 32core: best scala 34s @ 64 threads 結論 java 有更好的 scalability scala 類型推導 45% 說對攜帶碼有幫助 85% 說導致程序錯誤 調試 23% 認爲 scala 簡單 77% 認爲 java 簡單 multi-paradigram are better Sound Empirical Evidence in Software Testing Test data generation 測試數據自動生成 Large Empirical Studies - not always possible For open source software - big enough Identifing Linux Bug Fixing Patch current practice: manual Current research: keywords in commits link bug reports in bugzilla Try to solve classification problem issue pre-identified post-identified data from commit log feature extraction text pre-process stemmed non-stop words model learning research questions Active Refinement of Clone Anomaly Reports motivating code clones, clone groups clone used to detect bugs anomaly : inconsistent clone group many anomaly clone are note bug, high false positive approach reorder by sorted bug reports June7 Keynotes 2: Sustainability with Software - An Industrial Perspective Sustainability Classic View: Idenpendent view with overlap Social Environment Economic Nested viw Environment Social Economic Triple bottom line economic -global business, networks , global econ env natural res, climate change, population grow social awareness, connectivity, accountability Green IT reduce IT energy more than 50% cooling - doing nothing mini e-waste: not properly recycled 80% in EU 75% in US foster dematerialization In-Memory Technology: Expected Sustainable Benefits What can we do? consider all software lifecycle phases in your design avoid energy expensive behavior in your codes design lean architectures Green by IT 2% green IT 98% green IT On How Often code is cloned across repositories Line based hashing code clone detection never do anything harder than sorting hashing a window of 5 lines of normalized (tokenized) code, dropping 3/4 of the hashing 把 ccfinder 一個月的工作縮短到了 3, 4 天。沒有比較 presion 和 recall 。 14% type1 16% type2 17% type3 (not really type2) Graph-based analysis and prediction for sw evolution graph are everywhere internet topology social net chemistry biology in sw - func call graph - module dependency graph developer interaction graph - commit logs - bug reports experiment 11 oss, 27~171 release, > 9 years predictors NodeRank similar to pagerank of google measure relative importance of each node func call graph with noderank compare rank with severity scale on bugzilla correlation between noderank and BugSeverity func level 0.48 ~ 0.86 varies among projects. model level > func level ModularityRatio cohesion/coupling ratio: IntraDep(M)/InterDep(M) forecast mantencance effort use for identify modules that need redesign or refactoring EditDistance bug-based developer collaboration graphs ED (G1,G2)=|V1|+|V2|-2|V1 交 V2|+|E1|+|E2|-2|E1 交 E2| use for release planning resource allocation graph metrics graph diameter average node degree indicates reuse clustering coefficient assortativity num of cycles Conclusion \"Actionable intelligence\" from graph evolution studie 11 large long-live projs predictors identify pivotal moments in evolution What make long term contributors: willingness and opportunity in OSS OSS don't work without contributors form community mozilla (2000-2008) 10&#94;2.2 LTC <- 2 order -> 10&#94;4.2 new contributors <- 3.5 order -> 10&#94;7.7 users gnome (1999-2007) 10&#94;2.5 LTC <- 1.5 order -> 10&#94;4.0 new contributors <- 3.5 order -> 10&#94;6.5 users approach read issues of 20 LTC and 20 non- LTC suvery 56 (36 non- LTC and 20 LTC ) extract practices published on project web sites summeray Ability/Willingness distinguishes LTCs Environment macro-climate popularity micro-climate attention bumber of peers performance of peers regression model newcomers to LTC conversion drops actions in first month predicts LTCs 24% recall 37% precision develop of auxiliary functions: should you be agile? a empirial assessment of pair programming and test-first programming can agile help auxiliary functions? experiment pair vs solo test-first vs test-last students vs professors research questions r1: can pair help obtain more correct impl r2: can test-first r3: dst test1 encourage the impl or more test cases? r4: does test1 course more coverage result test-first higher coverage non change with correctness pair improve on correctness longer total programming time Static Detection of Resource Contention Problems in Server-side script Addressed the race condition of accessing database or filesystem of PHP Amplifying Tests to Validate Exception Handling Code 異常處理的代碼不但難寫，而且難以驗證。各種組合情況難以估計，尤其是手機 系統上。 A tactic-centric approach automating traceability of quality concerns tactic traceability information models","tags":"life"},{"loc":"//farseerfc.github.io/zhs/../en/msr2012.html","title":"MSR 2012 @ ICSE","text":"Mining Software Repository 2012 @ ICSE I participated MSR of this year. We came to University of Zurich early in the morning. The registration got something wrong when it seems that Swisses cannot tell the difference among Asians so that name cards of 3 Chinese with family name of Yang are misplaced. And also the organization field of Hotta was \"Japan, Japan\", as if he represented the Japan. MSR (MicroSoft Research) talk @ MSR (Mining Software Repositories) The first talk was the keynote given by Mrs Zhang from MSR (MicroSoft Research @ Asia), so it turned out to be MSR gave keynote of MSR . The talk was about Software Analysis and their clone detection tool called XIAO . XIAO was a clone detector developed by MSRA which can be used as a plugin for Microsoft Visual Studio. XIAO has two part, or system state: the statics state analysis all the clones which didn't consider the running time, while the dynamic state need real time response. The thing I need to develop for Samsung is something like dynamic mode. I wanted to know more about the internal details about XIAO but the talk was finished there. Towards Improving BTS with Game Mechanisms The contents of this talk is very much like this blog: http://www.joelonsoftware.com/items/2008/09/15.html The talk discussed whether the same game mechanism can be applied to the things like issue tracking or similar. From my point of view, it is useless to use game mechanism in this situation. The reason that stackoverflow can success lies on that they just captured the use of fade system in opensource community, as all hackers like to be approved as great hacker, as what is happening in Wikipedia. Whether the same theory can be applied in issue tracking systems inside a internal company is questionable. Although MSDN has basic the same structure as Wikipedia, the content of MSDN and Wikipedia have different involvement of users. So I myself didn't approve this research. GHTorrent They slide of this talk can be found from here: http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524 Data exporter for github. Main part of data of Github, namely the hosted code, are already exposed as git repos, and wiki of repos are stored in git repo. So the aim of this project is to expose other data such as issues, code comments, etc. The project access github api and fetch the needed data as distributed system in order to overcome the limitations of the github api. The project will provide download history as torrents. The json data from github api is stored as bson in MongoDB and the parsed data is stored in MySQL with schema. From my point of view, it will be better if the format of data can be uniformed and all data are stored in the git repo as wiki pages. As the history stored in git repo is more nature, and using git blame to trace author of code comments should also be more useful. Of course it is harder to read and write the raw data of git as we need more understanding of the internal format of git. Maybe only people from github can do this. Topic Mining I can not understand the two parameters, DE , AIC , used in this research, study this later. The experiment target of this research are Firefox, Mylyn and Eclipse. They are trying to analysis the identifiers and comments from source codes in software repos and find the relationship between topics and bugs, like what kind of topics are more likely to contain buggy codes. The result of this research is not so clear. Such as it said that the core functions of Firefox have more bug reports, but it said no reason about this. Maybe this only means that the core features are well tested, rather than that the core features are more buggy. But the slides showed by author are pretty and easy to understand. The evolution of software The keynote talk of the second day. It is about how should we combine the social media with software development. Maybe this is the reason why Github succeeded. In the talk she told about accessing tags, uBlogs, blogs etc. directly from Integrated Development Environments, or should we need cloud IDE such as Cloud9. Do Faster Releases Improve Software Quality? Used Firefox as example. The conclusion is that faster releases will lead to more bugs and more frequent crash, but bugs are get fixed more quickly and user will switch to new released more quickly. Security vs Performance Bugs in Firefox Performance bugs are regression, blocks release. Some of my thoughts Separation of commits based on Semantic analysis The user of some tools (such as git) are not following the design purposes of these tools which brings some difficulty to MSR . For example git has a prefect branch system, so it is desired for users of git to commit per topic. Commit per topic means that user send a commit for a single implementation of a feature or a bug fix, etc. If it is difficult to contain all modifications in a commit, then it should be in a separate branch and merged into master branch. But actually user tends to send very large commits, that contains many logical features, and they can not predict to open a new branch until a few commits. Maybe this is not the fault of the user of tools, this is the tools that are not smart enough. We should separate the commits according to the semantic topics inside a commit. About the slide systems used today The study with title Incorporating Version Histories in Information Retrieval Based Bug Localization used the slides made by beamer. It contains many equations, used many overlays are iterations, with few figures, is a typical beamer slide. It also used mindmap very well. There are at least 3 slides that are made by beamer today. The study with title Towards Improving Bug Tracking Systems with Game Mechanisms presented with prezi. It have many pictures and many transitions. But because of it is made by prezi, there are no headers and footers so no page numbers and section titles etc. This is not so convenient in such a official occasions because people need to refer to the page number in question session. There are at lease 6 presents used Apple Keynote. It is really difficult to tell the difference between slides made by PowerPoint and Keynote. 2 of them used the default theme of keynote. The rest are using PowerPoint. Mrs Zhang from Microsoft used PowerPoint but her slides looks like beamer very much such as the usage of footer and header and overlays. If these are made by PowerPoint that will involve many manually operations. It is worth to mention that the slides of a study with title Green Mining: A Methodology of Relating Software Change to Power Consumption are all badly drawn hand paintings. The effect of these slide are well received, they are green and clean and cute. You can refer to the following animation for the effect but it is not exactly the same version with what we saw : http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv Microsoft is MEANING It is not a news. But Microsoft is the sponsor of Mining Challenge, and the prize of this challenge will be Xbox and Kinect and the topic of this year is: Mining Android Bug I see what you are doing there Microsoft ……","tags":"life"},{"loc":"//farseerfc.github.io/zhs/../jp/msr2012.html","title":"MSR 2012 @ ICSE","text":"Mining Software Repository 2012 @ ICSE 今年の MSR を参加しました、会場はチューリッヒ大学にあります。朝早く大学に着いて、登録するときちょっと事情をありました。スイス人は明らかに中国人の名前をわからないから、３つの中国からの楊（ Yang ）の名札を間違えた。そして堀田先輩の名札に \"Japan, Japan\" になって、日本代表になった。 MSR (MicroSoft Research) talk @ MSR (Mining Software Repositories) まず一番目の Keynote はマイクロソフトアジア研究院 (MicroSoft Research @ Asia , MSR Asia) の Zhang 氏が発表する、こうして MSR が MSR に発表するになった。 Zhang の発表は Software Analysis と XIAO の２つの紹介です。 XIAO はマイクロソフトが開発した Code Clone Detector 、ある会社が私達に任せるのもこのようなシステム です。もっと詳しく知りたいが、実装に関わるものは言ってなかった。 Towards Improving BTS with Game Mechanisms これの内容は基本的にこのブロクに書いています： http://www.joelonsoftware.com/items/2008/09/15.html 同じ理論を Issue Tracking とかに応用できるかを言いました。個人的にこれは意味ない気がします。 stackoverflow の成功は Open Software Community にもともとある名誉システムを具現化したですから、それを会社の中に応用するのは 難しい気がする。 GHTorrent この研究のスライドはこちらに： http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524 Data exporter for github. Github の主なデータはコード、それは既に git からアクセスできます、 wiki は git として保存しているからそれも含まれている。ですからこのプロジェクトの目的は他のデータを表せる、つまり issues, commit comments など。このプロジェクトは github api を通じて、分布システムとして api の制限を超える、そして torrent の形で歴史を download できます。元のデータ は bson として MongoDB の保存して、 Schema を追加したデータは MySQL に保存する。 わたしの意見では、データを git の repo の形で保存するの方がいいかもしれない。 今の wiki のように、そして gitolite も全てのデータを git 自身の中に保存している。 The evolution of software 二日目の keynotes, social media をソフトウェア開発に巻き込めるについて話しました。もしかしてこれは Github の成功の理論かもしれない。 IDE の中に social media のアクセスを欲しいと言いました。 Do Faster Releases Imporve Software Quality? Firefox を例として研究しました。 結論としては、早い発行は bug を多く持たされ、 crash がもっと頻繁になるが、 bug の修復も早くなって、そしてユーザー側はもっと早く新しい発行に移動する ことをわかりました。 Security vs Performance Bugs in Firefox 性能に関する bug は regression テストが要る、そして発行を阻止する。 思いつき topic に基づいて commit の分析と分割 よく使うツール（例えば git ）のユーザーはツールの設計者の意図を従ってツールを使うことはない、設計者が思った用途以外にも使っていることが多い、それは Mining に対しては色々困難を持たされています。例えば git には完璧な branch 機能がある、通常に git のユーザーが一つの commit に一つの機能を実現してほしい、例としては bug の修復とか、機能の追加とか。それは難しいなら branch を使って、一連の commit を一つの branch になって、一つの branch に一つの機能を実現してほしい。それなのに、現状では、沢山の編集を一つの commit に含まれていて、後の管理とか情報の収集とかが困難になってしまう。 それはユーザーの悪いと思わない、ツールの方がもっと頑張らないとユーザーは正しく使えない。もし commit の時、自動的に commit の内容を分析して、その中に topic によって分けて、ユーザーに推薦するのをてきたらいいなぁ、と思っています。このように一つの commit を多くに分割したら、 commit の履歴 をもっと見やすくなって、続いて分析とかも便利になるはずです。 今回に皆使っている slide のシステム タイトルは Incorporating Version Histories in Information Retrieval Based Bug Localization の人が使っているのは beamer です。数式が多くて、 overlay も多くて， iterate も多い、図だけ少ない、典型的に beamer に作れそうなスライドです。 mindmap の使いもうまい。今日の一日に少なくとも 3 個の slide は beamer で作られています。 タイトルは Towards Improving Bug Tracking Systems with Game Mechanisms の人は prezi を使いました、図が多くて、 transition も多い。但しスライドとしては必要なページ数とかがなくて、このような国際会議の場合にはもっと 工夫をした方がいいかもしれな。 少なくとも六人以上は Apple の Keynote をつかていまう。 Keynote による作ったスライドは Powerpoint のになかなか区別しがたいですが、その中に二人は default の theme を使ったからわかります、他の人は PPT に決してありえない アニメションを使っていますから、多分 keynote 。 残りは勿論 Powerpoint です。 MSRA の張さんが作ったのは powerpoint なんですけど、すごく beamer の感じがします、例えば header と footer の使い方とか、 overlay 見たいのものでページの item を一つずつ展開するとか。それらを全部 powerpoint で作るのは相当手間がかかりそうです。 ちなみに言いたいのは一つタイトルは Green Mining: A Methodology of Relating Software Change to Power Consumption のスライドは全部 下手 な手描きの漫画で表せている、火狐のアイコンさえ手描きする、効果は意外に評判がいい。省エネでグリンで環境にいいで可愛らしい。具体的な効果は下の リンクから見えます、現場で見たのは別のバージョンなんですけど： http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv マイクロソフトは腹黒っ子 ! まぁ大したニュースではないですけど、 MSR2012 の Mining Challenge のスバンサー はマイクロソフトで、商品は Xbox と Kinect ですけど、今年のチャレンジのテーマは： Mining Android Bug マイクロソフトの殺意を感じしました。","tags":"life"},{"loc":"//farseerfc.github.io/zhs/../msr2012.html","title":"MSR 2012 @ ICSE","text":"Mining Software Repository 2012 @ ICSE 參加了今年的 MSR ，會場在 University of Zurich 。一大早來到大學，註冊有點小插曲，顯然瑞士人搞不清楚中國人的名字， 3 個楊（ Yang ）姓的中國人的名牌被搞錯了。然後堀田學長的所屬被寫作了 \"Japan, Japan\" ，成爲了全日本的代表。 MSR (MicroSoft Research) talk @ MSR (Mining Software Repositories) 首先是來自微軟亞洲研究院（ MicroSoft Research @ Asia, MSR Asia ）的 Keynots ，於是就變成了 MSR 在 MSR 的演講。 MSR 的張冬梅（ Dongmei Zhang ）女士的演講分爲關於 Software Analysis 和 XIAO 的兩部分。 XIAO 是 MSRA 開發的 Code Clone Detector ，似乎我要給井上研做的就是這個。想更多瞭解 Xiao 的細節，不過張女士 演講結束的時候的鼓掌導致了話筒的小故障。 Towards Improving BTS with Game Mechanisms 感覺這篇的內容基本上就是關於 http://www.joelonsoftware.com/items/2008/09/15.html 這裏寫到的東西，然後說同樣的理論是否可以用於 Issue Tracking 之類的事情上。個人感覺這個意義不大， stackoverflow 之所以成功是因爲它把開源社區本身就具有的名譽體系具現化了，本着大家都喜歡被別人奉爲大牛的心態，就如同 wikipedia 一樣。同樣的理論如果用於公司內部的 Issue Tracking 系統上，會得到完全不同的東西吧。就像 MSDN 的組織方式雖然和 wikipedia 是一樣的，但是在 MSDN 裏找信息的感覺和在 wikipedia 完全不一樣。個人不太看好這個方向。 GHTorrent 這篇的 slide 在這裏可以看到： http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524 Data exporter for github. Github 的主要數據，代碼，已經可以通過 git 接口獲得了， wiki 是 git 的形式保存的。所以這個項目的目的就是暴露別的數據，主要是 issue tracking ， code comments ，這種。代碼訪問 github api ，然後用分佈式實現以克服 api 的限制，然後提供 torrents 形式的 history 下載。 github api 獲得的 json 數據以 bson 的形式保存在 MongoDB 裏，解析過的有了 Schema 之後的數據保存 在 MySQL 裏並可以導出 SQL 。 個人的想法，覺得數據如果能夠更統一，全部存在 Git 裏或許更好，像 Wiki 一樣。同樣是要暴露全部歷史記錄的目的，用 Torrent 自己實現的歷史遠不如用 Git 的接口實現的歷史記錄方便吧， git blame 之類的也更方便追蹤 code comment 之類的作者信息。當然對 git 的 raw date 直接讀寫，需要對 git 的內部原理有足夠的理解， 或許只有 github 的人有這種能力了。 Topic Mining 用得兩個參數， DE 和 AIC ，完全不能理解，過後研究。實驗針對了 Firefox, Mylyn, Eclipse 三個軟件。試圖從 Repo 中分析源代碼的 identifier 和 comments ，找到 topic 和 bug 之間的關係，比如怎樣的 topic 更容易導致 bug 。得出的結論似乎也很曖昧，只是說核心功能被報告的 bug 更多，但是不知道原因。這只能表示核心 功能受到更多關注和更多測試吧，並不能說明核心功能就容易產生 bug 。 不過這個的 Slide 做得很漂亮，很容易理解。 SeCold A linked data platform for mining software repositories 沒聽懂這個項目的目的。 The evolution of software 第二天的 Keynotes ，關於將 Social Media 和 Software Development 相結合的想法。或許就是 Github 賴以成功的基礎。講到代碼中的 comment, Tags, uBlog, blog 之類 的 social 的特性和 IDE 的融合的趨勢。 Do Faster Releases Imporve Software Quality? 使用 Firefox 作爲例子。 結論是快速發佈導致 bug 更多，更容易 crash ，但是 bug 更快得到修復，並且用戶 更快轉向新的發佈。 Security vs Performance Bugs in Firefox Performance bugs are regression, blocks release. 一些感想 基於自然語義分析的 commit 分割 經常工具（比如 git ）的使用者並沒有按照工具設計者的意圖使用工具，這給 MSR 帶來很多困難。舉個例子， git 有非常完美的 branch 系統，通常期望 git 的使用者能夠在一次 commit 裏 commit 一個功能，比如一個 bug 的修復，或者一個 feature 的 添加，但是事實上經常有很多邏輯上的 commit 被合併在一個裏面了。 或許這不是使用者的錯，而是工具仍然不夠人性的表現。或許我們可以自動把 一次的 commit 按照語義分割成多個。 分割之後，可以更容易地把 issue 和 commit 關聯，也更容易組織更多的研究。 關於這次發表中大家用的 slides 系統 題目爲 \"Incorporating Version Histories in Information Retrieval Based Bug Localization\" 的人用的 slide 是 beamer 的。公式很多， overlay 很多，列表很多，圖片很少，典型的 beamer 做出的 slide 。思維導圖用得很不錯。今天一天 有至少 3 個 slide 是用 beamer 做的。 題目爲 \"Towards Improving Bug Tracking Systems with Game Mechanisms\" 的人用了 prezi ，圖片很多，過度很多。但是比如沒有頁號沒有頁眉頁腳，正式 會議的場合不太方便。 至少有六個以上用了 Apple Keynotes ， Keynotes 做出來的東西真的和 Powerpoint 做出來的很難區別，其中兩個人用了初始的主題所以才看出來。 剩下的自然是 PPT 。 MSRA 的張女士做的雖然是 PPT ，倒是有很多 beamer 的感覺，比如頁眉頁腳和 overlay 的用法。這些如果都是 PPT 做出來的，會多很多額外的 人力吧。 值得一提的是有一個題目爲 \"Green Mining: A Methodology of Relating Software Change to Power Consumption\" 的人的 slide 全是 \" 劣質 \" 的手繪漫畫，效果意外地好，很低碳很環保很綠色很可愛。具體效果可以參考下面的動畫，雖然 現場看到的不是一個版本： http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv 微軟是個腹黑娘！ 嘛雖然這也不是什麼新聞了。 MSR2012 的 Mining Challenge 的贊助商是微軟，管理 組織者來自微軟研究院，獎品是 Xbox 和 Kinect 。然後今年的題目是： Mining Android Bug 我看到了微軟滿滿的怨氣 ……","tags":"life"},{"loc":"//farseerfc.github.io/zhs/../pyssy.html","title":"Pyssy 項目","text":"簡介 Pyssy 是用於 上海交通大學飲水思源站 的一系列 Python 腳本和工具。 Pyssy 被有意設計爲既可以託管寄宿在 SAE [1] 上，也可以在單機上獨立使用。 項目地址： http://pyssy.sinaapp.com/ Github 上的源代碼地址： https://github.com/yssy-d3/pyssy [1] Sina App Engine ，新浪雲平臺，類似 Google App Engine 的東西。 依賴關係 Pyssy 使用 Flask 作爲網頁服務器，並且使用 Memcached 或者 Redis 作爲抓取 水源 Web 的緩存。 SAE Python 環境下請開啓 Memcached 支持。 本地環境下請安裝 Redis-py 並運行 redis-server 服務器程序。","tags":"python"},{"loc":"//farseerfc.github.io/zhs/../en/mix-ruby.html","title":"PyRuby","text":"Today I saw a package called PyRuby in Github. The readme says: PyRuby - Some Ruby for your Python! PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful. Usage All you have to do is import the ruby module: import ruby From now on you should be able to write Ruby code within a regular Python module. An example: 1.upto(10) { |n| puts n } Even PyPI has listed this as a package. In the beginning I thought this was again a Ruby implementation by PyPy project. Or at least it use some magic trick to write ruby code directly in Python. Then I browse into the source code of it. It contains only one file: ruby.py # -*- coding: utf-8 -*- print ( \"\"\" `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:` .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms. `:ohmdys+//::/::--::::////:-.```......`````.://:-` `/dNs. .+hNds:`-:-:///::------::///++///:--....--::///::-`.///. `oMm/ /hNmo.` `` `....``````````` ...------:::-:/+/-.:/:` /NMs oMd/` `::::--.---://+` //` `````-:::::+/-`::.` :NM+ yN` -+.` `/` o. ``::.-:. `` :NN: :Nm - ./ : `.-://///:-. `-` `` :NN- /NM/ .-:::-.` `/ `:sdmdhyMMMMMMNNmy/` :mNo` :hMd: /dmddddNNmdy+-. `smmy/-```hMMMMMMMhydm/ `-.`` `...:mMm+. -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+- dMN-`-+hmmmmdhhhhdddmMN-`-/o: .-::::/oydms- oNMo:+/::. ``...--:/+ohNMNhs- :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms. .MMo:/`o:.:+sso+:-` sM+ ./-` /mNh+-....-/ymNNdo::--/shd+` -`:mm: /MM-o ./ ohhsooohNmy::sh. `yM/ `:oyyyyyyhys+:.` hy `/Nh` : -NN. -MM// -: `` y: odddhh+ -omNh- `--.` `` ```` .:ohMMs. +Ms / yMo hMoo .+. :Mh ```` `/hNd/.` ohdddy::...`..` `-/sdmdyo+NMNh+- :Mh / sMs .mmh:..:. :NMm `-/dMNM+ ./+++/:`.hM:`.````.` `-/shmNmh+-` /Mmooso.hM/ .: `mM/ .mNs://: .NMNMs- -:-.`/+-sms. ` `shyyyhy`sNd` `.:+sdmmmdMM-. .oNM+ :m/ `s``yMh -mMo . sMNdMNNh+-. .ydyoyy` ``+o::+shdddhs+:-.:MM.`.-+hNMMh- `.`-/::dNs` -NM- mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.` `/mMMdmmddNMm+` ..-/hNh- sMy NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs `..:+ymMMMMd+--yNh. `+hNh: -Mm NMMM/yMh -NM-`..--:NMo:--.`+My :MNoydmNMMNmhdMh` -dNs` `yMd: `MN mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/ yMy` MN yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-. `yMMNs. /My `MN :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM- ./hNNy- /Nd` -Mh dMydMmsNMNdNNMMmmmNMMMdddhys+yMo`` /Nm: `:yNNdo. .sNd. +Ms .mMsMN::NN:.:MN: `.+NM. +Mo +Mm+ymNdo- .omm+` yM: .hNMd+:sMN. oMm. oMo +Mh ```.:+shMNmy+-``.-:-..-//-`:yNmo` mM. :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/` .Mm `` .-:/+osyyhhddddddddddhhyysoo+/:-. `./+//--+oo/--+ymmy/. :Mh .: `+:` `.------------` ```-////:/++/:../ydNdo:` +Ms `/` :+o+:-``` ``..-::///++///:-.`-+ydNdo:` oMs :/:.`` `..---.``` ````````..-:/:::---.` `-ohmmh+:` /Mh .://///:::-----.-----.......` `-+hmmy+- sMy` ``````-+ydmy+- /mNs-` `./ohmNMNNNmy+- /yNmho/:.``````````.-:/+syhdNmdyso+/-.` `:+ydmNMNNNNNNNNNmdhys+/:.` ``.....` LOL U MAD? \"\"\" ) import sys sys . exit ( 1 ) Yes, indead. The idea of using Ruby in Python is totally mad.","tags":"python"},{"loc":"//farseerfc.github.io/zhs/../jp/mix-ruby.html","title":"PyRuby","text":"きょう、 Github に PyRuby というプロジェクトを見ました。それの説明にこう書いています : PyRuby - Some Ruby for your Python! PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful. Usage All you have to do is import the ruby module: import ruby From now on you should be able to write Ruby code within a regular Python module. An example: 1.upto(10) { |n| puts n } さらに、 PyPI にそれのパッケージもあった。 最初に、これはもう一つの PyPy で実現した Ruby だと思った。少なくとも、本当の Ruby を Python から呼び出すの何かの魔法も可能かもしれない。 それのソースコートはこうなっています。 ruby.py # -*- coding: utf-8 -*- print ( \"\"\" `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:` .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms. `:ohmdys+//::/::--::::////:-.```......`````.://:-` `/dNs. .+hNds:`-:-:///::------::///++///:--....--::///::-`.///. `oMm/ /hNmo.` `` `....``````````` ...------:::-:/+/-.:/:` /NMs oMd/` `::::--.---://+` //` `````-:::::+/-`::.` :NM+ yN` -+.` `/` o. ``::.-:. `` :NN: :Nm - ./ : `.-://///:-. `-` `` :NN- /NM/ .-:::-.` `/ `:sdmdhyMMMMMMNNmy/` :mNo` :hMd: /dmddddNNmdy+-. `smmy/-```hMMMMMMMhydm/ `-.`` `...:mMm+. -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+- dMN-`-+hmmmmdhhhhdddmMN-`-/o: .-::::/oydms- oNMo:+/::. ``...--:/+ohNMNhs- :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms. .MMo:/`o:.:+sso+:-` sM+ ./-` /mNh+-....-/ymNNdo::--/shd+` -`:mm: /MM-o ./ ohhsooohNmy::sh. `yM/ `:oyyyyyyhys+:.` hy `/Nh` : -NN. -MM// -: `` y: odddhh+ -omNh- `--.` `` ```` .:ohMMs. +Ms / yMo hMoo .+. :Mh ```` `/hNd/.` ohdddy::...`..` `-/sdmdyo+NMNh+- :Mh / sMs .mmh:..:. :NMm `-/dMNM+ ./+++/:`.hM:`.````.` `-/shmNmh+-` /Mmooso.hM/ .: `mM/ .mNs://: .NMNMs- -:-.`/+-sms. ` `shyyyhy`sNd` `.:+sdmmmdMM-. .oNM+ :m/ `s``yMh -mMo . sMNdMNNh+-. .ydyoyy` ``+o::+shdddhs+:-.:MM.`.-+hNMMh- `.`-/::dNs` -NM- mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.` `/mMMdmmddNMm+` ..-/hNh- sMy NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs `..:+ymMMMMd+--yNh. `+hNh: -Mm NMMM/yMh -NM-`..--:NMo:--.`+My :MNoydmNMMNmhdMh` -dNs` `yMd: `MN mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/ yMy` MN yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-. `yMMNs. /My `MN :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM- ./hNNy- /Nd` -Mh dMydMmsNMNdNNMMmmmNMMMdddhys+yMo`` /Nm: `:yNNdo. .sNd. +Ms .mMsMN::NN:.:MN: `.+NM. +Mo +Mm+ymNdo- .omm+` yM: .hNMd+:sMN. oMm. oMo +Mh ```.:+shMNmy+-``.-:-..-//-`:yNmo` mM. :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/` .Mm `` .-:/+osyyhhddddddddddhhyysoo+/:-. `./+//--+oo/--+ymmy/. :Mh .: `+:` `.------------` ```-////:/++/:../ydNdo:` +Ms `/` :+o+:-``` ``..-::///++///:-.`-+ydNdo:` oMs :/:.`` `..---.``` ````````..-:/:::---.` `-ohmmh+:` /Mh .://///:::-----.-----.......` `-+hmmy+- sMy` ``````-+ydmy+- /mNs-` `./ohmNMNNNmy+- /yNmho/:.``````````.-:/+syhdNmdyso+/-.` `:+ydmNMNNNNNNNNNmdhys+/:.` ``.....` LOL U MAD? \"\"\" ) import sys sys . exit ( 1 ) 本当だ、 Python の中に Ruby を呼び出すという考えはアホだ。","tags":"python"},{"loc":"//farseerfc.github.io/zhs/../mix-ruby.html","title":"PyRuby","text":"今天在 GitHub 上閒逛的時候看到一個叫做 PyRuby 的項目。項目的 Readme 說得很好： PyRuby - Some Ruby for your Python! PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful. Usage All you have to do is import the ruby module: import ruby From now on you should be able to write Ruby code within a regular Python module. An example: 1.upto(10) { |n| puts n } 甚至 PyPI 上還有這個項目的包。 一開始我還以爲這又是一個野心勃勃的基於 PyPy 的 Ruby 實現，或者某種 trick 在 Python 裏面直接調用 Ruby 解釋器。 然後我想看看這個的源代碼 只有一個 ruby.py 文件，內容是： # -*- coding: utf-8 -*- print ( \"\"\" `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:` .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms. `:ohmdys+//::/::--::::////:-.```......`````.://:-` `/dNs. .+hNds:`-:-:///::------::///++///:--....--::///::-`.///. `oMm/ /hNmo.` `` `....``````````` ...------:::-:/+/-.:/:` /NMs oMd/` `::::--.---://+` //` `````-:::::+/-`::.` :NM+ yN` -+.` `/` o. ``::.-:. `` :NN: :Nm - ./ : `.-://///:-. `-` `` :NN- /NM/ .-:::-.` `/ `:sdmdhyMMMMMMNNmy/` :mNo` :hMd: /dmddddNNmdy+-. `smmy/-```hMMMMMMMhydm/ `-.`` `...:mMm+. -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+- dMN-`-+hmmmmdhhhhdddmMN-`-/o: .-::::/oydms- oNMo:+/::. ``...--:/+ohNMNhs- :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms. .MMo:/`o:.:+sso+:-` sM+ ./-` /mNh+-....-/ymNNdo::--/shd+` -`:mm: /MM-o ./ ohhsooohNmy::sh. `yM/ `:oyyyyyyhys+:.` hy `/Nh` : -NN. -MM// -: `` y: odddhh+ -omNh- `--.` `` ```` .:ohMMs. +Ms / yMo hMoo .+. :Mh ```` `/hNd/.` ohdddy::...`..` `-/sdmdyo+NMNh+- :Mh / sMs .mmh:..:. :NMm `-/dMNM+ ./+++/:`.hM:`.````.` `-/shmNmh+-` /Mmooso.hM/ .: `mM/ .mNs://: .NMNMs- -:-.`/+-sms. ` `shyyyhy`sNd` `.:+sdmmmdMM-. .oNM+ :m/ `s``yMh -mMo . sMNdMNNh+-. .ydyoyy` ``+o::+shdddhs+:-.:MM.`.-+hNMMh- `.`-/::dNs` -NM- mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.` `/mMMdmmddNMm+` ..-/hNh- sMy NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs `..:+ymMMMMd+--yNh. `+hNh: -Mm NMMM/yMh -NM-`..--:NMo:--.`+My :MNoydmNMMNmhdMh` -dNs` `yMd: `MN mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/ yMy` MN yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-. `yMMNs. /My `MN :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM- ./hNNy- /Nd` -Mh dMydMmsNMNdNNMMmmmNMMMdddhys+yMo`` /Nm: `:yNNdo. .sNd. +Ms .mMsMN::NN:.:MN: `.+NM. +Mo +Mm+ymNdo- .omm+` yM: .hNMd+:sMN. oMm. oMo +Mh ```.:+shMNmy+-``.-:-..-//-`:yNmo` mM. :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/` .Mm `` .-:/+osyyhhddddddddddhhyysoo+/:-. `./+//--+oo/--+ymmy/. :Mh .: `+:` `.------------` ```-////:/++/:../ydNdo:` +Ms `/` :+o+:-``` ``..-::///++///:-.`-+ydNdo:` oMs :/:.`` `..---.``` ````````..-:/:::---.` `-ohmmh+:` /Mh .://///:::-----.-----.......` `-+hmmy+- sMy` ``````-+ydmy+- /mNs-` `./ohmNMNNNmy+- /yNmho/:.``````````.-:/+syhdNmdyso+/-.` `:+ydmNMNNNNNNNNNmdhys+/:.` ``.....` LOL U MAD? \"\"\" ) import sys sys . exit ( 1 ) 是的 …… 的確 …… 這種嘗試把 Python 和 Ruby 放在一起的想法絕對是瘋了 ……","tags":"python"},{"loc":"//farseerfc.github.io/zhs/../en/discuss-cpp-template-downcast.html","title":"Discuss C++ Template Downcast","text":"This is a discuss in C board in bbs.sjtu.edu.cn, about type down-cast in C++ template. Original Discuss http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html The problem Today I read a book about we can do cast-down in template, so I write this to test: template < bool _Test , class _Type = void > struct enable_if { }; template < class _Type > struct enable_if < true , _Type > { typedef _Type type ; }; class A { }; class B : A { }; template < typename T > struct traits { static int const value = false ; }; template <> struct traits < A > { static int const value = true ; }; template < typename T > void f ( T , typename enable_if < traits < T >:: value >:: type * = 0 ) { } template <> void f < A > ( A , enable_if < traits < A >:: value >:: type * ) { } template < typename T > class BB {}; template < typename T > class DD : public BB < T > {}; template < typename T > void ff ( BB < T > ) {}; int main ( int argc , char * argv []) { A a ; B b ; DD < long > dd ; //f(b); ff ( dd ); } It is strange when f it don't allow my specified f<A>` . But in ff it allowed ff<BB<long>>` . Tested under VC10 and GCC3 .4 My answer to the problem Let's think ourself as compiler to see what happened there. Define mark # : A#B is the instantiated result when we put B into the parameter T of A<T> . First we discuss ff DD < long > dd ; After this sentense, the compiler saw the instantiation of DD<long> , so it instantiate DD#long , and also BB#long . ff ( dd ); This sentense required the compiler to calculate set of overloading functions. Step 1 we need to infer T of ff<T> from argument DD#long -> BB<T> . Based on the inference rule: Argument with type :code:`class_template_name<T>` can be use to infer :code:`T``. So compiler inferred T as long . Here if it is not BB but CC which is complete un-related, we can also infer, as long as CC is a template like CC<T> . Step 2 Template Specialization Resolution. There is only one template here so we matched ff<T> . Step 3 Template Instantiation After inferred long -> T , compiler instantiated ff#long . Set of available overloading functions : {ff#long} Then overloading resolution found the only match ff#long` , checked its real parameter DD#long can be down-cast to formal parameter BB#long . Then we discuss f f ( b ); Calculate set of overloading functions. Step 1 infer all template parameters for template f . According to inference rule: Parameter with type T can be used to infer T 。 So B -> T is inferred. Step 2 Template Specialization Resolution. Here B is not A so we can not apply specialization of f<A> , remaining f<T> as the only alternative. Step 3 Template Instantiation. When we put B into f<T> to instantiate as f#B , we need to instantiate traits#B` . There is no specialization for B so we use template traits<T> , traits#B::value=false , so enable_if#false didn't contains a type , an error occurred. The only template is mismatch, available overloading functions is empty set. So we got an error.","tags":"c"},{"loc":"//farseerfc.github.io/zhs/../discuss-cpp-template-downcast.html","title":"關於C++模板的類型轉換的討論","text":"這兩天在飲水思源的 C 板，關於 C++ 模板的類型轉換的一個討論，後面是我的解答。 討論地址 http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html 原問題 今天在書上看到模板演繹的時候可以允許 cast-down ，於是我寫了個東西： template < bool _Test , class _Type = void > struct enable_if { }; template < class _Type > struct enable_if < true , _Type > { typedef _Type type ; }; class A { }; class B : A { }; template < typename T > struct traits { static int const value = false ; }; template <> struct traits < A > { static int const value = true ; }; template < typename T > void f ( T , typename enable_if < traits < T >:: value >:: type * = 0 ) { } template <> void f < A > ( A , enable_if < traits < A >:: value >:: type * ) { } template < typename T > class BB {}; template < typename T > class DD : public BB < T > {}; template < typename T > void ff ( BB < T > ) {}; int main ( int argc , char * argv []) { A a ; B b ; DD < long > dd ; //f(b); ff ( dd ); } 奇怪的是重載決議的時候， f 的情況下它就不讓我特化的 f<A> 進來。 但是在 ff 的情況下， ff<BB<long>> 卻進來了。 在 VC10 和 GCC3.4 下測試 我的解答 我們來設身處地地作爲編譯器，看一遍到底發生了什麼。 約定符號 # : A#B 是把 B 帶入 A<T> 的參數 T 之後實例化得到的結果。 首先看 ff 的情況。 DD < long > dd ; 處理到這句的時候，編譯器看到了 DD<long> 的實例化，於是去實例化 DD#long ，繼而實例化了 BB#long 。 ff ( dd ); 這句，首先計算重載函數集合。 第一步，需要從參數 DD#long -> BB<T> 推斷 ff<T> 的 T 。根據函數模板參數推斷規則： :code:`class_template_name<T>` 類型的參數，可以用於推斷 :code:`T` 。 於是編譯器推斷 T 爲 long 。這裏就算不是 BB 而是完全無關的 CC 都可以推斷成功，只要 CC 也是一個 CC<T> 形式的模板。 第二步，模板特化匹配。因爲只有一個模板，所以匹配了最泛化的 ff<T> 。 第三步，模板實例化。 推斷了 long -> T 之後，編譯器實例化 ff#long 。 重載函數集合： {ff#long} 然後重載抉擇找到唯一的可匹配的實例 ff#long ，檢查實際參數 DD#long 可以隱式轉換到形式參數 BB#long ，從而生成了這次函數調用。 再來看 f 的情況。 f ( b ); 計算候選重載函數集合。 第一步，對所有 f 模板推斷實參。根據函數模板參數推斷規則： 帶有 :code:`T` 類型的參數，可以用於推斷 :code:`T` 。 於是 B -> T 被推斷出來了。 第二步，模板特化匹配。 這裏 B 不是 A ，所以不能用 f<A> 特化，只能用 f<T> 模板。 第三步，模板實例化。 B 帶入 f<T> 實例化成 f#B 的過程中，實例化 traits#B 。 由於沒有針對 B 的特化，所以用 traits<T> 模板， traits#B::value=false ，進而 enable_if#false 沒有 type ，出錯。 唯一的模板匹配出錯，重載函數集合爲空， SFINAE 原則不能找到合適的匹配，於是報錯。","tags":"c"},{"loc":"//farseerfc.github.io/zhs/../en/try-pelican.html","title":"Give a try to Pelican","text":"It seems in one night all geeks have their own Github User Page and Octopress Blog. Like everyone posted in their blogs, Static Blog is indeed more convenient than traditional Blog systems such as WordPress. I have been wanting my own Octopress since then. But it seems that Octopress isn't for me At first I was confused by Setup Steps of Octopress . What is this RVM thing? And what is that rbenv thing? It seems the high pace of Ruby community has beyond my imagination to a degree that they need a version manager to ensure the compatibility of different versions of Ruby. Althrough the same compatibility issue also troubles Python community [1] , but at least Python don't need a version manager (yet) to control this mass [2] . Real problem for me is that I haven't yet a Linux box that I can play around freely. (I really want one … ) Both RVM and rbenv needs to run on Unix/Linux/MacOSX. One can not be a geek if he use Windows ? (Maybe it's true…) Remaining problem is the battle between Ruby and Python campaign. I haven't tried Markdown , and I rather like ReST . It seems that both sides depend on Pygments as code block highlighter so Rubyists need Python environment anyway. I simply don't want to depend on any Ruby component. It is better when it is in pure Python, no C extensions so that I can debug into it and make minor modifications. So I started searching for Static Blog Engine in Python on Github. The author of the great framework Flask , mitsuhiko , wrote a rstblog , but it's not well developed. Hyde seems to be complete enough, but it use MarkDown as its default markup language, and the design of its homepage is too fashion to be used as blog. Finally I found Pelican . [1] Such as the difference between Python 2.x and 3.x , and also difference in C- API of implementations of PyPy , CPython , Stackless , Cython . [2] Yes, we have easy_install and pip , but all these are package manager, running in a perticular Python implementation. Python implementation itself don't need a manager. Version issue of Python largely have been solved by lightweight converters such as 2to3.py and 3to2.py , you don't need to store multiple implementations of Python in your disk for different packages. Yes you can use virtualenv if you need to preserve stablility but this is another story. Let it be Pelican For my own use, Pelican offers me some advantages over Octopress : Implemented in pure Python . This means that I can use different implementation of Python other than CPython easily. I use PyPy myself. Translation of multi-languages. The original author of Pelican is a France. This is unnecessory for most people, but I will post my blog mainly in three languages: English, Japanese and Chinese. ReST . So that I can use the @auto-rst feature of Leo . And also I don't need to switch between my blog and documentation of my projects. But it seems that Pelican was less contributed than Octopress . Some minor issues remains in latest version: Support of pelican-import from WordPress for Chinese and Japanese articles are buggy. Datetime format, timezone, and locale support for multi-language blogs are not so natural. I will work on this in these days There are not so many templates compared to Octopress . And less plugins . I hope more people from Python community can contribute to this excellent project, then all these issues will be fixed soon. My settings To install Pelican is simple: $ pip install pelican Write posts in ReST , with rst extensions, and put them in pages folder. (Re)Build all pages is simply: $ pelican -s settings.py Push to Github: $ git commit -am \"Commit message\" $ git push And following is my settings.py : # -*- coding: utf-8 -*- TIMEZONE = 'Asia/Tokyo' DATE_FORMATS = { 'en' :( 'usa' , '%a, %d %b %Y' ), 'zh' :( 'chs' , '%Y-%m- %d , %a' ), 'jp' :( 'jpn' , '%Y/%m/ %d (%a)' ), } # windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx LOCALE = [ 'usa' , 'chs' , 'jpn' , # windows 'en_US' , 'zh_CN' , 'ja_JP' ] # Unix/Linux DEFAULT_LANG = 'zh' SITENAME = 'Farseerfc Blog' AUTHOR = 'Jiachen Yang' DISQUS_SITENAME = 'farseerfcgithub' GITHUB_URL = 'https://github.com/farseerfc' SITEURL = 'http://farseerfc.github.com' TAG_FEED = 'feeds/ %s .atom.xml' SOCIAL = (( 'twitter' , 'http://twitter.com/farseerfc' ), ( 'github' , 'https://github.com/farseerfc' ), ( 'facebook' , 'http://www.facebook.com/farseerfc' ), ( 'weibo' , 'http://weibo.com/farseerfc' ), ( 'renren' , 'http://www.renren.com/farseer' ), ) TWITTER_USERNAME = 'farseerfc' THEME = 'notmyidea' CSS_FILE = \"wide.css\" DEFAULT_CATEGORY = 'Others' OUTPUT_PATH = '.' PATH = 'posts'","tags":"python"},{"loc":"//farseerfc.github.io/zhs/../jp/try-pelican.html","title":"Pelicanを試してみた","text":"一日の間に全ての ギーク たち が 自分の Github ユーザーページ と Octopress ブログを導入したような気がします。皆がブログに書いた通りに、静的ブログは確かに WordPress などの従来の動的ブログ・エンジンより便利だと思います。これらブログを見ると、私も自分の Octopress ブログを立ちましょう とずっと思っています。 ですが Octopress は私に向いてないかも 初めのところに Octopress の配置手順 に迷わされた。 RVM とはなに？ rbenv とは何のこと？見るところ Ruby コミュニティーの発展するハイペースは既に私の想像に超えましたみたい。彼らは Ruby の各バージョン間に互換性を持つために、バージョン管理が必要らしいです。同様の互換性問題が Python コミュニティーにもあるですが [1] 、 Python は今のところこのようなバージョン管理の必要がないと思います [2] 。 実際に迷惑したのは、私は今自由に持って遊べる Linux 環境が持っていないということ（ほしいなぁ …… ）。ですが RVM それとも rbenv 両方も Unix/Linux/MacOSX しか実行できないらしいです。ギークとしたの皆は絶対に Windows つかっじゃいけないんですか？（本当かも …… ）。 残りは Ruby と Python の争いです。私は Markdown に詳しくない、比べると ReST のほうが私に向いています。それに、どっちでも Pygments を依存しシンタックス・ハイライトをしているから、 Rubyist 達も少なくとも Python を入れなきゃダメみたいです。私の好みは一切の Ruby コンポーネントを頼らず、 C 拡張もない純粋な Python の実現がほしいです。 そこから Github に Python で実現した静的ブログ・エンジンを探し始めた。 Flask の作者である mitsuhiko 氏が書いた rstblog が素晴らしいが、あんまり他人に使われていないようです。 Hyde は多く使われているけれと、ホームページにブログの感じがみえないです。最後に Pelican を見かけました。 [1] 例えば Python 2.x と 3.x の間にあまりにも巨大なる差、それと PyPy 、 CPython 、 Stackless 、 Cython など各実現間に微妙な違いがあります。 [2] はい、こっちに easy_install とか pip があります、ですがそれらはパッケージ管理、特定な Python 環境を入れた後の話です。 Python 自身はまだ管理する必要がないです。 Python のバージョン問題も 2to3.py とか 3to2.py のようなツールで変換すればいいです、違うソフトを実行するためたくさんの Python バージョンを残る必要はないです。もしバージョンの違いが気にするなら virtualenv を使うのも構わないが、それも別のことです。 それでは Pelican にしよう 私自身にとって、 Pelican は Octopress よりいいところ： 純粋な Python で実現した。ですから CPython のほかべつの実現を使うのも心配がない。例えばわたしは PyPy を使ています。 多言語。 Pelican の原作者はフランス人らしいです。ほとんどの人はこれの必要がないと思うが …… できるだけ、わたしは三つの言語で書く。 ReST 。それなら Leo の @auto-rst を使って直接 ReST をかけます。 でも Pelican は Octopress のほど注目されていないから、一部問題があります。 pelican-import は WordPress から導入する時、日本語や中国語は問題となります。 多言語の機能と日付、タイムゾーンなどにバグがある。 私は改善しています。 テンプレートは少ない。 プラグインも少ない …… こんなに優れたツールにもっと注目されてほしい。 配置 Pelican を入れるのは簡単： $ pip install pelican 文章を ReST で書いて、 posts フォルダーに置きます。ページを生成する： $ pelican -s settings.py Github に送る : $ git commit -am \"Commit message\" $ git push 私の配置ファイル： # -*- coding: utf-8 -*- TIMEZONE = 'Asia/Tokyo' DATE_FORMATS = { 'en' :( 'usa' , '%a, %d %b %Y' ), 'zh' :( 'chs' , '%Y-%m- %d , %a' ), 'jp' :( 'jpn' , '%Y 年 %m 月 %d 日 (%a)' ), } # windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx LOCALE = [ 'usa' , 'chs' , 'jpn' , # windows 'en_US' , 'zh_CN' , 'ja_JP' ] # Unix/Linux DEFAULT_LANG = 'zh' SITENAME = 'Farseerfc Blog' AUTHOR = 'Jiachen Yang' DISQUS_SITENAME = 'farseerfcgithub' GITHUB_URL = 'https://github.com/farseerfc' SITEURL = 'http://farseerfc.github.com' TAG_FEED = 'feeds/ %s .atom.xml' SOCIAL = (( 'twitter' , 'http://twitter.com/farseerfc' ), ( 'github' , 'https://github.com/farseerfc' ), ( 'facebook' , 'http://www.facebook.com/farseerfc' ), ( 'weibo' , 'http://weibo.com/farseerfc' ), ( 'renren' , 'http://www.renren.com/farseer' ), ) TWITTER_USERNAME = 'farseerfc' THEME = 'notmyidea' CSS_FILE = \"wide.css\" DEFAULT_CATEGORY = 'Others' OUTPUT_PATH = '.' PATH = 'posts'","tags":"python"},{"loc":"//farseerfc.github.io/zhs/../try-pelican.html","title":"嘗試一下 Pelican","text":"似乎一夜之間所有的 極客們 都 有了 自己 的 Github 主頁 和 Octopress 博客。就像所有人在他們的博客中指出的，靜態博客的確比傳統的 WordPress 方式具有更多優勢。自從看到這些我就一直在想着自己搭一個 Octopress 。 但是似乎 Octopress 不適合我 一上手就被 Octopress 的搭建步驟 煩到了。 RVM 是什麼？ rbenv 又是什麼？看來 Ruby 社區的快節奏發展已經超過了我的想象，他們似乎需要一套發行版管理器來調和不同版本之間的 Ruby 的兼容性問題。雖然同樣的兼容性問題在 Python 社區也有 [1] ，不過總覺得 Python 至少還沒到需要一個發行版管理器的程度 [2] 。 真正的問題是我手上還沒有一個可以讓我隨便玩的 Linux 環境（真的想要 …… ）。而無論是 RVM 還是 rbenv 似乎都只支持 Unix/Linux/MacOSX 。身爲極客就註定不能用 Windows 麼？（或許是的 …… ）。 剩下的問題就是 Ruby 和 Python 兩大陣營的對立問題了。我不熟悉 Markdown ，相對來說比較喜歡 ReST 。似乎無論哪邊都要依賴 Pygments 作爲代碼着色器，那麼其實 Rubyist 也至少需要安裝 Python 。我傾向於不依賴任何 Ruby 組件，最好沒有 C 擴展的純 Python 實現。 於是我開始在 Github 上找 Python 的靜態博客引擎。 Flask 的作者 mitsuhiko 寫的 rstblog 看起來不錯，不過似乎沒有多少人在用。 Hyde 似乎很完善，不過默認的標記語言是 MarkDown ，又依賴於幾個 Ruby 組建，而且官方網站的設計實在太前衛。最終我看到了 Pelican 。 [1] 比如 Python 2.x 與 3.x 之間看似難以跨越的鴻溝，以及 PyPy 、 CPython 、 Stackless 、 Cython 等各個實現之間的微妙差別。 [2] 是的，我們有 easy_install ，我們有 pip ，不過這些都是包管理器，都是裝好特定的 Python 實現之後的事情。 Python 實現本身還不需要包管理器來管理。 Python 的版本問題基本上也只需要 2to3.py 和 3to2.py 這樣的輕量級轉換器就可以了，你不需要爲了安裝多個軟件而在硬盤裏留下多個不同版本的 Python 。如果爲了引用的穩定性，你可以用 virtualenv ，不過這又是另一回事情了。 那麼就 Pelican 吧 對我而言， Pelican 相比於 Octopress 有幾個好處： 純 Python 實現。這意味着我可以換用任何 Python 解釋器而不必擔心兼容性問題。比如我就換成了 PyPy 。 多語言支持。因爲 Pelican 的作者似乎是個法國人。不過這個似乎大部分人不需要 …… 我是想儘量把一篇博客寫成三種語言作爲鍛鍊吧。 ReST 。這樣我就可以用 Leo 的 @auto-rst 直接寫 ReST 了。簡單方便快捷有效。 不過似乎 Pelican 的關注度不如 Octopress 那麼高，現在一些部分還有細微的問題： pelican-import 從 WordPress 導入的時候對中文、日文的支持似乎很成問題。 日期格式、時區、字符集、和多語言功能的結合度還不夠。 我在嘗試改善它。 模板還不夠豐富。 插件也不夠多 …… 希望這麼優秀的工具能夠受到更多關注，以上這些問題都是增加關注度之後很快就能解決的問題。 我的設置 settings.py 安裝 Pelican 很容易，一句話就夠了： $ pip install pelican 然後把文章寫成 ReST 的格式，放在 `pages` 文件夾裏面。 ( 重新 ) 生成只要： $ pelican -s settings.py 上傳到 Github: $ git commit -am \"Commit message\" $ git push 就這麼簡單。附上我的配置文件： # -*- coding: utf-8 -*- TIMEZONE = 'Asia/Tokyo' DATE_FORMATS = { 'en' :( 'usa' , '%a, %d %b %Y' ), 'zh' :( 'chs' , '%Y-%m- %d , %a' ), 'jp' :( 'jpn' , '%Y/%m/ %d (%a)' ), } # windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx LOCALE = [ 'usa' , 'chs' , 'jpn' , # windows 'en_US' , 'zh_CN' , 'ja_JP' ] # Unix/Linux DEFAULT_LANG = 'zh' SITENAME = 'Farseerfc Blog' AUTHOR = 'Jiachen Yang' DISQUS_SITENAME = 'farseerfcgithub' GITHUB_URL = 'https://github.com/farseerfc' SITEURL = 'http://farseerfc.github.com' TAG_FEED = 'feeds/ %s .atom.xml' SOCIAL = (( 'twitter' , 'http://twitter.com/farseerfc' ), ( 'github' , 'https://github.com/farseerfc' ), ( 'facebook' , 'http://www.facebook.com/farseerfc' ), ( 'weibo' , 'http://weibo.com/farseerfc' ), ( 'renren' , 'http://www.renren.com/farseer' ), ) TWITTER_USERNAME = 'farseerfc' THEME = 'notmyidea' CSS_FILE = \"wide.css\" DEFAULT_CATEGORY = 'Others' OUTPUT_PATH = '.' PATH = 'posts'","tags":"python"},{"loc":"//farseerfc.github.io/zhs/../about-my-blogs.html","title":"關於我的Blogs","text":"從 farseerfc.wordpress.com 導入 很久沒有寫過 blog 或者之類的東西了。這邊一直荒廢着。 由於國內被牆的原因，另一個 wordpress ： http://fchome.sinaapp.com/ 應該會同步更新這裏的內容。 抽空寫點什麼吧。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../en/if-we-do-this-work.html","title":"\"…if we do this work … \" —Bill Gates","text":"Imported from renren \"…if we do this work … and the result is that Linux works great …\" —Bill Gates From: Bill Gates '— Sent: Sunday, January 24, 1999 8:41 AM Jeff Westorinon; Ben Fathi ; TO : Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder Subject: ACPI extensions One thing I find myself wondering about is whether we shouldn't try and make the \" ACPI \" extensions somehow Windows specific. It seems unfortunate if we do this work and get our partners to do the work and the result is that Linux works great without having to do the work . Maybe there is no way to avoid this problem but it does bother me. Maybe we could define the APIs so that they work well with NT and not the others even if they are open. Or maybe we could patent something relaled to this. From: http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/ PX03020 .pdf If this is the reason that Xen 4.0 is still not fully support ACPI 3.0, then f*ck you Bill Gates!","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../jp/if-we-do-this-work.html","title":"\"…if we do this work … \" —Bill Gates","text":"renren から導入した。 From: Bill Gates '— Sent: Sunday, January 24, 1999 8:41 AM Jeff Westorinon; Ben Fathi ; TO : Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder Subject: ACPI extensions One thing I find myself wondering about is whether we shouldn't try and make the \" ACPI \" extensions somehow Windows specific. It seems unfortunate if we do this work and get our partners to do the work and the result is that Linux works great without having to do the work . Maybe there is no way to avoid this problem but it does bother me. Maybe we could define the APIs so that they work well with NT and not the others even if they are open. Or maybe we could patent something relaled to this. From: http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/ PX03020 .pdf もしこれは今更 Xen4.0 の上に ACPI 3.0 完全的なサポートが得ない原因、なら Bill Gates を呪います！","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../if-we-do-this-work.html","title":"\"…if we do this work … \" —Bill Gates","text":"導入自 renren From: Bill Gates '— Sent: Sunday, January 24, 1999 8:41 AM Jeff Westorinon; Ben Fathi ; TO : Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder Subject: ACPI extensions One thing I find myself wondering about is whether we shouldn't try and make the \" ACPI \" extensions somehow Windows specific. It seems unfortunate if we do this work and get our partners to do the work and the result is that Linux works great without having to do the work . Maybe there is no way to avoid this problem but it does bother me. Maybe we could define the APIs so that they work well with NT and not the others even if they are open. Or maybe we could patent something relaled to this. From: http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/ PX03020 .pdf 如果這就是我至今在 Xen4.0 上得不到 ACPI 3.0 的完善支持的原因，那麼我詛咒 Bill Gates ！","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../zz-introducing-scholarzhang.html","title":"[zz]\"西廂計劃\"原理小解","text":"從 farseerfc.wordpress.com 導入 好神奇的想法，先存着，以後慢慢研究 原文： http://blog.youxu.info/2010/03/14/west- chamber/ 待月西廂下，迎風戶半開。隔牆花影動，疑是玉人來。 最近推上最流行的一個關鍵詞是 \" 西廂計劃 \", 這個計劃名字取得很浪漫，客戶端叫做張生，對，就是西廂記裏面那個翻牆去見崔鶯鶯小姐的張生；顯然，服務器端必然叫做崔鶯鶯。客戶端的張生是最重要的部件，可以不依賴於服務端工作。因爲西廂計劃的作者只是簡要的介紹了一下原理，其他報道又語焉不詳，我當時就覺得很好奇，花了昨天一個晚上詳細讀了一下源代碼，終於知道怎麼回事了，覺得原理非常漂亮，所以寫篇文章介紹總結一下。 先說大方向。大家都知道，連接被重置的本質，是因爲收到了破壞連接的一個 TCP Reset 包。以前劍橋大學有人實驗過，客戶端和服務器都忽略 Reset, 則通信可以不受影響。但是這個方法其實只有理論價值，因爲絕大多數服務器都不可能忽略 Reset 的 ( 比如 Linux, 需要 root 權限配置 iptables, 而且這本身也把正常的 Reset 給忽略了 ) 。只要服務器不忽略 Reset, 客戶端再怎麼弄都沒用，因爲服務器會停止發送數據， Reset 這條連接。所以，很多報道說西廂計劃是忽略 Reset, 我從源代碼來看應該不是這樣。在我看來，西廂計劃是利用了牆的一個可能的弱點 – 牆只在連接發起的時候把一個 TCP 連接加入監聽序列，如果牆認爲這個連接終止了，就會從監聽序列中去掉這條記錄，這樣，這條連接上後續的包就不會被監聽。西廂計劃就是讓牆 \" 認爲 \" 這個連接終止的一個絕妙的方法。只要牆認爲這個連接兩端都是死老虎，牆就不會觸發關鍵詞檢測，其後所有的數據，都不存在連接被重置的問題了。 如何讓一個連接置之死地而後生，就是西廂計劃那幫黑客神奇的地方了。這也不是一日之功。首先，這幫牛人發現，牆的是一個入侵檢測系統，把含有關鍵字的包當成一種 \" 入侵 \" 來對待。採取這種設計有很多好處，但缺點是入侵檢測系統可能具有的問題，牆都可能有。西廂計劃主頁上那篇著名的論文就是講這些七七八八的漏洞的。可以說處理這些七七八八的漏洞是非常困難的，迫使牆的設計者 \" 拆東牆，補西牆 \" 。這樣補來補去，外表看起來好像很牛逼的牆，其實有很多本質上無法簡單修補的漏洞，其中有一個致命的，就是 TCP 連接狀態的判定問題。出於入侵檢測系統這種設計的侷限，牆沒有，也沒辦法準確判定一條 TCP 連接的狀態，而只是根據兩邊收到的數據來 \" 推測 \" 連接的狀態。而所有的關鍵詞檢測功能，都是基於 \" 連接還活着 \" 的這個推測的結果的。因爲牆的規則是在連接發起的時候開始對這條連接的檢測，在連接終止的時候停止對這條連接的檢測，所以，一旦對連接的狀態推測錯誤，把還活着的連接當成已經關閉的連接，牆就會放棄對這條連接上隨後所有的包的檢測，他們都會都透明的穿過牆的入侵檢測。 上面只是想法，具體到 TCP 協議實現這一層，就要只迷惑牆，還不能觸及我要通信的服務器。最理想的情況下，在任何有效通信之前，就能讓牆出現錯誤判斷，這些，就需要對 TCP 協議有深刻理解了。西廂計劃的那幫黑客，居然真的去讀 TCP 幾百頁的 RFC ，還居然就發現了方法（這裏我假設讀者都知道 TCP 的三次握手過程和序列號每次加一的規則）。我們都知道，三次握手的時候，在收到服務器的 SYN / ACK 的時候，客戶端如果發送 ACK 並且序列號 +1 就算建立連接了，但是客戶端如果發送一個序列號沒 +1 的 FIN （表示連接終止，但是服務器知道，這時候連接還沒建立呢， FIN 這個包狀態是錯的，加上序列號也是錯的，服務器自己一判斷，就知道這個包是壞包，按照標準協議，服務器隨手丟棄了這個包） , 但這個包，過牆的時候，在牆看來，是表示連接終止的 ( 牆是 ma de in china, 是比較山寨的，不維護連接狀態，並且，牆並沒有記下剛纔服務器出去的 SYN / ACK 的序列號，所以牆不知道序列號錯了）。所以，牆很高興的理解爲連接終止，舒了一口氣去重置其他連接了， 而這個連接，就成了殭屍，牆不管你客戶端了，而這時候，好戲纔剛剛開始。 事實上，牆是雙向檢測的（或者說對每個包都檢測的），因此，對服務器和客戶端實現相同的對待方法，所以，牆不管客戶端還不行，假如服務端有關鍵詞傳給客戶端，牆還是有可能要發飆的（這裏說有可能，因爲我也不知道）。所以，最好的辦法就是，讓服務端也給牆一個終止連接的標誌就好了。可是這個說起來簡單，做起來難，怎麼能讓不受自己控制的服務器發一個自己想要的包呢？西廂計劃的那幫黑客，再次去讀幾百頁的 RFC , 令人驚訝的發現，他們居然在 RFC 上發現了一個可以用的特性。我們上面說了，三次握手的時候，在收到 SYN / ACK 後，客戶端要給服務器發送一個序列號 +1 的 ACK ，可是，假如我不 +1 呢，直接發 ACK 包給服務器。牆已經認爲你客戶端是死老虎了，不理你了，不知道你搞什麼飛機，讓這個 ACK 過了。可是服務器一看，不對啊，你給我的不是我期待的那個序列號， RFC 上說了， TCP 包如果序列號錯了的話，就回復一個 Reset. 所以，服務器就回復了一個 Reset 。這個 Reset 過牆的時候，牆一看樂了，服務器也終止連接了，好吧，兩邊都是死老虎了，我就不監聽這條連接了。而至於客戶端，這個服務器過來的 Reset 非常好識別，忽略就是。隨後，客戶端開始正確的發送 ACK , 至此，三次握手成功，真正的好戲開始，而牆則認爲客戶端和服務器都是死老虎，直接放過。所以，張生就這樣透明的過了牆。 至於過牆以後所有的事情，《西廂記》裏面都有記載，各位讀者自行買書學習。 現在的西廂計劃客戶端，即 \" 張生 \" 模塊的防連接重置的原理就是這樣，服務器端，即鶯鶯模塊的實現也是類似的。防 DNS 那個，不懂 DNS 協議，所以看不懂。我猜想，因爲開發人員都是黑客，所以自然喜歡用最經得起折騰和高度定製的 Linux 開發。現在看西廂計劃的實現，因爲依賴於 Linux 內核模塊 netfilter, 在 Linux 上如魚得水，但往其他平臺的移植可能是個亟待解決的問題。我覺得，在其他平臺上，可以通過 libpcap 和 libnet ，在用戶態實現相同的功能，就是有點麻煩而已，有興趣的懂網絡的可以照西廂計劃原理，在家自行做出此功能；當然，全中國人民都用 Linux 最好 :) PS 1: 據說是西廂計劃一個作者畫的原理圖： http://img.ly/DIi PS 2: 我對 TCP 的理解僅限於課本，如果上面的對技術的理解有錯，請大家指出。 PS 3: 有些漏洞，可能是設計上本質缺陷，不是那麼容易修復的。 PS 4: 除了最後一個圖，本文沒有其他相關鏈接，如需相關資料，自行 Google 。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../en/sine-cpu.html","title":"Write a program to keep CPU usage as sin funcion","text":"Imported from: renren . It is said that this is a problem from interview of Microsoft. Write a program, which makes the CPU usage curve in Windows Task Manager shows a Sin function. The program below is written in java: public class sincpu { private static final int cycle = 1024 , tick = 256 ; public static void main ( String [] args ) throws InterruptedException { for ( int i = 0 ;; i ++){ work ( calcNextSleep ( i % cycle )); sleep ( tick - calcNextSleep ( i % cycle )); } } private static long calcNextSleep ( long i ){ return ( int )( Math . sin (( double ) i * 2 * Math . PI / cycle ) * tick + tick ) / 2 ; } private static void sleep ( long sleepTime ) throws InterruptedException { if ( sleepTime < 2 ) Thread . yield (); else Thread . sleep ( sleepTime ); } private static void work ( long period ) { long start = System . currentTimeMillis (); for (;;){ Math . sin ( 1 ); if ( System . currentTimeMillis () - start >= period ) break ; } } } Be careful you need to turn off other cores if you have multi-core CPU .","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../sine-cpu.html","title":"寫程序讓CPU佔用率保持正弦函數","text":"導入自 renren 據說是一道微軟的面試題。如題，寫程序，讓 Windows 的任務管理器中的性能監視器呈現正弦曲線。 潛心鑽研良久，得代碼：（ java ） public class sincpu { private static final int cycle = 1024 , tick = 256 ; public static void main ( String [] args ) throws InterruptedException { for ( int i = 0 ;; i ++){ work ( calcNextSleep ( i % cycle )); sleep ( tick - calcNextSleep ( i % cycle )); } } private static long calcNextSleep ( long i ){ return ( int )( Math . sin (( double ) i * 2 * Math . PI / cycle ) * tick + tick ) / 2 ; } private static void sleep ( long sleepTime ) throws InterruptedException { if ( sleepTime < 2 ) Thread . yield (); else Thread . sleep ( sleepTime ); } private static void work ( long period ) { long start = System . currentTimeMillis (); for (;;){ Math . sin ( 1 ); if ( System . currentTimeMillis () - start >= period ) break ; } } } 多核 CPU 上測試時要注意關掉一個 CPU ：","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../some-thought-on-creationism.html","title":"關於神創論的一些見解","text":"導入自 renren 看到陳驫同學很有感想的一篇神創論與命運日誌，覺得近日很久沒有看到這樣的評論了。想說幾句自己的觀點。 首先我認爲，神創論與宿命論沒有多少關聯，甚至進化論者相較於神創論者更容易接受宿命論的觀點。因爲神創論主張意志的存在，人所具有的個體意志與神的意志，因此在神創論者的眼中事件的結果是可以通過意志來改變的，亦即如果我從物理樓 11 樓跳下，那麼我就可以改變自己死亡時間的宿命。上帝的意志同樣可以左右事件的結果，也就是所謂的宿命不復存在。而進化論者不承認意志獨立於物質世界的存在，你我的思考、行爲，都受到物理學法則諸如量子力學的約束，這就引出了北大物理系教授的那句 \" 宇宙中的一切都是可以計算的 \" ，亦即宿命論。如我我選擇現在從物理樓上跳下，我這一行爲並不是處於個人的獨立意志，乃是想證明這一點，亦即我跳樓這一舉動是有其背後的動機與原因的，就如同計算機的輸入必然導致了輸出，宿命的必然終結於此。 其次，關於事件的複雜度所導致的隨機化，在大量混沌隨機中也存在着如統計學和隨機分形學這樣的規律，並不是否認宿命的充分理由。 關於神創論的合理性問題。我認爲是否相信神的存在只是一個 boolean 二值問題，它爲 true 爲 false 本身並不重要，重要的是確定它的取值之後得到的推論與結果。如果否認神的存在，如現代數學這樣的完美又何以存在，進化論者的解釋是事物最終會向着更好更高級的方向發展，產生現代數學乃至現代科學是發展的必然。而這種論調顯然有悖於物理中以熱力學第二定律爲首的，預言事物會隨時間推演愈發混亂的論斷。更進一步，甚至整個人類、整個生物系統的存在都是有悖於熱力學推論的現象，是某種理論只能以 \" 小概率事件 \" 解釋的現象。 神創論的核心觀點之一，是神的唯一存在性，按照鄒恆明的比喻，這就如同數學中集閤中元素的的唯一性一般至關重要。數學乃至近代科學的發展，其起源在於這種對神性的探求，而不僅僅是好奇心就可以解釋的。反觀東方文化中數學的發展，開始時領先於西方科學千餘每年，但是始終作爲一種 craft-oriented 的實用主義學科。可以說沒有了神的唯一性支持，人們就不能確信自己能找到這樣一種完美高效的學科，只能在實用的基礎上發展其基礎算數。可以想象，沒有神的完美與唯一性，數學必將發展成現代化學或者微軟軟件這樣，龐大而充滿特例，到處都是修補與查表，怎麼會像現在的完美、簡潔與和諧。 神創論者並不是將難題推與 \" 神 \" 然後放任不管，他們相信神是最爲理智的存在，創人時人同樣得到了神的智慧和理智，也就是神可以用人的理智來理解。 引用牛頓《自然哲學的數學原理》中終章的話 \" 太陽、恆星、行星的這個極精緻的結構不可能存在，除非通過一個有理智的和有權能的存在的設計和主宰 …… 他不是作爲宇宙的靈魂，而是作爲一切的主宰而統治所有 ……\" 以上 …… ( 發現最近的哲理思維果然慢了不少，寫作思緒也一片混亂 &#94;_&#94;)","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../9-thoughts-about-oop-from-wrongly-insert-memory-stick.html","title":"由記憶棒誤差故障引發的關於面向對象設計的九點思考","text":"從 farseerfc.wordpress.com 導入 故障描述 : MMC Memory Stick Duo 記憶棒未經 Adapter 適配器，直接插入 SD Reader ，致使 MMC 卡入 SD Reader 中。 棧展開：某日下午，無課。忙於數分作業，想查詢用手機拍攝的板書照片。取出手機中的 MMC 。未經裝配 Adapter ，直接插入 SD Reader 。 (A runtime exception was thrown.) 嘗試翻轉筆記本機身，倒出 MMC ，未果。 (rethrow) 嘗試用手指甲取出，未果。 (rethrow) 考慮到有 \" 推入反彈 \" 機制，嘗試將 MMC 推入更深，反彈機制由於類型不匹配而失效，未果。 (rethrow) (The exception spread across the border of the model.) 電腦維修技師接手 (catch) 技師未能發現問題所在，由我解說原委。 (Because the exception lose the information, RTTI was asked to recall the information) 技師發現問題，嘗試用鑷子鑷出 MMC ，未果。技師開解機箱 (expose the data structure) 技師製作鉤子，勾出 MMC(hooker link to the structure) 取出 MMC ，故障解除 故障總結 1. 接收到沒有完全瞭解、或沒有適當工具解決的 exception 時，不要嘗試用不成熟的技術解決，應儘快尋求能解決它的代碼。否則，被反覆 rethrow 的 exception ，尤其是通過模塊邊界的 exception ，有可能由 subclass 退化爲 superclass ，並因此而喪失一些信息。儘量不要讓 exception 丟失信息，必要時，通過 RTTI 機制尋回信息。 2. 超負荷運轉，多線程執行，這種種複雜性都有可能導致錯誤，應避免。無論你有多麼信任你的代碼或能力。 3. 在設計 class 的 interface 時，相匹配的 interface 應該滿足 is-a 的關係。因此，任何能插入 SD Reader 的 object ，即任何實現了 SD interface 的 object ，都應該 is-a SD card 。這次故障中， interface 接受了 MMC ，但 MMC 不是 SD 。即使這種情況下 throw an exception ，都不能使事態緩和。能提供 compile-time error 時，儘量讓錯誤以 compile-time error 的形式展現，並在事先解決。類型匹配問題是應該能在事先解決的問題。 4.Design patterns 中的 Adapter pattern 應該只是迫不得已情況之下的解決方案。只有當你無權改變現狀時，才能使用 Adapter 。如果能改變現狀，應該改變設計以符合 interface 。 5. 因爲上條，所有相似功能的對象應具有相同的 interface ，不同的 interface 是本次故障的根源所在。 6. 特殊情況下，破壞封裝機制並 expose the data structure 是必要的，應該有方法支持這種做法。 C 的指針和 C# 的 Reflection 技術都以不同的方式支持這種做法。其他的一些語言機制，比如 serializing( 序列化 ) 或 streaming( 流化 ) ，也可以以某種方式間接支持這一做法。當然，機制還應避免這種做法被濫用。 7. 相反功能具有相同操作的設計，容易造成使用的混亂，應適當避免。比如 SD Reader 的推入反彈設計，即插入和彈出使用同一個向裏推的操作的設計。同樣的設計還包括， C++ 中的 setNewHandle 使用同一個函數，同時設置和返回 handle 。以及有些書中提倡的，使用同名函數重載的方式，實現 setter/getter 的設計。 8. 特殊工具 (hooker) 對於解決特定問題，通常比手工解決有效。不要嫌麻煩而不願意構造特殊工具。 9. 棧語義，即 FILO 順序，總在不知不覺中影響我們。違反了 FILO 順序的操作極易造成混亂。本故障發生時正確的處理順序爲：裝配 Adapter 插入 SD Reader 讀取數據 停用設備 拔出 SD Reader 拆解 Adapter 本次故障的原因就是違反了 FILO 順序，違反了棧語義。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../program-development-in-java-preface.html","title":"Program Development in Java Preface","text":"從 farseerfc.wordpress.com 導入 程序開發原理 —— 抽象、規格與面向對象設計 Barbara Liskov 、 John Guttag 著 楊嘉晨等譯 關於翻譯風格： 多年來閱讀計算機類的著作及譯作，感覺總體的困難在於一大堆沒有標準譯名的技術術語。由於通行於工業界和學術界的還是英文原名和術語，我決定保留大量的英文術語。這樣的翻譯風格借鑑於臺灣著名的譯者和作者侯捷先生。對於譯與不譯的權衡，主要考慮閱讀的流暢，以及讀者的理解能力，或許難免帶有一些主觀色彩。 前言 Preface 構建產品級質量的程序 —— 可以在很長一段時間內使用的程序 —— 衆所周知是極其困難的。本書的目標就是改善程序員解決這項任務的效率。我希望讀者在閱讀本書之後成爲一名好程序員。我相信本書的成功在於改善編程技巧，因爲我的學生告訴我這已經發生在他們身上。 怎麼纔算是一名好程序員？是產生整個程序產品的效率。關鍵是要在每一階段減少浪費掉的努力。解決的方法包括：在開始編寫代碼之前就仔細考慮你的實現方案，通過未雨綢繆的方法來編寫代碼，使用嚴格的測試在早期發現錯誤，以及仔細注意模塊化編程，這樣當錯誤出現時，只需要改動極少數代碼就可以修正整個程序。本書涉及所有這些領域的技術。 模塊化編程 (Modularity) 是編寫好程序的關鍵。把程序分解成許多小模塊，每一個模塊通過良好定義的狹窄接口和別的模塊交互作用 (interact) 。有了模塊化，可以修正一部分程序中的錯誤而不考慮程序的其他部分，而且可以僅僅理解一部分程序而不必理解整個程序。沒有模塊化，程序是一大堆有着錯綜複雜的相互關係的部分的拼湊。很難去領悟和修改這樣一個程序，同樣也很難讓它正常工作。 因此本書的重點在於創建模塊化的程序：怎樣把程序組織成一系列精心挑選的模塊。本書認爲模塊化就是抽象 (abstraction) 。每一個模塊意味着一個抽象，比如說指引一系列文檔中的關鍵字的目錄，或者在文檔中使用目錄來查找匹配某個問題的文檔的過程。着重強調面向對象編程思想 —— 在程序中使用數據抽象和對象的思想。 這本書使用 Java 作爲它的編程示例的語言。我們沒有假定讀者已經熟悉 Java 。儘管可能沒什麼價值，但是本書中的思想是語言無關的，並且可以在任何語言的編程中使用。 怎樣使用這本書？ How Can the Book Be Used 本書《程序開發原理》有兩種使用方法。其一是作爲課本教材，講述如何用面向對象的方法來設計和實現複雜系統；其二是編程專家使用，幫助他們改善編程技能，增進他們的關於模塊化和 Object-Oriented( 面向對象 ) 設計的知識。 作爲教材使用時，本書一般作爲第二或第三門程序設計課程。我們已經在 MIT 使用本書很多年，給大一大二的本科生教授第二門編程課。在這一階段，學生們已經知道怎樣編寫小程序。課程在兩方面利用這一點：讓學生更仔細地思考小程序，以及教他們如何利用小程序作爲組件構建大型程序。這本書也可以在專業（如軟件工程）後期教學中使用。 建立在本書基礎上的課程適合於所有計算機科學專業。儘管許多學生可能永遠不會成爲真正的大型程序的設計師，他們可以在開發部門工作，在那兒他們負責設計和實現能與整個結構耦合的子系統。模塊化設計的子系統是這種任務中心，這對那些從事大型程序設計任務的人來說也同樣重要。 這本書講什麼？ What Is This Book About 通觀全篇三分之二的書致力於討論在構建獨立的程序模塊時產生的問題，剩下的部分討論怎樣運用這些模塊構建大型程序。 程序模塊 Program Modules 這一部分的書集中討論抽象機制 (abstraction mechanism) 。它討論 procedure( 子程序 ) 和 exception( 異常 ) ，數據抽象，遍歷 (iteration) 抽象，數據抽象系列 (family) 以及多態 (polymorphic) 抽象。 在對抽象的討論中，三個步驟是重要的。首先是決定被抽象的東西到底是什麼：它提供給它的用戶哪些行爲。創造抽象是設計的關鍵，因此本書討論如何在衆多選擇中挑選，以及怎樣才能創造出好的抽象。 第二步是通過爲一個抽象制定一個規格 (specification) 來獲取它的意義。如果沒有一些描述，一個抽象就會含糊不清，而變得沒有使用價值。 specification 則提供了需要的描述。本書定義了一種 specification 的格式，討論了一份好的 specification 應有的屬性，並且提供了許多示例。 第三步是實現抽象。本書討論怎樣設計一份實現，以及在簡潔性和執行性能之間怎樣權衡利弊。書中強調封裝 (encapsulation) 的重要性以及在一份實現中履行規格中定義的行爲的重要性。書中同樣提供一些技術 —— 尤其是不變式斷言 (representation invariant) 和抽象函數 (abstraction function)—— 來幫助讀者理解代碼和它的原因。不變式斷言和抽象函數都實現到儘可能的程度，這對於除錯和調試很有用。 關於類型層次 (type hierarchy) 的材料注重討論使用它作爲抽象的技術 —— 一種把相關聯的一組數據抽象歸入同一系列的技術。這裏很重要的一點是，是否應當將一個類型作爲另一個類型的子類。本書定義了替換原則 —— 通過比較子類和父類的 specification ，來決定是否建立子類關係的方法 [1] 。 本書同樣涉及除錯和調試。書中討論怎樣得到足夠數量的測試情況，來準備通過黑箱和白箱測試，它同樣強調了複查 (regression) 測試的重要性。 編寫大型程序 Programming in the Large 本書的其後部分講解怎樣用模塊化的方法設計和實現大型程序。它建立在前文有關 abstraction 和 specification 的材料的基礎之上。 編寫大型程序涵蓋四個主要議題。首先講解需求分析 —— 怎樣才能領悟程序中需要什麼。本書討論怎樣實施需求分析，也討論書寫產生的需求規格的方式，通過使用一種描述程序的抽象階段的數據模型。使用這種模型將產生一份更爲正式的 specification ，同時它也使需求檢查更加嚴格，這樣可以更好的領悟需求。 編寫大型程序的第二項議題是程序設計，這通常是一個循序漸進的過程。設計過程圍繞構建有用的抽象來組織，這些抽象作爲整個程序之中理想的構建組建。這些抽象在設計時被仔細的編寫規格，這樣當程序實現時，那些實現抽象的模塊可以獨立地開發。這種設計使用設計筆記編寫文檔，包括描述整個程序結構的模塊間依賴性的圖示。 第三項議題是實現和測試。本書討論了前置設計分析對於實現的必要性，以及怎樣進行設計複審。它同樣討論了設計和實現的順序。這一部分比較了自頂而下與自底而上的組織方式，討論如何使用驅動程序和佔位程序 [2] (stub) ，並且強調了制定一個事先的順序策略的必要性，以滿足開發組織和客戶的需求。 本書以一章設計模式 (design pattern) 結束。一些模式在前面的章節介紹過，比如遍歷抽象是算法的主要組建。最後的章節討論前文中沒有涉及到的模式。希望它作爲這一教材的介紹。有興趣的讀者可以繼續閱讀其它書中更完善的討論 [3] 。 [1] 譯註：如果子類的 specification 包括了所有父類的 specification ，就是說父類的要求也是子類的要求，或者子類的要求更爲嚴格，那麼可以建立父子關係。而替換原則的說法是，對於具有父子關係的類，任何需要一個父類對象的地方，都可以替換爲一個子類對象。 [2] 譯註：在測試某一組建時，由於其餘組建還未實現，這一組建與其餘組建的接口銜接部分無法工作。此時可以針對這一組建編寫其餘組建的佔位程序 (stub) ，預留出接口的銜接代碼。佔位代碼通常不做任何有價值的事情，只報告組建的銜接部位工作正常。 [3] 譯註：作者指的是設計模式的開山之作 —— 《 Design Patterns—Elements of Reusable Object-Oriented Software 》 , 作者爲設計模式界著名的 \" 四人幫 \"GoF(Gang of Four) 。此書詳盡討論了三大類共 23 個廣泛使用的設計模式的適用範圍、依存關係、實現細節以及已有的應用領域等問題。書中以 C++ 和 Smalltalk 爲示例語言，不過書中所涉及的模式適用於所有面向對象的語言。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../c-tricks-3-2-label-goto-and-implementation-of-switch.html","title":"C++ Tricks 3.2 標號、goto，以及switch的實現","text":"從 farseerfc.wordpress.com 導入 3.2 標號、 goto ，以及 switch 的實現 goto 語句及標號 (label) 是最古老的 C 語言特性，也是最早被人們拋棄的語言特性之一。像彙編語言中的 jmp 指令一樣， goto 語句可以跳轉到同一函數體中任何標號位置： void f() {int i=0; Loop: //A label ++i; if(i<10)goto Loop; //Jump to the label } 在原始而和諧的早期 Fortran 和 Basic 時代，我們沒有 if then else ，沒有 for 和 while ，甚至沒有函數的概念，一切控制結構都靠 goto( 帶條件的或無條件的 ) 構件。軟件工程師將這樣的代碼稱作 \" 意大利麪條 \" 代碼。實踐證明這樣的代碼極容易造成混亂。 自從證明了結構化的程序可以做意大利麪條做到的任何事情，人們就開始不遺餘力地推廣結構化設計思想，將 goto 像猛獸一般囚禁在牢籠，標號也因此消失。 標號唯一散發餘熱的地方，是在 switch 中控制分支流程。 很多人不甚瞭解 switch 存在的意義，認爲它只是大型嵌套 if then else 結構的縮略形式，並且比 if 語句多了很多 \" 不合理 \" 的限制。如果你瞭解到 switch 在編譯器內部的實現機制，就不難理解強加在 switch 之上的諸多限制，比如 case 後只能跟一個編譯期整型常量，比如用 break 結束每一個 case 。首先看一個 switch 實例： switch (shape.getAngle()) { case 3: cout<<\"Triangle\";break; case 4: cout<<\"Square\";break; case 0:case1: cout<<\"Not a sharp!\";break; default: cout<<\"Polygon\"; } 任何程序員都可以寫出與之對應的 if 結構： int i= getAngle(shape); if (i==3) cout<<\"Triangle\"; else if(i==4) cout<<\"Square\"; else if(i==0||i==1) cout<<\"Not a sharp!\"; else cout<<\"Polygon\"; 看起來這兩段代碼在語義上是完全一樣的，不是麼？ 不！或許代碼的執行結果完全一樣，但是就執行效率而言， switch 版本的更快！ 要了解爲什麼 switch 的更快，我們需要知道編譯器是怎樣生成 switch 的實現代碼的： 首先，保留 switch 之後由 {} 括起來的語具體，僅將其中 case 、 default 和 break 替換爲真正的標號： switch (getAngle(shape)) { _case_3: cout<<\"Triangle\";goto _break; _case_4: cout<<\"Square\"; goto _break; _case_0:_case_1: cout<<\"Not a sharp!\"; goto _break; _default: cout<<\"Polygon\"; _break: } 隨後，對於所有出現在 case 之後的常量，列出一張只有 goto 的跳轉表，其順序按 case 後的常量排列： goto _case_0; goto _case_1; goto _case_3; goto _case_4; 然後，計算 case 之後的常量與跳轉表地址之間的關係，如有需要，在跳轉表中插入空缺的項目： 100105: goto _case_0; 100110: goto _case_1; 100115: goto _default; // 因爲沒有 case 2 ，所以插入此項以條轉到 default 100120: goto _case_3; 100125: goto _case_4; 假設一個 goto 語句佔用 5 個字節，那麼在本例中， goto 的地址 =case 後的常量 *5+100105 之後，生成跳轉代碼，在其餘條件下跳轉至 default ，在已知範圍內按照公式跳轉，全部的實現如下： { int i= getAngle(shape); if (i<0||i>=5)goto _default; i=i*5+100105; // 按照得出的公式算出跳轉地址 goto i; // 僞代碼， C 中不允許跳轉到整數，但是彙編允許 100105: goto _case_0; 100110: goto _case_1; 100115: goto _default; 100120: goto _case_3; 100125: goto _case_4; _case_3: cout<<\"Triangle\";goto _break; _case_4: cout<<\"Square\"; goto _break; _case_0:_case_1: cout<<\"Not a sharp!\"; goto _break; _default: cout<<\"Polygon\"; _break: } 經過這樣處理整個 switch 結構，使得無論 switch 後的變量爲何值，都可以通過最多兩次跳轉到達目標代碼。相比之下 if 版本的代碼則採用線性的比較和跳轉，在 case 語句很多的情況下效率極低。 由此 , 我們也可以知道 , 爲什麼 case 後跟的一定是編譯期整型常數，因爲編譯器需要根據這個值製作跳轉表。我們可以明白爲什麼 case 與 case 之間應該用 break 分隔，因爲編譯器不改變 switch 語句體的結構， case 其本身只是一個具有語義的標號而已，要想跳出 switch ，就必須用 break 語句。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../c-tricks-3-1-lvalue-rvalue-constant.html","title":"C++ Tricks 3.1 左值右值與常量性(lvalue，rvalue & constant)","text":"從 farseerfc.wordpress.com 導入 3.1 左值右值與常量性 (lvalue ， rvalue & constant) 首先要搞清楚的是，什麼是左值，什麼是右值。這裏給出左值右值的定義： 1 、左值是可以出現在等號 (=) 左邊的值，右值是隻能出現在等號右邊的值。 2 、左值是可讀可寫的值，右值是隻讀的值。 3 、左值有地址，右值沒有地址。 根據左值右值的第二定義，值的左右性就是值的常量性 —— 常量是右值，非常量是左值。比如： 1=1;//Error 這個複製操作在 C++ 中是語法錯誤， MSVC 給出的錯誤提示爲 \"error C2106: ‘=' : left operand must be l-value\" ，就是說 '=' 的左操作數必須是一個左值，而字面常數 1 是一個右值。可見，嚴格的區分左值右值可以從語法分析的角度找出程序的邏輯錯誤。 根據第二定義，一個左值也是一個右值，因爲左值也可讀，而一個右值不是一個左值，因爲右值不可寫。 通常情況下，聲明的變量是一個左值，除非你指定 const 將它變成一個右值： int lv=1; const int rv=lv; 由於右值的值在程序執行期間不能改變，所以必須用另一個右值初始化它。 一個普通變量只能用右值初始化，如果你想傳遞左值，必須聲明一個引用或一個指針： int & ref=lv;// 用引用傳遞左值 int * plv=&lv;// 傳遞指針以間接傳遞左值 必須用左值初始化引用，然而，可以用右值初始化常量引用： int & r1=1; //Error! const int & r2=1; // OK 這實際上相當於： int _r2=1; const int & r2=_r2; 這樣的寫法在函數體內沒什麼作用，但是在傳遞函數參數時，它可以避免潛在的 ( 傳遞左值時的 ) 複製操作，同時又可以接受右值。 通常情況下，函數的參數和返回值都只傳回右值，除非你明確的通過引用傳遞左值。 明確了左值與右值的區別，有助於我們寫函數時確定什麼時候應該有 const ，什麼時候不該有。比如，我們寫了一個代表數學中複數的類 Complex ： class Complex; 然後，我們寫針對 Complex 的運算符重載： operator+ 和 operator= 。問題在於，參數和返回值應該是什麼類型，可選類型有四種： Complex 、 const Complex 、 Complex& 、 const Complex& 。 對於 operator+ ，我們不會改變參數的值，所以可以通過 const Complex& 傳遞參數。至於返回值類型，由於 int 類型的加法返回右值，所以根據 Do as the ints do 的原則，返回值類型爲 const Complex ： const Complex operator+(const Complex&,const Complex&); 對於 operator= ，同樣要思考這些問題。我們寫入第一個參數，所以第一個參數爲 Complex& ，我們只讀取第二個參數，所以第二個參數爲 const Complex& 。至於返回值，還是 Do as the ints do 。 int 的賦值返回左值，不信你可以試一試： int i; (i=1)=2; 雖然比較傻，先將 i 賦爲 1 ，再將其改爲 2 ，但是這是被 C++ 語法支持的做法，我們就理應遵守。所以返回第一個參數的左值： Complex& operator=(Complex&,const Complex&); const 是 C++ 引入的語言特性，也被 ANSI C99 借鑑，在經典版本的 C 語言中是沒有的。關於 const 的歷史，有幾點值得玩味。最初 Bjarne Stroustrup 引入 const 時，可寫性是和可讀性分開的。那時使用關鍵字 readonly 和 writeonly 。這個特點被首先提交到 C 的 ANSI 標準化委員會 ( 當時還沒有 C++ 標準化的計劃 ) ，但是 ANSI C 標準只接受了 readonly 的概念，並將其命名爲 const 。隨後，有人發現在多線程同步的環境下，有些變量的值會在編譯器的預料之外改變，爲了防止過度優化破壞這些變量， C++ 又引入關鍵字 violate 。從語義特點來看， violate 是 const 的反義詞，因爲 const 表示不會變的量，而 violate 表示會不按照預期自行變化的量。從語法特點而言， violate 與 const 是極爲相似的，適用於 const 的一切語法規則同樣適用於 violate 。 值的常量性可以被劃分爲兩種：編譯期常量和運行期常量。 C++ 語法並沒有嚴格區分這兩種常量，導致了少許混亂： const int i=5;const int * pi=&i; const_cast<int&>i=1;// 對於運行期常量，在需要時可以去除它的常量性 int a[i];// 對於編譯期常量，可以用它來指定數組大小 cout<<i<<sizeof(a)/sizeof(a[0])<<*pi; 這種將編譯期與運行期常量的特性混用的方法，勢必導致語義的混亂。數組 a 的大小最終是 5 ，因爲採用了 i 的編譯期值，而不管 i 在運行期是否被改變了值。最後一句代碼將（有可能）輸出 551 ，第一個 i 的值作爲一種優化在編譯期綁定，第二個值標明瞭 a 的大小，第三個值通過指針顯示地輸出 i 的運行期真實值。 在 C++ 的近親 C# 的語法中，這兩種常量被嚴格地區分開：編譯期常量由 const 指定，只能是內建類型變量；運行期常量由 readonly 指定，可以是任何類型。永遠不會改變的常量，如圓周率 pi 的值，應該用 const 聲明；而其它有可能改變的常量，皆由 readonly 聲明。 C++ 中的 const 的特點更傾向於 C# 中的 readonly ，雖然語法上允許使用 const 的編譯期常量性，但正如上文所展示的，這容易造成混亂。爲了得到 C# 中 const 的語義，在 C++ 中，我們不必迴歸惡魔 #define 的懷抱，可以使用所謂 \" 匿名 enum 技巧 \" 。當匿名聲明一個 enum 類型時，其中的枚舉值就是一個 int 類型的編譯期常量，比如： enum{Size=5;}; int a[Size]; 這種使用匿名 enum 來聲明編譯期常量的做法，被廣泛應用於 STL 、 boost 等模板庫的實現代碼中。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../c-tricks-2-2-i386-memory-layout.html","title":"C++ Tricks 2.2 I386平臺的內存佈局","text":"從 farseerfc.wordpress.com 導入 2.2 I386 平臺的內存佈局 衆所周知， I386 是 32 位體系結構。因此對於絕大多數 I386 平臺的 C++ 編譯器而言， sizeof(int)=sizeof(long)=sizeof(void*)=4 。當然 C++ 標準對此沒有任何保證，我們也不應該試圖編寫依賴於此的代碼。 32 位指針的可尋址空間爲 4GB 。爲充分利用這麼大的尋址空間，也是爲了支持其它更先進的技術比如多任務技術或者動態鏈接庫技術， WinNT 使用虛擬內存技術，給與每個應用程序全部 4GB 的內存空間。 4GB 的地址被一分爲二，前 2GB 供應用程序自己使用，後 2GB 由系統內核分配和管理。這 2GB 的內存地址，通常被劃分成 3 種內存區使用： 1 代碼及靜態數據區 由代碼加載器從動態鏈接庫鏡像 ( 通常是 exe 或 dll 文件 ) 加載，通常定位到鏡像文件中指定的基址開始的內存區。如果基址所在內存已被佔用，動態連接器會將代碼或數據重定向到其它可用地址。 在 C++ 中，靜態數據包括：名字空間 (namespace) 和全局 (global) 對象、函數的 static 對象、類的 static 數據成員。這些靜態數據由編譯器分配地址 ( 但可能被重定向 ) ，由靜態連接器寫入代碼文件 ( 通常是 exe 或 dll) 的靜態數據區段。所以標準說，這些靜態數據在編譯期就已經具有地址。 2 棧 (Stack) 棧是最常用的動態數據存儲區，所有函數的 non-static 對象和函數參數都在程序運行期在棧上分配內存。在數據結構中，術語 \" 棧 (Stack)\" 意指先進後出 ( FILO ， First In Last Out) ，與 \" 隊列 (Queue)\" 所指的 FIFO 相對。相對於基於堆的對象分配技術，默認使用棧的對象分配有兩點優勢： 一、棧的 FILO 與人的思維方式相同 現實生活中有許多事例都使用 FILO 的方式，比如人們必須先提起話筒再撥打號碼，而後掛斷電話之後再放下話筒。使用 FILO 的棧，可以保證事物的銷燬順序以其誕生順序相反的順序進行，不會產生在掛斷電話之前就放下話筒的尷尬。 二、棧的分配管理僅需要兩個額外指針：棧頂 (esp) 和棧底 (ebp) 指針 從實現的技術層面而言，棧的管理比其它動態分配技術要簡單很多。 I386 平臺上的動態棧管理，僅需要棧頂和棧底兩個指針。這兩個指針的存儲顯然不能放置於棧中，置於靜態數據區又有損效率。 I386 平臺爲管理動態棧專門預留了兩個通用寄存器變量 esp 與 ebp ，分別代表棧頂 (esp,Extended Stack Pointer) 與棧底 (Extended Bottom Pointer) 指針。其中的 extended 代表它們是 32 位指針，以區分 16 位的 sp 和 bp 寄存器。 棧是動態存儲區的特點，表明它的內存佔用將隨着程序的運行而變化。 I386 平臺上 WinNT 將應用程序的棧置於程序空間，向下增長。程序初始化時，由操作系統將 esp 指向系統分配的棧空間的頂部。當程序需要在棧上分配變量時，就將 esp 減去變量所需字節數，這被稱作 \" 壓棧 (Push)\" ；隨後又要銷燬變量時，就將 esp 加上變量所需字節數，這被稱作 \" 彈出 (Pop)\" 。 esp 與 ebp 兩者之間所夾的空間，就是當前函數正在使用的棧空間。由於棧向下增長， esp( 棧頂 ) 的值總是小於 ebp( 棧底 ) 的值，新分配的變量地址總是小於舊變量的地址。 3 堆 (Heap) 和自由存儲區 棧中的變量對於分配與釋放的順序有特定要求，這在一定程度上限制了棧的適用範圍。面向對象 ( OO ， Object Oriented) 的程序設計思想也要求能自由地控制變量的分配與銷燬。由此，現代操作系統都提供了被稱作 \" 堆 (Heap)\" 的自由存儲區，以允許由程序員控制的對象創建和銷燬過程。 C 標準庫函數 malloc 和 free 則是對操作系統提供的堆操作的封裝。 C++ 提供的自由存儲區運算符 new 和 delete 則通常是 malloc 和 free 的又一層封裝。 操作系統經由 malloc 和 free 控制對堆的訪問。堆的存儲管理技術各不相同，簡單的使用雙鏈表管理，複雜的可以比擬一個完整的文件系統。 由於額外的管理需求，使用系統提供的通用分配器在堆上分配和銷燬變量的代價，無論從空間角度還是效率角度而言，都比在棧上分配對象要高昂很多。對於 sizeof 上百的大型對象，這樣的高昂代價還是可以接受的，但是對於 sizeof 只有個位數的小對象，這樣的代價通常是一個數量級的差距。正因爲這個原因， STL 不使用 new 和 delete ，轉而使用分配子 (alllocor) 分配對象。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../c-tricks.html","title":"C++ Tricks","text":"從 farseerfc.wordpress.com 導入 C++ Tricks By FarseerFc 從今天起，我再將在 Live Space 和 QQZone 同時發表一系列文章，暫定名爲 \"C++Tricks\" 。 本文旨在記錄和闡述一些本人學習 C++ 時所得的心得、技巧。總體來看，本文涉及的內容是每一個 C++ 程序員都應該知道的，但是很少見諸 C++ 教材。希望對各位同仁學習 C++ 有所幫助。 也可以通過 QQ 或 MSN 向我索要此文的 DOC 版或 PDF 版，會比網頁上的更新的快一點。 1 詞法問題 (Lexical Problems) 1.1 條件運算符 (?:) 1.2 逗號運算符 (,) 、邏輯運算符 (&&,||) 與運算符重載的陷阱 2 X86 體系結構 2.1 X86 概述 2.2 I386 平臺的內存佈局 2.3 I386 平臺 C 函數內部的棧分配 2.4 I386 平臺 C 函數調用邊界的棧分配 2.5 I386 平臺的邊界對齊 (Align) 2.6 I386 平臺 C 函數的可變參數表 (Variable Arguments) 2.7 I386 平臺的其它函數調用模型 3 過程式編程 3.1 左值右值與常量性 (lvalue ， rvalue & constant) 3.2 標號、 goto ，以及 switch 的實現","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../c-tricks-2-3-i386-stack-allocation-in-c-functions.html","title":"C++ Tricks 2.3 I386平臺C函數內部的棧分配","text":"從 farseerfc.wordpress.com 導入 2.3 I386 平臺 C 函數內部的棧分配 函數使用棧來保存局部變量，傳遞函數參數。進入函數時，函數在棧上爲函數中的變量統一預留棧空間，將 esp 減去相應字節數。當函數執行流程途徑變量聲明語句時，如有需要就調用相應構造函數將變量初始化。當執行流程即將離開聲明所在代碼塊時，以初始化的順序的相反順序逐一調用析構函數。當執行流程離開函數體時，將 esp 加上相應字節數，歸還棧空間。 爲了訪問函數變量，必須有方法定位每一個變量。變量相對於棧頂 esp 的位置在進入函數體時就已確定，但是由於 esp 會在函數執行期變動，所以將 esp 的值保存在 ebp 中，並事先將 ebp 的值壓棧。隨後，在函數體中通過 ebp 減去偏移量來訪問變量。以一個最簡單的函數爲例： void f() { int a=0; //a 的地址被分配爲 ebp-4 char c=1; //c 的地址被分配爲 ebp-8 } 產生的彙編代碼爲： push ebp ; 將 ebp 壓棧 mov ebp,esp ;ebp=esp 用棧底備份棧頂指針 sub esp,8 ;esp-=8 ，爲 a 和 c 預留空間，包括邊界對齊 mov dword ptr[ebp-4],0 ;a=0 mov byte ptr[ebp-8],1 ;c=1 add esp,8 ;esp+=8 ，歸還 a 和 c 的空間 mov esp,ebp ;esp=ebp 從棧底恢復棧頂指針 pop ebp ; 恢復 ebp ret ; 返回 相應的內存佈局是這樣： 09992:c=1 <-esp 09996:a=0 10000: 舊 ebp <-ebp 10004:…… 注 : 彙編中的 pop 、 push 、 call 、 ret 語句是棧操作指令，其功能可以用普通指令替換 push ebp 相當於 : add esp,4 mov dword ptr[esp],ebp pop ebp 相當於： mov ebp,dword ptr[esp] sub esp,4 call fun_address 相當於： push eip jmp fun_address ret 相當於 add esp,4 jmp dword ptr[esp-4] 帶參數的 ret ret 8 相當於 add esp,12 jmp dword ptr[esp-4] 所有局部變量都在棧中由函數統一分配，形成了類似逆序數組的結構，可以通過指針逐一訪問。這一特點具有很多有趣性質，比如，考慮如下函數，找出其中的錯誤及其造成的結果： void f() { int i,a[10]; for(i=0;i<=10;++i)a[i]=0;/An error occurs here! } 這個函數中包含的錯誤，即使是 C++ 新手也很容易發現，這是老生常談的越界訪問問題。但是這個錯誤造成的結果，是很多人沒有想到的。這次的越界訪問，並不會像很多新手預料的那樣造成一個 \" 非法操作 \" 消息，也不會像很多老手估計的那樣會默不作聲，而是導致一個，呃，死循環！ 錯誤的本質顯而易見，我們訪問了 a[10] ，但是 a[10] 並不存在。 C++ 標準對於越界訪問只是說 \" 未定義操作 \" 。我們知道， a[10] 是數組 a 所在位置之後的一個位置，但問題是，是誰在這個位置上。是 i! 根據前面的討論， i 在數組 a 之前被聲明，所以在 a 之前分配在棧上。但是， I386 上棧是向下增長的，所以， a 的地址低於 i 的地址。其結果是在循環的最後， a[i] 引用到了 i 自己！接下來的事情就不難預見了， a[i] ，也就是 i ，被重置爲 0 ，然後繼續循環的條件仍然成立 …… 這個循環會一直繼續下去，直到在你的帳單上產生高額電費，直到耗光地球電能，直到太陽停止燃燒 …… 呵呵，或者直到聰明的你把程序 Kill 了 ……","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html","title":"C++ Tricks 2.4 I386平臺C函數調用邊界的棧分配","text":"從 farseerfc.wordpress.com 導入 2.4 I386 平臺 C 函數調用邊界的棧分配 當調用一個函數時，主調函數將參數以聲明中相反的順序壓棧，然後將當前的代碼執行指針 (eip) 壓棧，然後跳轉到被調函數的入口點。在被調函數中，通過將 ebp 加上一個偏移量來訪問函數參數，以聲明中的順序 ( 即壓棧的相反順序 ) 來確定參數偏移量。被調函數返回時，彈出主調函數壓在棧中的代碼執行指針，跳回主調函數。再由主調函數恢復到調用前的棧。 函數的返回值不同於函數參數，通過寄存器傳遞。如果返回值類型可以放入 32 位變量，比如 int 、 short 、 char 、指針等類型，通過 eax 寄存器傳遞。如果返回值類型是 64 位變量，如 _int64 ，同過 edx+eax 傳遞， edx 存儲高 32 位， eax 存儲低 32 位。如果返回值是浮點類型，如 float 和 double ，通過專用的浮點數寄存器棧的棧頂返回。如果返回值類型是用戶自定義結構，或 C++ 類類型，通過修改函數簽名，以引用型參數的形式傳回。 同樣以最簡單的函數爲例： void f(){ int i=g(1,2); } int g(int a,int b){ int c=a+b ； return c; } 產生的彙編代碼如下： f: push ebp ; 備份 ebp mov ebp,esp ; 建立棧底 sub esp,4 ; 爲 i 分配空間 mov eax,2 ; 準備參數 b 的值 2 push eax ; 將 b 壓棧 mov eax,1 ; 準備參數 a 的值 1 push eax ; 將 a 壓棧 call g ; 調用 g add esp,8 ; 將 a 和 b 一起彈出，恢復調用前的棧 mov dword ptr[ebp-4],eax ; 將返回值保存進變量 i mov esp,ebp ; 恢復棧頂 pop ebp ; 恢復棧底 g: push ebp ; 備份 ebp mov ebp,esp ; 建立棧底 sub esp,4 ; 爲局部變量 c 在棧中分配內存 mov eax,dword ptr[ebp+8] ; 通過 ebp 間接讀取參數 a 的值 mov ebx,dword ptr[ebp+12] ; 通過 ebp 間接讀取參數 b 的值 add eax,ebx ; 將 a 和 b 的值相加，之和存在 eax 中 mov dword ptr[ebp-4],eax ; 將和存入變量 c mov eax,dword ptr[ebp-4] ; 將 c 作爲返回值，代碼優化後會刪除此句 add esp,4 ; 銷燬 c 的內存 mov esp,ebp ; 恢復棧頂 pop ebp ; 恢復棧底 ret ; 返回函數 f 棧的內存佈局如下： 100076:c <- g 的 esp 100080:f 的 ebp=100100 <- g 的 ebp 100084:f 的 eip 100088:a=1 100092:b=2 100096:i 100100: 舊 ebp <-f 的 ebp 100104:…… 注意在函數 g 的彙編代碼中，訪問函數的局部變量和訪問函數參數的區別。局部變量總是通過將 ebp 減去偏移量來訪問，函數參數總是通過將 ebp 加上偏移量來訪問。對於 32 位變量而言，第一個局部變量位於 ebp-4 ，第二個位於 ebp-8 ，以此類推， 32 位局部變量在棧中形成一個逆序數組；第一個函數參數位於 ebp+8 ，第二個位於 ebp+12 ，以此類推， 32 位函數參數在棧中形成一個正序數組。 由於函數返回值通過寄存器返回，不需要空間分配等操作，所以返回值的代價很低。基於這個原因，舊的 C 語法約定，不寫明返回值類型的函數，返回值類型爲 int 。這一規則與現行的 C++ 語法相違背，因爲 C++ 中，不寫明返回值類型的函數返回值類型爲 void ，表示不返回值。這種語法不兼容性是爲了加強 C++ 的類型安全，但同時也帶來了一些問題。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../c-tricks-2-5-address-alignment.html","title":"C++ Tricks 2.5 I386平臺的邊界對齊(Align)","text":"從 farseerfc.wordpress.com 導入 2.5 I386 平臺的邊界對齊 (Align) 首先提問，既然 I386 上 sizeof(int)==4 、 sizeof(char)==1 ，那麼如下結構 (struct)A 的 sizeof 是多少？ struct A{int i;char c;}; 答案是 sizeof(A)==8……1+5=8 ？ 呵呵，這就是 I386 上的邊界對齊問題。我們知道， I386 上有整整 4GB 的地址空間，不過並不是每一個字節上都可以放置任何東西的。由於內存總線帶寬等等的技術原因，很多體系結構都要求內存中的變量被放置於某一個邊界的地址上。如果違反這個要求，重則導致停機出錯，輕則減慢運行速度。對於 I386 平臺而言，類型爲 T 的變量必須放置在 sizeof(T) 的整數倍的地址上， char 可以隨便放置， short 必須放在 2 的整數倍的地址上， int 必須放在 4 的整數倍的地址上， double 必須放在 8 的整數倍的地址上。如果違反邊界對齊要求，從內存中讀取數據必須進行兩次，然後將獨到的兩半數據拼接起來，這會嚴重影響效率。 由於邊界對齊問題的要求，在計算 struct 的 sizeof 的時候，編譯器必須算入額外的字節填充，以保證每一個變量都能自然對齊。比如如下聲明的 struct: struct WASTE { char c1; int i; char c2; } 實際上相當於聲明瞭這樣一個結構： struct WASTE { char c1; char _filling1 [3];// 三個字節填充，保證下一個 int 的對齊 int i; char c2 ； char _filling2 [3];// 又三個字節填充 } 值得注意的是尾部的 3 個字節填充，這是爲了可以在一個數組中聲明 WASTE 變量，並且每一個都自然對齊。因爲有了這些填充，所以 sizeof( WASTE )==12 。這是一種浪費，因爲只要我們重新安排變量的聲明，就可以減少 sizeof ： struct WASTE { int i; char c1,c2; } 像這樣的安排， sizeof 就減少到 8 ，只有 2 個字節的額外填充。爲了與彙編代碼相兼容， C 語言語法規定，編譯器無權擅自安排結構體內變量的佈局順序，必須從左向右逐一排列。所以，妥當安排成員順序以避免內存空間的浪費，就成了我們程序員的責任之一。一般的，總是將結構體的成員按照其 sizeof 從大到小排列， double 在最前， char 在最後，這樣總可以將結構的字節填充降至最小。 C++ 繼承了 C 語言關於結構體佈局的規定，所以以上的佈局準則也適用於 C++ 的 class 的成員變量。 C++ 進一步擴展了佈局規定，同一訪問區段 (private 、 public 、 protected) 中的變量，編譯器無權重新排列，不過編譯器有權排列訪問區段的前後順序。基於這個規則， C++ 中有的程序員建議給每一個成員變量放在單獨區段，在每一個成員聲明之前都加上 private: 、 public: 、 protected: 標誌，這可以最大限度的利用編譯器的決策優勢。 在棧中按順序分配的變量，其邊界也受到對齊要求的限制。與在結構中不同的是，棧中的變量還必須保證其後續變量無論是何種類型都可以自由對齊，所以在棧中的變量通常都有平臺相關的對齊最小值。在 MSVC 編譯器上，這個最小值可以由宏 _INTSIZEOF(T) 查詢： #define _INTSIZEOF(T) ( (sizeof(T) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) _INTSIZEOF(T) 會將 sizeof(T) 進位到 sizeof(int) 的整數倍。 由於在棧中分配變量使用 _INTSIZEOF 而不是 sizeof ，在棧上連續分配多個小變量 (sizeof 小於 int 的變量 ) 會造成內存浪費，不如使用結構 (struct) 或數組。也就是說： char c1,c2,c3,c4;// 使用 16 字節 char c[4];// 使用 4 字節 當然，使用數組的方法在訪問數組變量 ( 比如 c[1]) 時有一次額外的指針運算和提領 (dereference) 操作，這會有執行效率的損失。這又是一種空間 ( 內存佔用 )vs 時間 ( 執行效率 ) 的折中，需要程序員自己根據情況權衡利弊。 sizeof 的大小可能比我們預期的大，也可能比我們預期的小。對於空類： class Empty {}; 在通常情況下， sizeof(Empty) 至少爲 1 。這是因爲 C++ 語法規定，對於任何實體類型的兩個變量，都必須具有不同的地址。爲了符合語法要求，編譯器會給 Empty 加入 1 字節的填充。所以 sizeof() 的值不可能出現 0 的情況。可是對於以下的類聲明： class A:public Empty{vitual ~A(){}}; sizeof(A) 有可能是 6 ，也有可能是 5 ，也有可能是 4 ！必不可少的四個字節是一個指向虛函數表的指針。一個可能有的字節是 Empty 的大小，這是是因爲編譯器在特定情況下會將 Empty 視作一個 \" 空基類 \" ，從而實施 \" 空基類優化 \" ，省掉那毫無作用的一字節填充。另一個字節是 A 的一字節填充，因爲從語法上講， A 沒有成員聲明，理應有 1 字節填充，而從語義上講，編譯器給 A 的聲明加入了一個指向虛函數表的指針，從而 A 就不再是一個 \" 空類 \" ，是否實施這個優化，要看編譯器作者對語法措詞的理解。也就是說， sizeof 也會出現 4+1+1=4 的情況。具體要看編譯器有沒有實施 \" 空基類優化 \" 和 \" 含虛函數表的空類優化 \" 。 結構和類的空間中可能有填充的字節，這意味着填充字節中可能有數值，雖然這數值並不影響結構的邏輯狀態，但是它也可能不知不覺中影響到你。比如說，你手頭正好有一組依賴於底層硬件 ( 比如多處理器 ) 的函數，他們在操縱連續字節時比手動編碼要快很多，而你想充分利用這種硬件優勢： bool BitCompare(void* begin,void* end,void* another); 這個函數將區間 [begin,end) 之間的字節與 another 開始的字節相比較，如果有一位不同就返回 false ，否則返回 true 。 比如你想將這個函數用於你自己的類的 operator== 中，這樣可以利用硬件加快速度。不過你在動手前要充分考慮，你的 class 是否真的要比較每一位。如果在類的成員中存在編譯器填充的字節數，那麼應用以上的函數就是不正確的，因爲填充的字節中可以有不同的值。爲了保證你可以用 Bitwise Compare ，你必須確保填充的字節中的值也是相同的。這不僅要求你在類的構造函數中初始化類的每一 bit 而不是每一個成員，也要求你在複製初始化和複製賦值函數中也同時保證 bitwise copy 語義，而不是編譯器默認產生的 memberwise 語義。當然，你可能通過與 BitCompare 一同提供的 BitCopy 來完成這個艱鉅的任務。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../c-tricks-2-6-i386-variable-arguments.html","title":"C++ Tricks 2.6 I386平臺C函數的可變參數表(Variable Arguments)","text":"從 farseerfc.wordpress.com 導入 2.6 I386 平臺 C 函數的可變參數表 (Variable Arguments) 基於前文 (2.4 節 ) 分析，我們可以不通過函數簽名，直接通過指針運算，來得到函數的參數。由於參數的壓棧和彈出操作都由主調函數進行，所以被調函數對於參數的真實數量不需要知曉。因此，函數簽名中的變量聲明不是必需的。爲了支持這種參數使用形式， C 語言提供可變參數表。可變參數表的語法形式是在參數表末尾添加三個句點形成的省略號 \"…\" ： void g(int a,char* c,…); 省略號之前的逗號是可選的，並不影響詞法語法分析。上面的函數 g 可以接受 2 個或 2 個以上的參數，前兩個參數的類型固定，其後的參數類型未知，參數的個數也未知。爲了知道參數個數，我們必須通過其他方法，比如通過第一個參數傳遞： g(3,\"Hello\",2,4,5);// 調用 g 並傳遞 5 個參數，其中後 3 個爲可變參數。 在函數的實現代碼中，可以通過 2.4 節敘述的，參數在棧中的排列順序，來訪問位於可變參數表的參數。比如 : void g(int a,char* c…){ void *pc=&c;int* pi=static_cast<int*>(pc)+1;// 將 pi 指向首個可變參數 for(int i=0;i<a;i++)std::cout<<pi[i]<<\" \" ； std::cout<<c<<std::endl; } 我們甚至可以讓一個函數的所有參數都是可變參數，只要有辦法獲知參數的數量即可。比如，我們約定，在傳遞給 addAll 的參數都是 int ，並且最後一個以 0 結束： int addAll(…); int a=f(1,4,2,5,7,0); 那麼 addAll 可以這樣實現： int addAll(…){ int sum=0;int *p=&sum; //p 指向第一個局部變量 p+=3; // 跳過 sum ， ebp ， eip ，現在 p 指向第一個參數 for(;*p;++p) // 如果 p 不指向 0 就繼續循環 sum+=*p; return sum; } 可變參數表的最廣泛應用是 C 的標準庫函數中的格式化輸入輸出： printf 和 scanf 。 void printf(char *c,…); void scanf(char *c,…); 兩者都通過它的首個參數指出後續參數表中的參數類型和參數數量。 如果可變參數表中的參數類型不一樣，那麼操縱可變參數表就需要複雜的指針運算，並且還要時刻注意邊界對齊 (align) 問題，非常令人頭痛。好在 C 標準庫提供了用於操縱可變參數表的宏 (macro) 和結構 (struct) ，他們被定義在庫文件 stdarg.h 中 : typedef struct {char *p;int offset;} va_list; #define va_start(valist,arg) #define va_arg(valist,type) #define va_end(valist) 其中結構 va_list 用於指示參數在棧中的位置，宏 va_start 接受一個 va_list 和函數的可變參數表之前的參數，通過第一個參數初始化 va_list 中的相應數據，因此要使用 stdarg.h 中的宏，你的可變參數表的函數必須至少有一個具名參數。 va_arg 返回下一個類型爲 type 的參數， va_end 結束可變參數表的使用。還是以上文的 addAll 爲例，這次寫出它的使用標準宏的版本： int addAll(int i,…) { va_list vl; // 定義一個 va_list 結構 va_start(vl,i); // 用省略號之前的參數初始化 vl if(i=0)return 0; // 如果第一個參數就是 0 ，返回 int sum=i; // 將第一個參數加入 sum for(;;){ i=va_arg(vl,int); // 取得下一個參數，類型是 sum if(i==0)break; // 如果參數是 0 ，跳出循環 sum+=i; } va_end(vl); return sum; } 可以看出，如果參數類型一致，使用標準庫要多些幾行代碼。不過如果參數類型不一致或者未知 (printf 的情況 ) ，使用標準庫就要方便很多，因爲我們很難猜出編譯器處置邊界對齊 (align) 等彙編代碼的細節。使用標準庫的代碼是可以移植的，而使用上文所述的其它方法操縱可變參數表都是不可移植的，僅限於在 I386 平臺上使用。 縱使可變參數表有使用上的便利性，它的缺陷也有很多，不可移植性和平臺依賴性只是其一，最大的問題在於它的類型不安全性。使用可變參數表就意味着編譯器不對參數作任何類型檢查，這在 C 中算是一言難盡的歷史遺留問題，在 C++ 中就意味着惡魔 reinterpret_cast 被你喚醒。 C 的可變參數表是 C++ 代碼錯誤頻發的根源之一，以至於 C++ 標準將可變參數表列爲即將被廢除的 C 語言遺留特性。 C++ 語法中的許多新特性，比如重載函數、默認參數值、模板，都可以一定程度上替代可變參數表，並且比可變參數表更加安全。 可變參數表在 C++ 中惟一值得嘉獎的貢獻，是在模板元編程 ( TMP ) 的 SFINAE 技術中利用可變參數表製作最差匹配重載。根據 C++ 標準中有關函數重載決議的規則，具有可變參數表的函數總是最差匹配，編譯器在被逼無奈走頭無路時纔會選擇可變參數表。利用這一點，我們可以精心製作重載函數來提取類型信息。比如，要判斷一個通過模板傳遞來的類型是不是 int ： long isIntImp(int); char isIntImp(…); template<typename T> struct isInt { enum{value=sizeof(isIntImp(T()))==sizeof(long);} } 然後，在一個具有模板參數 T 的函數中，我們就可以寫 if(isInt<T>::value)//… 在這個 ( 不怎麼精緻的 ) 例子中，如果 T 是 int ，那麼 isIntImp 的第一個重載版本就會被選中，返回值類型就是 long ，這樣 value 就爲 1 。否則，編譯器只能選中第二個具有可變參數表的重載版本，返回值類型成爲 char ，這樣 value 就爲 0 。把它說得再明白一些，上文的代碼所表達的意思是：如果類型 T 是 int ，那它就是 int ，否則它就不是 int ，呵呵簡單吧。這種通過重載決議規則來提取類型信息的技術，在模板元編程中被稱作 SFINAE ，它和其它模板元編程技術被廣泛運用於 STL 、 Boost 等模板庫的開發實現之中。 值得注意的是，在上文 SFINAE 的運用中， isIntImp 並沒有出現定義而只提供了聲明，因爲我們並沒有實際調用 isIntImp 函數，而只是讓它參與重載決議並用 sizeof 判斷其返回值類型。這是 C++ 的一個設計準則的完美體現：不需要的東西可以不出現。由於這一準則，我們避免了在 C++ 中調用具有可變參數表的函數這一危險舉動，而僅僅利用了可變參數表在語法分析過程中的特殊地位，這種對於危險語言特性的巧妙利用是善意而無害的。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../c-tricks-2-7-i386-calling-conventions.html","title":"C++ Tricks 2.7 I386平臺的其它函數調用模型","text":"從 farseerfc.wordpress.com 導入 2.7 I386 平臺的其它函數調用模型 上文介紹的只是 I386 平臺上 C 函數調用的標準模型，被稱作 __cdecl 。事實上， Microsoft Visual C++ 編譯器還支持其它一些函數調用模型，所有調用模型名稱皆以雙下劃線開頭，下面列出所有函數調用模型的異同： 1 __cdecl 參數壓棧順序：逆序 ( 從右至左 ) 參數堆棧恢復者：主調函數 (caller) __cdecl 明確地指出函數使用 C 函數調用模型，這是默認的調用模型。 2 __stdcall 參數壓棧順序：逆序 ( 從右至左 ) 參數堆棧恢復者：被調函數 (callee) __stdcall 是微軟所謂的標準調用模型。可惜的是它與 __cdecl 不兼容。幾乎所有的 Win32API 函數使用這種函數調用模型，希望在 DLL 之間，或者在程序和 WinNT 操作系統之間傳遞函數指針的函數也應該使用這種模型。與 __cdecl 模型的不同之處在於， __stdcall 模型下由被調函數恢復堆棧。主調函數在 call 語句之後，不需要再加上 add 語句。而被調函數的 ret 語句則被添加一個參數，代表函數參數堆棧的長度。因此，被調函數需要明確的知曉函數參數的數量和類型，所以在 __stdcall 模型下不支持可變參數表，所有參數必須寫明。 3 __thiscall 參數壓棧順序：逆序 ( 從右至左 ) ， this 用 ecx 傳遞。 參數堆棧恢復者：被調函數 (callee) __thiscall 是 VC 編譯器中類的非靜態成員函數 (non-static member functon) 的默認調用模型。但是如果此成員函數有可變參數表， VC 編譯器會使用 __cdecl 。和 __stdcall 一樣， __thiscall 由被調函數恢復堆棧。比較獨特的是 __thiscall 會通過 ecx 寄存器傳遞成員函數的 this 指針，而 __cdecl 下 this 指針是通過在參數表最前面增加一個函數參數來傳遞的。 __thiscall 是 VC 編譯器對 this 指針的使用的一種優化，大大提高了面向對象程序的效率。在 VC2003 及之前的編譯器上 __thiscall 不是一個關鍵字，不能被顯式指定。但可以給成員函數顯式指定 __cdecl 來避免使用 __thiscall 。 4 __fastcall 參數壓棧順序：逆序 ( 從右至左 ) ，前兩個 32 位函數參數放入 ecx 和 edx 中 參數堆棧恢復者：被調函數 (callee) 快速函數調用模型，將前兩個 32 位函數參數放入 ecx 和 edx 中，其餘參數再逆序壓棧。使用的是和 __thiscall 類似的優化技術，加快函數調用，適合運用在小型 inline 函數上。同樣使用 __stdcall 形式的被調函數恢復堆棧，所以不支持可變參數表。 5 __pascal 參數壓棧順序：正序 ( 從左至右 ) 參數堆棧恢復者：被調函數 (callee) 過程式編程語言 Pascal 所使用的函數調用模型，由此得名。也是 16 位版本的 Windows 使用的 API 模型，過時的模型，現在已經廢棄且禁止使用。你會看到有些書本仍會不時提到它，所以需要注意。 __pascal 是正序壓棧，這與大部分 I386 函數模型都不相同。與 __stdcall 一樣，由被調者恢復堆棧，不支持可變參數表。歷史上曾有過的別名 PASCAL 、 pascal 、 _pascal( 單下劃線 ) ，現在都改成了 __stdcall 的別名，與 __pascal( 雙下劃線 ) 不同。 6 其它函數調用模型，以及模型別名。 __syscall ：操作系統內部使用的函數調用模型，由用戶模式向核心模式跳轉時使用的模型。由於用戶模式和核心模式使用不同的棧，所以沒辦法使用棧來傳遞參數，所有參數通過寄存器傳遞，這限制了參數的數量。用戶模式編程中不允許使用。 __fortran ：數學運算語言 fortran 使用的函數模型，由此得名。在 C 中調用由 fortran 編譯的函數時使用。 __clrcall ：微軟 .Net 框架使用的函數模型，託管 (Managed)C++ 默認使用，也可以從非託管代碼調用託管函數時使用。參數在託管棧上正序 ( 從左至右 ) 壓棧，不使用普通棧。 CALLBACK 、 PASCAL 、 WINAPI 、 APIENTRY 、 APIPRIVATE ： I386 平臺上是 __stdcall 的別名 WINAPIV ： I386 平臺上是 __cdecl 的別名 7 函數調用模型的指定 函數調用模型的指定方式和 inline 關鍵字的指定方式相同，事實上， inline 可以被看作是 C++ 語言內建的一種函數調用模型。唯一不同的是，聲明函數指針時，也要指明函數調用模型，而 inline 的指針是不能指明的，根本不存在指向 inline 函數的指針。比如： int CALLBACK GetVersion(); int ( CALLBACK * pf)()=GetVersion;","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../c-tricks-2-1-x86-architecture.html","title":"C++ Tricks 2.1 X86概述","text":"從 farseerfc.wordpress.com 導入 2.1 X86 概述 所謂 X86 體系結構，是指以 Intel 8086 芯片爲首的芯片所沿襲的 CPU 結構，一些文檔中又被稱作 IA32 體系結構。包括的芯片有但不限於 :Intel 8086 至 80486 ，奔騰 (Pentium) 系列處理器 1 至 4 ，賽揚系列處理器，酷睿系列處理器，以及 AMD 的相應型號產品。 X86 體系結構在早期屬於 16 位處理器，自 80386 之後擴展爲 32 位處理器，所以一些文檔中又把 80386 之後的 32 位處理器體系稱作 I386 。自 Pentium4 後期， AMD 的 Athlon64 開始， I386 被進一步擴充爲 64 位處理器，含有 64 位尋址能力的 X86 體系結構被稱作 X86-64 或 IA32-64 。總之，市售的個人電腦用 CPU ，除蘋果的 Macintosh 之外，全部採用 X86 體系結構芯片。 在 X86 早期， 16 位的尋址能力只支持 64KB(2&#94;16=64K) 內存，這顯然是不夠的。 Intel 採用分段尋址的方法，用 4 位段位 +16 位偏移量，提供了總共 1MB(2&#94;20=1M) 的尋址能力。所以在 X86 的 16 位編程中，有兩種指針類型：長指針 (lp,long pointer) 和短指針 (sp,short pointer) ，長指針 (20 位 ) 提供整個內存空間尋址能力，短指針 (16 位 ) 僅支持同一段中的尋址。在 \" 古代 \"DOS 及 Win3.x 編程過程中，兩種類型的指針，以及總共 1MB 的內存大小，常常把程序員們折騰得焦頭爛額。 自 I386 之後， CPU 纔開始提供 32 位的尋址能力。有了整整 4GB(2&#94;32=4G) 的尋址空間，所有指針統一爲長指針 (32 位 ) 。時至今日，我們仍可以看到微軟文檔中指針變量的 lp 前綴。由於內存管理的需要，分段機制被保留下來，但這一次不是因爲地址空間太小，而是因爲地址空間遠大於實際內存容量，從而採用了虛擬內存機制。 在從 16 位結構向 32 位結構轉變的過程中，由於向下兼容的歷史原因，曾一度長時間出現硬件 32 位 (I386) 、軟件 16 位 (Win3.x) 的情況。同樣也是爲了兼容 16 位軟件， Win9x 操作系統 (Win95 、 Win98 、 WinME) 保留了 16 位代碼和 32 位代碼。混合代碼的設計使得 Win9x 及其混亂和不穩定。直到完全 32 位內核的操作系統 WinNT( 以及構建於其上的 Win2000 ， WinXP ， Win2003) 的出現， X86 平臺上內存佈局混亂的局面才得以改善。有了從 16 位至 32 位移植的經驗和準備，現今的從 32 位到 64 位的操作系統移植顯得平穩順利很多。 WinXP 和 WinVista 系統都同時發佈了 32 位版本和 64 位版本，並且其 x86-64 系統都實現了對 32 位軟件的無縫銜接支持。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../c-tricks-1-2-trap-in-comma-logical-operator.html","title":"C++ Tricks 1.2 逗號運算符(,)、邏輯運算符(&&,||)與運算符重載的陷阱","text":"從 farseerfc.wordpress.com 導入 1.2 逗號運算符 (,) 、邏輯運算符 (&&,||) 與運算符重載的陷阱 很多人甚至不知道逗號 (,) 也是個 C++ 運算符。與語法上要求出現的逗號 ( 比如分隔函數參數的逗號 ) 不同的是，出現在表達式中的逗號運算符在語義上表示多個表達式操作的連續執行，類似於分隔多語句的分號。比如： for ( int i=0,j=9;i<10;++i , —j)std::cout<<i<<\"+\"<<j<<\"=9\\n\"; 在這句語句中，出現了兩個逗號，其中前者是語法上用來分隔聲明的變量的，並非逗號運算符，而後者則是一個逗號運算符。根據 C++ 標準，逗號運算符的執行順序爲從左到右依次執行，返回最後一個子表達式的結果。由於只有最後一個表達式返回結果，所以對於一個語義正常的逗號表達式而言，前幾個子表達式必須具有副作用。同時，從語言的定義中也可以看出，逗號表達式對求值的順序有嚴格要求。 對求值順序有要求的，除了逗號表達式和條件表達式 ( 參見 1.1) ，在 C++ 中還有邏輯運算符 (&& 和 ||) 。邏輯運算相較於數學運算和位運算而言，有個顯著的不同點：邏輯運算在計算到一半時，就有可能已經得到結果，這樣繼續運算另一半就不是必需的。對於 A&&B ，如果 A=false ，那麼無論 B 爲何值，整個的結果都是 false ；同樣的 A||B ，如果 A=true ，那麼不考慮 B ，結果一定是 true 。 C++ 標準規定，如果邏輯運算到一半 ( 算出 A) 時，就已經可以確定運算的結果，那麼就不運算剩下的另一半 (B) 。這種執行語義被稱作 \" 短路 \" 。在其它一些編程語言中，短路語義是可以選擇的：在 Ada 裏非短路的邏輯運算符爲 and 和 or ，短路的邏輯運算符爲 and_then 和 or_else 。但是在 C++ 中，邏輯運算符的短路語義是語法上強制的，我們沒有非短路版本的運算符。如果確實需要非短路語義，我們總是可以通過增加一個 bool 中間變量加以解決。有時，短路對於保證正確執行是必須的，比如： char *p=getString(); if (p && *p)std::cout<<p; 這段代碼在得到了一個字符串後，在字符串不爲空時輸出它。在 C++ 中判斷一個字符串不爲空需要兩個步驟：判斷指針是否爲 0 ，以及指針不爲 0 時判斷指針指向的內容是否爲 '' 。就像條件表達式中討論到的 ( 參見 1.1) ，在 p 爲空時提領 p 是個極其危險的操作。邏輯運算符的短路語義則避免了這種危險。 以上對逗號運算符與邏輯運算符的討論，僅限於 C++ 標準所定義的運算符語義。爲什麼這樣說呢？這是因爲在 C++ 中，運算符的語義是可以由程序員自行定義的，這種機制叫做運算符重載 (operator overload) 。運算符重載可以將人們熟悉的運算符表達式轉換成函數調用，使編程靈活而直觀，是個方便的語言特性。不過有時運算符重載也會使人困擾，那就是當運算符重載遇到求值順序問題時。 C++ 中，並不是所有合法運算符都可以被合法地重載。條件運算符雖然對求值順序有要求，但它並不在可重載運算符之列，所以運算符重載機制對它沒有影響。問題在於，逗號運算符和邏輯運算符都可以被合法地重載： class BadThing{/* Some Bad and Stupid Thing*/}; BadThing& operator ,(BadThing&, BadThing&);// 重載了逗號運算符 bool operator &&(BadThing&, BadThing&);// 重載了 && BadThing b1,b2; if (b1&&b2)b1,b2;// 被替換成如下形式： if ( operator &&(b1,b2)) operator ,(b1,b2); 可以看到，重載了運算符之後，對運算符的使用被替換爲相應的函數調用形式。因此，舊有的運算符的執行順序不再適用，取而代之的是函數參數的壓棧順序。 根據 C++ 標準規定，任何參數必須在進入函數之前壓棧，所以在進入 operator && 之前， b1 、 b2 就會被求值，這裏不再有短路規則，任何依賴於短路語義的不知不覺間操作 BadThing 的代碼 ( 可能通過模板 ) 都會混亂。 短路語義只是一個方面，更重要的在於壓棧順序。鑑於執行效率和舊代碼兼容性等細節問題， C++ 標準在壓棧順序上給編譯器的開發者留有很大自主性。標準的說辭是，編譯器可能以任何它覺得方便的順序將參數壓棧，從左到右，從右到左，甚至從中間到兩邊，在這一點上我們不能安全地做任何假設。在上面的例子中，編譯器生成的代碼可能先計算 b1 再計算 b2 ，也可能是相反的順序。再看看編譯器的實際情況，在我試過的所有基於 X86 體系結構的編譯器中，參數都是以逆向壓棧，即從右到左，有悖於大多數人的閱讀習慣和直覺 ( 別說你是來自伊斯蘭的 ……) 。 在 C 時代使用函數調用時，壓棧順序並不是什麼大問題，畢竟大多數人會在函數調用的邊界稍稍小心一些。但是到了 C++ 中，事情變得有些複雜，因爲簡單如 a+b 的使用，就有可能被運算符重載機制替換爲函數調用。更何況有模板參與之後，我們寫代碼時不能確定對象的真實類型，也就無法預知一個運算符是否真的被重載過，唯一穩妥的方法是，假定任何有可能被重載的運算符的使用都是函數調用。 <p style=\"margin:0;\"> 回到上文的示例中，由於 , 和 && 都被替換爲函數調用，程序的執行順序將成爲壓棧順序，在 X86 上很有可能是從右到左，與標準定義的運算符的順序正好相反。逗號運算符原本就含有 \" 先 … 後 …\" 的語義，這種顛倒的執行順序勢必造成程序和程序員的混亂。以我的經驗而言，含有 operator , 的類，完全沒有辦法和 STL 或者 iostream 相互協作，反而會導致巨量的錯誤報告 ( 什麼叫巨量的錯誤報告有概念麼？如果沒有，那說明你還沒玩過範式編程 ( GP , Generic Programming) 。去玩玩 GP 吧，看看你的編譯器對巨量的定義。在我手頭，針對 3.5KB 的代碼文件傾瀉出 3.8 MB 的錯誤信息的編譯器不在少數 ……) 。有鑑於此，我的結論是，除非你有充足的依據支持你這麼做 ( 比如你的粗暴上司的鍵盤上只剩下逗號能用 ) ，並且你清楚的瞭解這麼做的後果的嚴重性 ( 比如至少要看過此文 ) ，否則我奉勸你，永遠不要碰 operator , 、 operator && 以及 operator || ！","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../c-tricks-1-1-conditional-operator.html","title":"C++ Tricks 1.1 條件運算符(?:)","text":"從 farseerfc.wordpress.com 導入 1.1 條件運算符 (?:) 條件運算符 (?:) 是 C++ 中唯一的三目運算符 (trinary operator) ，用於在表達式中作條件判斷，通常可以替換 if 語句，與 Visual Basic 中的 iif 函數、 Excel 中的 if 函數有同樣的作用。語法形式如下： condition ? true_value : false_value 其中 condition * 條件是任何可以轉換爲 bool 類型的表達式，包括但不僅限於 **bool* 、 int 、指針。與 if 和 while 的條件部分稍顯不同的是，這裏不能定義變量，否則會導致語法錯誤。 另外，條件語句會切實地控制執行流程，而不僅僅是控制返回值。也就是說，兩個返回值表達式中永遠只有一個會被求值，在表達式的執行順序很重要時，這點尤爲值得注意。比如： int *pi=getInt(); int i=pi ? *pi : 0; 這裏，只有當 pi 的值不爲 0 時，它纔會被提領 (dereference) 。這種語義保證了程序的正確性，因爲提領一個空指針將導致致命的運行期錯誤 ( 通常是非法操作的警告 ) 。同時，正因爲條件運算符控制運算流程的特點，使得它不能用類似 iif 的普通函數來模擬： int iif( int con, int t, int f){ if (c) return t; return f;}// 試圖模擬 ?: …//in some function int *pi=getInt(); int i=iif(pi,*pi,0);//Error! 這段代碼會導致上文提到的致命運行期錯誤。 C/C++ 標準規定，參數在被傳遞給函數之前求值，因此無論 pi 爲何值，都會被提領。又因爲函數傳回一個空指針的情況比較少見，所以這樣的錯誤在調試時很難被發現，一旦發生又勢必造成重大災難。這樣的代碼在實踐中應儘量避免。 有時，條件運算符控制流程的特點會不知不覺影響我們的代碼。在 C 時代，最大值 MAX 通常用宏實現： #define MAX (a,b) ((a)>(b) ? (a) : (b)) 需要用額外的括號將宏參數和宏本體保護起來，以免運算符優先級擾亂邏輯，這是宏醜陋的特點之一，這裏暫且不提。矛盾在於，用具有副作用的表達式調用宏時，會出現問題： int i=5,j=6;//… int a= MAX (++i,++j); 代碼的作者原意顯然是想先將 i,j 分別遞增，再將其中較大的一個賦給 a 。執行這段代碼，當 i=5,j=6 時， a=8 ，知道爲什麼嗎？通過宏展開，賦值語句成這樣： int a=(++i)>(++j) ? (++i) : (++j);// 刪除了多餘括號 在判斷之前， i 、 j 被分別自增一次，然後捨棄 : 之前的部分， j 又被自增一次。執行之後， i=6,j=8 。 MAX 的更正確更安全的實現，是利用模板將類型參數化。 STL 標準算法中就有一個這樣的工具級模版函數 std::max 。 條件運算符是表達式而不是語句，這使得它可以出現在任何需要表達式的地方，這擴大了它的適用範圍。在那些語法上只能出現表達式而不能出現語句的地方（比如變量初始化），條件運算符有着不可替代的作用。 條件運算符優於 if 語句的另一個場合是 \" 模板元編程 \"( TMP , Template MetaProgramming) 。在 TMP 這個古怪奇異的編譯期運算編程技術中，一切舊有的技術和法則被全線擊破，我們所能仰仗的工具，只有模板特化 (Specialization) 、 typedef s 、函數聲明 ( 無法調用它們 ) 、以及編譯期常量運算。已經有人很深入地論證過，僅有以上這些，就已經形成了一個 \" 圖靈完善 \" 的計算機語言。我們可以用模板特化技術，來模擬條件分支，循環迭代等一系列複雜的語言結構。由於可以參與編譯期常量運算，條件運算符在 TMP 世界中很自然地扮演起重要角色。 比如，給與類型 T 的一個變量 t ，我們想聲明一個緩衝區存放 t 和一個 int ，緩衝區的大小不小於 sizeof(T) 也不小於 sizeif(int) ，我們可以這樣寫： char buffer[sizeof(T)>sizeof(int)? sizeof(T): sizeof(int)]; 我們不能用一個 if 語句替換這個運算： int i; if(sizeof(T)>sizeof(int))i=sizeof(T); else i=sizeof(int); char buffer[i];// 語法錯誤 ! 原因在於數組聲明中的下標必須是一個編譯期常量，而不是一個運行期的值，條件表達式的運算可以在編譯期進行， if 語句就只能在執行期執行。","tags":"import"},{"loc":"//farseerfc.github.io/zhs/../filling-believings-calling-conscience.html","title":"填補信仰、喚醒良知","text":"從 farseerfc.wordpress.com 導入 填補信仰、喚醒良知 我們聽盡了呼籲與號召，對於良知，我不必譴責喪失它的國人，不必盛讚良知的美好。我只想討論，喪失了良知的原因 —— 空缺的信仰。 一、空缺信仰喪失良知 現代的國人缺少信仰，以至於喪失良知。曾幾何時，中華民族由良好的信仰凝聚而成。三皇五帝時，族民們以炎黃爲信仰；春秋戰國時，士大夫之族以周制禮樂爲信仰；漢代以後，百姓延習孔孟之說、老聃之道，以儒家學說爲信仰；自大唐起，以佛教爲首的現代宗教紛紛傳入中原，人民開始以它們作爲信仰。 直至鴉片戰爭、五四運動，西方文化入侵中華，國人開始拋棄國學，轉而去研究科學；文化大革命，十年文化浩劫，人們批判舊的信仰，卻沒有合適的新的信仰前來填補。從此，國人的信仰出現空缺，國人的良知也被一塊塊蠶食殆盡。 二、信仰、科學、迷信 在許多國人的心目中，信仰就等於迷信。從小到大的教育告訴我們，信奉宗教是愚昧而又無知的表現，科學與信仰是矛盾的。是麼？ 我們無法保證社會上的每一個人都接受過良好的教育，我們無法確信最前沿的科學素養能在民衆中普及。在科普與教育力不從心的社會死角，在科學技術尚不能及的文化盲區，我們依舊需要信仰的規範與限制，我們的良知需要信仰！ 信仰不等於迷信。信仰本身無所謂謎與不迷，迷信是持有信仰的人誤解了信仰，盲目遵從的結果。以爲燒過香就可以免遭禍患，以爲捐了錢就可以升入天堂，以爲引火自焚就可以功德圓滿，這便是迷信了。希特勒曾經的人類完善計劃，依照遺傳學的原理，將科學家與運動員強行結爲夫婦孕育生命，希望得到最優秀的人類種族，這便是對科學這種信仰的迷信！ 由此可見，科學與信仰並不是矛盾的硬幣的兩面，從某種意義而言科學本身也是信仰的一種。雖然歷史上宗教往往作爲科學發展的阻礙，可信奉真理的信念一直是推動科學發展的動力。牛頓就曾說過，對自然規律的探詢是爲了更接近上帝。由此可見，信仰與真理，與良知毫無矛盾。 三、信仰喚醒良知 很少有人仔細思考過，良知的缺失是由信仰的缺失造成的。信仰是人思想的寄託與依靠，是人行動處世的準則。沒有了信仰的人，思想行爲就缺少了約束的標準，人就更容易因爲一時不成熟的衝動，背叛良知、鑄成錯誤。 泰國人以佛教爲信仰，泰國的寺廟每天都會有成千上萬人頂禮膜拜。寺廟有一個人盡皆知的不成文規定：不得穿鞋進入。於是在寺廟之外，遊客們可以看到千百雙各式的鞋子有序的擺放在門口。國人每每看到此景，總會詫異地問：沒有人會偷鞋麼？得到的答案極爲簡單：廟前偷鞋會遭報應。由於擁有信仰，泰國人作了壞事會受到良知的譴責，泰國商人售出假貨會徹夜難眠。二戰期間，無數猶太難民被天主教會收留藏匿從而僥倖逃生，這同樣是出於，天主教徒們被自己信奉的教義 \" 衆生生來平等 \" ，所喚醒的良知。 天下無賊的世界，不能僅靠科普說教來營造。如果脫離了信仰，縱使是教育也無法培養良知。我問過許多修化學的同學，學習化學的意義，結論竟是爲了考試。如果沒有對科學的信仰，我們可以牢記公式定理，卻質疑它們是真理；如果沒有對社會公德的信仰，我們可以熟背交通規則，卻正大光明地闖紅燈；如果沒有對醫療道德的信仰，醫生可以放任傷口發炎，從而留住病人繼續治療 …… 國人需要信仰的約束，需要填補信仰的空白，從而喚醒那深埋於每個國人內心深處的良知！","tags":"import"}]}