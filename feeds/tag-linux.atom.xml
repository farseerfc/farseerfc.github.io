<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Farseerfc的小窩 - linux</title><link href="//farseerfc.me/" rel="alternate"></link><link href="//farseerfc.me/feeds/tag-linux.atom.xml" rel="self"></link><id>//farseerfc.me/</id><updated>2019-02-07T02:14:00+09:00</updated><entry><title>用 usbip 轉發 raspberry pi 的 USB 鍵盤鼠標給 Arch Linux 的 PC</title><link href="//farseerfc.me/usbip-forward-raspberrypi.html" rel="alternate"></link><published>2019-02-07T02:14:00+09:00</published><updated>2019-02-07T02:14:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2019-02-07:/usbip-forward-raspberrypi.html</id><summary type="html">&lt;p&gt;惠狐 &lt;a class="reference external" href="/links.html#megumifox"&gt;megumifox&lt;/a&gt; 寫了篇 &lt;a class="reference external" href="https://blog.megumifox.com/public/2019/02/06/%E7%94%A8pulseaudio%E5%B0%86%E7%94%B5%E8%84%91%E7%9A%84%E5%A3%B0%E9%9F%B3%E7%94%A8%E6%89%8B%E6%9C%BA%E6%94%BE%E5%87%BA%E6%9D%A5/"&gt;用PulseAudio將電腦的聲音用手機放出來&lt;/a&gt;
，文末提到想知道我怎麼用樹莓派轉發 USB 的，於是寫篇文章記錄一下。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;起因&lt;/h2&gt;
&lt;p&gt;家裏有個裝了 Arch Linux ARM 的樹莓派3B 閒置着，裝了 Arch Linux ARM 偶爾上電更新一下，
不過因爲性能實在不適合做別的事情於是一直在吃灰。某日 &lt;del&gt;給老婆安利幻想萬華鏡&lt;/del&gt;&lt;ins&gt;和老婆看片&lt;/ins&gt;
的時候， &lt;del&gt;老婆不吃安利於是遷怒鍵盤鼠標&lt;/del&gt;&lt;ins&gt;鍵盤鼠標被長長的 USB 線扯着感覺很難受&lt;/ins&gt;
，於是偶發奇想，能不能利用一下樹莓派的多達 4 個 USB 2.0 端口接鼠標鍵盤呢，
這樣鼠標鍵盤就可以跟着樹莓派來回走，不用拖着長長的 USB 線了。&lt;/p&gt;
&lt;p&gt;上網搜了一下， Linux 環境有個 usbip 工具正好能做到這個。原理也很直觀， usbip 能把 USB …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;惠狐 &lt;a class="reference external" href="/links.html#megumifox"&gt;megumifox&lt;/a&gt; 寫了篇 &lt;a class="reference external" href="https://blog.megumifox.com/public/2019/02/06/%E7%94%A8pulseaudio%E5%B0%86%E7%94%B5%E8%84%91%E7%9A%84%E5%A3%B0%E9%9F%B3%E7%94%A8%E6%89%8B%E6%9C%BA%E6%94%BE%E5%87%BA%E6%9D%A5/"&gt;用PulseAudio將電腦的聲音用手機放出來&lt;/a&gt;
，文末提到想知道我怎麼用樹莓派轉發 USB 的，於是寫篇文章記錄一下。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;起因&lt;/h2&gt;
&lt;p&gt;家裏有個裝了 Arch Linux ARM 的樹莓派3B 閒置着，裝了 Arch Linux ARM 偶爾上電更新一下，
不過因爲性能實在不適合做別的事情於是一直在吃灰。某日 &lt;del&gt;給老婆安利幻想萬華鏡&lt;/del&gt;&lt;ins&gt;和老婆看片&lt;/ins&gt;
的時候， &lt;del&gt;老婆不吃安利於是遷怒鍵盤鼠標&lt;/del&gt;&lt;ins&gt;鍵盤鼠標被長長的 USB 線扯着感覺很難受&lt;/ins&gt;
，於是偶發奇想，能不能利用一下樹莓派的多達 4 個 USB 2.0 端口接鼠標鍵盤呢，
這樣鼠標鍵盤就可以跟着樹莓派來回走，不用拖着長長的 USB 線了。&lt;/p&gt;
&lt;p&gt;上網搜了一下， Linux 環境有個 usbip 工具正好能做到這個。原理也很直觀， usbip 能把 USB
端口上的數據封裝成 IP 協議通過網絡轉發出去，從而兩個網絡間相互聯通的電腦就可以遠程轉發 USB 了。
設置好的話，就像是一臺 PC 多了幾個位於樹莓派上的 USB 端口，插上樹莓派的 USB 設備統統作爲 PC
的設備。&lt;/p&gt;
&lt;p&gt;這篇文章假設有一個裝了 Arch Linux 的 PC ，和一個裝了 Arch Linux ARM 的樹莓派，
並且兩者間能通過網絡互相訪問到。別的發行版上大概也可以這麼做，只是我沒有試過。 usbip
工具似乎普遍被發行版打包了，除此之外需要的也只是 Linux 內核提供好的功能而已。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="arch-linux-arm"&gt;
&lt;h2&gt;設置 Arch Linux ARM 的樹莓派端&lt;/h2&gt;
&lt;p&gt;假設樹莓派上面網絡已經設置妥當，開機插電就能自動聯網。接下來安裝 usbip 工具：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo pacman -Syu usbip&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後需要記錄一下樹莓派的 IP 地址：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ip addr&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;3: wlan0: ......&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;inet 192.168.0.117/24 brd 192.168.0.255 scope global noprefixroute wlan0&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;......&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下來給 udev 添加一個規則，當插入 usb 設備的時候，執行我的腳本 usbipall.sh
把 usb 設備通過 usbip 共享出去：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; cat /etc/udev/rules.d/usbipall.rules&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;ACTION=="add", SUBSYSTEM=="usb", RUN+="/usr/bin/bash /usr/local/bin/usbipall.sh"&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;這個 rules 文件 &lt;a class="reference external" href="https://github.com/farseerfc/dotfiles/blob/master/usbiprpi/usbipall.rules"&gt;可以在我的 dotfiles 裏面找到&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;然後規則調用的 usbipall.sh 我這麼寫的， &lt;a class="reference external" href="https://github.com/farseerfc/dotfiles/blob/master/usbiprpi/usbipall.sh"&gt;文件同樣在我的 dotfiles 裏面&lt;/a&gt; ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nv"&gt;allusb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;usbip list -p -l&lt;span class="k"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;for&lt;/span&gt; usb in &lt;span class="nv"&gt;$allusb&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="nv"&gt;busid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$usb&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sed &lt;span class="s2"&gt;"s|#.*||g;s|busid=||g"&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"1-1.1"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;then&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="c1"&gt;# ignoring usb ethernet&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;continue&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;fi&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;date -Iseconds&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;: Exporting &lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    usbip &lt;span class="nb"&gt;bind&lt;/span&gt; --busid&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;done&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;)&lt;/span&gt; &amp;gt;&amp;gt;/var/log/usbipall.log &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;這個腳本做了這樣幾件事。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;調用 &lt;code class="code"&gt;
usbip list --local&lt;/code&gt;
 列出本地所有 usb 設備。&lt;/li&gt;
&lt;li&gt;針對每個設備&lt;ol class="arabic"&gt;
&lt;li&gt;取出它的 busid&lt;/li&gt;
&lt;li&gt;判斷是不是樹莓派的 USB 以太網卡，不是的話繼續&lt;/li&gt;
&lt;li&gt;通過 &lt;code class="code"&gt;
usbip bind --busid=&lt;/code&gt;
 命令把這個 usb 設備導出到網上&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最後把所有輸出記錄到 /var/log/usbipall.log 日誌裏面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;樹莓派這邊設置就完成了。從此之後插入的 usb 設備就會統統導出出去。&lt;/p&gt;
&lt;p&gt;這裏需要注意一下，啓用了 udev 規則之後，就沒法插鍵盤鼠標到樹莓派上控制它了……我都是從另一端 ssh
上樹莓派操作的。如果有什麼地方設置錯誤，可能需要把樹莓派的 SD 卡拔下來插到電腦上，刪除掉 rules
文件……&lt;/p&gt;
&lt;p&gt;仔細檢查設置正確了之後，重新載入 udev 規則，或者重啓樹莓派：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;#&lt;/span&gt; systemctl restart systemd-udevd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;這樣樹莓派這邊就設置好了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="arch-linux-pc"&gt;
&lt;h2&gt;設置 Arch Linux 的 PC 端&lt;/h2&gt;
&lt;p&gt;同樣假設 PC 這邊也已經聯網。接下來同樣安裝 usbip 工具：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo pacman -Syu usbip&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後我寫了個小腳本去鏈接樹莓派端， &lt;a class="reference external" href="https://github.com/farseerfc/dotfiles/blob/master/usbiprpi/usbiprpi3.sh"&gt;這個文件 usbiprpi3.sh 也在我的 dotfiles&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nv"&gt;rpi3&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"192.168.0.117"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;modprobe vhci-hcd&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nv"&gt;allusb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;usbip list -p -r &lt;span class="nv"&gt;$rpi3&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; cut -d&lt;span class="s2"&gt;":"&lt;/span&gt; -f1 -s &lt;span class="p"&gt;|&lt;/span&gt; sed &lt;span class="s1"&gt;'s|^[ \t]*||;/^$/d'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;for&lt;/span&gt; busid in &lt;span class="nv"&gt;$allusb&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"1-1.1"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;then&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="c1"&gt;# ignoring usb ethernet&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;continue&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;fi&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Attaching &lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    usbip attach --remote&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$rpi3&lt;/span&gt; --busid&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;done&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中腳本第一行填入上面記錄下來的樹莓派的 IP 地址，接下來腳本做了這麼幾件事：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;用 modprobe 確認加載 vhci-hcd 通用虛擬鍵鼠驅動&lt;/li&gt;
&lt;li&gt;用 &lt;code class="code"&gt;
usbip list --remote=&lt;/code&gt;
 列出遠程設備上已經導出了的 USB 設備，取出他們的 busid&lt;/li&gt;
&lt;li&gt;對每個設備用 &lt;code class="code"&gt;
usbip attach&lt;/code&gt;
 接上該設備&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然後就已經準備妥當，接下來是見證奇蹟的時刻：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sleep &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; sudo ./usbiprpi3.sh&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;Attaching 1-1.4.3&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;Attaching 1-1.4.1&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因爲只有一套鍵盤鼠標，所以先 sleep 個 10 秒，在此期間快速把鍵鼠拔下來插到樹莓派的 USB 口上去。
如果對自己手速沒自信也可以把時間設長一點。然後用 root 權限執行 usbiprpi3.sh 。&lt;/p&gt;
&lt;p&gt;一切正常的話，先能觀測插上樹莓派的鍵盤鼠標被樹莓派初始化了一下，比如鍵盤燈會亮，
然後這些設備會被導出出去，從而鍵盤燈滅掉，然後 10 秒等待結束後他們被遠程接到了 PC 端，
又會被初始化一下，同時 PC 端這邊會有上述 Attaching 的輸出。然後鍵盤鼠標就能像平常一樣用啦。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;使用體驗&lt;/h2&gt;
&lt;p&gt;因爲就是通過 IP 轉發 USB 嘛，所以就和普通地接 USB 的體驗差不多，當然前提是網絡環境足夠穩定。
在我家間隔 5 米到無線路由器的環境下，基本感覺不到網絡延遲的影響。
通過這種方式聊天上網應該和直接接 USB 設備完全一樣。本文就是在通過樹莓派轉發的前提下用鍵盤打字寫的。&lt;/p&gt;
&lt;p&gt;不過如果網絡負載本身就很大的話，可能會一些延遲，比如我開着 OBS 直播打東方的時候，原本就手殘
的我感覺更加手殘了……&lt;/p&gt;
&lt;p&gt;試過拿着樹莓派在房間到處走，走到無線信號覆蓋不到的地方， usbip 會斷掉，PC 上的現象就像是 USB
設備被拔下來了……所以如果無線網絡不穩的話，可能需要對上面腳本做個循環？不過那樣可能會用起來很彆扭吧。&lt;/p&gt;
&lt;p&gt;以及，上述操作 usbip 是走 TCP 3240 端口，數據包大概完全沒有加密，所以考慮安全性的話，
最好還是在內網環境使用。不過轉念一想，萬一有別人接上了我導出出去的 USB ，也就是截獲我的鍵盤，
PC 這邊沒法 attach 設備了，應該馬上會發現吧。我敲打 sudo 之類命令的時候 shell 裏面沒有回顯，
就不會再繼續敲密碼了。而且似乎對攻擊者也沒有什麼好處？要是他 usb attach 到了我的設備上，
我就能控制他的鍵盤了耶~&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="linux"></category><category term="archlinux"></category><category term="raspberrypi"></category><category term="usbip"></category><category term="usb"></category><category term="forward"></category></entry><entry><title>【譯】使用 GNU stow 管理你的點文件</title><link href="//farseerfc.me/using-gnu-stow-to-manage-your-dotfiles.html" rel="alternate"></link><published>2018-12-08T03:35:00+09:00</published><updated>2018-12-08T03:35:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2018-12-08:/using-gnu-stow-to-manage-your-dotfiles.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;譯註&lt;/h2&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;這篇是翻譯自 &lt;a class="reference external" href="http://brandon.invergo.net/news/2012-05-26-using-gnu-stow-to-manage-your-dotfiles.html"&gt;Brandon Invergo 的博客的英文文章 Using GNU Stow to manage your dotfiles&lt;/a&gt; 。
Brandon Invergo 的博客採用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"&gt;CC-BY-SA 3.0&lt;/a&gt;
授權，因此本文也同樣採用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"&gt;CC-BY-SA 3.0&lt;/a&gt;
，不同於其它我寫的文章是 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;CC-BY-NC-SA 4.0&lt;/a&gt;
授權。&lt;/p&gt;
&lt;p&gt;我自己已經使用此文中介紹的方案管理 &lt;a class="reference external" href="https://git.io/fcdots"&gt;我自己的 dotfiles&lt;/a&gt;
快 3 年了。最早想採用這樣的管理方案是爲了方便在多臺 Arch Linux 系統之間同步配置，
後來逐漸主力系統也更新換代了一次，又同步到了自己的 vps 上去，目前管理多個 Arch Linux
上都多少都有這套配置。甚至裝好 Arch Linux 添加好用戶最初做的事情就是安裝 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;譯註&lt;/h2&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;這篇是翻譯自 &lt;a class="reference external" href="http://brandon.invergo.net/news/2012-05-26-using-gnu-stow-to-manage-your-dotfiles.html"&gt;Brandon Invergo 的博客的英文文章 Using GNU Stow to manage your dotfiles&lt;/a&gt; 。
Brandon Invergo 的博客採用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"&gt;CC-BY-SA 3.0&lt;/a&gt;
授權，因此本文也同樣採用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"&gt;CC-BY-SA 3.0&lt;/a&gt;
，不同於其它我寫的文章是 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;CC-BY-NC-SA 4.0&lt;/a&gt;
授權。&lt;/p&gt;
&lt;p&gt;我自己已經使用此文中介紹的方案管理 &lt;a class="reference external" href="https://git.io/fcdots"&gt;我自己的 dotfiles&lt;/a&gt;
快 3 年了。最早想採用這樣的管理方案是爲了方便在多臺 Arch Linux 系統之間同步配置，
後來逐漸主力系統也更新換代了一次，又同步到了自己的 vps 上去，目前管理多個 Arch Linux
上都多少都有這套配置。甚至裝好 Arch Linux 添加好用戶最初做的事情就是安裝 stow git
然後 clone 了我自己的 dotfiles repo 下來，然後按需取想要的配置，快捷方便有效。&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;p&gt;廢話不多說，下面是原文和翻譯。與之前的翻譯一樣，正文部分給出原文引用以便對照參考。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;使用 GNU stow 管理你的點文件&lt;/h2&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;我昨天偶然間發現一些我覺得值得分享的經驗，就是那種「爲毛我沒有早點知道這個？」那一類的。
我將在這篇文章中介紹如何使用 GNU Stow 管理你的 GNU/Linux 系統中位於用戶家目錄裏的各種配置文件
（通常又叫「點文件(dotfiles)」比如 .bashrc）。&lt;/td&gt;
&lt;td&gt;I accidentally stumbled upon something yesterday that I felt like sharing,
which fell squarely into the "why the hell didn't I know about this before?"
category. In this post, I'll describe how to manage the various
configuration files in your GNU/Linux home directory
(aka "dotfiles" like .bashrc) using GNU Stow.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;這件事的困難之處在於，如果能用版本管理系統(VCS, Version Control System)比如
Git, Mercurial(hg), Bazaar(bzr)
管理點文件的話會非常方便，但是這些點文件大部分都位於家目錄的頂級目錄下，
在這個位置不太適合初始化一個版本管理倉庫。這些年下來我試過很多程序，設計目的在於解決這個問題，
幫你把這些配置文件安置在某個下級目錄中，然後安裝或者鏈接這些文件到它們應該在的位置。
嘗試下來這些程序沒有一個真正能打動我。它們要麼有很多依賴（比如 Ruby 和一大坨庫），
要麼需要我記住如何用它，考慮到同步配置這種不算經常使用的場合，要記住用法真的挺難。&lt;/td&gt;
&lt;td&gt;The difficulty is that it would be helpful to manage one's configuration
files with a version control system like Git, Mercurial or Bazaar, but
many/most dotfiles reside at the top-level of your home directory,
where it wouldn't be a good idea to initialize a VCS repository.
Over time I've come across various programs which aim to manage this
for you by keeping all the files in a subdirectory and then installing or
linking them into their appropriate places. None of those programs ever
really appealed to me. They would require a ton of dependencies
(like Ruby and a ton of libraries for it) or they would require me to
remember how to use them, which is difficult when really for such a task
you rarely use the program.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;最近我在用 GNU Stow 來管理我從源代碼在本地編譯安裝到 &lt;code class="code"&gt;
/​usr/​local/​&lt;/code&gt;
 中的一些程序。
基本上說，在這種常見用法下，是你把這些本地編譯的包配置安裝到
&lt;code class="code"&gt;
/​usr/​local/​stow/​${PKGNAME}-{PKGVERSION}&lt;/code&gt;
 這樣的位置，然後在
&lt;code class="code"&gt;
/​usr/​local/​stow/​&lt;/code&gt;
 目錄中執行 &lt;code class="code"&gt;
# stow ${PKGNAME}-${PKGVERSION}&lt;/code&gt;

，然後它就會爲程序所有的文件創建符號鏈接放在 &lt;code class="code"&gt;
/​usr/​local&lt;/code&gt;

中合適的地方。然後當你想用 Stow 卸載這個程序的時候，就不必再考慮會留下什麼垃圾文件，
或者找不到安裝時用的 Makefile 了。這種安裝方式下也可以非常容易地切換一個程序的不同版本
（比如我想嘗試不同配置選項下的 &lt;a class="reference external" href="https://dwm.suckless.org/"&gt;dwm&lt;/a&gt; 或者
&lt;a class="reference external" href="https://st.suckless.org/"&gt;st&lt;/a&gt; 的時候）。&lt;/td&gt;
&lt;td&gt;Lately I've been using GNU Stow to manage programs I install from source to
/usr/local/. Basically, in this typical usage, you install locally built
packages to /usr/local/stow/${PKGNAME}-{PKGVERSION} and then
from /usr/local/stow/ you run # stow ${PKGNAME}-${PKGVERSION} and the
program generates symbolic links to all the programs' files into the
appropriate places under /usr/local/. Then, when you uninstall a program
via Stow, you don't have to worry about any stray files that you or a
provide Makefile may have missed. It also makes handling alternate versions
of a program quite easy (i.e. when I'm experimenting with different
configurations of dwm or st).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;前段時間在我掃郵件列表的時候，看到某個帖子中某人在說使用 Stow 管理安裝他的點文件。
當時我沒特別在意這個帖子，但是大概我大腦潛意識把它歸檔保存爲今後閱讀了。
昨天我想起來試試這種用法，試過後我不得不說，這比那些專門設計用來做這任務的點文件管理器要方便太多了，
雖然表面上看起來這種用法沒那麼顯而易見。&lt;/td&gt;
&lt;td&gt;Some time ago I happened across a mailing list posting where someone
described using Stow to manage the installation of their dotfiles.
I didn't pay much attention to it but my brain must have filed it away
for later. Yesterday I decided to give it a try and I have to say that
it is so much more convenient than those other dedicated dotfile-management
programs, even if it wasn't an immediately obvious option.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;方法很簡單。我建了個 &lt;code class="code"&gt;
${HOME}/​dotfiles&lt;/code&gt;
 文件夾，然後在裏面爲我想管理的每個程序配置都
創建一個子文件夾。然後我把這些程序的配置從原本的家目錄移動到這每一個對應的子文件夾中，
並保持它們在家目錄中的文件夾結構。比如，如果某個文件原本應該位於家目錄的頂層文件夾裏，
那它現在應該放在這個程序名子目錄的頂層文件夾。如果某個配置文件通常應該位於默認的
&lt;code class="code"&gt;
${XDG_CONFIG_HOME}/​${PKGNAME}&lt;/code&gt;
 位置 (&lt;code class="code"&gt;
${HOME}/​.config/​${PKGNAME}&lt;/code&gt;
)，
那麼現在它應該放在 &lt;code class="code"&gt;
${HOME}/​dotfiles/​${PKGNAME}/​.config/​${PKGNAME}&lt;/code&gt;

，如此類推。然後在那個 dotfiles 文件夾裏面，直接運行 &lt;code class="code"&gt;
$ stow $PKGNAME&lt;/code&gt;
 命令，
Stow 就會爲你自動創建這些配置文件的符號鏈接到合適的位置。接下來就很容易爲這個 dotfiles
目錄初始化版本管理倉庫，從而記錄你對這些配置文件做的修改（並且這也可以極度簡化在不同電腦之間
共享配置，這也是我想要這麼做的主要原因）。&lt;/td&gt;
&lt;td&gt;The procedure is simple. I created the ${HOME}/dotfiles directory and then
inside it I made subdirectories for all the programs whose cofigurations
I wanted to manage. Inside each of those directories, I moved in all the
appropriate files, maintaining the directory structure of my home directory.
So, if a file normally resides at the top level of your home directory,
it would go into the top level of the program's subdirectory.
If a file normally goes in the default ${XDG_CONFIG_HOME}/${PKGNAME}
location (${HOME}/.config/${PKGNAME}), then it would instead go in
${HOME}/dotfiles/${PKGNAME}/.config/${PKGNAME} and so on.
Finally, from the dotfiles directory, you just run $ stow $PKGNAME and
Stow will symlink all the package's configuration files to the appropriate
locations. It's then easy to make the dotfiles a VCS repository so you can
keep track of changes you make (plus it makes it so much easier to share
configurations between different computers, which was my main reason to
do it).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;舉個例子，比如說你想管理 Bash, VIM, Uzbl 這三個程序的配置文件。Bash 會在家目錄的頂層文件夾
放幾個文件； VIM 通常會有在頂層文件夾的 .vimrc 文件和 .vim 目錄；然後 Uzbl 的配置位於
&lt;code class="code"&gt;
${XDG_CONFIG_HOME}/​uzbl&lt;/code&gt;
 以及 &lt;code class="code"&gt;
${XDG_DATA_HOME}/​uzbl&lt;/code&gt;

。於是在遷移配置前，你的家目錄的文件夾結構應該看起來像這樣：&lt;/td&gt;
&lt;td&gt;For example, let's say you want to manage the configuration for Bash,
VIM and Uzbl. Bash has a couple files in the top-level directory;
VIM typically has your .vimrc file on the top-level and a .vim directory;
and Uzbl has files in ${XDG_CONFIG_HOME}/uzbl and ${XDG_DATA_HOME}/uzbl.
So, your home directory looks like this:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;home/&lt;/span&gt;
&lt;span class="code-line"&gt;    brandon/&lt;/span&gt;
&lt;span class="code-line"&gt;        .config/&lt;/span&gt;
&lt;span class="code-line"&gt;            uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;        .local/&lt;/span&gt;
&lt;span class="code-line"&gt;            share/&lt;/span&gt;
&lt;span class="code-line"&gt;                uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                    [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;        .vim/&lt;/span&gt;
&lt;span class="code-line"&gt;            [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;        .bashrc&lt;/span&gt;
&lt;span class="code-line"&gt;        .bash_profile&lt;/span&gt;
&lt;span class="code-line"&gt;        .bash_logout&lt;/span&gt;
&lt;span class="code-line"&gt;        .vimrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;然後遷移配置的方式是，應該建一個 dotfiles 子目錄，然後像這樣移動所有配置文件：&lt;/td&gt;
&lt;td&gt;You would then create a dotfiles subdirectory and move all the files there:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;home/&lt;/span&gt;
&lt;span class="code-line"&gt;    /brandon/&lt;/span&gt;
&lt;span class="code-line"&gt;        .config/&lt;/span&gt;
&lt;span class="code-line"&gt;        .local/&lt;/span&gt;
&lt;span class="code-line"&gt;            .share/&lt;/span&gt;
&lt;span class="code-line"&gt;        dotfiles/&lt;/span&gt;
&lt;span class="code-line"&gt;            bash/&lt;/span&gt;
&lt;span class="code-line"&gt;                .bashrc&lt;/span&gt;
&lt;span class="code-line"&gt;                .bash_profile&lt;/span&gt;
&lt;span class="code-line"&gt;                .bash_logout&lt;/span&gt;
&lt;span class="code-line"&gt;            uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                .config/&lt;/span&gt;
&lt;span class="code-line"&gt;                    uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                        [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;                .local/&lt;/span&gt;
&lt;span class="code-line"&gt;                    share/&lt;/span&gt;
&lt;span class="code-line"&gt;                        uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                            [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;            vim/&lt;/span&gt;
&lt;span class="code-line"&gt;                .vim/&lt;/span&gt;
&lt;span class="code-line"&gt;                    [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;                .vimrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;然後執行以下命令：&lt;/td&gt;
&lt;td&gt;Then, perform the following commands:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; ~/dotfiles&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; stow bash&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; stow uzbl&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; stow vim&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;然後，瞬間，所有你的配置文件（的符號鏈接）就安安穩穩地放入了它們該在的地方，無論原本這些目錄結構
有多麼錯綜複雜，這樣安排之後的 dotfiles 文件夾內的目錄結構立刻整理得有條有理，
並且可以很容易地轉換成版本控制倉庫。非常有用的一點是，如果你有多臺電腦，可能這些電腦並沒有
安裝完全一樣的軟件集，那麼你可以手選一些你需要的軟件配置來安裝。在你的 dotfiles 文件夾中總是
可以找到所有的配置文件，但是如果你不需要某個程序的某份配置，那你就不對它執行 stow
命令，它就不會擾亂你的家目錄。&lt;/td&gt;
&lt;td&gt;And, voila, all your config files (well, symbolic links to them) are all
in the correct place, however disorganized that might be, while the actual
files are all neatly organized in your dotfiles directory, which is easily
turned into a VCS repo. One handy thing is that if you use multiple
computers, which may not have the same software installed on them,
you can pick and choose which configurations to install when you need them.
All of your dotfiles are always available in your dotfiles directory,
but if you don't need the configuration for one program, you simply don't
Stow it and thus it does not clutter your home directory.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;嗯，以上就是整個用法介紹。希望能有別人覺得這個用法有用！我知道對我來說這個非常有幫助。&lt;/td&gt;
&lt;td&gt;Well, that's all there is to it. Hopefully someone else out there finds
this useful! I know I've found it to be a huge help.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="linux"></category><category term="dotfiles"></category><category term="stow"></category></entry><entry><title>爲什麼 Linus Torvalds 不願意將 Linux 變成 GPLv3 授權？</title><link href="//farseerfc.me/why-linus-torvalds-undermine-gplv3.html" rel="alternate"></link><published>2016-08-08T16:15:00+09:00</published><updated>2016-08-08T16:15:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2016-08-08:/why-linus-torvalds-undermine-gplv3.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="https://www.zhihu.com/question/48884264/answer/113454129"&gt;知乎&lt;/a&gt; 轉載&lt;/p&gt;
&lt;p&gt;和上篇文章一樣，這篇也是來自一個知乎上我回答的問題。&lt;/p&gt;
&lt;p&gt;原問題：为什么 Linus Torvalds 不愿意将 Linux 变成 GPLv3 授权？&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
DebConf 14: Q&amp;amp;A with Linus Torvalds&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_1Mg5_gxNXTo"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/1Mg5_gxNXTo"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XMTY3NjIzNDU0NA"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;embed align="middle" allowfullscreen="true" allowscriptaccess="always" class="embed-responsive-item" quality="high" src="http://player.youku.com/player.php/sid/XMTY3NjIzNDU0NA/v.swf" type="application/x-shockwave-flash"/&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_1Mg5_gxNXTo"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XMTY3NjIzNDU0NA"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我的回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這裏有段 Linus Torvalds 在 DebConf 14 上的 Q&amp;amp;A:
&lt;a class="reference external" href="https://youtu.be/1Mg5_gxNXTo?t=47m20s"&gt;https://youtu.be/1Mg5_gxNXTo?t=47m20s&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中關於 GPLv3 和協議的那一段在47:20開始到57:00左右。
裏面 Linus 對自己的觀點澄清得很清楚了。
看u2b或者聽英語有困難的請留評論，我抽空可以試着翻譯一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;然後接下來就是我承諾的翻譯了 …&lt;/h2&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="https://www.zhihu.com/question/48884264/answer/113454129"&gt;知乎&lt;/a&gt; 轉載&lt;/p&gt;
&lt;p&gt;和上篇文章一樣，這篇也是來自一個知乎上我回答的問題。&lt;/p&gt;
&lt;p&gt;原問題：为什么 Linus Torvalds 不愿意将 Linux 变成 GPLv3 授权？&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
DebConf 14: Q&amp;amp;A with Linus Torvalds&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_1Mg5_gxNXTo"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/1Mg5_gxNXTo"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XMTY3NjIzNDU0NA"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;embed align="middle" allowfullscreen="true" allowscriptaccess="always" class="embed-responsive-item" quality="high" src="http://player.youku.com/player.php/sid/XMTY3NjIzNDU0NA/v.swf" type="application/x-shockwave-flash"/&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_1Mg5_gxNXTo"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XMTY3NjIzNDU0NA"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我的回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這裏有段 Linus Torvalds 在 DebConf 14 上的 Q&amp;amp;A:
&lt;a class="reference external" href="https://youtu.be/1Mg5_gxNXTo?t=47m20s"&gt;https://youtu.be/1Mg5_gxNXTo?t=47m20s&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中關於 GPLv3 和協議的那一段在47:20開始到57:00左右。
裏面 Linus 對自己的觀點澄清得很清楚了。
看u2b或者聽英語有困難的請留評論，我抽空可以試着翻譯一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;然後接下來就是我承諾的翻譯了&lt;/h2&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問：你是否同意說你貶低了 GPLv3 ? 以及……&lt;/td&gt;
&lt;td&gt;Q: Do you agree that you undermine GPLv3? and ...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 是的&lt;/td&gt;
&lt;td&gt;L: Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問：我們如何纔能讓你別這麼做？&lt;/td&gt;
&lt;td&gt;Q: How can we get you to stop?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 什麼？&lt;/td&gt;
&lt;td&gt;L: What?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問：我們如何纔能讓你別這麼做？&lt;/td&gt;
&lt;td&gt;Q: How can we get you to stop?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 哦我討厭 GPLv3 ，我是在故意貶低它。實際上我覺得 GPLv3 的擴展非常可怕。
我能理解爲什麼人們想要做這個，但是我覺得它本應是一個全新的協議。&lt;/td&gt;
&lt;td&gt;L: Oh I hate GPLv3. I undermined it on purpose.
I actually thought the GPLv3 extensions were horrible.
I understand why people would want to do them but I think it should have
been a completely new license.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;嗯我喜歡版本 2 的那些理由，並且我仍然覺得版本 2 是一個非常棒的協議，
理由是：「我給你源代碼，你給我你對它的修改，我們就扯平了」
對吧？這是我用 GPL 版本 2 的理由，就是這麼簡單。&lt;/td&gt;
&lt;td&gt;Emm my argument for liking version 2, and I still think version 2 is a
great license, was that, "I give you source code, you give me your
changes back, we are even." Right? That's my take on GPL version 2, right,
it's that simple.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;然後版本 3 的擴展在某些方面讓我個人覺得非常不舒服，也就是說「我給你源代碼，
這意味着你必須服從我的一些規則，否則你不能把它用在你的設備上。」
對我來說，這是違反了版本 2 協議所追求的所有目的。然而我理解爲什麼 FSF 要這麼做，
因爲我知道 FSF 想要達成什麼，但是對我來說這完全是不同的協議了。&lt;/td&gt;
&lt;td&gt;And version 3 extended that in ways that I personally am really
uncomfortable with, namely "I give you source code, that means that if
you use that source code, you can't use it on your device unless you
follow my rules." And to me that's, that's a violation of everything
version 2 stood for. And I understand why the FSF did it because I know
what the FSF wants.     But to me it's not the same license at all.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;所以我當時非常不安，並且表明了自己的觀點，並且這是在版本 3 發佈的數月之前。
在那很久之前曾經有過一場討論……在版本 3 之前有一個早期的版本，
事實上幾年之前，那時我就說過：「不，這不可能工作」。
並且在那個早期的討論階段我已經在內核裏寫好了「嘿，我可沒有寫過版本 2
或者更高版本」。所以之後也沒有過（爭議）……隨後版本 3 出來的時候我非常開心，
因爲我早在大概 5 年前做了預防，之後也就再也沒有過關於內核的協議究竟是哪個
版本的討論。&lt;/td&gt;
&lt;td&gt;So I was very upset and made it very clear, and this was months before
version 3 was actually published. There was a discussion about this
long before... There was an earlier version of version 3, years before
actually, where I said "No, this is not gonna fly."
And during that earlier discussion I had already added to the kernel that,
"Hey, I don't have the version 2 or later". And there was no...
And I was really happy then when version 3 came out, that I have done that
something like 5 years before, because there was ever never any question
about what the license for the kernel was.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;不過事實上我覺得版本 3 是……呃不……我事實上覺得版本 3 是個 &lt;strong&gt;不錯&lt;/strong&gt; 的協議，
對吧。我堅定地相信「如果是你寫的代碼，那麼你有權利決定它應該用什麼協議」。
並且版本 3 是個不錯的選擇。版本 3 不好的地方在……「我們給你了版本 2
，然後我們試圖偷偷混入這些新的規則，並且想逼着所有人都跟着升級」這是我不喜歡版本
3 的地方。並且 FSF 在其中做了很多見不得人的事情，我覺得做得很不道德。&lt;/td&gt;
&lt;td&gt;But I actually thought that version 3 is ... Uh, no ... I actually think
version 3 is a &lt;strong&gt;FINE&lt;/strong&gt; license, right. I'm a firm believer in,
"If you write your code, it is your choice to pick a license."
And version 3 is a fine license. Version 3 was not a good ...
"Here we give you version 2, and then we tried to sneak in these new rules,
and tried to force everybody to upgrade." That was the part I disliked.
And the FSF did some really sneaky stuff, downright immoral in my opinion.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問：所以你在說 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tivoization"&gt;Tivoization&lt;/a&gt; 的事情麼？&lt;/td&gt;
&lt;td&gt;Q: So you are talking about &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tivoization"&gt;Tivoization&lt;/a&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
譯註： 關於 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tivoization"&gt;Tivoization&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
Tivoization 是 FSF 發明的一個詞，表示 TiVo 的做法。 TiVo
是一個生產類似電視機頂盒之類的設備的廠商，他們在他們的設備中用到了 Linux
內核和很多別的開源組件，並且他們根據 GPLv2 協議開放了他們使用的組件的源代碼。
然而他們在他們出售的設備中增加了數字簽名，驗證正在執行的系統和軟件是他們自己
編制的軟件，從而限制了用戶修改運行軟件的自由。這種做法在 FSF 看來是鑽了 GPLv2
的法律上的空子，所以 FSF 提出了 GPLv3 封堵這種做法。&lt;/div&gt;
&lt;/div&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 沒錯，Tivoization 的事情一直是我反對版本 3 的主要根據。並且，FSF
在這件事上表現得極不誠實。「嘿，其實我們允許你無效化 Tivoization 條款」，這樣他們試圖，
應該說他們是在明白着欺騙別人，並且說「嘿，這意味着你可以使用除去 Tivoization 部分的 GPLv3」。
這很……在場的諸位中有誰從 FSF 那兒聽過這個說法？（請舉手）&lt;/td&gt;
&lt;td&gt;L: Ehmm, yeah the Tivoization is always my main, eh dislike of version 3.
And, the FSF was being very dishonest thing. "Hey, we actually allow you
to invalidate the Tivoization clause" and they tried to, they literally
lied to people, and say "Hey, so that means that you can use GPLv3 without
the Tivoization part", right. This is ... How many people heard this
particular statement from the FSF? (Please raise your hands)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;好吧，或許他們只試過對我用這套說辭，但是他們真的試過。我的反應是「我可不傻」，對吧。是的，
的確你可以…… GPLv3 允許你說「好， Tivoization 的事情對我們來說不是問題」，
但是它同時又允許別人接過這個項目，並且說「嘿，我覺得……去掉了 Tivoization 的 GPLv3
是兼容完整的 GPLv3 的，所以我可以 fork 這個項目，然後我將在自己的 fork 上用完整的
GPLv3 寫驅動。」然後我就囧了。我的困境在於說「嘿，我給了你我的源代碼，現在我卻不能拿回你對它
的修改了」。這是徹底違背了我用這個協議最初的目的了。&lt;/td&gt;
&lt;td&gt;Ok, maybe they only tried to convince me with that one.
But they did try. And it was like, "I'm not stupid", right. Yes, you can
... The GPLv3 allows you to say "Ok, Tivoization is not an issue for us".
But it allows somebody else to take the project, and say "Hey, I ... The
GPLv3 without Tivoization is compatible with the full GPLv3, so I will now
make my own fork of this, and I will start doing drivers that use the full
version of version 3" And where am I stuck then? I am stuck saying "Hey I
give you the source code, and now I can't take it back your changes".
That's completely against the whole point of the license in the first
place.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;所以 FSF 是，我是說那時他們暗地裏做的那些事情，讓我當下決定永遠不再和 FSF 有任何瓜葛。
所以如果你想捐錢給一個行善的組織，那就捐給 EFF 吧。FSF 充滿了瘋狂難處的人。這只是我的觀點。
呃其實我……嗯……我說得有點過分了。FSF 裏有很多不錯的人，不過其中有些人有點過激。&lt;/td&gt;
&lt;td&gt;So the FSF was, I mean the kind of stuff that was going on behind the
scenes, ah, made me once and for all to decide to never had any thing to
do with the FSF again. So if you wanted to give money to an organization
that does good? Give it to the EFF. The FSF is full of crazy bittered
people. That's just mine opinion. Uh, actually I have ... Ah ...
I overstated that a bit, right. The FSF has a lot of nice people in it,
but some of them are bit too extreme.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問: 嗯我也希望 EFF 能更多的關注於軟件的自由方面。但是你能……你覺得 Tivoization
這種行爲也能在某種方式上讓我作爲用戶獲益麼？&lt;/td&gt;
&lt;td&gt;Q: Well I wish the EFF care more about software freedom. But, uh,
can you ... Do you think that Tivoization benefits me as a user somehow?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 不，我不覺得。我的意思是……這從來都不是我的論據，這不是我選擇了 GPLv2 的理由。
並不是說我覺得 Tivoization 是某種值得你去爭取的權利，而是說在我的世界觀中，這是你的決定。
如果你生產硬件去鎖住了其中的軟件，這是你作爲一個硬件提供者的決定。
這完全不影響我作爲一個軟件提供者給你軟件的決定。你能看出我的立場在哪兒了麼？
我不喜歡上鎖的硬件，但是同時這也從來不是我想要給 Linux 加上的的社會契約。&lt;/td&gt;
&lt;td&gt;L: No, no I don't. I mean that ... But that was never my argument. That
was not why I selected the GPLv2. This is my whole point. It's not that
I think Tivoization is necessarily something that you should strive for.
But it is something that in my world view, it's your decision.
If you make hardware that locks down the software, that's your decision
as a hardware maker. That has no impact on my decision as a software maker
to give you the software. Do you see where I am coming from? I don't like
the locked down hardware, but at the same time that was never the social
contract I intended with Linux.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;對我來說，呃我想說，大家可能知道或者不知道， GPLv2 並不是 Linux 的最初的協議。
對我來說重要的部分一直是「我給你軟件，你可以用它做任何你想要做的事情。如果你做了任何改進，
你需要把它交還給我。」這是協議最初的樣子。最早的協議還有一條完全錯誤的條款，寫得完全不合理，
那時我很傻。嘿我也傻過。我最初的協議說你不能用它賺錢。這是失策，這明顯是不對的不好的，
因爲它和我真正想要做的事情沒有任何關係。但是那時我很傻很天真，
我沒意識到錢的事情在其中完全不重要。然後我發現了其中的問題，我看到了 GPLv2 然後說「嘿，
這是個完美的協議」。然後我看到了 GPLv3 我說「不，這做得過分了，這不是我想要的」
所以我讓 Linux 成爲了僅限 GPLv2 ，對吧。&lt;/td&gt;
&lt;td&gt;To me, umm, I mean, people may or may not
realize GPLv2 wasn't even the first license for Linux.
To me the important part was always "I give you software, you can do
whatever you want with it. If you making improvements, you have to give
them back." That was the first version of the license. It also had a
completely broken clause which was completely insane and I was stupid.
Hey it happened. My origin license says that you can't make money
change hands. And that was a mistake. That was clearly just wrong and bad
because it really didn't have anything to do with what I wanted. But I
was young, I was poor, I didn't realize that the whole money thing wasn't
the important part. And I have saw the errors in my ways, I saw the GPLv2
and said "Hey, that's the perfect license". And I saw the GPLv3 and I said
"No, that's overreaching a lot, that's not what I wanted". And so I made
Linux GPLv2 only, right.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問: 所以你是否認爲，即使你不能修改跑着這個軟件的設備，拿回對軟件的修改也還是同樣重要的？&lt;/td&gt;
&lt;td&gt;Q: So do you think getting the patches back is as useful even if you can't
modify the device that it is used on?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 是的，當然。我想說 TiVo 它自己實際上就是一個例子。他們的修改有點複雜，但是我想說他們基本
是，一開始基本是運行在一套相當標準的 MIPS 設備上。然後他們的修改是想繞開他們用到的芯片上的
一些問題，並且這些是合格的修改。之後的事情是他們覺得他們需要鎖住他們的硬件，我不喜歡這個。
但是就像我已經說的，我覺得這是他們的決定。&lt;/td&gt;
&lt;td&gt;L: Yeah, absolutely. And I mean TiVo itself is actually an example of this.
Their patches were kind of crafty but I mean they were basically running
on a, originally a fairly standard MIPS thing. And their patches were
working around bugs in the chipsets they used. And they were valid patches.
The fact that they then felt that their hardware had to be locked down
someway. I didn't like it. But as I have mentioned, I felt that that was
their decision.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;並且他們有真正的理由去這麼做。這是有時人們忽視的地方。有時是真的有理由去做 TiVo
他們做的事情。有時強加給你這種限制的是，無線運營商。有時強加給你的是迪士尼。
有時強加給你限制的甚至是法律。 GPLv3 在醫療設備之類的場合其實允許最後一種情況，我記得。
我的觀點是，整個 Tivoization 的事情有時是有理由去這麼做的。如果你生產……
我是說我不是硬件設計者，我覺得 FPGA 之類的東西很酷，但是我……我的意思是我真的不想把我對世界的
看法強加給別人。你不是非得要用 Linux ，如果你想要用 Linux
，那麼我唯一要求你做的事情是把源代碼（變更）還給我。然後在 GPLv2
中還有很多繁文縟節規定了詳細的細節，這些都不重要。這是我一直以來的觀點。&lt;/td&gt;
&lt;td&gt;And they had real reasons for that. That's something people sometimes
missed. There are sometimes reasons to do what TiVo did. Sometimes it's
imposed on you by, wireless carriers. Sometimes it's imposed on you by
Disney. Uh sometimes it's imposed on you by laws. The GPLv3 actually
accepts the last one when it comes to things like medical equipment
I think. But the point is that the whole Tivoization thing is, sometimes
it's, there is a reason for it. And if you make ... I mean I am not a
hardware designer. I think FPGA and stuff like that is really cool.
But I always ... I mean I really don't want to impose my world view on
anybody else. You don't have to use Linux. If you do use Linux, the only
thing I asked for is source code back. And there is all these other
verbiages in the GPLv2 about exact details, those aren't important.
And that was always my standpoint.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問: 好吧那我就不浪費時間了。&lt;/td&gt;
&lt;td&gt;Q: Ok, well I will stop my non-point of making noise now.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
譯註： 關於 &lt;a class="reference external" href="https://zh.wikipedia.org/wiki/ISC%E8%A8%B1%E5%8F%AF%E8%AD%89"&gt;ISC 協議&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
ISC 協議是一個開源軟件協議，和兩句的 BSD 協議功能相同。OpenBSD 項目選擇儘量用 ISC
協議公開他們新寫的代碼。&lt;/div&gt;
&lt;/div&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 我的意思是別誤解……我也喜歡別的協議。我用過……到底是哪個 BSD 協議是可以接受的？
有一個 BSD 協議實際上非常不錯。它實際上是……什麼？&lt;/td&gt;
&lt;td&gt;L: I mean don't get me ... I mean I like other licenses too. I have used
like the four, emmm... Which BSD license is the acceptable one?
One of the BSD license is actually really nice. And it's actually the...
What?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;觀衆： ISC&lt;/td&gt;
&lt;td&gt;A: ISC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: ISC？並且事實上我在鼓勵那些不在意拿回修改但是在意「嘿，我做了一個很酷的東西，請用它」。
我鼓勵這些人去用 BSD 協議做這些事情。我想說 BSD 協議在這種場合是完美的。
只是碰巧我覺得對於我的項目，拿回修改也同樣重要，所以對我而言 BSD 不好。但是重點是
&lt;strong&gt;對我而言&lt;/strong&gt; 。 GPLv3 可能對你們想要做的事情而言是完美的協議，這很好，並且這時你就應該去用
GPLv3 。只是當代碼是別人寫的時候，你沒有這個選擇權。&lt;/td&gt;
&lt;td&gt;L: ISC? And I actually encourage people who don't care about the giving
code back but care about the "Hey, I did something cool, please use it".
I encourage people to use the BSD license for that. And I mean the BSD
license is wonderful for that. It so happens that I thought that for my
project the giving back is equally important so I, for me BSD is bad.
But the point is &lt;strong&gt;for me&lt;/strong&gt;. The GPLv3 maybe the perfect license for what
you guys want to do. And that's fine. And then it's the license you should
use. It's just that when somebody else wrote the code you don't get that
choice.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="Linux"></category><category term="zhihu"></category><category term="GPLv3"></category><category term="licenses"></category><category term="Linus Torvalds"></category><category term="GPL"></category><category term="FSF"></category><category term="EFF"></category></entry><entry><title>PacVis: 可視化 pacman 本地數據庫</title><link href="//farseerfc.me/pacvis.html" rel="alternate"></link><published>2016-07-31T03:52:00+09:00</published><updated>2016-07-31T03:52:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2016-07-31:/pacvis.html</id><summary type="html">
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
PacVis&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Demo of PacVis" class="img-responsive" src="//farseerfc.me/images/pacvis-first.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pacvis"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;我爲什麼要做 PacVis&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我喜歡 Arch Linux ，大概是因爲唯有 Arch Linux 能給我對整個系統「瞭如指掌」的感覺。
在 Arch Linux 裏我能清楚地知道我安裝的每一個包，能知道系統裏任何一個文件是來自哪個包，
以及我爲什麼要裝它。或許對 Debian/Fedora/openSUSE 足夠熟悉了之後也能做到這兩點，
不過他們的細緻打包的結果通常是包的數量比 Arch 要多個 3 到 10 倍，並且打包的細節也比 Arch
Linux 簡單的 PKGBUILD 要複雜一個數量級。&lt;/p&gt;
&lt;p&gt;每一個裝過 Arch Linux 的人大概都知道，裝了 Arch Linux 之後得到的系統非常樸素，按照
ArchWiki 上的流程一路走下來的話，最關鍵的一條命令就是 &lt;code class="code"&gt;
pacstrap /​mnt …&lt;/code&gt;&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
PacVis&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Demo of PacVis" class="img-responsive" src="//farseerfc.me/images/pacvis-first.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pacvis"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;我爲什麼要做 PacVis&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我喜歡 Arch Linux ，大概是因爲唯有 Arch Linux 能給我對整個系統「瞭如指掌」的感覺。
在 Arch Linux 裏我能清楚地知道我安裝的每一個包，能知道系統裏任何一個文件是來自哪個包，
以及我爲什麼要裝它。或許對 Debian/Fedora/openSUSE 足夠熟悉了之後也能做到這兩點，
不過他們的細緻打包的結果通常是包的數量比 Arch 要多個 3 到 10 倍，並且打包的細節也比 Arch
Linux 簡單的 PKGBUILD 要複雜一個數量級。&lt;/p&gt;
&lt;p&gt;每一個裝過 Arch Linux 的人大概都知道，裝了 Arch Linux 之後得到的系統非常樸素，按照
ArchWiki 上的流程一路走下來的話，最關鍵的一條命令就是 &lt;code class="code"&gt;
pacstrap /​mnt base&lt;/code&gt;
 ，
它在 &lt;code class="code"&gt;
/​mnt&lt;/code&gt;
 裏作爲根調用 &lt;code class="code"&gt;
pacman -S base&lt;/code&gt;
 裝上了整個 base 組，
然後就沒有然後了。這個系統一開始空無一物，你需要的任何東西都是後來一點點用
&lt;code class="code"&gt;
pacman&lt;/code&gt;
 手動裝出來的，沒有累贅，按你所需。&lt;/p&gt;
&lt;p&gt;然而時間長了，系統中難免會有一些包，是你裝過用過然後忘記了，
然後這些包就堆在系統的角落裏，就像家裏陳年的老傢俱，佔着地，落着灰。雖然
&lt;code class="code"&gt;
pacman -Qtd&lt;/code&gt;
 能方便地幫你找出所有
&lt;strong&gt;曾經作爲依賴被裝進來，而現在不被任何包依賴&lt;/strong&gt; 的包，但是對於那些你手動指定的包，
它就無能爲力了。&lt;/p&gt;
&lt;p&gt;於是我就一直在找一個工具能幫我梳理系統中包的關係，方便我：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;找出那些曾經用過而現在不需要的包&lt;/li&gt;
&lt;li&gt;找出那些體積大而且佔地方的包&lt;/li&gt;
&lt;li&gt;釐清系統中安裝了的包之間的關係&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="figure"&gt;
&lt;img alt="Android System Architecture" class="img-responsive" src="//farseerfc.me/images/Android-System-Architecture.jpg"/&gt;
&lt;p class="caption"&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Android_(operating_system)"&gt;Android 系統架構&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;關於最後一點「釐清包的關係」，我曾經看到過
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Architecture_of_OS_X"&gt;macOS 系統架構圖&lt;/a&gt;
和 Android 的系統架構圖，對其中的層次化架構印象深刻，之後就一直在想，是否能畫出現代
Linux 桌面系統上類似的架構圖呢？又或者 Linux 桌面系統是否會展現完全不同的樣貌？
從維基百科或者別的渠道能找到 Linux 內核、或者 Linux 圖形棧，
或者某個桌面環境的架構，但是沒有找到覆蓋一整個發行版的樣貌的。
於是我便想，能不能從包的依賴關係中自動生成這樣一張圖呢。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;PacVis的老前輩們&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在開始寫 PacVis 之前，我試過一些類似的工具，他們都或多或少能解決一部分我的需要，
又在某些方面有所不足。這些工具成爲了 PacVis 的雛形，啓發了 PacVis
應該做成什麼樣子。&lt;/p&gt;
&lt;div class="section" id="pactree"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id13"&gt;pactree&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;pactree 曾經是一個
&lt;a class="reference external" href="https://bbs.archlinux.org/viewtopic.php?id=51795"&gt;獨立的項目&lt;/a&gt; ，現在則是
&lt;a class="reference external" href="https://www.archlinux.org/pacman/pactree.8.html"&gt;pacman 的一部分&lt;/a&gt; 了。
從手冊頁可以看出， pactree 的輸出是由某個包開始的依賴樹。
加上 &lt;code class="code"&gt;
--graph&lt;/code&gt;
 參數之後 pactree 還能輸出
&lt;a class="reference external" href="http://www.graphviz.org/"&gt;dot&lt;/a&gt; 格式的矢量圖描述，然後可以用 dot 畫出依賴圖：&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;code class="code"&gt;
pactree pacvis-git -d3 --graph | dot -Tpng &amp;gt;pacvis-pactree.png&lt;/code&gt;
&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="pactree --graph" class="img-responsive" src="//farseerfc.me/images/pacvis-pactree.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; pactree pacvis-git -d3&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;pacvis-git&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;├─python-tornado&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│ └─python&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─expat&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─bzip2&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─gdbm&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─openssl&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─libffi&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   └─zlib&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;├─pyalpm&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│ ├─python&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│ └─pacman&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─bash&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─glibc&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─libarchive&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─curl&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─gpgme&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─pacman-mirrorlist&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   └─archlinux-keyring&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;└─python-setuptools&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;  └─python-packaging&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;    ├─python-pyparsing&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;    └─python-six&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt; $&lt;/span&gt; pactree pacvis-git -d3 --graph &lt;span class="p"&gt;|&lt;/span&gt; dot -Tpng &amp;gt;pacvis-pactree.png&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;從畫出的圖可以看出，因爲有共用的依賴，所以從一個包開始的依賴關係已經不再是一棵
&lt;a class="reference external" href="https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B"&gt;圖論意義上的樹(Tree)&lt;/a&gt;
了。最初嘗試做 PacVis 的早期實現的時候，就是試圖用 bash/python 腳本解析 pactree 和
pacman 的輸出，在 pactree 的基礎上把整個系統中所有安裝的包全都包含到一張圖裏。
當然後來畫出的結果並不那麼理想，首先由於圖非常巨大，導致 dot
的自動佈局要耗費數小時，最後畫出的圖也過於巨大基本上沒法看。&lt;/p&gt;
&lt;p&gt;然而不得不說沒有 pactree 就不會有 PacVis ，甚至 pacman 被分離出 alpm
庫也和 pactree 用 C 重寫的過程有很大關係，而 PacVis 用來查詢 pacman 數據庫的庫
pyalpm 正是 alpm 的 Python 綁定。因爲 pactree 的需要而增加出的 alpm 庫奠定了 PacVis
實現的基石。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pacgraph"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;pacgraph&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
pacgraph 的輸出&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="pacgraph" class="img-responsive" src="//farseerfc.me/images/pacvis-pacgraph.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="http://kmkeen.com/pacgraph/index.html"&gt;pacgraph&lt;/a&gt; 是一位 Arch Linux 的
Trusted User &lt;a class="reference external" href="http://kmkeen.com/"&gt;keenerd&lt;/a&gt; 寫的程序，和
PacVis 一樣也是用 Python 實現的。
比起 pactree ， pacgraph 明顯更接近我的需求，它默認繪製整個系統的所有安裝包，
並且用聰明的佈局算法解決了 dot 佈局的性能問題。&lt;/p&gt;
&lt;p&gt;pacgraph 的輸出是一個富有藝術感的依賴圖，圖中用不同的字體大小表示出了每個包佔用
的磁盤空間。通過觀察 pacgraph 的輸出，我們可以清楚地把握系統全局的樣貌，
比如一眼看出這是個桌面系統還是個服務器系統，並且可以很容易地發現那些佔用磁盤空間
巨大的包，考慮清理這些包以節約空間。&lt;/p&gt;
&lt;p&gt;更棒的是 pacgraph 還提供了一個交互性的 GUI 叫做 pacgraph-tk ，顯然通過 tk 實現。
用這個 GUI 可以縮放觀察整幅圖的細節，或者選中某個包觀察它和別的包的依賴關係。&lt;/p&gt;
&lt;p&gt;pacgraph 還支持通過參數指定只繪製個別包的依賴關係，就像 pactree 那樣。&lt;/p&gt;
&lt;p&gt;不過 pacgraph 也不是完全滿足我的需要。如我前面說過，我希望繪製出的圖能反應
&lt;strong&gt;這個發行版的架構面貌&lt;/strong&gt; ，而 pacgraph 似乎並不區別「該包依賴的包」和「依賴該包的包」
這兩種截然相反的依賴關係。換句話說 pacgraph 畫出的是一張無向圖，
而我更想要一張有向圖，或者說是 &lt;strong&gt;有層次結構的依賴關係圖&lt;/strong&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;於是就有了 PacVis&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
PacVis 剛打開的樣子&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="PacVis on startup" class="img-responsive" src="//farseerfc.me/images/pacvis-second.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;總結了老前輩們的優勢與不足，我便開始利用空餘時間做我心目中的 PacVis 。
前後斷斷續續寫了兩個月，又分爲兩個階段，第一階段做了基本的功能和雛形，
第二階段套用上 &lt;a class="reference external" href="https://getmdl.io/"&gt;https://getmdl.io/&lt;/a&gt; 的模板，總算有了能拿得出手給別人看的樣子。&lt;/p&gt;
&lt;p&gt;於是乎前兩天在 AUR 上給 pacvis 打了個
&lt;a class="reference external" href="https://aur.archlinux.org/packages/pacvis-git/"&gt;pacvis-git&lt;/a&gt;
包，現在想在本地跑 pacvis 應該很方便了，用任何你熟悉的 aurhelper
就可以安裝，也可以直接從 aur 下載 PKGBUILD 打包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;~$ git clone aur@aur.archlinux.org:pacvis-git.git&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;~$ cd pacvis-git&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;~/pacvis-git$ makepkg -si&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;~/pacvis-git$ pacvis&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;Start PacVis at http://localhost:8888/&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照提示說的，接下來打開瀏覽器訪問 &lt;a class="reference external" href="http://localhost:8888/"&gt;http://localhost:8888/&lt;/a&gt; 就能看到 PacVis
的樣子了。僅僅作爲嘗試也可以直接打開跑在我的服務器上的 demo:
&lt;a class="reference external" href="https://pacvis.farseerfc.me/"&gt;https://pacvis.farseerfc.me/&lt;/a&gt; ，這個作爲最小安裝的服務器載入速度大概比普通的桌面系統快一點。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
在 Windows msys2 跑 PacVis&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="PacVis on Windows msys2" class="img-responsive" src="//farseerfc.me/images/pacvis-msys2.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;另外補充一下，因爲 PacVis 只依賴 pyalpm 和 tornado ，所以在別的基於 pacman
的系統上跑它應該也沒有任何問題，包括
&lt;a class="reference external" href="https://msys2.github.io/"&gt;Windows 上的 msys2&lt;/a&gt; 裏（儘管在 msys2 上編譯
tornado 的包可能要花些功夫）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;PacVis 的圖例和用法&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;操作上 PacVis 仿照地圖程序比如 Google Maps 的用法，可以用滾輪或者觸摸屏的手勢
縮放、拖拽，右上角有個側邊欄，不需要的話可以點叉隱藏掉，右下角有縮放的按鈕和
回到全局視圖的按鈕，用起來應該還算直觀。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="PacVis showing pacvis-git" class="img-responsive" src="//farseerfc.me/images/pacvis-pacvis-git.png"/&gt;
&lt;p class="caption"&gt;pacvis-git 包的依賴&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;先解釋圖形本身，整張圖由很多小圓圈的節點，以及節點之間的箭頭組成。
一個圓圈就代表一個軟件包，而一條箭頭代表一個依賴關係。縮放到細節的話，
能看到每個小圓圈的下方標註了這個軟件包的名字，鼠標懸浮在圓圈上也會顯示響應信息。
還可以點開軟件包，在右側的邊欄裏會有更詳細的信息。&lt;/p&gt;
&lt;p&gt;比如圖例中顯示了 pacvis-git 自己的依賴，它依賴 pyalpm, python-tornado 和
python-setuptools ，其中 pyalpm 又依賴 pacman 。圖中用
&lt;span class="label label-primary"&gt;紫色&lt;/span&gt; 表示手動安裝的包，
&lt;span class="label label-warning"&gt;橙色&lt;/span&gt; 表示被作爲依賴安裝的包，
箭頭的顏色也隨着包的顏色改變。&lt;/p&gt;
&lt;p&gt;值得注意的是圖中大多數箭頭都是由下往上指的，這是因爲 PacVis 按照包的依賴關係做
了拓撲排序，並且給每個包賦予了一個拓撲層級。比如 pacvis-git 位於 39
層，那麼它依賴的 pyalpm 就位於 38 層，而 pyalpm 依賴的 pacman 就位於 37
層。根據層級關係排列包是 PacVis 於 pacgraph 之間最大的不同之處。&lt;/p&gt;
&lt;p&gt;除了手動縮放， PacVis 還提供了搜索框，根據包名快速定位你感興趣的包。
以及在右側邊欄中的 Dep 和 Req-By 等頁中，包的依賴關係也是做成了按鈕的形式，
可以由此探索包和包之間的關聯。&lt;/p&gt;
&lt;p&gt;最後稍微解釋一下兩個和實現相關的參數：&lt;/p&gt;
&lt;div class="label label-info"&gt;
Max Level&lt;/div&gt;
&lt;p&gt;這是限制 PacVis 載入的最大拓撲層。系統包非常多的時候 PacVis
的佈局算法會顯得很慢，限制層數有助於加快載入，特別是在調試 PacVis 的時候比較有用。&lt;/p&gt;
&lt;div class="label label-info"&gt;
Max Required-By&lt;/div&gt;
&lt;p&gt;這是限制 PacVis 繪製的最大被依賴關係。稍微把玩一下 PacVis 就會發現系統內絕大多數
的包都直接依賴了 glibc 或者 gcc-libs 等個別的幾個包，而要繪製這些依賴的話會導致
渲染出的圖中有大量長直的依賴線，不便觀察。於是可以通過限制這個值，使得 PacVis
不繪製被依賴太多的包的依賴關係，有助於讓渲染出的圖更易觀察。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;從 PacVis 能瞭解到的一些事實&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
一個 KDE 桌面的 PacVis 結果全圖， &lt;a class="reference external" href="//farseerfc.me/images/pacvis-16384.png"&gt;放大（17M）&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="A normal KDE desktop in PacVis" class="img-responsive" src="//farseerfc.me/images/pacvis-4096-anno.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;稍微玩一下 PacVis 就能發現不少有趣現象，上述「絕大多數包依賴 glibc 」就是一例。
除此之外還有不少值得玩味的地方。&lt;/p&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id18"&gt;依賴層次&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;系統中安裝的包被明顯地分成了這樣幾個層次：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;glibc 等 C 庫&lt;/li&gt;
&lt;li&gt;Bash/Perl/Python 等腳本語言&lt;/li&gt;
&lt;li&gt;coreutils/gcc/binutils 等核心工具&lt;/li&gt;
&lt;li&gt;pacman / systemd 等較大的系統工具&lt;/li&gt;
&lt;li&gt;gtk{2,3}/qt{4,5} 等 GUI toolkit&lt;/li&gt;
&lt;li&gt;chromium 等 GUI 應用&lt;/li&gt;
&lt;li&gt;Plasma/Gnome 等桌面環境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大體上符合直觀的感受，不過細節上有很多有意思的地方，比如 zsh 因爲 gdbm
間接依賴了 bash，這也說明我們不可能在系統中用 zsh 完全替代掉 bash。
再比如 python （在 Arch Linux 中是 python3）和 python2 和 pypy
幾乎在同一個拓撲層級。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="zsh depends on bash because of gdbm" class="img-responsive" src="//farseerfc.me/images/pacvis-zsh-bash.png" style="width: 45%;"/&gt;
&lt;p class="caption"&gt;zsh 因爲 gdbm 間接依賴了 bash&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;不過偶爾顯示的依賴層級不太符合直觀，比如 qt5-base &amp;lt; qt4 &amp;lt; gtk2 &amp;lt; gtk3 。
qt5 因爲被拆成了數個包所以比 qt4 更低級這可以理解，而 gtk 系比 qt
系更高級這一點是很多人（包括我）沒有預料到的吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;循環依賴&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有些包的依賴關係形成了循環依賴，一個例子是 freetype2 和 harfbuzz，freetype2
是繪製字體的庫，harfbuzz 是解析 OpenType 字形的庫，兩者對對方互相依賴。
另一個例子是 KDE 的 kio 和 kinit，前者提供類似 FUSE 的資源訪問抽象層，
後者初始化 KDE 桌面環境。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="freetype2 harfbuzz" class="img-responsive" src="//farseerfc.me/images/pacvis-freetype2-harfbuzz.png" style="width: 45%;"/&gt;
&lt;p class="caption"&gt;freetype2 和 harfbuzz 之間的循環依賴&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;因爲這些循環依賴的存在，使得 PacVis 在實現時不能直接拓撲排序，我採用環探測
算法找出有向圖中所有的環，並且打破這些環，然後再使用拓撲排序。
因此我在圖中用紅色的箭頭表示這些會導致環的依賴關係。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id20"&gt;有些包沒有依賴關係&lt;/a&gt;&lt;/h3&gt;
&lt;div class="figure"&gt;
&lt;img alt="PacVis Level 0" class="img-responsive" src="//farseerfc.me/images/pacvis-level0.png" style="width: 45%;"/&gt;
&lt;p class="caption"&gt;man-pages 和 licenses 沒有依賴關係&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;有些包既不被別的包依賴，也不依賴別的包，而是孤立在整張圖中，比如
man-pages 和 licenses 。這些包在圖中位於最頂端，拓撲層級是 0 ，我用
&lt;span class="label label-info"&gt;藍色&lt;/span&gt; 正方形特別繪製它們。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="linux"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id21"&gt;只看依賴關係的話 Linux 內核完全不重要&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;所有用戶空間的程序都依賴着 glibc ，而 glibc 則從定義良好的 syscall 調用內核。
因此理所當然地，如果只看用戶空間的話， glibc 和別的 GNU 組件是整個 GNU/Linux
發行版的中心，而 Linux 則是位於依賴層次中很深的位置，甚至在我的 demo 服務器上
Linux 位於整個圖中的最底端，因爲它的安裝腳本依賴 mkinitcpio
而後者依賴了系統中的衆多組件。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pacman-qtd"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id22"&gt;pacman -Qtd 不能找到帶有循環依賴的孤兒包&lt;/a&gt;&lt;/h3&gt;
&lt;div class="figure"&gt;
&lt;img alt="pacman -Qtd cannot find packages with circle dependency" class="img-responsive" src="//farseerfc.me/images/pacvis-circledeps-Qtd.png" style="width: 45%;"/&gt;
&lt;p class="caption"&gt;msys2 中帶有循環依賴的孤兒包&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;這是我在 msys2 上測試 PacVis 的時候發現的，我看到在渲染的圖中有一片羣島，
沒有連上任何手動安裝的包。這種情況很不正常，因爲我一直在我的所有系統中跑
&lt;code class="code"&gt;
pacman -Qtd&lt;/code&gt;
 找出孤兒包並刪掉他們。放大之後我發現這些包中有一條循環依賴，
這說明 &lt;code class="code"&gt;
pacman -Qtd&lt;/code&gt;
 不能像語言的垃圾回收機制那樣找出有循環依賴的孤兒包。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id23"&gt;PacVis 的未來&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;目前的 PacVis 基本上是我最初開始做的時候設想的樣子，隨着開發逐漸又增加了不少功能。
一些是迫於佈局算法的性能而增加的（比如限制層數）。&lt;/p&gt;
&lt;p&gt;今後準備再加入以下這些特性：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;更合理的 optdeps 處理。目前只是把 optdeps 關係在圖上畫出來了。&lt;/li&gt;
&lt;li&gt;更合理的 &lt;strong&gt;依賴關係抉擇&lt;/strong&gt; 。有時候包的依賴關係並不是直接根據包名，而是
&lt;code class="code"&gt;
provides&lt;/code&gt;
 由一個包提供另一個包的依賴。目前 PacVis 用 alpm
提供的方式抉擇這種依賴，於是這種關係並沒有記錄在圖上。&lt;/li&gt;
&lt;li&gt;目前的層級關係沒有考慮包所在的倉庫 (core/extra/community/...) 或者包所屬的組。
加入這些關係能更清晰地表達依賴層次。&lt;/li&gt;
&lt;li&gt;目前沒有辦法只顯示一部分包的關係。以後準備加入像 pactree/pacgraph 一樣顯示部分包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你希望 PacVis 出現某些有趣的用法和功能，也
&lt;a class="reference external" href="https://github.com/farseerfc/pacvis/issues"&gt;請給我提 issue&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="python"></category><category term="pacvis"></category><category term="pacman"></category><category term="arch"></category><category term="linux"></category><category term="pacgraph"></category></entry><entry><title>X 中的混成器與 Composite 擴展</title><link href="//farseerfc.me/compositor-in-X-and-compositext.html" rel="alternate"></link><published>2015-03-19T17:45:00+09:00</published><updated>2015-03-19T17:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-03-19:/compositor-in-X-and-compositext.html</id><summary type="html">
&lt;p&gt;在上篇文章 &lt;a class="reference external" href="//farseerfc.me/brief-history-of-compositors-in-desktop-os.html"&gt;「桌面系統的混成器簡史」&lt;/a&gt;
中我介紹了其它桌面系統中的混成器的發展史和工作原理，
話題回到我們的正題 Linux 系統上，來說說目前 X 中混成器是如何工作的。
這篇文章將比上一篇深入更多技術細節，不想看太多細節的可以直接跳過看 &lt;a class="reference external" href="#id6"&gt;結論&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="x"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;原始的 X 的繪圖模型&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先，沒有混成器的時候 X 是這樣畫圖的：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="ditaa img-responsive" src="//farseerfc.me/uml/e06d011e.png"/&gt;
&lt;p&gt;X 的應用程序沒有統一的繪圖 API 。GTK+ 在 3.0 之後統一用 &lt;a class="reference external" href="http://cairographics.org/"&gt;Cairo&lt;/a&gt; 繪圖，
而 Cairo 則是基於 PDF 1.4 的繪圖模型構建的，
GTK 的 2.0 和之前的版本中也有很大一部分的繪圖是用 Cairo 進行，
其餘則通過 xlib 或者 xcb 調用 X 核心協議提供的繪圖原語繪圖 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
&lt;p&gt;在上篇文章 &lt;a class="reference external" href="//farseerfc.me/brief-history-of-compositors-in-desktop-os.html"&gt;「桌面系統的混成器簡史」&lt;/a&gt;
中我介紹了其它桌面系統中的混成器的發展史和工作原理，
話題回到我們的正題 Linux 系統上，來說說目前 X 中混成器是如何工作的。
這篇文章將比上一篇深入更多技術細節，不想看太多細節的可以直接跳過看 &lt;a class="reference external" href="#id6"&gt;結論&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="x"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;原始的 X 的繪圖模型&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先，沒有混成器的時候 X 是這樣畫圖的：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="ditaa img-responsive" src="//farseerfc.me/uml/e06d011e.png"/&gt;
&lt;p&gt;X 的應用程序沒有統一的繪圖 API 。GTK+ 在 3.0 之後統一用 &lt;a class="reference external" href="http://cairographics.org/"&gt;Cairo&lt;/a&gt; 繪圖，
而 Cairo 則是基於 PDF 1.4 的繪圖模型構建的，
GTK 的 2.0 和之前的版本中也有很大一部分的繪圖是用 Cairo 進行，
其餘則通過 xlib 或者 xcb 調用 X 核心協議提供的繪圖原語繪圖。
QT 的情況也是類似，基本上用 QPaint 子系統繪製成位圖然後交給 X 的顯示服務器。
顯示服務器拿到這些繪製請求之後，再在屏幕上的相應位置繪製整個屏幕。
當然還有很多老舊的不用 GTK 或者 QT 的程序，他們則直接調用 X 核心協議提供的繪圖原語。&lt;/p&gt;
&lt;p&gt;值得注意一點是 X 上除了沒有統一的繪圖模型，也沒有統一的矢量圖格式。
X 核心協議的繪圖原語提供的是像素單位的繪圖操作，沒有類似 GDI+ 或者 Quartz
提供的 &lt;ruby&gt;&lt;rb&gt;設備無關&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Device Independence&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的「點」的抽象。所以只用 X
的繪圖原語的話，我們可以把 (1,1) 這個像素點塗黑，但是不能把 (0.5, 0.5)
這個點塗黑，這一設計缺陷在
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix Hater's Handbook&lt;/a&gt;
中已經被吐槽過了。因爲這個缺陷，所以直接用 X 繪圖原語繪製的圖像不能像
矢量圖那樣進行無損縮放。同樣的缺陷導致 X 繪圖原語繪製的字符不能做到
&lt;ruby&gt;&lt;rb&gt;子像素級&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;subpixel-level&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; &lt;ruby&gt;&lt;rb&gt;抗鋸齒&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;anti-aliasing&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
（這解釋了默認配置下的 xterm 和
&lt;a class="reference external" href="http://arch.acgtyrant.com/2015/01/05/I-do-not-recommend-urxvt-again-now/"&gt;urxvt 中的字體渲染爲什麼難看&lt;/a&gt;
）。相比之下 GDI 有對應的 WMF 矢量圖格式， Quartz 有對應的 PDF 矢量圖格式，
而 X 中沒有這樣的格式對應。因爲沒有統一的矢量圖格式，所以無論是 Cairo 、QPaint
還是沒有用這些繪圖庫但是同樣在意字體和曲線渲染效果的程序（比如 Firefox 和
Chromium）都需要首先渲染到內部的 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/X_PixMap"&gt;XPixMap&lt;/a&gt;
位圖格式，做好子像素渲染和矢量縮放，然後再把渲染好的位圖轉交給 X 圖形服務器。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="composite"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;通過 Composite 擴展重定向窗口輸出&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2004年發佈的 X11R6.8 版本的 Xorg 引入了
&lt;a class="reference external" href="http://freedesktop.org/wiki/Software/CompositeExt/"&gt;Composite 擴展&lt;/a&gt;
。這個擴展背後的動機以及前因後果在一篇文章
&lt;a class="reference external" href="http://keithp.com/~keithp/talks/xarch_ols2004/xarch-ols2004-html/"&gt;The (Re)Architecture of the X Window System&lt;/a&gt;
中有詳細的表述。Composite 擴展允許某個 X 程序做這幾件事情：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;通過 &lt;code class="code"&gt;
RedirectSubwindows&lt;/code&gt;
 調用將一個窗口樹中的所有窗口渲染重定向到
&lt;ruby&gt;&lt;rb&gt;內部存儲&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;off-screen storage&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。重定向的時候可以指定讓 X
自動更新窗口的內容到屏幕上或者由混成器手動更新。&lt;/li&gt;
&lt;li&gt;通過 &lt;code class="code"&gt;
NameWindowPixmap&lt;/code&gt;
 取得某個窗口的內部存儲。&lt;/li&gt;
&lt;li&gt;通過 &lt;code class="code"&gt;
GetOverlayWindow&lt;/code&gt;
 獲得一個特殊的用於繪圖的窗口，
在這個窗口上繪製的圖像將覆蓋在屏幕的最上面。&lt;/li&gt;
&lt;li&gt;通過 &lt;code class="code"&gt;
CreateRegionFromBorderClip&lt;/code&gt;
 取得某個窗口的邊界剪裁區域（不一定是矩形）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了 Composite 擴展，一個 X 程序就可以調用這些 API 實現混成器。
這裏有篇 &lt;a class="reference external" href="http://www.talisman.org/~erlkonig/misc/x11-composite-tutorial/"&gt;教學解釋如何使用 Composite 擴展&lt;/a&gt; 。開啓了混成的 X 是這樣繪圖的：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="ditaa img-responsive" src="//farseerfc.me/uml/18f7774d.png"/&gt;
&lt;p&gt;整個 X 的混成器模型與 Mac OS X 的混成器模型相比，有如下幾點顯著的區別：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;混成的部分是交由外部的程序完成的，對混成的繪製方式和繪製普通窗口一樣。
出於效率考慮，絕大多數 X 上的混成器額外使用了 XRender 擴展或者
OpenGL/EGL 來加速繪製貼圖。不過即使如此，還是不能避免同樣的位圖（內容不一定完全一致，
比如 X 可以在窗口交給它的位圖上加上邊框然後再返還給混成器） &lt;strong&gt;在不同的三個程序之間來回傳遞&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code class="code"&gt;
RedirectSubwindows&lt;/code&gt;
 調用針對的是一個窗口樹，換句話說是一個窗口
及其全部子窗口，不同於 Mac OS X 中混成器會拿到全部窗口的輸出。
這個特點其實並不算是限制，因爲 X 中每個虛擬桌面都有一個根窗口，只要指定這個根窗口
就可以拿到整個虛擬桌面上的全部可見窗口輸出了。
反而這個設計提供了一定的自由度，比如我們可以用這個調用實現一個截圖程序，
拿到某個特定窗口的輸出，而不用在意別的窗口。&lt;/li&gt;
&lt;li&gt;爲了讓窗口有輸出，窗口必須顯示在當前桌面上，不能處於最小化
狀態或者顯示在別的虛擬桌面，用 X 的術語說就是窗口必須處於 &lt;ruby&gt;&lt;rb&gt;被映射&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;mapped&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
的狀態。因此直接用上述方法 &lt;strong&gt;不能得到沒有顯示的窗口的輸出&lt;/strong&gt; ，比如不能對最小化的窗口
直接實現 Windows 7 中的 Aero Peak 之類的效果。這個限制可以想辦法繞開，
比如在需要窗口輸出的時候臨時把窗口映射到桌面上，拿到輸出之後再隱藏起來，
不過要實現這一點需要混成器和窗口管理器相互配合。&lt;/li&gt;
&lt;li&gt;不像 Mac OS X 的基於 OpenGL Surface 的繪圖模型是 &lt;ruby&gt;&lt;rb&gt;設備無關&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;device independent&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
的，這裏 X 的繪圖模型是 &lt;ruby&gt;&lt;rb&gt;設備相關&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;device dependent&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的。
這既是優點也是缺點。從缺點方面而言，顯示到 X 的位圖輸出因爲設備相關性，
所以嚴格對應顯示器的點陣，並不適合作爲文檔格式打印出來。當然無論是 Cairo
還是 QPaint 都提供了到 PostScript 或者 PDF 後端的輸出，所以實用層面這個並不構成問題。
設備相關這一點的優點在於，繪製到 XPM 位圖的時候，程序和繪圖庫是能拿到輸出設備（顯示器）
的特殊屬性的，從而繪圖庫能考慮不同的色彩、分辨率、 DPI 或者
&lt;ruby&gt;&lt;rb&gt;子像素佈局&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;subpixel layout&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 這些屬性以提供最好的渲染效果。
Mac OS X 10.4 在設計的時候也曾考慮過提供無極縮放的支持，而這種支持到了 Mac OS X
10.5 中就縮水變成了 Retina 的固定 2 倍縮放。這種局面在 X
上沒有發生正是因爲 X 的繪圖模型的這種設備相關性，而 Mac OS X 的混成器採用的
OpenGL Surface 則無視了這些設備相關的屬性。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;輸入事件的重定向，這可能做到麼？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通過上述 Composite 擴展提供的 API ，混成器可以把窗口的 &lt;strong&gt;輸出&lt;/strong&gt; 重定向到自己的窗口上。
但是僅僅重定向輸出，整個 X 還不處於可用狀態，因爲 &lt;strong&gt;沒有重定向輸入&lt;/strong&gt; 。
考慮一下用戶試圖用鼠標點擊某個按鈕或者文本框，這時鼠標處於的位置是在 OverlayWindow
上繪製的位置，這個鼠標事件會交給 OverlayWindow ，而用戶期待這個事件被發送給他看到的按鈕上。&lt;/p&gt;
&lt;p&gt;需要重定向的事件主要有鍵盤和鼠標事件兩大類（暫時先不考慮觸摸屏之類的額外輸入）。
由於 Composite 擴展並沒有直接提供這方面的重定向 API ，這使得輸入事件處理起來都比較麻煩，&lt;/p&gt;
&lt;p&gt;假設要重定向鍵盤事件，混成器需要效仿輸入法框架（fcitx, ibus, scim）
那樣處理一部分按鍵事件並把其餘事件轉給具有輸入焦點的程序。
看看現有的輸入法框架和諸多程序間的問題，我們就能知道這裏的坑有多深。
於是 &lt;strong&gt;大部分 X 的混成器都不處理鍵盤事件重定向&lt;/strong&gt;
。再來看重定向鼠標事件，這邊的坑比重定向鍵盤事件的坑更多，
因爲不像重定向窗口輸出那樣只需要考慮 &lt;ruby&gt;&lt;rb&gt;頂層&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;top-level&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 窗口，
重定向鼠標輸入的時候要考慮所有子窗口（它們有獨立的事件隊列），
以及要準確記錄輸入事件事件發生時的鍵盤組合鍵狀態，還要正確實現 ICCCM/EWMH
中描述的轉交窗口焦點的複雜規則，所有這些都已經在 X 中實現過的事情需要重新實現一遍。&lt;/p&gt;
&lt;p&gt;由於坑太多難以實現，所以所有 X 下的混成器的實現方式都是直接忽略這個繁重的任務，
&lt;strong&gt;不重定向輸入事件&lt;/strong&gt; 而把它交給 X 處理。具體的實現方式就是通過
&lt;a class="reference external" href="http://freedesktop.org/wiki/Software/FixesExt/"&gt;XFixes&lt;/a&gt;
擴展提供的 &lt;code class="code"&gt;
SetWindowShapeRegion&lt;/code&gt;
 API 將 OverlayWindow 的 &lt;strong&gt;輸入區域&lt;/strong&gt;
&lt;code class="code"&gt;
ShapeInput&lt;/code&gt;
 設爲空區域，從而忽略對這個 OverlayWindow 的一切鼠標鍵盤事件。
這樣一來對 OverlayWindow 的點擊會透過 OverlayWindow 直接作用到底下的窗口上。&lt;/p&gt;
&lt;p&gt;因爲選擇了不重定向輸入事件， X 下的混成器通常會處於以下兩種狀態：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;選擇狀態下可以縮放窗口的大小，扭曲窗口的形狀，並且可以把窗口繪製在任意想要繪製的位置上
（並不是移動窗口的位置）， &lt;strong&gt;但是不能讓用戶與窗口的內容交互&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;正常狀態下可以讓用戶與窗口的內容交互，但是
&lt;strong&gt;繪製的窗口位置、大小和形狀必須嚴格地和 X 記錄的窗口的位置、大小和形狀保持一致&lt;/strong&gt;
。持續時間短暫的動畫效果可以允許位置和形狀稍有偏差，但是在動畫的過程中如果用戶點擊了
變形縮放過的窗口，那麼鼠標事件將發往錯誤的（ X 記錄中的而非顯示出的）窗口元素上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以發現這兩種狀態就直接對應了 Gnome 3 的普通狀態和縮略圖狀態（點擊 &lt;ruby&gt;&lt;rb&gt;活動&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Activity&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
或者戳畫面左上角之後顯示的狀態），這也解釋了爲什麼儘管 Gnome 3
的窗口有碩大的關閉按鈕，但是在縮略圖狀態下 Gnome 3 仍然需要給窗口加上額外的關閉按鈕：
&lt;strong&gt;因爲處於縮略狀態下的窗口只是一張畫而不能點&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;Composite 擴展的這些限制使得 X 下的混成器目前只能實現 Mac OS X 那樣的 Exposé
效果，而不能實現 &lt;a class="reference external" href="//farseerfc.me/brief-history-of-compositors-in-desktop-os.html#project-looking-glass-3d"&gt;LG3D&lt;/a&gt; 那樣直接在 3D 空間中操縱窗口內容。&lt;/p&gt;
&lt;p&gt;解決重定向問題曾經的一縷曙光是 &lt;ruby&gt;&lt;rb&gt;昇陽公司&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Sun Microsystems&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 在開發 &lt;a class="reference external" href="//farseerfc.me/brief-history-of-compositors-in-desktop-os.html#project-looking-glass-3d"&gt;LG3D&lt;/a&gt; 的過程中同時提議過另一個 X
擴展叫做 Event Interception 或者簡稱 &lt;a class="reference external" href="http://freedesktop.org/wiki/Software/XEvIE/"&gt;XEvIE&lt;/a&gt; ，這個擴展的設計目的就是提供 API
讓某個程序接收並操縱全部的鍵盤和鼠標事件。可惜這個擴展隨着昇陽公司本身的隕落而
處於無人維護的狀態，這一點也在它的官方網頁上說明了：&lt;/p&gt;
&lt;blockquote&gt;
It has been suggested that this extension should not be used
because it is broken and maintainerless.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;Composite 擴展的不足&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通過上面的介紹，我們就已經可以看到 Composite 擴展的不足之處了。
總結起來說，主要有兩大不足：&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;繪圖效率低。因爲同樣的位圖從應用程序傳到 Xorg ，再從 Xorg 傳到混成器，
最後從混成器再繪製到屏幕上，繞了一個大彎。這就是爲什麼 Wayland 的開發者在他的slide
&lt;a class="reference external" href="http://people.freedesktop.org/~daniels/lca2013-wayland-x11.pdf"&gt;the real story behind Wayland and X&lt;/a&gt;
裏這麼說：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;and what's the X server? really bad IPC&lt;/p&gt;
&lt;p&gt;那麼 X 服務器到底做了什麼呢？ 非常糟糕的進程間通訊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;沒有重定向輸入事件。如果我們要在 X 的混成器裏做這個事情，
基本上我們要全部重寫一遍 X 已經寫好的窗口事件分發邏輯。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然同樣要重寫，爲什麼不直接重寫一遍 X 呢，扔掉那些歷史負擔，扔掉那些無用的 API
，重新設計可擴展的 API ，做好快速安全的 IPC —— 嗯，重寫 X 就是 Wayland 的目的。&lt;/p&gt;
&lt;p&gt;不過這麼重寫了的 Wayland 還是我們熟悉可愛的 X 麼？它有哪些地方變樣了？
這將是我下一篇文章的內容。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;附錄：擴展閱讀&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我自己沒有寫過窗口管理器，沒有寫過混成器，沒有寫過 Wayland
程序，以上說的都是我從互聯網上看到的整理出來的內容。寫下本文的過程中我參考了這些文章：&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://keithp.com/~keithp/talks/xarch_ols2004/xarch-ols2004-html/"&gt;The (Re)Architecture of the X Window System&lt;/a&gt; 這篇2004年寫的文章描述了 Composite
擴展出現的動機和歷史，介紹了繪圖庫的實現情況，涉及了上面所說的那些 X 擴展被用到的情況和可能。
同時這篇文章還展望了很多現在的 X 已然實現了的功能，比如 OpenGL 和 X 的結合方面我們有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/GLX"&gt;GLX&lt;/a&gt; 和 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/AIGLX"&gt;AIGLX&lt;/a&gt;
，比如內核的顯卡支持方面我們有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Direct_Rendering_Infrastructure"&gt;DRI&lt;/a&gt; 和 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Mode_setting"&gt;KMS&lt;/a&gt; 。總之這是一篇描述 Linux
桌面未來的發展軌跡的非常有閱讀價值的歷史文獻。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://wingolog.org/archives/2008/07/26/so-you-want-to-build-a-compositor"&gt;so you want to build a compositor&lt;/a&gt; 這是一篇 2008 年寫的博文，介紹如何用 Clutter
實現一個最簡單的混成器。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.talisman.org/~erlkonig/misc/x11-composite-tutorial/"&gt;Composite tutorial&lt;/a&gt; 這是另一篇介紹如何實現一個簡單的混成器的博文，用 Qt 實現，但是同樣很底層。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://projects.mini-dweeb.org/projects/unagi"&gt;unagi&lt;/a&gt; 這是一個可用的（但是已經長期沒有開發的）類似 xcompmgr 的混成器。這個項目貌似
是一位研究生的碩士畢業設計，同時他公開了碩士學位的畢業論文
&lt;a class="reference external" href="http://projects.mini-dweeb.org/attachments/download/3/report.pdf"&gt;Master thesis: Writing an X compositing manager&lt;/a&gt;
其中也對實現一個簡單的混成器做了詳盡描述，包括介紹了相關的 X 擴展和調用。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="linux"></category><category term="wayland"></category><category term="xorg"></category><category term="compositor"></category></entry><entry><title>archlinux 上用 chrome 實現 透明計算 遠程登錄</title><link href="//farseerfc.me/arch-chrome-remote-desktop.html" rel="alternate"></link><published>2015-02-13T20:39:00+09:00</published><updated>2015-02-13T20:39:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-02-13:/arch-chrome-remote-desktop.html</id><summary type="html">
&lt;p&gt;&lt;a class="reference external" href="http://news.sciencenet.cn/htmlnews/2015/1/311393.shtm"&gt;透明計算&lt;/a&gt;
具體是什麼，因爲他們沒有公開技術細節所以我並不知道，只是看
&lt;a class="reference external" href="http://v.qq.com/page/h/v/q/h0145ebh1vq.html"&gt;公開出來的演示視頻&lt;/a&gt;
，感覺似乎只要能從手機上遠程登錄系統桌面，就能算是透明計算了。
如果透明計算真是這個意思，那麼我似乎已經用着這個技術很多年了嘛。&lt;/p&gt;
&lt;p&gt;Xorg 上常用的遠程桌面工具有很多，基於 VNC 協議的、基於NX的和基於 RDP 協議的都能找到，
直接 ssh X forwarding 效果也不錯。只是這些方案的一個 &lt;strong&gt;不太易用&lt;/strong&gt; 的地方在於，需要
通過 ip 訪問到遠程的電腦，所以在跨越 NAT 之類的情況下不太容易使用。&lt;/p&gt;
&lt;p&gt;於是今天介紹一個使用方便設置也簡單的方法： 通過 chrome-remote-desktop 在 archlinux
上使用遠程桌面。這個方案的優勢在於，藉助 Google 的雲端服務器（內部貌似是XMPP協議下的握手）
方便地實現了 NAT 穿透，無論什麼網絡環境基本都能使用。當然，要支持遠程登錄，
位於遠端的登錄的計算機必須一直開着 …&lt;/p&gt;</summary><content type="html">
&lt;p&gt;&lt;a class="reference external" href="http://news.sciencenet.cn/htmlnews/2015/1/311393.shtm"&gt;透明計算&lt;/a&gt;
具體是什麼，因爲他們沒有公開技術細節所以我並不知道，只是看
&lt;a class="reference external" href="http://v.qq.com/page/h/v/q/h0145ebh1vq.html"&gt;公開出來的演示視頻&lt;/a&gt;
，感覺似乎只要能從手機上遠程登錄系統桌面，就能算是透明計算了。
如果透明計算真是這個意思，那麼我似乎已經用着這個技術很多年了嘛。&lt;/p&gt;
&lt;p&gt;Xorg 上常用的遠程桌面工具有很多，基於 VNC 協議的、基於NX的和基於 RDP 協議的都能找到，
直接 ssh X forwarding 效果也不錯。只是這些方案的一個 &lt;strong&gt;不太易用&lt;/strong&gt; 的地方在於，需要
通過 ip 訪問到遠程的電腦，所以在跨越 NAT 之類的情況下不太容易使用。&lt;/p&gt;
&lt;p&gt;於是今天介紹一個使用方便設置也簡單的方法： 通過 chrome-remote-desktop 在 archlinux
上使用遠程桌面。這個方案的優勢在於，藉助 Google 的雲端服務器（內部貌似是XMPP協議下的握手）
方便地實現了 NAT 穿透，無論什麼網絡環境基本都能使用。當然，要支持遠程登錄，
位於遠端的登錄的計算機必須一直開着 Chrome Remote Desktop 的後臺服務。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Chrome Remote Desktop 插件&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Chrome Remote Desktop 插件" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-plugin.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="chrome-remote-desktop"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;Chrome Remote Desktop 的客戶端&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;雖然可能有很多人不知道，不過 Chrome 內包括遠程桌面的功能很久了。只是這個功能的界面默認
沒有提供界面，要使用它需要安裝 Google 官方出品的
&lt;a class="reference external" href="https://chrome.google.com/webstore/detail/chrome-remote-desktop/gbchcmhmhahfdphkhkmpfmihenigjmpp"&gt;remote-desktop 插件&lt;/a&gt; 。
裝好之後遠程桌面的客戶端就準備好，可以用來遠程訪問別的計算機桌面了（無論是 Windows/OS X
還是 Linux 都支持）。並且不光可以自己遠程訪問自己賬戶的桌面，還可以遠程協助朋友的桌面。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="archlinux"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;Archlinux 上設置遠程登錄的服務器&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;有了客戶端之後還要設置一下纔能讓桌面作爲遠程登錄的服務器。Windows 和 OS X 上 Chrome
會自動下載需要的安裝包，無腦下一步就能裝好了。Linux上由於發行版衆多，桌面配置各異，
所以需要一點手動配置。官方的設置步驟記載在 &lt;a class="reference external" href="https://support.google.com/chrome/answer/1649523"&gt;這裏&lt;/a&gt;
其中給出了 debian 用的二進制包和 Ubuntu 12.10 上的設置方式，以下設置是參考官方步驟。&lt;/p&gt;
&lt;p&gt;首先要安裝 chrome-remote-desktop 這個包，這個包實際上對應了 Windows/OS X 上用安裝程序
安裝的 Remote Desktop Host Controller。 archlinux 上開啓了
&lt;a class="reference external" href="https://github.com/archlinuxcn/repo"&gt;[archlinuxcn]&lt;/a&gt;
倉庫的話，可以直接安裝打好的包。或者可以從
&lt;a class="reference external" href="https://aur.archlinux.org/packages/chrome-remote-desktop/"&gt;AUR&lt;/a&gt; 裝。&lt;/p&gt;
&lt;pre&gt;&lt;span class="code-line"&gt;$ pacman -Ss chrome-remote-desktop&lt;br/&gt;&lt;span style="color:purple;font-weight:bold;"&gt;archlinuxcn/&lt;/span&gt;&lt;span style="font-weight:bold;"&gt;chrome-remote-desktop &lt;/span&gt;&lt;span style="color:green;font-weight:bold;"&gt;40.0.2214.44-1&lt;/span&gt;&lt;br/&gt;Allows you to securely access your computer over the Internet through Chrome.&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;裝好之後從會說這麼一段話：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;groupadd：无效的组 ID “chrome-remote-desktop”&lt;/p&gt;
&lt;p&gt;Please create ~/.config/chrome-remote-desktop folder manually, if it doesn't exist, or else you can't use CRD.
The needed files are created by the Chrome app, inside the chrome-remote-desktop folder, after Enabling Remote Connections.
To {enable,start} the service use systemctl --user {enable,start} chrome-remote-desktop&lt;/p&gt;
&lt;p&gt;You may need to create a ~/.chrome-remote-desktop-session file with commands to start your session&lt;/p&gt;
&lt;p&gt;Go to &lt;a class="reference external" href="https://support.google.com/chrome/answer/1649523"&gt;https://support.google.com/chrome/answer/1649523&lt;/a&gt; for more information.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那句報錯是 AUR 裏打的包還沒跟上上游 Google 的更改導致的錯誤，
首先我們需要把遠程登錄的用戶添加入 chrome-remote-desktop 這個用戶組裏。
新版本的 chrome remote desktop 提供了一個命令做這個事情，所以執行以下命令就可以了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; /opt/google/chrome-remote-desktop/chrome-remote-desktop --add-user&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後我們需要手動創建 &lt;code class="code"&gt;
~/​.config/​chrome-remote-desktop&lt;/code&gt;
 這個文件夾，內容是空的
就好了，隨後 chrome 會往這裏面放 &lt;code class="code"&gt;
host#.json&lt;/code&gt;
 文件用於身份驗證。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; mkdir ~/.config/chrome-remote-desktop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後我們要創建一個 shell 腳本 &lt;code class="code"&gt;
~/​.chrome-remote-desktop-session&lt;/code&gt;
 ，這是遠程
登錄時的 .xinitrc ，內容麼就是啓動你想在遠程登錄時用的桌面環境。
這裏可以指定一個和你正在登錄的 WM/DE 不同的桌面，比如我啓動 xfce4：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; cat ~/.chrome-remote-desktop-session&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;#&lt;/span&gt;!/bin/bash&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;startxfce4&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; chmod &lt;span class="m"&gt;755&lt;/span&gt; .chrome-remote-desktop-session&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下來需要從 Chrome 的插件裏啓用遠程桌面。打開 Chrome 的 Remote Desktop 插件，這時
應該可以看到一個「啓用遠程鏈接」的按鈕。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="Chrome Remote Desktop 插件中「啓用遠程鏈接」的按鈕" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-enable-button.png"/&gt;
&lt;p class="caption"&gt;Chrome Remote Desktop 插件中「啓用遠程鏈接」的按鈕&lt;/p&gt;
&lt;/div&gt;
&lt;div class="alert alert-warning compound"&gt;
&lt;p&gt;在撰寫本文的時候， Archlinux 官方源裏的 chromium 的版本和 aur/google-chrome
的版本尚且還是 40.0.2214.111 ，而 Chrome Web Store 中提供的 Chrome Remote
Desktop 的插件的版本是 41.0.2272.41 。雖然通常並不要求兩者版本一致，不過貌似最近
Chrome 內部的 Remoting 功能更改了 API 導致可能出問題。如果你找不到
「啓用遠程鏈接」的按鈕，請嘗試一下新版本的 Chrome 比如 google-chrome-dev 。
在這一步啓用之後，老版本的 chrome 應該也就能使用遠程桌面了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="alert alert-warning compound"&gt;
&lt;p&gt;在32位的 Linux 版本上，最近更新的 Chrome Remote Desktop 插件可能無法正確識別 Host
的版本，具體 &lt;a class="alert-link reference external" href="https://code.google.com/p/chromium/issues/detail?id=332930"&gt;參考這個 bug&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;點擊「啓用遠程鏈接」，設定一個 PIN 密碼（不需要很複雜，這裏首先有 Google 帳號驗證保證只有
你纔能訪問），然後就能看到這套電腦的 hostname 出現在「我的電腦」列表裏。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="啓用遠程鏈接之後的樣子" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-after-enabled.png"/&gt;
&lt;p class="caption"&gt;啓用遠程鏈接之後的樣子&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;同時，啓用了遠程鏈接之後，可以在剛剛創建的 ~/.config/chrome-remote-desktop
文件夾中找到記錄了驗證信息的文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ls .config/chrome-remote-desktop&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;chrome-profile  host#8cfe7ecfd6bb17955c1ea22f77d0d800.json  pulseaudio#8cfe7ecfd6&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後就可以啓動對應的 systemd 用戶服務了，如果想自動啓動服務要記得 &lt;code class="code"&gt;
systemctl --user enable&lt;/code&gt;
 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; systemctl --user start chrome-remote-desktop.service&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果上面的設置一切正常，就可以看到 chrome-remote-desktop 啓動了另外一個 Xorg 執行你
剛剛指定的桌面環境：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="htop 中看到的 chrome-remote-desktop 啓動的另外一個 Xorg" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-htop.png"/&gt;
&lt;p class="caption"&gt;htop 中看到的 chrome-remote-desktop 啓動的另外一個 Xorg&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;然後就可以試着通過 Remote Desktop 插件登錄到這個新開的 Xorg 了：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="「遠程」登錄到新的 XFCE4" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-xfce4.png"/&gt;
&lt;p class="caption"&gt;「遠程」登錄到新的 XFCE4&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="linux-chrome-windows-os-x"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;Linux 版本的 Chrome遠程桌面 和 Windows/ OS X 上的區別&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通過上面的設置步驟也可以看出，Linux版本的遠程桌面會在後臺開一個獨立的 X 會話，而不能
復用現在已有的 X 會話。對遠程登錄的用法而言這還能接受，對遠程協助的功能而言有點問題，
因爲正在使用的人不能觀察協助者做了什麼，協助者也不能繼續請求協助的人的操作。&lt;/p&gt;
&lt;p&gt;當然目前 Chrome 遠程桌面的 Linux Host Controller 還只是 beta 版本，官方只測試支持
Ubuntu 12.04 和 12.10 （14.04之後似乎有
&lt;a class="reference external" href="https://code.google.com/p/chromium/issues/detail?id=366432"&gt;Bug&lt;/a&gt;
），所以不能要求太多。希望以後能改善吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bonus"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;Bonus： 手機遠程登錄&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
手機上的 Chrome 遠程桌面 App&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="手機上的 Chrome 遠程桌面 App" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-android.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通過上面的設置就可以從任何一個 Chrome 遠程桌面客戶端登錄剛剛設置的這臺電腦了。
因爲 Chrome 在三大桌面系統 Windows / OS X / Linux 上都有，所以應該能覆蓋大多數桌面
系統了。&lt;/p&gt;
&lt;p&gt;除了桌面的 Chrome 之外還有一個客戶端是 Android 上的
&lt;a class="reference external" href="https://play.google.com/store/apps/details?id=com.google.chromeremotedesktop"&gt;Chrome 遠程桌面 App&lt;/a&gt; 經過上面的設置之後，從這個 App 也能看到並登錄：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="手機遠程登錄" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-android-logined.png"/&gt;
&lt;p class="caption"&gt;手機遠程登錄&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;好啦，開始享受國家自然科學一等獎的透明計算技術吧！&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="linux"></category><category term="archlinux"></category><category term="arch"></category><category term="chrome"></category><category term="remote"></category><category term="desktop"></category></entry><entry><title>從非緩衝輸入流到 Linux 控制檯的歷史</title><link href="//farseerfc.me/from-unbuffered-stdin-to-history-of-linux-tty.html" rel="alternate"></link><published>2014-12-12T17:06:00+09:00</published><updated>2014-12-12T17:06:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2014-12-12:/from-unbuffered-stdin-to-history-of-linux-tty.html</id><summary type="html">
&lt;p&gt;這篇也是源自於水源C板上板友的一個問題，涉及Linux上的控制檯的實現方式和歷史原因。因爲內容比較長，所以在這裏再排版一下發出來。
&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1418138991,file,M.1418138991.A.html"&gt;原帖在這裏&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;可以設置不帶緩衝的標準輸入流嗎？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;WaterElement(UnChanged) 於 2014年12月09日23:29:51 星期二 問到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;請問對於標準輸入流可以設置不帶緩衝嗎？比如以下程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer …&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary><content type="html">
&lt;p&gt;這篇也是源自於水源C板上板友的一個問題，涉及Linux上的控制檯的實現方式和歷史原因。因爲內容比較長，所以在這裏再排版一下發出來。
&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1418138991,file,M.1418138991.A.html"&gt;原帖在這裏&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;可以設置不帶緩衝的標準輸入流嗎？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;WaterElement(UnChanged) 於 2014年12月09日23:29:51 星期二 問到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;請問對於標準輸入流可以設置不帶緩衝嗎？比如以下程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;似乎還是需要在命令行輸入後按回車纔會讓 &lt;code class="code"&gt;
fgets&lt;/code&gt;
 返回，不帶緩衝究竟體現在哪裏？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;這和緩存無關，是控制檯的實現方式的問題。&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;再講細節一點，這裏有很多個程序和設備。以下按 linux 的情況講：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;終端模擬器窗口（比如xterm）收到鍵盤事件&lt;/li&gt;
&lt;li&gt;終端模擬器(xterm)把鍵盤事件發給虛擬終端 pty1&lt;/li&gt;
&lt;li&gt;pty1 檢查目前的輸入狀態，把鍵盤事件轉換成 stdin 的輸入，發給你的程序&lt;/li&gt;
&lt;li&gt;你的程序的 c 庫從 stdin 讀入一個輸入，處理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;標準庫說的輸入緩存是在 4 的這一步進行的。而行輸入是在 3 的這一步被緩存起來的。&lt;/p&gt;
&lt;p&gt;終端pty有多種狀態，一般控制檯程序所在的狀態叫「回顯行緩存」狀態，這個狀態的意思是:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;所有普通字符的按鍵，會回顯到屏幕上，同時記錄在行緩存區裏。&lt;/li&gt;
&lt;li&gt;處理退格( &lt;kbd class="kbd"&gt;
BackSpace&lt;/kbd&gt;
 )，刪除( &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;
 )按鍵爲刪掉字符，左右按鍵移動光標。&lt;/li&gt;
&lt;li&gt;收到回車的時候把整個一行的內容發給stdin。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;參考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Cooked_mode"&gt;http://en.wikipedia.org/wiki/Cooked_mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同時在Linux/Unix下可以發特殊控制符號給pty讓它進入「raw」狀態，這種狀態下按鍵
不會被回顯，顯示什麼內容都靠你程序自己控制。
如果你想得到每一個按鍵事件需要用raw狀態，這需要自己控制回顯自己處理緩衝，
簡單點的方法是用 readline 這樣的庫（基本就是「回顯行緩存」的高級擴展，支持了
Home/End，支持歷史）或者 ncurses 這樣的庫（在raw狀態下實現了一個簡單的窗口/
事件處理框架）。&lt;/p&gt;
&lt;p&gt;參考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/POSIX_terminal_interface#History"&gt;http://en.wikipedia.org/wiki/POSIX_terminal_interface#History&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除此之外， &lt;kbd class="kbd"&gt;
Ctrl-C&lt;/kbd&gt;
 轉換到 SIGINT ， &lt;kbd class="kbd"&gt;
Ctrl-D&lt;/kbd&gt;
 轉換到 EOF 這種也是在 3 這一步做的。&lt;/p&gt;
&lt;p&gt;以及，有些終端模擬器提供的 &lt;kbd class="kbd"&gt;
Ctrl-Shift-C&lt;/kbd&gt;
 表示複製這種是在 2 這一步做的。&lt;/p&gt;
&lt;p&gt;以上是 Linux/unix 的方式。 Windows的情況大體類似，只是細節上有很多地方不一樣：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;窗口事件的接收者是創建 cmd 窗口的 Win32 子系統。&lt;/li&gt;
&lt;li&gt;Win32子系統接收到事件之後，傳遞給位於 命令行子系統 的 cmd 程序&lt;/li&gt;
&lt;li&gt;cmd 程序再傳遞給你的程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Windows上同樣有類似行緩存模式和raw模式的區別，只不過實現細節不太一樣。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="strace"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;strace查看了下&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WaterElement(UnChanged) 於 2014年12月10日21:53:54 星期三 回復：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;感謝FC的詳盡解答。&lt;/p&gt;
&lt;p&gt;用strace查看了下，設置標準輸入沒有緩存的話讀每個字符都會調用一次 &lt;code class="code"&gt;
read&lt;/code&gt;
 系統調用，
比如輸入abc：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;read(0, abc&lt;/span&gt;
&lt;span class="code-line"&gt;"a", 1)                         = 1&lt;/span&gt;
&lt;span class="code-line"&gt;read(0, "b", 1)                         = 1&lt;/span&gt;
&lt;span class="code-line"&gt;read(0, "c", 1)                         = 1&lt;/span&gt;
&lt;span class="code-line"&gt;read(0, "\n", 1)                        = 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有緩存的話就只調用一次了 &lt;code class="code"&gt;
read&lt;/code&gt;
 系統調用了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;read(0, abc&lt;/span&gt;
&lt;span class="code-line"&gt;"abc\n", 1024)                  = 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="raw-mode"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;如果想感受一下 raw mode&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;沒錯，這個是你的進程內C庫做的緩存，tty屬於字符設備所以是一個一個字符塞給你的
程序的。&lt;/p&gt;
&lt;p&gt;如果想感受一下 raw mode 可以試試下面這段程序（沒有檢測錯誤返回值）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;termios.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ttyfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;/* reset tty - useful also for restoring the terminal when this process&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;   wishes to temporarily relinquish the tty&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* flush and reset */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;/* put terminal in raw mode - see termio(7I) for modes */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* copy original and then modify below */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* input modes - clear indicated ones giving: no break, no CR to NL,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;       no parity check, no strip char, no start/stop output (sic) control */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_iflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BRKINT&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICRNL&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;INPCK&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISTRIP&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IXON&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* output modes - clear giving: no post processing such as NL to CR+NL */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_oflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OPOST&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* control modes - set 8 bit chars */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cflag&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CS8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* local modes - clear giving: echoing off, canonical off (no erase with&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;       backspace, ^U,...),  no extended functions, no signal chars (^Z,^C) */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_lflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ECHO&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICANON&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IEXTEN&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISIG&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* control chars - set return condition: min number of bytes and timer */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after 5 bytes or .8 seconds&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;                                                after first byte seen      */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* immediate - anything       */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after two bytes, no timer  */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after a byte or .8 seconds */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* put terminal in raw mode after flushing */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;atexit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;終端上的字符編程&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;vander(大青蛙) 於 2014年12月12日08:52:20 星期五 問到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;學習了！&lt;/p&gt;
&lt;p&gt;進一步想請教一下fc大神。如果我在Linux上做終端上的字符編程，是否除了用ncurses庫
之外，也可以不用該庫而直接與終端打交道，就是你所說的直接在raw模式？
另外，終端類型vt100和linux的差別在哪裏？爲什麼Kevin Boone的KBox配置手冊裏面說必
須把終端類型設成linux，而且要加上terminfo文件，才能讓終端上的vim正常工作？term
info文件又是幹什麼的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;Linux控制檯的歷史&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;嗯理論上可以不用 ncurses 庫直接在 raw 模式操縱終端。&lt;/p&gt;
&lt;p&gt;這裏稍微聊一下terminfo/termcap的歷史，詳細的歷史和吐槽參考
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater's Handbook&lt;/a&gt;
第6章 Terminal Insanity。&lt;/p&gt;
&lt;p&gt;首先一個真正意義上的終端就是一個輸入設備（通常是鍵盤）加上一個輸出設備（打印
機或者顯示器）。很顯然不同的終端的能力不同，比如如果輸出設備是打印機的話，顯
示出來的字符就不能刪掉了（但是能覆蓋），而且輸出了一行之後就不能回到那一行了
。再比如顯示器終端有的支持粗體和下劃線，有的支持顏色，而有的什麼都不支持。
早期Unix工作在電傳打字機（TeleTYpe）終端上，後來Unix被port到越來越多的機器上
，然後越來越多類型的終端會被連到Unix上，很可能同一臺Unix主機連了多個不同類型
的終端。由於是不同廠商提供的不同的終端，能力各有不同，自然控制他們工作的方式
也是不一樣的。所有終端都支持回顯行編輯模式，所以一般的面向行的程序還比較好寫
，但是那時候要撰寫支持所有終端的「全屏」程序就非常痛苦，這種情況就像現在瀏覽
器沒有統一標準下寫HTML要測試各種瀏覽器兼容性一樣。
通常的做法是&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;使用最小功能子集&lt;/li&gt;
&lt;li&gt;假設終端是某個特殊設備，不管別的設備。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;水源的代碼源頭 Firebird2000 就是那樣的一個程序，只支持固定大小的vt102終端。&lt;/p&gt;
&lt;p&gt;這時有一個劃時代意義的程序出現了，就是 vi，試圖要做到「全屏可視化編輯」。這在
現在看起來很簡單，但是在當時基本是天方夜譚。
vi 的做法是提出一層抽象，記錄它所需要的所有終端操作，然後有一個終端類型數據庫
，把那些操作映射到終端類型的具體指令上。當然並不是所有操作在所有終端類型上都
支持，所以會有一堆 fallback，比如要「強調」某段文字，在彩色終端上可能
fallback 到紅色，在黑白終端上可能 fallback 到粗體。&lt;/p&gt;
&lt;p&gt;vi 一出現大家都覺得好頂讚，然後想要寫更多類似 vi 這樣的全屏程序。然後 vi 的作
者就把終端抽象的這部分數據庫放出來形成一個單獨的項目，叫 termcap （Terminal
Capibility），對應的描述終端的數據庫就是 termcap 格式。然後 termcap 只是一個
數據庫（所以無狀態）還不夠方便易用，所以後來又有人用 termcap 實現了 curses 。&lt;/p&gt;
&lt;p&gt;再後來大家用 curses/termcap 的時候漸漸發現這個數據庫有一點不足：它是爲 vi 設
計的，所以只實現了 vi 需要的那部分終端能力。然後對它改進的努力就形成了新的
terminfo 數據庫和 pcurses 和後來的 ncurses 。 然後 VIM 出現了自然也用
terminfo 實現這部分終端操作。&lt;/p&gt;
&lt;p&gt;然後麼就是 X 出現了， xterm 出現了，大家都用顯示器了，然後 xterm 爲了兼容各種
老程序加入了各種老終端的模擬模式。不過因爲最普及的終端是 vt100 所以 xterm 默
認是工作在兼容 vt100 的模式下。然後接下來各種新程序（偷懶不用*curses的那些）
都以 xterm/vt100 的方式寫。&lt;/p&gt;
&lt;p&gt;嗯到此爲止是 Unix 世界的黑歷史。&lt;/p&gt;
&lt;p&gt;知道這段歷史的話就可以明白爲什麼需要 TERM 變量配合 terminfo 數據庫纔能用一些
Unix 下的全屏程序了。類比一下的話這就是現代瀏覽器的 user-agent。&lt;/p&gt;
&lt;p&gt;然後話題回到 Linux 。 大家知道 Linux 早期代碼不是一個 OS， 而是 Linus 大神想
在他的嶄新蹭亮的 386-PC 上遠程登錄他學校的 Unix 主機，接收郵件和逛水源（咳咳
）。於是 Linux 最早的那部分代碼並不是一個通用 OS 而只是一個 bootloader 加一個
終端模擬器。所以現在 Linux 內核裏還留有他當年實現的終端模擬器的部分代碼，而這
個終端模擬器的終端類型就是 linux 啦。然後他當時是爲了逛水源嘛所以 linux 終端
基本上是 vt102 的一個接近完整子集。&lt;/p&gt;
&lt;p&gt;說到這裏脈絡大概應該清晰了， xterm終端類型基本模擬 vt100，linux終端類型基本模
擬 vt102。這兩個的區別其實很細微，都是同一個廠商的兩代產品嘛。有差別的地方差
不多就是 &lt;kbd class="kbd"&gt;
Home&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
End&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageUp&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageDown&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;

這些不在 ASCII 控制字符表裏的按鍵的映射關係不同。&lt;/p&gt;
&lt;p&gt;嗯這也就解釋了爲什麼在linux環境的圖形界面的終端裏 telnet 上水源的話，上面這些
按鍵會錯亂…… 如果設置終端類型是 linux/vt102 的話就不會亂了。在 linux 的
TTY 裏 telnet 也不會亂的樣子。&lt;/p&gt;
&lt;p&gt;寫到這裏纔發現貌似有點長…… 總之可以參考
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater's Handbook&lt;/a&gt;
裏的相關歷史評論和吐槽，那一段非常有意思。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="c"></category><category term="linux"></category><category term="stdio"></category><category term="tty"></category><category term="unix"></category><category term="ugh"></category><category term="ncurses"></category><category term="termcap"></category><category term="terminfo"></category></entry><entry><title>KDE5 Plasma 之跳動賣萌的活動按鈕</title><link href="//farseerfc.me/jumping-kde5-plasma-activities-button.html" rel="alternate"></link><published>2014-12-09T01:54:00+09:00</published><updated>2014-12-09T01:54:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2014-12-09:/jumping-kde5-plasma-activities-button.html</id><content type="html">&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;今天嘗試 KDE5 Plasma 的活動的時候無意間發現這個現象。
只要把活動按鈕拖出桌面，它就會在桌面邊緣來回跳動。
視頻如下：&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_SSbf97jGSpI"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/SSbf97jGSpI"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XODQ0NjM2MzQ4"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;embed align="middle" allowfullscreen="true" allowscriptaccess="always" class="embed-responsive-item" quality="high" src="http://player.youku.com/player.php/sid/XODQ0NjM2MzQ4/v.swf" type="application/x-shockwave-flash"/&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_SSbf97jGSpI"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XODQ0NjM2MzQ4"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;當然你可以把它再拖回來，所以這個問題還無傷大雅，只是賣萌。&lt;/p&gt;
&lt;p&gt;比比之前 Gnome3 那個跳動的界面真是好太多了：&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_TRQJdRHYwrw"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/TRQJdRHYwrw"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XNjc4MjQ5NjE2"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;embed align="middle" allowfullscreen="true" allowscriptaccess="always" class="embed-responsive-item" quality="high" src="http://player.youku.com/player.php/sid/XNjc4MjQ5NjE2/v.swf" type="application/x-shockwave-flash"/&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_TRQJdRHYwrw"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XNjc4MjQ5NjE2"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;順便，今天還看到一個賣萌的 KDE5 Plasma 靜音圖標的翻譯：&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;blockquote class="twitter-tweet" lang="zh-tw"&gt;&lt;p&gt;KDE5のミュート画面の中国語翻訳、「静音」のはずだが「镜音」になっている。Vocaloidファンのネタだか、単なる入力ミスだか分からない。 &lt;a href="http://t.co/ipyHjXMscR"&gt;pic.twitter.com/ipyHjXMscR&lt;/a&gt;&lt;/p&gt;— Jiachen YANG (@farseerfc) &lt;a href="https://twitter.com/farseerfc/status/541944351270518784"&gt;2014 12月 8日&lt;/a&gt;&lt;/blockquote&gt;</content><category term="tech"></category><category term="kde5"></category><category term="plasma"></category><category term="linux"></category><category term="gnome3"></category></entry><entry><title>“…if we do this work … ” --Bill Gates</title><link href="//farseerfc.me/if-we-do-this-work.html" rel="alternate"></link><published>2011-03-14T20:34:00+09:00</published><updated>2011-03-14T20:34:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2011-03-14:/if-we-do-this-work.html</id><summary type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/716517729"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From: Bill Gates&lt;/p&gt;
&lt;p&gt;’-- Sent: Sunday, January 24, 1999 8:41 AM&lt;/p&gt;
&lt;p&gt;Jeff Westorinon; Ben Fathi ;&lt;/p&gt;
&lt;p&gt;TO: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder&lt;/p&gt;
&lt;p&gt;Subject: ACPI extensions&lt;/p&gt;
&lt;p&gt;One thing I find myself wondering about is whether we shouldn’t try and
make the "ACPI" extensions somehow Windows specific.&lt;/p&gt;
&lt;p&gt;It …&lt;/p&gt;</summary><content type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/716517729"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From: Bill Gates&lt;/p&gt;
&lt;p&gt;’-- Sent: Sunday, January 24, 1999 8:41 AM&lt;/p&gt;
&lt;p&gt;Jeff Westorinon; Ben Fathi ;&lt;/p&gt;
&lt;p&gt;TO: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder&lt;/p&gt;
&lt;p&gt;Subject: ACPI extensions&lt;/p&gt;
&lt;p&gt;One thing I find myself wondering about is whether we shouldn’t try and
make the "ACPI" extensions somehow Windows specific.&lt;/p&gt;
&lt;p&gt;It seems unfortunate if we do this work and get our partners to do the
work and the result is that &lt;strong&gt;Linux works great without having to do the work&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maybe there is no way to avoid this problem but it does bother me.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Maybe we could define the APIs so that they work well with NT and not
the others even if they are open.&lt;/p&gt;
&lt;p&gt;Or maybe we could patent something relaled to this.&lt;/p&gt;
&lt;p&gt;From:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf"&gt;http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果這就是我至今在Xen4.0上得不到ACPI 3.0的完善支持的原因，那麼我詛咒Bill Gates！&lt;/p&gt;
</content><category term="import"></category><category term="microsoft"></category><category term="linux"></category><category term="acpi"></category></entry></feed>