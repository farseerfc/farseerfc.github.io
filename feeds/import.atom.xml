<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Farseerfc的小窩 - import</title><link href="//farseerfc.me/" rel="alternate"></link><link href="//farseerfc.me/feeds/import.atom.xml" rel="self"></link><id>//farseerfc.me/</id><updated>2016-08-08T16:15:00+09:00</updated><entry><title>爲什麼 Linus Torvalds 不願意將 Linux 變成 GPLv3 授權？</title><link href="//farseerfc.me/why-linus-torvalds-undermine-gplv3.html" rel="alternate"></link><published>2016-08-08T16:15:00+09:00</published><updated>2016-08-08T16:15:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2016-08-08:/why-linus-torvalds-undermine-gplv3.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="https://www.zhihu.com/question/48884264/answer/113454129"&gt;知乎&lt;/a&gt; 轉載&lt;/p&gt;
&lt;p&gt;和上篇文章一樣，這篇也是來自一個知乎上我回答的問題。&lt;/p&gt;
&lt;p&gt;原問題：为什么 Linus Torvalds 不愿意将 Linux 变成 GPLv3 授权？&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
DebConf 14: Q&amp;amp;A with Linus Torvalds&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_1Mg5_gxNXTo"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/1Mg5_gxNXTo"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XMTY3NjIzNDU0NA"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XMTY3NjIzNDU0NA" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_1Mg5_gxNXTo"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XMTY3NjIzNDU0NA"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我的回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這裏有段 Linus Torvalds 在 DebConf 14 上的 Q&amp;amp;A:
&lt;a class="reference external" href="https://youtu.be/1Mg5_gxNXTo?t=47m20s"&gt;https://youtu.be/1Mg5_gxNXTo?t=47m20s&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中關於 GPLv3 和協議的那一段在47:20開始到57:00左右。
裏面 Linus 對自己的觀點澄清得很清楚了。
看u2b或者聽英語有困難的請留評論，我抽空可以試着翻譯一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;然後接下來就是我承諾的翻譯了 …&lt;/h2&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="https://www.zhihu.com/question/48884264/answer/113454129"&gt;知乎&lt;/a&gt; 轉載&lt;/p&gt;
&lt;p&gt;和上篇文章一樣，這篇也是來自一個知乎上我回答的問題。&lt;/p&gt;
&lt;p&gt;原問題：为什么 Linus Torvalds 不愿意将 Linux 变成 GPLv3 授权？&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
DebConf 14: Q&amp;amp;A with Linus Torvalds&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_1Mg5_gxNXTo"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/1Mg5_gxNXTo"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XMTY3NjIzNDU0NA"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XMTY3NjIzNDU0NA" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_1Mg5_gxNXTo"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XMTY3NjIzNDU0NA"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我的回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這裏有段 Linus Torvalds 在 DebConf 14 上的 Q&amp;amp;A:
&lt;a class="reference external" href="https://youtu.be/1Mg5_gxNXTo?t=47m20s"&gt;https://youtu.be/1Mg5_gxNXTo?t=47m20s&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中關於 GPLv3 和協議的那一段在47:20開始到57:00左右。
裏面 Linus 對自己的觀點澄清得很清楚了。
看u2b或者聽英語有困難的請留評論，我抽空可以試着翻譯一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;然後接下來就是我承諾的翻譯了&lt;/h2&gt;
&lt;a aria-controls="ebbd22ff" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#ebbd22ff" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="ebbd22ff"&gt;
&lt;blockquote&gt;
Q: Do you agree that you undermine GPLv3? and ...&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;問：你是否同意說你貶低了 GPLv3 ? 以及……&lt;/p&gt;
&lt;a aria-controls="505c14ba" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#505c14ba" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="505c14ba"&gt;
&lt;blockquote&gt;
L: Yes&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;L: 是的&lt;/p&gt;
&lt;a aria-controls="97e91d0f" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#97e91d0f" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="97e91d0f"&gt;
&lt;blockquote&gt;
Q: How can we get you to stop?&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;問：我們如何纔能讓你別這麼做？&lt;/p&gt;
&lt;a aria-controls="77f7155c" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#77f7155c" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="77f7155c"&gt;
&lt;blockquote&gt;
L: What?&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;L: 什麼？&lt;/p&gt;
&lt;a aria-controls="d3591d99" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#d3591d99" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="d3591d99"&gt;
&lt;blockquote&gt;
Q: ...How can we get you to stop?&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;問：……我們如何纔能讓你別這麼做？&lt;/p&gt;
&lt;a aria-controls="7b4e5b8a" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#7b4e5b8a" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="7b4e5b8a"&gt;
&lt;blockquote&gt;
L: Oh I hate GPLv3. I undermined it on purpose.
I actually thought the GPLv3 extensions were horrible.
I understand why people would want to do them but I think it should have
been a completely new license.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;L: 哦我討厭 GPLv3 ，我是在故意貶低它。實際上我覺得 GPLv3 的擴展非常可怕。
我能理解爲什麼人們想要做這個，但是我覺得它本應是一個全新的協議。&lt;/p&gt;
&lt;a aria-controls="20696190" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#20696190" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="20696190"&gt;
&lt;blockquote&gt;
Emm my argument for liking version 2, and I still think version 2 is a
great license, was that, "I give you source code, you give me your
changes back, we are even." Right? That's my take on GPL version 2, right,
it's that simple.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;嗯我喜歡版本 2 的那些理由，並且我仍然覺得版本 2 是一個非常棒的協議，
理由是：「我給你源代碼，你給我你對它的修改，我們就扯平了」
對吧？這是我用 GPL 版本 2 的理由，就是這麼簡單。&lt;/p&gt;
&lt;a aria-controls="7565a2bc" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#7565a2bc" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="7565a2bc"&gt;
&lt;blockquote&gt;
And version 3 extended that in ways that I personally am really
uncomfortable with, namely "I give you source code, that means that if
you use that source code, you can't use it on your device unless you
follow my rules." And to me that's, that's a violation of everything
version 2 stood for. And I understand why the FSF did it because I know
what the FSF wants.     But to me it's not the same license at all.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;然後版本 3 的擴展在某些方面讓我個人覺得非常不舒服，也就是說「我給你源代碼，
這意味着你必須服從我的一些規則，否則你不能把它用在你的設備上。」
對我來說，這是違反了版本 2 協議所追求的所有目的。然而我理解爲什麼 FSF 要這麼做，
因爲我知道 FSF 想要達成什麼，但是對我來說這完全是不同的協議了。&lt;/p&gt;
&lt;a aria-controls="f0b4e1fb" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#f0b4e1fb" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="f0b4e1fb"&gt;
&lt;blockquote&gt;
So I was very upset and made it very clear, and this was months before
version 3 was actually published. There was a discussion about this
long before... There was an earlier version of version 3, years before
actually, where I said "No, this is not gonna fly."
And during that earlier discussion I had already added to the kernel that,
"Hey, I don't have the version 2 or later". And there was no...
And I was really happy then when version 3 came out, that I have done that
something like 5 years before, because there was ever never any question
about what the license for the kernel was.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;所以我當時非常不安，並且表明了自己的觀點，並且這是在版本 3 發佈的數月之前。
在那很久之前曾經有過一場討論……在版本 3 之前有一個早期的版本，
事實上幾年之前，那時我就說過：「不，這不可能工作」。
並且在那個早期的討論階段我已經在內核裏寫好了「嘿，我可沒有寫過版本 2
或者更高版本」。所以之後也沒有過（爭議）……隨後版本 3 出來的時候我非常開心，
因爲我早在大概 5 年前做了預防，之後也就再也沒有過關於內核的協議究竟是哪個
版本的討論。&lt;/p&gt;
&lt;a aria-controls="32e9bcca" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#32e9bcca" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="32e9bcca"&gt;
&lt;blockquote&gt;
But I actually thought that version 3 is ... Uh, no ... I actually think
version 3 is a &lt;strong&gt;FINE&lt;/strong&gt; license, right. I'm a firm believer in,
"If you write your code, it is your choice to pick a license."
And version 3 is a fine license. Version 3 was not a good ...
"Here we give you version 2, and then we tried to sneak in these new rules,
and tried to force everybody to upgrade." That was the part I disliked.
And the FSF did some really sneaky stuff, downright immoral in my opinion.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;不過事實上我覺得版本 3 是……呃不……我事實上覺得版本 3 是個 &lt;strong&gt;不錯&lt;/strong&gt; 的協議，
對吧。我堅定地相信「如果是你寫的代碼，那麼你有權利決定它應該用什麼協議」。
並且版本 3 是個不錯的選擇。版本 3 不好的地方在……「我們給你了版本 2
，然後我們試圖偷偷混入這些新的規則，並且想逼着所有人都跟着升級」這是我不喜歡版本
3 的地方。並且 FSF 在其中做了很多見不得人的事情，我覺得做得很不道德。&lt;/p&gt;
&lt;a aria-controls="318f390b" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#318f390b" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="318f390b"&gt;
&lt;blockquote&gt;
Q: So you are talking about &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tivoization"&gt;Tivoization&lt;/a&gt;?&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;問：所以你在說 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tivoization"&gt;Tivoization&lt;/a&gt; 的事情麼？&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
譯註： 關於 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tivoization"&gt;Tivoization&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
Tivoization 是 FSF 發明的一個詞，表示 TiVo 的做法。 TiVo
是一個生產類似電視機頂盒之類的設備的廠商，他們在他們的設備中用到了 Linux
內核和很多別的開源組件，並且他們根據 GPLv2 協議開放了他們使用的組件的源代碼。
然而他們在他們出售的設備中增加了數字簽名，驗證正在執行的系統和軟件是他們自己
編制的軟件，從而限制了用戶修改運行軟件的自由。這種做法在 FSF 看來是鑽了 GPLv2
的法律上的空子，所以 FSF 提出了 GPLv3 封堵這種做法。&lt;/div&gt;
&lt;/div&gt;
&lt;a aria-controls="db80a74e" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#db80a74e" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="db80a74e"&gt;
&lt;blockquote&gt;
L: Ehmm, yeah the Tivoization is always my main, eh dislike of version 3.
And, the FSF was being very dishonest thing. "Hey, we actually allow you
to invalidate the Tivoization clause" and they tried to, they literally
lied to people, and say "Hey, so that means that you can use GPLv3 without
the Tivoization part", right. This is ... How many people heard this
particular statement from the FSF? (Please raise your hands)&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;L: 沒錯，Tivoization 的事情一直是我反對版本 3 的主要根據。並且，FSF
在這件事上表現得極不誠實。「嘿，其實我們允許你無效化 Tivoization 條款」，這樣他們試圖，
應該說他們是在明白着欺騙別人，並且說「嘿，這意味着你可以使用除去 Tivoization 部分的 GPLv3」。
這很……在場的諸位中有誰從 FSF 那兒聽過這個說法？（請舉手）&lt;/p&gt;
&lt;a aria-controls="d4a2f0a6" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#d4a2f0a6" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="d4a2f0a6"&gt;
&lt;blockquote&gt;
Ok, maybe they only tried to convince me with that one.
But they did try. And it was like, "I'm not stupid", right. Yes, you can
... The GPLv3 allows you to say "Ok, Tivoization is not an issue for us".
But it allows somebody else to take the project, and say "Hey, I ... The
GPLv3 without Tivoization is compatible with the full GPLv3, so I will now
make my own fork of this, and I will start doing drivers that use the full
version of version 3" And where am I stuck then? I am stuck saying "Hey I
give you the source code, and now I can't take it back your changes".
That's completely against the whole point of the license in the first
place.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;好吧，或許他們只試過對我用這套說辭，但是他們真的試過。我的反應是「我可不傻」，對吧。是的，
的確你可以…… GPLv3 允許你說「好， Tivoization 的事情對我們來說不是問題」，
但是它同時又允許別人接過這個項目，並且說「嘿，我覺得……去掉了 Tivoization 的 GPLv3
是兼容完整的 GPLv3 的，所以我可以 fork 這個項目，然後我將在自己的 fork 上用完整的
GPLv3 寫驅動。」然後我就囧了。我的困境在於說「嘿，我給了你我的源代碼，現在我卻不能拿回你對它
的修改了」。這是徹底違背了我用這個協議最初的目的了。&lt;/p&gt;
&lt;a aria-controls="2f77aec5" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#2f77aec5" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="2f77aec5"&gt;
&lt;blockquote&gt;
So the FSF was, I mean the kind of stuff that was going on behind the
scenes, ah, made me once and for all to decide to never had any thing to
do with the FSF again. So if you wanted to give money to an organization
that does good? Give it to the EFF. The FSF is full of crazy bittered
people. That's just mine opinion. Uh, actually I have ... Ah ...
I overstated that a bit, right. The FSF has a lot of nice people in it,
but some of them are bit too extreme.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;所以 FSF 是，我是說那時他們暗地裏做的那些事情，讓我當下決定永遠不再和 FSF 有任何瓜葛。
所以如果你想捐錢給一個行善的組織，那就捐給 EFF 吧。FSF 充滿了瘋狂難處的人。這只是我的觀點。
呃其實我……嗯……我說得有點過分了。FSF 裏有很多不錯的人，不過其中有些人有點過激。&lt;/p&gt;
&lt;a aria-controls="51874275" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#51874275" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="51874275"&gt;
&lt;blockquote&gt;
Q: Well I wish the EFF care more about software freedom. But, uh,
can you ... Do you think that Tivoization benefits me as a user somehow?&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;問: 嗯我也希望 EFF 能更多的關注於軟件的自由方面。但是你能……你覺得 Tivoization
這種行爲也能在某種方式上讓我作爲用戶獲益麼？&lt;/p&gt;
&lt;a aria-controls="489be787" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#489be787" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="489be787"&gt;
&lt;blockquote&gt;
L: No, no I don't. I mean that ... But that was never my argument. That
was not why I selected the GPLv2. This is my whole point. It's not that
I think Tivoization is necessarily something that you should strive for.
But it is something that in my world view, it's your decision.
If you make hardware that locks down the software, that's your decision
as a hardware maker. That has no impact on my decision as a software maker
to give you the software. Do you see where I am coming from? I don't like
the locked down hardware, but at the same time that was never the social
contract I intended with Linux.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;L: 不，我不覺得。我的意思是……這從來都不是我的論據，這不是我選擇了 GPLv2 的理由。
並不是說我覺得 Tivoization 是某種值得你去爭取的權利，而是說在我的世界觀中，這是你的決定。
如果你生產硬件去鎖住了其中的軟件，這是你作爲一個硬件提供者的決定。
這完全不影響我作爲一個軟件提供者給你軟件的決定。你能看出我的立場在哪兒了麼？
我不喜歡上鎖的硬件，但是同時這也從來不是我想要給 Linux 加上的的社會契約。&lt;/p&gt;
&lt;a aria-controls="d4934e2e" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#d4934e2e" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="d4934e2e"&gt;
&lt;blockquote&gt;
To me, umm, I mean, people may or may not
realize GPLv2 wasn't even the first license for Linux.
To me the important part was always "I give you software, you can do
whatever you want with it. If you making improvements, you have to give
them back." That was the first version of the license. It also had a
completely broken clause which was completely insane and I was stupid.
Hey it happened. My origin license says that you can't make money
change hands. And that was a mistake. That was clearly just wrong and bad
because it really didn't have anything to do with what I wanted. But I
was young, I was poor, I didn't realize that the whole money thing wasn't
the important part. And I have saw the errors in my ways, I saw the GPLv2
and said "Hey, that's the perfect license". And I saw the GPLv3 and I said
"No, that's overreaching a lot, that's not what I wanted". And so I made
Linux GPLv2 only, right.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;對我來說，呃我想說，大家可能知道或者不知道， GPLv2 並不是 Linux 的最初的協議。
對我來說重要的部分一直是「我給你軟件，你可以用它做任何你想要做的事情。如果你做了任何改進，
你需要把它交還給我。」這是協議最初的樣子。最早的協議還有一條完全錯誤的條款，寫得完全不合理，
那時我很傻。嘿我也傻過。我最初的協議說你不能用它賺錢。這是失策，這明顯是不對的不好的，
因爲它和我真正想要做的事情沒有任何關係。但是那時我很傻很天真，
我沒意識到錢的事情在其中完全不重要。然後我發現了其中的問題，我看到了 GPLv2 然後說「嘿，
這是個完美的協議」。然後我看到了 GPLv3 我說「不，這做得過分了，這不是我想要的」
所以我讓 Linux 成爲了僅限 GPLv2 ，對吧。&lt;/p&gt;
&lt;a aria-controls="9e4f3a4f" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#9e4f3a4f" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="9e4f3a4f"&gt;
&lt;blockquote&gt;
Q: So do you think getting the patches back is as useful even if you can't
modify the device that it is used on?&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;問: 所以你是否認爲，即使你不能修改跑着這個軟件的設備，拿回對軟件的修改也還是同樣重要的？&lt;/p&gt;
&lt;a aria-controls="1eafb32a" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#1eafb32a" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="1eafb32a"&gt;
&lt;blockquote&gt;
L: Yeah, absolutely. And I mean TiVo itself is actually an example of this.
Their patches were kind of crafty but I mean they were basically running
on a, originally a fairly standard MIPS thing. And their patches were
working around bugs in the chipsets they used. And they were valid patches.
The fact that they then felt that their hardware had to be locked down
someway. I didn't like it. But as I have mentioned, I felt that that was
their decision.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;L: 是的，當然。我想說 TiVo 它自己實際上就是一個例子。他們的修改有點複雜，但是我想說他們基本
是，一開始基本是運行在一套相當標準的 MIPS 設備上。然後他們的修改是想繞開他們用到的芯片上的
一些問題，並且這些是合格的修改。之後的事情是他們覺得他們需要鎖住他們的硬件，我不喜歡這個。
但是就像我已經說的，我覺得這是他們的決定。&lt;/p&gt;
&lt;a aria-controls="93f9460e" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#93f9460e" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="93f9460e"&gt;
&lt;blockquote&gt;
And they had real reasons for that. That's something people sometimes
missed. There are sometimes reasons to do what TiVo did. Sometimes it's
imposed on you by, wireless carriers. Sometimes it's imposed on you by
Disney. Uh sometimes it's imposed on you by laws. The GPLv3 actually
accepts the last one when it comes to things like medical equipment
I think. But the point is that the whole Tivoization thing is, sometimes
it's, there is a reason for it. And if you make ... I mean I am not a
hardware designer. I think FPGA and stuff like that is really cool.
But I always ... I mean I really don't want to impose my world view on
anybody else. You don't have to use Linux. If you do use Linux, the only
thing I asked for is source code back. And there is all these other
verbiages in the GPLv2 about exact details, those aren't important.
And that was always my standpoint.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;並且他們有真正的理由去這麼做。這是有時人們忽視的地方。有時是真的有理由去做 TiVo
他們做的事情。有時強加給你這種限制的是，無線運營商。有時強加給你的是迪士尼。
有時強加給你限制的甚至是法律。 GPLv3 在醫療設備之類的場合其實允許最後一種情況，我記得。
我的觀點是，整個 Tivoization 的事情有時是有理由去這麼做的。如果你生產……
我是說我不是硬件設計者，我覺得 FPGA 之類的東西很酷，但是我……我的意思是我真的不想把我對世界的
看法強加給別人。你不是非得要用 Linux ，如果你想要用 Linux
，那麼我唯一要求你做的事情是把源代碼（變更）還給我。然後在 GPLv2
中還有很多繁文縟節規定了詳細的細節，這些都不重要。這是我一直以來的觀點。&lt;/p&gt;
&lt;a aria-controls="1bed26a3" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#1bed26a3" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="1bed26a3"&gt;
&lt;blockquote&gt;
Q: Ok, well I will stop my non-point of making noise now.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;問: 好吧那我就不浪費時間了。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
譯註： 關於 &lt;a class="reference external" href="https://zh.wikipedia.org/wiki/ISC%E8%A8%B1%E5%8F%AF%E8%AD%89"&gt;ISC 協議&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
ISC 協議是一個開源軟件協議，和兩句的 BSD 協議功能相同。OpenBSD 項目選擇儘量用 ISC
協議公開他們新寫的代碼。&lt;/div&gt;
&lt;/div&gt;
&lt;a aria-controls="a8a95a78" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#a8a95a78" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="a8a95a78"&gt;
&lt;blockquote&gt;
L: I mean don't get me ... I mean I like other licenses too. I have used
like the four, emmm... Which BSD license is the acceptable one?
One of the BSD license is actually really nice. And it's actually the...
What?&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;L: 我的意思是別誤解……我也喜歡別的協議。我用過……到底是哪個 BSD 協議是可以接受的？
有一個 BSD 協議實際上非常不錯。它實際上是……什麼？&lt;/p&gt;
&lt;a aria-controls="4624145d" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#4624145d" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="4624145d"&gt;
&lt;blockquote&gt;
A: ISC&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;觀衆： ISC&lt;/p&gt;
&lt;a aria-controls="b1cbe308" aria-expanded="false" class="translate-collapse-btn" data-toggle="collapse" href="#b1cbe308" role="button"&gt;
&lt;span class="badge badge-pill badge-light"&gt;&lt;i class="fa fa-language"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/a&gt;&lt;div class="collapse" id="b1cbe308"&gt;
&lt;blockquote&gt;
L: ISC? And I actually encourage people who don't care about the giving
code back but care about the "Hey, I did something cool, please use it".
I encourage people to use the BSD license for that. And I mean the BSD
license is wonderful for that. It so happens that I thought that for my
project the giving back is equally important so I, for me BSD is bad.
But the point is &lt;strong&gt;for me&lt;/strong&gt;. The GPLv3 maybe the perfect license for what
you guys want to do. And that's fine. And then it's the license you should
use. It's just that when somebody else wrote the code you don't get that
choice.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;L: ISC？並且事實上我在鼓勵那些不在意拿回修改但是在意「嘿，我做了一個很酷的東西，請用它」。
我鼓勵這些人去用 BSD 協議做這些事情。我想說 BSD 協議在這種場合是完美的。
只是碰巧我覺得對於我的項目，拿回修改也同樣重要，所以對我而言 BSD 不好。但是重點是
&lt;strong&gt;對我而言&lt;/strong&gt; 。 GPLv3 可能對你們想要做的事情而言是完美的協議，這很好，並且這時你就應該去用
GPLv3 。只是當代碼是別人寫的時候，你沒有這個選擇權。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="Linux"></category><category term="zhihu"></category><category term="GPLv3"></category><category term="licenses"></category><category term="Linus Torvalds"></category><category term="GPL"></category><category term="FSF"></category><category term="EFF"></category></entry><entry><title>C语言中“.”与“-&gt;”有什么区别？</title><link href="//farseerfc.me/dot-and-arrow-in-c.html" rel="alternate"></link><published>2016-08-08T00:02:00+09:00</published><updated>2016-08-08T00:02:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2016-08-08:/dot-and-arrow-in-c.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="https://www.zhihu.com/question/49164544/answer/114584541"&gt;知乎&lt;/a&gt; 轉載&lt;/p&gt;
&lt;p&gt;轉載幾篇知乎上我自己的回答，因爲不喜歡知乎的排版，所以在博客裏重新排版一遍。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;原問題：C语言中“.”与“-&amp;gt;”有什么区别？&lt;/h2&gt;
&lt;p&gt;除了表达形式有些不同，功能可以说完全一样阿。那为何又要构造两个功能一样的运算符？ 效率有差异？可是现在编译器优化都那么强了，如果真是这样岂不是有些多此一举&lt;/p&gt;
&lt;hr class="docutils"/&gt;
&lt;p&gt;刚刚翻了下书，说早期的C实现无法用结构直接当作参数在函数间传递，只能用指向结构的指针在函数间进行传递！我想这应该也是最直观的原因吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;我的回答&lt;/h2&gt;
&lt;p&gt;首先 &lt;code class="code"&gt;
a-&amp;gt;b&lt;/code&gt;
 的含義是 &lt;code class="code"&gt;
(*a).b&lt;/code&gt;
 ，所以他們是不同的，不過的確 &lt;code class="code"&gt;
-&amp;gt;&lt;/code&gt;
 可以用 &lt;code class="code"&gt;
*&lt;/code&gt;
 和 &lt;code class="code"&gt;
.&lt;/code&gt;
 實現，不需要單獨一個運算符。
嗯，我這是說現代的標準化的 C 語義上來說， &lt;code class="code"&gt;
-&amp;gt;&lt;/code&gt;
 可以用 &lt;code class="code"&gt;
*&lt;/code&gt;
 和 &lt;code class="code"&gt;
.&lt;/code&gt;
 的組合實現。&lt;/p&gt;
&lt;p&gt;早期的 C 有一段時間的語義和現代的 C 的語義不太一樣。&lt;/p&gt;
&lt;p&gt;稍微有點彙編的基礎的同學可能知道，在機器碼和彙編的角度來看，不存在變量，不存在 struct …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="https://www.zhihu.com/question/49164544/answer/114584541"&gt;知乎&lt;/a&gt; 轉載&lt;/p&gt;
&lt;p&gt;轉載幾篇知乎上我自己的回答，因爲不喜歡知乎的排版，所以在博客裏重新排版一遍。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;原問題：C语言中“.”与“-&amp;gt;”有什么区别？&lt;/h2&gt;
&lt;p&gt;除了表达形式有些不同，功能可以说完全一样阿。那为何又要构造两个功能一样的运算符？ 效率有差异？可是现在编译器优化都那么强了，如果真是这样岂不是有些多此一举&lt;/p&gt;
&lt;hr class="docutils"/&gt;
&lt;p&gt;刚刚翻了下书，说早期的C实现无法用结构直接当作参数在函数间传递，只能用指向结构的指针在函数间进行传递！我想这应该也是最直观的原因吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;我的回答&lt;/h2&gt;
&lt;p&gt;首先 &lt;code class="code"&gt;
a-&amp;gt;b&lt;/code&gt;
 的含義是 &lt;code class="code"&gt;
(*a).b&lt;/code&gt;
 ，所以他們是不同的，不過的確 &lt;code class="code"&gt;
-&amp;gt;&lt;/code&gt;
 可以用 &lt;code class="code"&gt;
*&lt;/code&gt;
 和 &lt;code class="code"&gt;
.&lt;/code&gt;
 實現，不需要單獨一個運算符。
嗯，我這是說現代的標準化的 C 語義上來說， &lt;code class="code"&gt;
-&amp;gt;&lt;/code&gt;
 可以用 &lt;code class="code"&gt;
*&lt;/code&gt;
 和 &lt;code class="code"&gt;
.&lt;/code&gt;
 的組合實現。&lt;/p&gt;
&lt;p&gt;早期的 C 有一段時間的語義和現代的 C 的語義不太一樣。&lt;/p&gt;
&lt;p&gt;稍微有點彙編的基礎的同學可能知道，在機器碼和彙編的角度來看，不存在變量，不存在 struct 這種東西，只存在寄存器和一個叫做內存的大數組。&lt;/p&gt;
&lt;p&gt;所以變量，是 C 對內存地址的一個抽象，它代表了一個位置。舉個例子，C 裏面我們寫：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其實在彙編的角度來看更像是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 A 和 B 各是兩個內存地址，是指針。&lt;/p&gt;
&lt;p&gt;好，以上是基本背景。&lt;/p&gt;
&lt;p&gt;基於這個背景我們討論一下 struct 是什麼，以及 struct 的成員是什麼。
假設我們有&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;Point&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;Point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;從現代語義上講 &lt;code class="code"&gt;
p&lt;/code&gt;
 就是一個結構體對象， &lt;code class="code"&gt;
x&lt;/code&gt;
 和 &lt;code class="code"&gt;
y&lt;/code&gt;
 各是其成員，嗯。&lt;/p&gt;
&lt;p&gt;從彙編的語義上講， &lt;code class="code"&gt;
p&lt;/code&gt;
 是一個不完整的地址，或者說，半個地址，再或者說，一個指向的東西是虛構出來的地址。而 &lt;code class="code"&gt;
x&lt;/code&gt;
 和 &lt;code class="code"&gt;
y&lt;/code&gt;
 各是在 Point 結構中的地址偏移量。也就是說，必須有 &lt;code class="code"&gt;
p&lt;/code&gt;
 和 &lt;code class="code"&gt;
x&lt;/code&gt;
 或者 &lt;code class="code"&gt;
p&lt;/code&gt;
 和 &lt;code class="code"&gt;
y&lt;/code&gt;
 同時出現，才形成一個完整的地址，單獨的一個 &lt;code class="code"&gt;
p&lt;/code&gt;
 沒有意義。&lt;/p&gt;
&lt;p&gt;早期的 C 就是在這樣的模型上建立的。所以對早期的 C 而言， &lt;code class="code"&gt;
*pp&lt;/code&gt;
 沒有意義，你取得了一個 struct ，而這個 struct 不能塞在任何一個寄存器裏，編譯器和 CPU 都無法表達這個東西。&lt;/p&gt;
&lt;p&gt;這時候只有 &lt;code class="code"&gt;
p.x&lt;/code&gt;
 和 &lt;code class="code"&gt;
p.y&lt;/code&gt;
 有意義，它們有真實的地址。&lt;/p&gt;
&lt;p&gt;早期的 C 就是這樣一個看起來怪異的語義，而它更貼近機器的表達。
所以對早期的 C 而言，以下的代碼是對的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而以下代碼是錯的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因爲作爲這個賦值的目標地址表達式的一部分， &lt;code class="code"&gt;
*pp&lt;/code&gt;
 ，這個中間結果沒法直譯到機器碼。&lt;/p&gt;
&lt;p&gt;所以對早期的 C 而言，對 pp 解引用的操作，必須和取成員的偏移的操作，這兩者緊密結合起來變成一個單獨的操作，其結果纔有意義。&lt;/p&gt;
&lt;p&gt;所以早期的 C 就發明了 -&amp;gt; ，表示這兩個操作緊密結合的操作。於是纔能寫：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;pp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嗯，這就是它存在的歷史原因。
而這個歷史原因現在已經不重要了，現代的符合標準的 C 編譯器都知道 &lt;code class="code"&gt;
(*pp).x&lt;/code&gt;
 和 &lt;code class="code"&gt;
pp-&amp;gt;x&lt;/code&gt;
 是等價的了。&lt;/p&gt;
&lt;p&gt;說句題外話， C++ 裏面還發明了 &lt;code class="code"&gt;
.*&lt;/code&gt;
 和 &lt;code class="code"&gt;
-&amp;gt;*&lt;/code&gt;
 這兩個運算符（注意 &lt;code class="code"&gt;
-&amp;gt;*&lt;/code&gt;
 不是單獨的 &lt;code class="code"&gt;
-&amp;gt;&lt;/code&gt;
 和 &lt;code class="code"&gt;
*&lt;/code&gt;
 並排放的意思），關於爲什麼要發明這兩個運算符，而不能直接說 &lt;code class="code"&gt;
a -&amp;gt;* b&lt;/code&gt;
 的意思就是 &lt;code class="code"&gt;
a -&amp;gt;(*b)&lt;/code&gt;
 ，這個就作爲課堂作業吧。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C"></category><category term="zhihu"></category></entry><entry><title>關於我的Blogs</title><link href="//farseerfc.me/about-my-blogs.html" rel="alternate"></link><published>2011-09-27T02:35:00+09:00</published><updated>2011-09-27T02:35:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2011-09-27:/about-my-blogs.html</id><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;很久沒有寫過blog或者之類的東西了。這邊一直荒廢着。&lt;/p&gt;
&lt;p&gt;由於國內被牆的原因，另一個wordpress： &lt;a class="reference external" href="http://fchome.sinaapp.com/"&gt;http://fchome.sinaapp.com/&lt;/a&gt;
應該會同步更新這裏的內容。&lt;/p&gt;
&lt;p&gt;抽空寫點什麼吧。&lt;/p&gt;
</content><category term="import"></category></entry><entry><title>“…if we do this work … ” --Bill Gates</title><link href="//farseerfc.me/if-we-do-this-work.html" rel="alternate"></link><published>2011-03-14T20:34:00+09:00</published><updated>2011-03-14T20:34:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2011-03-14:/if-we-do-this-work.html</id><summary type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/716517729"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From: Bill Gates&lt;/p&gt;
&lt;p&gt;’-- Sent: Sunday, January 24, 1999 8:41 AM&lt;/p&gt;
&lt;p&gt;Jeff Westorinon; Ben Fathi ;&lt;/p&gt;
&lt;p&gt;TO: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder&lt;/p&gt;
&lt;p&gt;Subject: ACPI extensions&lt;/p&gt;
&lt;p&gt;One thing I find myself wondering about is whether we shouldn’t try and
make the "ACPI" extensions somehow Windows specific.&lt;/p&gt;
&lt;p&gt;It …&lt;/p&gt;</summary><content type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/716517729"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From: Bill Gates&lt;/p&gt;
&lt;p&gt;’-- Sent: Sunday, January 24, 1999 8:41 AM&lt;/p&gt;
&lt;p&gt;Jeff Westorinon; Ben Fathi ;&lt;/p&gt;
&lt;p&gt;TO: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder&lt;/p&gt;
&lt;p&gt;Subject: ACPI extensions&lt;/p&gt;
&lt;p&gt;One thing I find myself wondering about is whether we shouldn’t try and
make the "ACPI" extensions somehow Windows specific.&lt;/p&gt;
&lt;p&gt;It seems unfortunate if we do this work and get our partners to do the
work and the result is that &lt;strong&gt;Linux works great without having to do the work&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maybe there is no way to avoid this problem but it does bother me.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Maybe we could define the APIs so that they work well with NT and not
the others even if they are open.&lt;/p&gt;
&lt;p&gt;Or maybe we could patent something relaled to this.&lt;/p&gt;
&lt;p&gt;From:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf"&gt;http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果這就是我至今在Xen4.0上得不到ACPI 3.0的完善支持的原因，那麼我詛咒Bill Gates！&lt;/p&gt;
</content><category term="import"></category><category term="microsoft"></category><category term="linux"></category><category term="acpi"></category></entry><entry><title>[zz]“西廂計劃”原理小解</title><link href="//farseerfc.me/zz-introducing-scholarzhang.html" rel="alternate"></link><published>2010-03-17T09:40:00+09:00</published><updated>2010-03-17T09:40:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2010-03-17:/zz-introducing-scholarzhang.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;好神奇的想法，先存着，以後慢慢研究&lt;/p&gt;
&lt;p&gt;原文： &lt;a class="reference external" href="http://blog.youxu.info/2010/03/14/west-chamber/"&gt;http://blog.youxu.info/2010/03/14/west-
chamber/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;待月西廂下，迎風戶半開。隔牆花影動，疑是玉人來。&lt;/p&gt;
&lt;p&gt;最近推上最流行的一個關鍵詞是”西廂計劃”,
這個計劃名字取得很浪漫，客戶端叫做張生，對，就是西廂記裏面那個翻牆去見崔鶯鶯小姐的張生；顯然，服務器端必然叫做崔鶯鶯。客戶端的張生是最重要的部件，可以不依賴於服務端工作。因爲西廂計劃的作者只是簡要的介紹了一下原理，其他報道又語焉不詳，我當時就覺得很好奇，花了昨天一個晚上詳細讀了一下源代碼，終於知道怎麼回事了，覺得原理非常漂亮，所以寫篇文章介紹總結一下。&lt;/p&gt;
&lt;p&gt;先說大方向。大家都知道，連接被重置的本質，是因爲收到了破壞連接的一個 TCP
Reset 包。以前劍橋大學有人實驗過，客戶端和服務器都忽略 Reset,
則通信可以不受影響 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;好神奇的想法，先存着，以後慢慢研究&lt;/p&gt;
&lt;p&gt;原文： &lt;a class="reference external" href="http://blog.youxu.info/2010/03/14/west-chamber/"&gt;http://blog.youxu.info/2010/03/14/west-
chamber/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;待月西廂下，迎風戶半開。隔牆花影動，疑是玉人來。&lt;/p&gt;
&lt;p&gt;最近推上最流行的一個關鍵詞是”西廂計劃”,
這個計劃名字取得很浪漫，客戶端叫做張生，對，就是西廂記裏面那個翻牆去見崔鶯鶯小姐的張生；顯然，服務器端必然叫做崔鶯鶯。客戶端的張生是最重要的部件，可以不依賴於服務端工作。因爲西廂計劃的作者只是簡要的介紹了一下原理，其他報道又語焉不詳，我當時就覺得很好奇，花了昨天一個晚上詳細讀了一下源代碼，終於知道怎麼回事了，覺得原理非常漂亮，所以寫篇文章介紹總結一下。&lt;/p&gt;
&lt;p&gt;先說大方向。大家都知道，連接被重置的本質，是因爲收到了破壞連接的一個 TCP
Reset 包。以前劍橋大學有人實驗過，客戶端和服務器都忽略 Reset,
則通信可以不受影響。但是這個方法其實只有理論價值，因爲絕大多數服務器都不可能忽略
Reset 的 (比如 Linux, 需要 root 權限配置iptables, 而且這本身也把正常的
Reset 給忽略了)。只要服務器不忽略 Reset,
客戶端再怎麼弄都沒用，因爲服務器會停止發送數據，Reset
這條連接。所以，很多報道說西廂計劃是忽略 Reset,
我從源代碼來看應該不是這樣。在我看來，西廂計劃是利用了牆的一個可能的弱點–牆只在連接發起的時候把一個
TCP
連接加入監聽序列，如果牆認爲這個連接終止了，就會從監聽序列中去掉這條記錄，這樣，這條連接上後續的包就不會被監聽。西廂計劃就是讓牆“認爲”這個連接終止的一個絕妙的方法。只要牆認爲這個連接兩端都是死老虎，牆就不會觸發關鍵詞檢測，其後所有的數據，都不存在連接被重置的問題了。&lt;/p&gt;
&lt;p&gt;如何讓一個連接置之死地而後生，就是西廂計劃那幫黑客神奇的地方了。這也不是一日之功。
首先，這幫牛人發現，牆的是一個入侵檢測系統，把含有關鍵字的包當成一種“入侵”來對待。採取這種設計有很多好處，但缺點是入侵檢測系統可能具有的問題，牆都可能有。西廂計劃主頁上那篇著名的論文就是講這些七七八八的漏洞的。可以說處理這些七七八八的漏洞是非常困難的，迫使牆的設計者“拆東牆，補西牆”。這樣補來補去，外表看起來好像很牛逼的牆，其實有很多本質上無法簡單修補的漏洞，其中有一個致命的，就是
TCP 連接狀態的判定問題。
出於入侵檢測系統這種設計的侷限，牆沒有，也沒辦法準確判定一條 TCP
連接的狀態，而只是根據兩邊收到的數據來“推測”連接的狀態。而所有的關鍵詞檢測功能，都是基於“連接還活着”的這個推測的結果的。因爲牆的規則是在連接發起的時候開始對這條連接的檢測，在連接終止的時候停止對這條連接的檢測，所以，一旦對連接的狀態推測錯誤，把還活着的連接當成已經關閉的連接，牆就會放棄對這條連接上隨後所有的包的檢測，他們都會都透明的穿過牆的入侵檢測。&lt;/p&gt;
&lt;p&gt;上面只是想法，具體到 TCP
協議實現這一層，就要只迷惑牆，還不能觸及我要通信的服務器。最理想的情況下，在任何有效通信之前，就能讓牆出現錯誤判斷，這些，就需要對
TCP 協議有深刻理解了。西廂計劃的那幫黑客，居然真的去讀 TCP 幾百頁的
RFC，還居然就發現了方法（這裏我假設讀者都知道 TCP
的三次握手過程和序列號每次加一的規則）。
我們都知道，三次握手的時候，在收到服務器的 SYN/ACK
的時候，客戶端如果發送 ACK 並且序列號+1
就算建立連接了，但是客戶端如果發送一個序列號沒 +1 的 FIN
（表示連接終止，但是服務器知道，這時候連接還沒建立呢， FIN
這個包狀態是錯的，加上序列號也是錯的，服務器自己一判斷，就知道這個包是壞包，按照標準協議，服務器隨手丟棄了這個包）,
但這個包，過牆的時候，在牆看來，是表示連接終止的(牆是 ma de in china,
是比較山寨的，不維護連接狀態，並且，牆並沒有記下剛纔服務器出去的 SYN/ACK
的序列號，所以牆不知道序列號錯了）。所以，牆很高興的理解爲連接終止，舒了一口氣去重置其他連接了，
而這個連接，就成了殭屍，牆不管你客戶端了，而這時候，好戲纔剛剛開始。&lt;/p&gt;
&lt;p&gt;事實上，牆是雙向檢測的（或者說對每個包都檢測的），因此，對服務器和客戶端實現相同的對待方法，所以，牆不管客戶端還不行，假如服務端有關鍵詞傳給客戶端，牆還是有可能要發飆的（這裏說有可能，因爲我也不知道）。所以，最好的辦法就是，讓服務端也給牆一個終止連接的標誌就好了。可是這個說起來簡單，做起來難，怎麼能讓不受自己控制的服務器發一個自己想要的包呢？
西廂計劃的那幫黑客，再次去讀幾百頁的 RFC, 令人驚訝的發現，他們居然在 RFC
上發現了一個可以用的特性。我們上面說了，三次握手的時候，在收到 SYN/ACK
後，客戶端要給服務器發送一個序列號+1 的ACK，可是，假如我不+1呢，直接發
ACK 包給服務器。
牆已經認爲你客戶端是死老虎了，不理你了，不知道你搞什麼飛機，讓這個 ACK
過了。可是服務器一看，不對啊，你給我的不是我期待的那個序列號， RFC
上說了，TCP 包如果序列號錯了的話，就回復一個 Reset.
所以，服務器就回復了一個 Reset。這個 Reset
過牆的時候，牆一看樂了，服務器也終止連接了，好吧，兩邊都是死老虎了，我就不監聽這條連接了。而至於客戶端，這個服務器過來的
Reset 非常好識別，忽略就是。隨後，客戶端開始正確的發送 ACK,
至此，三次握手成功，真正的好戲開始，而牆則認爲客戶端和服務器都是死老虎，直接放過。所以，張生就這樣透明的過了牆。
至於過牆以後所有的事情，《西廂記》裏面都有記載，各位讀者自行買書學習。&lt;/p&gt;
&lt;p&gt;現在的西廂計劃客戶端，即“張生”模塊的防連接重置的原理就是這樣，服務器端，即鶯鶯模塊的實現也是類似的。防DNS那個，不懂
DNS
協議，所以看不懂。我猜想，因爲開發人員都是黑客，所以自然喜歡用最經得起折騰和高度定製的
Linux 開發。 現在看西廂計劃的實現，因爲依賴於 Linux 內核模塊 netfilter,
在 Linux 上如魚得水，但往其他平臺的移植可能是個亟待解決的問題。
我覺得，在其他平臺上，可以通過 libpcap 和 libnet
，在用戶態實現相同的功能，就是有點麻煩而已，有興趣的懂網絡的可以照西廂計劃原理，在家自行做出此功能；當然，全中國人民都用
Linux 最好 :)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;PS 1: 據說是西廂計劃一個作者畫的原理圖：&lt;a class="reference external" href="http://img.ly/DIi"&gt;http://img.ly/DIi&lt;/a&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;PS 2: 我對 TCP 的理解僅限於課本，如果上面的對技術的理解有錯，請大家指出。&lt;/div&gt;
&lt;div class="line"&gt;PS 3: 有些漏洞，可能是設計上本質缺陷，不是那麼容易修復的。&lt;/div&gt;
&lt;div class="line"&gt;PS 4: 除了最後一個圖，本文沒有其他相關鏈接，如需相關資料，自行Google。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="zz"></category></entry><entry><title>寫程序讓CPU佔用率保持正弦函數</title><link href="//farseerfc.me/sine-cpu.html" rel="alternate"></link><published>2008-06-02T23:27:00+09:00</published><updated>2008-06-02T23:27:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2008-06-02:/sine-cpu.html</id><summary type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/298871889"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;據說是一道微軟的面試題。如題，寫程序，讓Windows的任務管理器中的性能監視器呈現正弦曲線。&lt;/p&gt;
&lt;img alt="正弦曲線" class="align-center img-responsive" src="http://fm531.img.xiaonei.com/pic001/20080602/23/14/large_10019p67.jpg"/&gt;
&lt;img alt="正弦曲線" class="align-center img-responsive" src="http://fm541.img.xiaonei.com/pic001/20080602/23/14/large_9935o67.jpg"/&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;p&gt;潛心鑽研良久，得代碼：（java）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;sincpu&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;calcNextSleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int …&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/298871889"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;據說是一道微軟的面試題。如題，寫程序，讓Windows的任務管理器中的性能監視器呈現正弦曲線。&lt;/p&gt;
&lt;img alt="正弦曲線" class="align-center img-responsive" src="http://fm531.img.xiaonei.com/pic001/20080602/23/14/large_10019p67.jpg"/&gt;
&lt;img alt="正弦曲線" class="align-center img-responsive" src="http://fm541.img.xiaonei.com/pic001/20080602/23/14/large_9935o67.jpg"/&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;p&gt;潛心鑽研良久，得代碼：（java）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;sincpu&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;calcNextSleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sleep&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;sleepTime&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleepTime&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;yield&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;else&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleepTime&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;period&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(;;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;period&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;                &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多核CPU上測試時要注意關掉一個CPU：&lt;/p&gt;
&lt;img alt="多核CPU上測試" class="align-center img-responsive" src="http://fm411.img.xiaonei.com/pic001/20080602/23/14/large_9946k67.jpg"/&gt;
</content><category term="import"></category><category term="java"></category><category term="microsoft"></category></entry><entry><title>關於神創論的一些見解</title><link href="//farseerfc.me/some-thought-on-creationism.html" rel="alternate"></link><published>2008-05-12T11:16:00+09:00</published><updated>2008-05-12T11:16:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2008-05-12:/some-thought-on-creationism.html</id><summary type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/292274803"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到陳驫同學很有感想的一篇神創論與命運日誌，覺得近日很久沒有看到這樣的評論了。想說幾句自己的觀點。&lt;/p&gt;
&lt;p&gt;首先我認爲，神創論與宿命論沒有多少關聯，甚至進化論者相較於神創論者更容易接受宿命論的觀點。因爲神創論主張意志的存在，人所具有的個體意志與神的意志，因此在神創論者的眼中事件的結果是可以通過意志來改變的，亦即如果我從物理樓11樓跳下，那麼我就可以改變自己死亡時間的宿命。上帝的意志同樣可以左右事件的結果，也就是所謂的宿命不復存在。而進化論者不承認意志獨立於物質世界的存在，你我的思考、行爲，都受到物理學法則諸如量子力學的約束，這就引出了北大物理系教授的那句“宇宙中的一切都是可以計算的”，亦即宿命論。如我我選擇現在從物理樓上跳下，我這一行爲並不是處於個人的獨立意志，乃是想證明這一點，亦即我跳樓這一舉動是有其背後的動機與原因的，就如同計算機的輸入必然導致了輸出，宿命的必然終結於此。&lt;/p&gt;
&lt;p&gt;其次，關於事件的複雜度所導致的隨機化，在大量混沌隨機中也存在着如統計學和隨機分形學這樣的規律，並不是否認宿命的充分理由。&lt;/p&gt;
&lt;p&gt;關於神創論的合理性問題。我認爲是否相信神的存在只是一個boolean二值問題，它爲true爲false本身並不重要，重要的是確定它的取值之後得到的推論與結果。如果否認神的存在，如現代數學這樣的完美又何以存在，進化論者的解釋是事物最終會向着更好更高級的方向發展，產生現代數學乃至現代科學是發展的必然。而這種論調顯然有悖於物理中以熱力學第二定律爲首的，預言事物會隨時間推演愈發混亂的論斷。更進一步，甚至整個人類、整個生物系統的存在都是有悖於熱力學推論的現象，是某種理論只能以“小概率事件”解釋的現象。&lt;/p&gt;
&lt;p&gt;神創論的核心觀點之一，是神的唯一存在性 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/292274803"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到陳驫同學很有感想的一篇神創論與命運日誌，覺得近日很久沒有看到這樣的評論了。想說幾句自己的觀點。&lt;/p&gt;
&lt;p&gt;首先我認爲，神創論與宿命論沒有多少關聯，甚至進化論者相較於神創論者更容易接受宿命論的觀點。因爲神創論主張意志的存在，人所具有的個體意志與神的意志，因此在神創論者的眼中事件的結果是可以通過意志來改變的，亦即如果我從物理樓11樓跳下，那麼我就可以改變自己死亡時間的宿命。上帝的意志同樣可以左右事件的結果，也就是所謂的宿命不復存在。而進化論者不承認意志獨立於物質世界的存在，你我的思考、行爲，都受到物理學法則諸如量子力學的約束，這就引出了北大物理系教授的那句“宇宙中的一切都是可以計算的”，亦即宿命論。如我我選擇現在從物理樓上跳下，我這一行爲並不是處於個人的獨立意志，乃是想證明這一點，亦即我跳樓這一舉動是有其背後的動機與原因的，就如同計算機的輸入必然導致了輸出，宿命的必然終結於此。&lt;/p&gt;
&lt;p&gt;其次，關於事件的複雜度所導致的隨機化，在大量混沌隨機中也存在着如統計學和隨機分形學這樣的規律，並不是否認宿命的充分理由。&lt;/p&gt;
&lt;p&gt;關於神創論的合理性問題。我認爲是否相信神的存在只是一個boolean二值問題，它爲true爲false本身並不重要，重要的是確定它的取值之後得到的推論與結果。如果否認神的存在，如現代數學這樣的完美又何以存在，進化論者的解釋是事物最終會向着更好更高級的方向發展，產生現代數學乃至現代科學是發展的必然。而這種論調顯然有悖於物理中以熱力學第二定律爲首的，預言事物會隨時間推演愈發混亂的論斷。更進一步，甚至整個人類、整個生物系統的存在都是有悖於熱力學推論的現象，是某種理論只能以“小概率事件”解釋的現象。&lt;/p&gt;
&lt;p&gt;神創論的核心觀點之一，是神的唯一存在性，按照鄒恆明的比喻，這就如同數學中集閤中元素的的唯一性一般至關重要。數學乃至近代科學的發展，其起源在於這種對神性的探求，而不僅僅是好奇心就可以解釋的。反觀東方文化中數學的發展，開始時領先於西方科學千餘每年，但是始終作爲一種craft-oriented的實用主義學科。可以說沒有了神的唯一性支持，人們就不能確信自己能找到這樣一種完美高效的學科，只能在實用的基礎上發展其基礎算數。可以想象，沒有神的完美與唯一性，數學必將發展成現代化學或者微軟軟件這樣，龐大而充滿特例，到處都是修補與查表，怎麼會像現在的完美、簡潔與和諧。&lt;/p&gt;
&lt;p&gt;神創論者並不是將難題推與“神”然後放任不管，他們相信神是最爲理智的存在，創人時人同樣得到了神的智慧和理智，也就是神可以用人的理智來理解。&lt;/p&gt;
&lt;p&gt;引用牛頓《自然哲學的數學原理》中終章的話“太陽、恆星、行星的這個極精緻的結構不可能存在，除非通過一個有理智的和有權能的存在的設計和主宰……他不是作爲宇宙的靈魂，而是作爲一切的主宰而統治所有……”&lt;/p&gt;
&lt;p&gt;以上……&lt;/p&gt;
&lt;p&gt;(發現最近的哲理思維果然慢了不少，寫作思緒也一片混亂^_^)&lt;/p&gt;
</content><category term="import"></category><category term="creationism"></category></entry><entry><title>由記憶棒誤差故障引發的關於面向對象設計的九點思考</title><link href="//farseerfc.me/9-thoughts-about-oop-from-wrongly-insert-memory-stick.html" rel="alternate"></link><published>2007-09-20T14:38:00+09:00</published><updated>2007-09-20T14:38:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-09-20:/9-thoughts-about-oop-from-wrongly-insert-memory-stick.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;故障描述:
MMC Memory Stick Duo記憶棒未經Adapter適配器，直接插入SD Reader，致使MMC卡入SD Reader中。&lt;/p&gt;
&lt;p&gt;棧展開：
某日下午，無課。
忙於數分作業，想查詢用手機拍攝的板書照片。
取出手機中的MMC。
未經裝配Adapter，直接插入SD Reader。
(A runtime exception was thrown.)
嘗試翻轉筆記本機身，倒出MMC，未果。(rethrow)
嘗試用手指甲取出，未果。(rethrow)
考慮到有“推入反彈”機制，嘗試將MMC推入更深，反彈機制由於類型不匹配而失效，未果。(rethrow)
(The exception spread across the border of the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;故障描述:
MMC Memory Stick Duo記憶棒未經Adapter適配器，直接插入SD Reader，致使MMC卡入SD Reader中。&lt;/p&gt;
&lt;p&gt;棧展開：
某日下午，無課。
忙於數分作業，想查詢用手機拍攝的板書照片。
取出手機中的MMC。
未經裝配Adapter，直接插入SD Reader。
(A runtime exception was thrown.)
嘗試翻轉筆記本機身，倒出MMC，未果。(rethrow)
嘗試用手指甲取出，未果。(rethrow)
考慮到有“推入反彈”機制，嘗試將MMC推入更深，反彈機制由於類型不匹配而失效，未果。(rethrow)
(The exception spread across the border of the model.)
電腦維修技師接手(catch)
技師未能發現問題所在，由我解說原委。
(Because the exception lose the information, RTTI was asked to recall the information)
技師發現問題，嘗試用鑷子鑷出MMC，未果。
技師開解機箱(expose the data structure)
技師製作鉤子，勾出MMC(hooker link to the structure)
取出MMC，故障解除&lt;/p&gt;
&lt;p&gt;故障總結
1.接收到沒有完全瞭解、或沒有適當工具解決的exception時，不要嘗試用不成熟的技術解決，應儘快尋求能解決它的代碼。否則，被反覆rethrow的exception，尤其是通過模塊邊界的exception，有可能由subclass退化爲superclass，並因此而喪失一些信息。儘量不要讓exception丟失信息，必要時，通過RTTI機制尋回信息。&lt;/p&gt;
&lt;p&gt;2.超負荷運轉，多線程執行，這種種複雜性都有可能導致錯誤，應避免。無論你有多麼信任你的代碼或能力。&lt;/p&gt;
&lt;p&gt;3.在設計class的interface時，相匹配的interface應該滿足is-a的關係。因此，任何能插入SD Reader的object，即任何實現了SD interface的object，都應該is-a SD card。這次故障中，interface接受了MMC，但MMC不是SD。即使這種情況下throw an exception，都不能使事態緩和。能提供compile-time error時，儘量讓錯誤以compile-time error的形式展現，並在事先解決。類型匹配問題是應該能在事先解決的問題。&lt;/p&gt;
&lt;p&gt;4.Design patterns中的Adapter pattern應該只是迫不得已情況之下的解決方案。只有當你無權改變現狀時，才能使用Adapter。如果能改變現狀，應該改變設計以符合interface。&lt;/p&gt;
&lt;p&gt;5.因爲上條，所有相似功能的對象應具有相同的interface，不同的interface是本次故障的根源所在。&lt;/p&gt;
&lt;p&gt;6.特殊情況下，破壞封裝機制並expose the data structure是必要的，應該有方法支持這種做法。C的指針和C#的Reflection技術都以不同的方式支持這種做法。其他的一些語言機制，比如serializing(序列化)或streaming(流化)，也可以以某種方式間接支持這一做法。當然，機制還應避免這種做法被濫用。&lt;/p&gt;
&lt;p&gt;7.相反功能具有相同操作的設計，容易造成使用的混亂，應適當避免。比如SD Reader的推入反彈設計，即插入和彈出使用同一個向裏推的操作的設計。同樣的設計還包括，C++中的setNewHandle使用同一個函數，同時設置和返回handle。以及有些書中提倡的，使用同名函數重載的方式，實現setter/getter的設計。&lt;/p&gt;
&lt;p&gt;8.特殊工具(hooker)對於解決特定問題，通常比手工解決有效。不要嫌麻煩而不願意構造特殊工具。&lt;/p&gt;
&lt;p&gt;9.棧語義，即FILO順序，總在不知不覺中影響我們。違反了FILO順序的操作極易造成混亂。本故障發生時正確的處理順序爲：
裝配Adapter
    插入SD Reader
        讀取數據
        停用設備
    拔出SD Reader
拆解Adapter
本次故障的原因就是違反了FILO順序，違反了棧語義。&lt;/p&gt;
</content><category term="import"></category><category term="oop"></category></entry><entry><title>Program Development in Java Preface</title><link href="//farseerfc.me/program-development-in-java-preface.html" rel="alternate"></link><published>2007-09-16T13:26:00+09:00</published><updated>2007-09-16T13:26:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-09-16:/program-development-in-java-preface.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;程序開發原理&lt;/h2&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;——抽象、規格與面向對象設計&lt;/h3&gt;
&lt;p&gt;Barbara Liskov 、John Guttag 著&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;楊嘉晨 等譯&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;關於翻譯風格：&lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;多年來閱讀計算機類的著作及譯作，感覺總體的困難在於一大堆沒有標準譯名的技術術語。由於通行於工業界和學術界的還是英文原名和術語，我決定保留大量的英文術語。這樣的翻譯風格借鑑於臺灣著名的譯者和作者侯捷先生。對於譯與不譯的權衡，主要考慮閱讀的流暢，以及讀者的理解能力，或許難免帶有一些主觀色彩。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="preface"&gt;
&lt;h2&gt;前言 Preface&lt;/h2&gt;
&lt;p&gt;構建產品級質量的程序——可以在很長一段時間內使用的程序——衆所周知是極其困難的。本書的目標就是改善程序員解決這項任務的效率。我希望讀者在閱讀本書之後成爲一名好程序員。我相信本書的成功在於改善編程技巧，因爲我的學生告訴我這已經發生在他們身上。&lt;/p&gt;
&lt;p&gt;怎麼纔算是一名好程序員？是產生整個程序產品的效率。關鍵是要在每一階段減少浪費掉的努力。解決的方法包括：在開始編寫代碼之前就仔細考慮你的實現方案，通過未雨綢繆的方法來編寫代碼，使用嚴格的測試在早期發現錯誤，以及仔細注意模塊化編程，這樣當錯誤出現時，只需要改動極少數代碼就可以修正整個程序。本書涉及所有這些領域的技術。&lt;/p&gt;
&lt;p&gt;模塊化編程(Modularity)是編寫好程序的關鍵。把程序分解成許多小模塊，每一個模塊通過良好定義的狹窄接口和別的模塊交互作用 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;程序開發原理&lt;/h2&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;——抽象、規格與面向對象設計&lt;/h3&gt;
&lt;p&gt;Barbara Liskov 、John Guttag 著&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;楊嘉晨 等譯&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;關於翻譯風格：&lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;多年來閱讀計算機類的著作及譯作，感覺總體的困難在於一大堆沒有標準譯名的技術術語。由於通行於工業界和學術界的還是英文原名和術語，我決定保留大量的英文術語。這樣的翻譯風格借鑑於臺灣著名的譯者和作者侯捷先生。對於譯與不譯的權衡，主要考慮閱讀的流暢，以及讀者的理解能力，或許難免帶有一些主觀色彩。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="preface"&gt;
&lt;h2&gt;前言 Preface&lt;/h2&gt;
&lt;p&gt;構建產品級質量的程序——可以在很長一段時間內使用的程序——衆所周知是極其困難的。本書的目標就是改善程序員解決這項任務的效率。我希望讀者在閱讀本書之後成爲一名好程序員。我相信本書的成功在於改善編程技巧，因爲我的學生告訴我這已經發生在他們身上。&lt;/p&gt;
&lt;p&gt;怎麼纔算是一名好程序員？是產生整個程序產品的效率。關鍵是要在每一階段減少浪費掉的努力。解決的方法包括：在開始編寫代碼之前就仔細考慮你的實現方案，通過未雨綢繆的方法來編寫代碼，使用嚴格的測試在早期發現錯誤，以及仔細注意模塊化編程，這樣當錯誤出現時，只需要改動極少數代碼就可以修正整個程序。本書涉及所有這些領域的技術。&lt;/p&gt;
&lt;p&gt;模塊化編程(Modularity)是編寫好程序的關鍵。把程序分解成許多小模塊，每一個模塊通過良好定義的狹窄接口和別的模塊交互作用(interact)。有了模塊化，可以修正一部分程序中的錯誤而不考慮程序的其他部分，而且可以僅僅理解一部分程序而不必理解整個程序。沒有模塊化，程序是一大堆有着錯綜複雜的相互關係的部分的拼湊。很難去領悟和修改這樣一個程序，同樣也很難讓它正常工作。&lt;/p&gt;
&lt;p&gt;因此本書的重點在於創建模塊化的程序：怎樣把程序組織成一系列精心挑選的模塊。本書認爲模塊化就是抽象(abstraction)。每一個模塊意味着一個抽象，比如說指引一系列文檔中的關鍵字的目錄，或者在文檔中使用目錄來查找匹配某個問題的文檔的過程。着重強調面向對象編程思想——在程序中使用數據抽象和對象的思想。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;這本書使用Java作爲它的編程示例的語言。我們沒有假定讀者已經熟悉Java。儘管可能沒什麼價值，但是本書中的思想是語言無關的，並且可以在任何語言的編程中使用。&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="how-can-the-book-be-used"&gt;
&lt;h3&gt;怎樣使用這本書？ How Can the Book Be Used&lt;/h3&gt;
&lt;p&gt;本書《程序開發原理》有兩種使用方法。其一是作爲課本教材，講述如何用面向對象的方法來設計和實現複雜系統；其二是編程專家使用，幫助他們改善編程技能，增進他們的關於模塊化和Object-Oriented(面向對象)設計的知識。&lt;/p&gt;
&lt;p&gt;作爲教材使用時，本書一般作爲第二或第三門程序設計課程。我們已經在MIT使用本書很多年，給大一大二的本科生教授第二門編程課。在這一階段，學生們已經知道怎樣編寫小程序。課程在兩方面利用這一點：讓學生更仔細地思考小程序，以及教他們如何利用小程序作爲組件構建大型程序。這本書也可以在專業（如軟件工程）後期教學中使用。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;建立在本書基礎上的課程適合於所有計算機科學專業。儘管許多學生可能永遠不會成爲真正的大型程序的設計師，他們可以在開發部門工作，在那兒他們負責設計和實現能與整個結構耦合的子系統。模塊化設計的子系統是這種任務中心，這對那些從事大型程序設計任務的人來說也同樣重要。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-is-this-book-about"&gt;
&lt;h3&gt;這本書講什麼？What Is This Book About&lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;通觀全篇三分之二的書致力於討論在構建獨立的程序模塊時產生的問題，剩下的部分討論怎樣運用這些模塊構建大型程序。&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="program-modules"&gt;
&lt;h4&gt;程序模塊Program Modules&lt;/h4&gt;
&lt;p&gt;這一部分的書集中討論抽象機制(abstraction
mechanism)。它討論procedure(子程序)和exception(異常)，數據抽象，遍歷(iteration)抽象，數據抽象系列(family)以及多態(polymorphic)抽象。&lt;/p&gt;
&lt;p&gt;在對抽象的討論中，三個步驟是重要的。首先是決定被抽象的東西到底是什麼：它提供給它的用戶哪些行爲。創造抽象是設計的關鍵，因此本書討論如何在衆多選擇中挑選，以及怎樣才能創造出好的抽象。&lt;/p&gt;
&lt;p&gt;第二步是通過爲一個抽象制定一個規格(specification)來獲取它的意義。如果沒有一些描述，一個抽象就會含糊不清，而變得沒有使用價值。specification則提供了需要的描述。本書定義了一種specification的格式，討論了一份好的specification應有的屬性，並且提供了許多示例。&lt;/p&gt;
&lt;p&gt;第三步是實現抽象。本書討論怎樣設計一份實現，以及在簡潔性和執行性能之間怎樣權衡利弊。書中強調封裝(encapsulation)的重要性以及在一份實現中履行規格中定義的行爲的重要性。書中同樣提供一些技術——尤其是不變式斷言(representation
invariant)和抽象函數(abstraction
function)——來幫助讀者理解代碼和它的原因。不變式斷言和抽象函數都實現到儘可能的程度，這對於除錯和調試很有用。&lt;/p&gt;
&lt;p&gt;關於類型層次(type
hierarchy)的材料注重討論使用它作爲抽象的技術——一種把相關聯的一組數據抽象歸入同一系列的技術。這裏很重要的一點是，是否應當將一個類型作爲另一個類型的子類。本書定義了替換原則——通過比較子類和父類的specification，來決定是否建立子類關係的方法&lt;a class="reference external" href="#_ftn1"&gt;[1]&lt;/a&gt;。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;本書同樣涉及除錯和調試。書中討論怎樣得到足夠數量的測試情況，來準備通過黑箱和白箱測試，它同樣強調了複查(regression)測試的重要性。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="programming-in-the-large"&gt;
&lt;h4&gt;編寫大型程序 Programming in the Large&lt;/h4&gt;
&lt;p&gt;本書的其後部分講解怎樣用模塊化的方法設計和實現大型程序。它建立在前文有關abstraction和specification的材料的基礎之上。&lt;/p&gt;
&lt;p&gt;編寫大型程序涵蓋四個主要議題。首先講解需求分析——怎樣才能領悟程序中需要什麼。本書討論怎樣實施需求分析，也討論書寫產生的需求規格的方式，通過使用一種描述程序的抽象階段的數據模型。使用這種模型將產生一份更爲正式的specification，同時它也使需求檢查更加嚴格，這樣可以更好的領悟需求。&lt;/p&gt;
&lt;p&gt;編寫大型程序的第二項議題是程序設計，這通常是一個循序漸進的過程。設計過程圍繞構建有用的抽象來組織，這些抽象作爲整個程序之中理想的構建組建。這些抽象在設計時被仔細的編寫規格，這樣當程序實現時，那些實現抽象的模塊可以獨立地開發。這種設計使用設計筆記編寫文檔，包括描述整個程序結構的模塊間依賴性的圖示。&lt;/p&gt;
&lt;p&gt;第三項議題是實現和測試。本書討論了前置設計分析對於實現的必要性，以及怎樣進行設計複審。它同樣討論了設計和實現的順序。這一部分比較了自頂而下與自底而上的組織方式，討論如何使用驅動程序和佔位程序&lt;a class="reference external" href="#_ftn2"&gt;[2]&lt;/a&gt;(stub)，並且強調了制定一個事先的順序策略的必要性，以滿足開發組織和客戶的需求。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;本書以一章設計模式(design pattern)結束。一些模式在前面的章節介紹過，比如遍歷抽象是算法的主要組建。最後的章節討論前文中沒有涉及到的模式。希望它作爲這一教材的介紹。有興趣的讀者可以繼續閱讀其它書中更完善的討論&lt;a class="reference external" href="#_ftn3"&gt;[3]&lt;/a&gt;。&lt;/div&gt;
&lt;/div&gt;
&lt;hr class="docutils"/&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref1"&gt;[1]&lt;/a&gt;
譯註：如果子類的specification包括了所有父類的specification，就是說父類的要求也是子類的要求，或者子類的要求更爲嚴格，那麼可以建立父子關係。而替換原則的說法是，對於具有父子關係的類，任何需要一個父類對象的地方，都可以替換爲一個子類對象。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref2"&gt;[2]&lt;/a&gt;
譯註：在測試某一組建時，由於其餘組建還未實現，這一組建與其餘組建的接口銜接部分無法工作。此時可以針對這一組建編寫其餘組建的佔位程序(stub)，預留出接口的銜接代碼。佔位代碼通常不做任何有價值的事情，只報告組建的銜接部位工作正常。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref3"&gt;[3]&lt;/a&gt; 譯註：作者指的是設計模式的開山之作——《Design
Patterns—Elements of Reusable Object-Oriented
Software》,作者爲設計模式界著名的“四人幫”GoF(Gang of
Four)。此書詳盡討論了三大類共23個廣泛使用的設計模式的適用範圍、依存關係、實現細節以及已有的應用領域等問題。書中以C++和Smalltalk爲示例語言，不過書中所涉及的模式適用於所有面向對象的語言。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="Java"></category></entry><entry><title>C++ Tricks 3.2 標號、goto，以及switch的實現</title><link href="//farseerfc.me/c-tricks-3-2-label-goto-and-implementation-of-switch.html" rel="alternate"></link><published>2007-09-16T13:08:00+09:00</published><updated>2007-09-16T13:08:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-09-16:/c-tricks-3-2-label-goto-and-implementation-of-switch.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h2&gt;3.2 標號、goto，以及switch的實現&lt;/h2&gt;
&lt;p&gt;goto語句及標號(label)是最古老的C語言特性，也是最早被人們拋棄的語言特性之一。像彙編語言中的jmp指令一樣，goto語句可以跳轉到同一函數體中任何標號位置：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{int i=0;&lt;/p&gt;
&lt;p&gt;Loop: //A label&lt;/p&gt;
&lt;p&gt;++i;&lt;/p&gt;
&lt;p&gt;if(i&amp;lt;10)goto Loop; //Jump to the label&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;在原始而和諧的早期Fortran和Basic時代，我們沒有if then
else，沒有for和while，甚至沒有函數的概念，一切控制結構都靠goto(帶條件的或無條件的)構件。軟件工程師將這樣的代碼稱作“意大利麪條”代碼。實踐證明這樣的代碼極容易造成混亂。&lt;/p&gt;
&lt;p&gt;自從證明了結構化的程序可以做意大利麪條做到的任何事情，人們就開始不遺餘力地推廣結構化設計思想，將goto像猛獸一般囚禁在牢籠 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h2&gt;3.2 標號、goto，以及switch的實現&lt;/h2&gt;
&lt;p&gt;goto語句及標號(label)是最古老的C語言特性，也是最早被人們拋棄的語言特性之一。像彙編語言中的jmp指令一樣，goto語句可以跳轉到同一函數體中任何標號位置：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{int i=0;&lt;/p&gt;
&lt;p&gt;Loop: //A label&lt;/p&gt;
&lt;p&gt;++i;&lt;/p&gt;
&lt;p&gt;if(i&amp;lt;10)goto Loop; //Jump to the label&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;在原始而和諧的早期Fortran和Basic時代，我們沒有if then
else，沒有for和while，甚至沒有函數的概念，一切控制結構都靠goto(帶條件的或無條件的)構件。軟件工程師將這樣的代碼稱作“意大利麪條”代碼。實踐證明這樣的代碼極容易造成混亂。&lt;/p&gt;
&lt;p&gt;自從證明了結構化的程序可以做意大利麪條做到的任何事情，人們就開始不遺餘力地推廣結構化設計思想，將goto像猛獸一般囚禁在牢籠，標號也因此消失。&lt;/p&gt;
&lt;p&gt;標號唯一散發餘熱的地方，是在switch中控制分支流程。&lt;/p&gt;
&lt;p&gt;很多人不甚瞭解switch存在的意義，認爲它只是大型嵌套if then
else結構的縮略形式，並且比if語句多了很多“不合理”的限制。如果你瞭解到switch在編譯器內部的實現機制，就不難理解強加在switch之上的諸多限制，比如case後只能跟一個編譯期整型常量，比如用break結束每一個case。首先看一個switch實例：&lt;/p&gt;
&lt;p&gt;switch (shape.getAngle())&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;case 3: cout&amp;lt;&amp;lt;”Triangle”;break;&lt;/p&gt;
&lt;p&gt;case 4: cout&amp;lt;&amp;lt;”Square”;break;&lt;/p&gt;
&lt;p&gt;case 0:case1: cout&amp;lt;&amp;lt;”Not a sharp!”;break;&lt;/p&gt;
&lt;p&gt;default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;任何程序員都可以寫出與之對應的if結構：&lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i==3) cout&amp;lt;&amp;lt;”Triangle”;&lt;/p&gt;
&lt;p&gt;else if(i==4) cout&amp;lt;&amp;lt;”Square”;&lt;/p&gt;
&lt;p&gt;else if(i==0||i==1) cout&amp;lt;&amp;lt;”Not a sharp!”;&lt;/p&gt;
&lt;p&gt;else cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;看起來這兩段代碼在語義上是完全一樣的，不是麼？&lt;/p&gt;
&lt;p&gt;不！或許代碼的執行結果完全一樣，但是就執行效率而言，switch版本的更快！&lt;/p&gt;
&lt;p&gt;要了解爲什麼switch的更快，我們需要知道編譯器是怎樣生成switch的實現代碼的：&lt;/p&gt;
&lt;p&gt;首先，保留switch之後由{}括起來的語具體，僅將其中case、default和break替換爲真正的標號：&lt;/p&gt;
&lt;p&gt;switch (getAngle(shape))&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;隨後，對於所有出現在case之後的常量，列出一張只有goto的跳轉表，其順序按case後的常量排列：&lt;/p&gt;
&lt;p&gt;goto _case_0;&lt;/p&gt;
&lt;p&gt;goto _case_1;&lt;/p&gt;
&lt;p&gt;goto _case_3;&lt;/p&gt;
&lt;p&gt;goto _case_4;&lt;/p&gt;
&lt;p&gt;然後，計算case之後的常量與跳轉表地址之間的關係，如有需要，在跳轉表中插入空缺的項目：&lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default; //因爲沒有case 2，所以插入此項以條轉到default&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt;假設一個goto語句佔用5個字節，那麼在本例中，goto的地址=case後的常量*5+100105&lt;/p&gt;
&lt;p&gt;之後，生成跳轉代碼，在其餘條件下跳轉至default，在已知範圍內按照公式跳轉，全部的實現如下：&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i&amp;lt;0||i&amp;gt;=5)goto _default;&lt;/p&gt;
&lt;p&gt;i=i*5+100105; //按照得出的公式算出跳轉地址&lt;/p&gt;
&lt;p&gt;goto i; //僞代碼，C中不允許跳轉到整數，但是彙編允許&lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default;&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;經過這樣處理整個switch結構，使得無論switch後的變量爲何值，都可以通過最多兩次跳轉到達目標代碼。相比之下if版本的代碼則採用線性的比較和跳轉，在case語句很多的情況下效率極低。&lt;/p&gt;
&lt;p&gt;由此,我們也可以知道,爲什麼case後跟的一定是編譯期整型常數，因爲編譯器需要根據這個值製作跳轉表。我們可以明白爲什麼case與case之間應該用break分隔，因爲編譯器不改變switch語句體的結構，case其本身只是一個具有語義的標號而已，要想跳出switch，就必須用break語句。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 3.1 左值右值與常量性(lvalue，rvalue &amp; constant)</title><link href="//farseerfc.me/c-tricks-3-1-lvalue-rvalue-constant.html" rel="alternate"></link><published>2007-09-16T13:07:00+09:00</published><updated>2007-09-16T13:07:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-09-16:/c-tricks-3-1-lvalue-rvalue-constant.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h2&gt;3.1 左值右值與常量性(lvalue，rvalue &amp;amp; constant)&lt;/h2&gt;
&lt;p&gt;首先要搞清楚的是，什麼是左值，什麼是右值。這裏給出左值右值的定義：&lt;/p&gt;
&lt;p&gt;1、左值是可以出現在等號(=)左邊的值，右值是隻能出現在等號右邊的值。&lt;/p&gt;
&lt;p&gt;2、左值是可讀可寫的值，右值是隻讀的值。&lt;/p&gt;
&lt;p&gt;3、左值有地址，右值沒有地址。&lt;/p&gt;
&lt;p&gt;根據左值右值的第二定義，值的左右性就是值的常量性——常量是右值，非常量是左值。比如：&lt;/p&gt;
&lt;p&gt;1=1;//Error&lt;/p&gt;
&lt;p&gt;這個複製操作在C++中是語法錯誤，MSVC給出的錯誤提示爲“error C2106: '=' :
left operand must be
l-value”，就是說’=’的左操作數必須是一個左值，而字面常數1是一個右值。可見，嚴格的區分左值右值可以從語法分析的角度找出程序的邏輯錯誤。&lt;/p&gt;
&lt;p&gt;根據第二定義，一個左值也是一個右值 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h2&gt;3.1 左值右值與常量性(lvalue，rvalue &amp;amp; constant)&lt;/h2&gt;
&lt;p&gt;首先要搞清楚的是，什麼是左值，什麼是右值。這裏給出左值右值的定義：&lt;/p&gt;
&lt;p&gt;1、左值是可以出現在等號(=)左邊的值，右值是隻能出現在等號右邊的值。&lt;/p&gt;
&lt;p&gt;2、左值是可讀可寫的值，右值是隻讀的值。&lt;/p&gt;
&lt;p&gt;3、左值有地址，右值沒有地址。&lt;/p&gt;
&lt;p&gt;根據左值右值的第二定義，值的左右性就是值的常量性——常量是右值，非常量是左值。比如：&lt;/p&gt;
&lt;p&gt;1=1;//Error&lt;/p&gt;
&lt;p&gt;這個複製操作在C++中是語法錯誤，MSVC給出的錯誤提示爲“error C2106: '=' :
left operand must be
l-value”，就是說’=’的左操作數必須是一個左值，而字面常數1是一個右值。可見，嚴格的區分左值右值可以從語法分析的角度找出程序的邏輯錯誤。&lt;/p&gt;
&lt;p&gt;根據第二定義，一個左值也是一個右值，因爲左值也可讀，而一個右值不是一個左值，因爲右值不可寫。&lt;/p&gt;
&lt;p&gt;通常情況下，聲明的變量是一個左值，除非你指定const將它變成一個右值：&lt;/p&gt;
&lt;p&gt;int lv=1;&lt;/p&gt;
&lt;p&gt;const int rv=lv;&lt;/p&gt;
&lt;p&gt;由於右值的值在程序執行期間不能改變，所以必須用另一個右值初始化它。&lt;/p&gt;
&lt;p&gt;一個普通變量只能用右值初始化，如果你想傳遞左值，必須聲明一個引用或一個指針：&lt;/p&gt;
&lt;p&gt;int &amp;amp; ref=lv;//用引用傳遞左值&lt;/p&gt;
&lt;p&gt;int * plv=&amp;amp;lv;//傳遞指針以間接傳遞左值&lt;/p&gt;
&lt;p&gt;必須用左值初始化引用，然而，可以用右值初始化常量引用：&lt;/p&gt;
&lt;p&gt;int &amp;amp; r1=1; //Error!&lt;/p&gt;
&lt;p&gt;const int &amp;amp; r2=1; //OK&lt;/p&gt;
&lt;p&gt;這實際上相當於：&lt;/p&gt;
&lt;p&gt;int _r2=1;&lt;/p&gt;
&lt;p&gt;const int &amp;amp; r2=_r2;&lt;/p&gt;
&lt;p&gt;這樣的寫法在函數體內沒什麼作用，但是在傳遞函數參數時，它可以避免潛在的(傳遞左值時的)複製操作，同時又可以接受右值。&lt;/p&gt;
&lt;p&gt;通常情況下，函數的參數和返回值都只傳回右值，除非你明確的通過引用傳遞左值。&lt;/p&gt;
&lt;p&gt;明確了左值與右值的區別，有助於我們寫函數時確定什麼時候應該有const，什麼時候不該有。比如，我們寫了一個代表數學中複數的類Complex：&lt;/p&gt;
&lt;p&gt;class Complex;&lt;/p&gt;
&lt;p&gt;然後，我們寫針對Complex的運算符重載：operator+和operator=。問題在於，參數和返回值應該是什麼類型，可選類型有四種：
Complex、const Complex、Complex&amp;amp;、const Complex&amp;amp;。&lt;/p&gt;
&lt;p&gt;對於operator+，我們不會改變參數的值，所以可以通過const
Complex&amp;amp;傳遞參數。至於返回值類型，由於int類型的加法返回右值，所以根據Do
as the ints do的原則，返回值類型爲const Complex：&lt;/p&gt;
&lt;p&gt;const Complex operator+(const Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt;對於operator=，同樣要思考這些問題。我們寫入第一個參數，所以第一個參數爲Complex&amp;amp;，我們只讀取第二個參數，所以第二個參數爲const
Complex&amp;amp;。至於返回值，還是Do as the ints
do。int的賦值返回左值，不信你可以試一試：&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;(i=1)=2;&lt;/p&gt;
&lt;p&gt;雖然比較傻，先將i賦爲1，再將其改爲2，但是這是被C++語法支持的做法，我們就理應遵守。所以返回第一個參數的左值：&lt;/p&gt;
&lt;p&gt;Complex&amp;amp; operator=(Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt;const是C++引入的語言特性，也被ANSI
C99借鑑，在經典版本的C語言中是沒有的。關於const的歷史，有幾點值得玩味。最初Bjarne
Stroustrup引入const時，可寫性是和可讀性分開的。那時使用關鍵字readonly和writeonly。這個特點被首先提交到C的ANSI標準化委員會(當時還沒有C++標準化的計劃)，但是ANSI
C標準只接受了readonly的概念，並將其命名爲const。隨後，有人發現在多線程同步的環境下，有些變量的值會在編譯器的預料之外改變，爲了防止過度優化破壞這些變量，C++又引入關鍵字violate。從語義特點來看，violate是const的反義詞，因爲const表示不會變的量，而violate表示會不按照預期自行變化的量。從語法特點而言，violate與const是極爲相似的，適用於const的一切語法規則同樣適用於violate。&lt;/p&gt;
&lt;p&gt;值的常量性可以被劃分爲兩種：編譯期常量和運行期常量。C++語法並沒有嚴格區分這兩種常量，導致了少許混亂：&lt;/p&gt;
&lt;p&gt;const int i=5;const int * pi=&amp;amp;i;&lt;/p&gt;
&lt;p&gt;const_cast&amp;lt;int&amp;amp;&amp;gt;i=1;//對於運行期常量，在需要時可以去除它的常量性&lt;/p&gt;
&lt;p&gt;int a[i];//對於編譯期常量，可以用它來指定數組大小&lt;/p&gt;
&lt;p&gt;cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;sizeof(a)/sizeof(a[0])&amp;lt;&amp;lt;*pi;&lt;/p&gt;
&lt;p&gt;這種將編譯期與運行期常量的特性混用的方法，勢必導致語義的混亂。數組a的大小最終是5，因爲採用了i的編譯期值，而不管i在運行期是否被改變了值。最後一句代碼將（有可能）輸出551，第一個i的值作爲一種優化在編譯期綁定，第二個值標明瞭a的大小，第三個值通過指針顯示地輸出i的運行期真實值。&lt;/p&gt;
&lt;p&gt;在C++的近親C#的語法中，這兩種常量被嚴格地區分開：編譯期常量由const指定，只能是內建類型變量；運行期常量由readonly指定，可以是任何類型。永遠不會改變的常量，如圓周率pi的值，應該用const聲明；而其它有可能改變的常量，皆由readonly聲明。&lt;/p&gt;
&lt;p&gt;C++中的const的特點更傾向於C#中的readonly，雖然語法上允許使用const的編譯期常量性，但正如上文所展示的，這容易造成混亂。爲了得到C#中const的語義，在C++中，我們不必迴歸惡魔#define的懷抱，可以使用所謂“匿名enum技巧”。當匿名聲明一個enum類型時，其中的枚舉值就是一個int類型的編譯期常量，比如：&lt;/p&gt;
&lt;p&gt;enum{Size=5;};&lt;/p&gt;
&lt;p&gt;int a[Size];&lt;/p&gt;
&lt;p&gt;這種使用匿名enum來聲明編譯期常量的做法，被廣泛應用於STL、boost等模板庫的實現代碼中。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.2 I386平臺的內存佈局</title><link href="//farseerfc.me/c-tricks-2-2-i386-memory-layout.html" rel="alternate"></link><published>2007-08-28T14:30:00+09:00</published><updated>2007-08-28T14:30:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks-2-2-i386-memory-layout.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.2 I386平臺的內存佈局&lt;/h2&gt;
&lt;p&gt;衆所周知，I386是32位體系結構。因此對於絕大多數I386平臺的C++編譯器而言，sizeof(int)=sizeof(long)=sizeof(void*)=4。當然C++標準對此沒有任何保證，我們也不應該試圖編寫依賴於此的代碼。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;32位指針的可尋址空間爲4GB。爲充分利用這麼大的尋址空間，也是爲了支持其它更先進的技術比如多任務技術或者動態鏈接庫技術，WinNT使用虛擬內存技術，給與每個應用程序全部4GB的內存空間。4GB的地址被一分爲二，前2GB供應用程序自己使用，後2GB由系統內核分配和管理。這2GB的內存地址，通常被劃分成3種內存區使用：&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;1 代碼及靜態數據區&lt;/h3&gt;
&lt;p&gt;由代碼加載器從動態鏈接庫鏡像(通常是exe或dll文件)加載，通常定位到鏡像文件中指定的基址開始的內存區。如果基址所在內存已被佔用，動態連接器會將代碼或數據重定向到其它可用地址。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;在C++中，靜態數據包括：名字空間(namespace)和全局(global)對象、函數的static對象、類的static數據成員 …&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.2 I386平臺的內存佈局&lt;/h2&gt;
&lt;p&gt;衆所周知，I386是32位體系結構。因此對於絕大多數I386平臺的C++編譯器而言，sizeof(int)=sizeof(long)=sizeof(void*)=4。當然C++標準對此沒有任何保證，我們也不應該試圖編寫依賴於此的代碼。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;32位指針的可尋址空間爲4GB。爲充分利用這麼大的尋址空間，也是爲了支持其它更先進的技術比如多任務技術或者動態鏈接庫技術，WinNT使用虛擬內存技術，給與每個應用程序全部4GB的內存空間。4GB的地址被一分爲二，前2GB供應用程序自己使用，後2GB由系統內核分配和管理。這2GB的內存地址，通常被劃分成3種內存區使用：&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;1 代碼及靜態數據區&lt;/h3&gt;
&lt;p&gt;由代碼加載器從動態鏈接庫鏡像(通常是exe或dll文件)加載，通常定位到鏡像文件中指定的基址開始的內存區。如果基址所在內存已被佔用，動態連接器會將代碼或數據重定向到其它可用地址。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;在C++中，靜態數據包括：名字空間(namespace)和全局(global)對象、函數的static對象、類的static數據成員。這些靜態數據由編譯器分配地址(但可能被重定向)，由靜態連接器寫入代碼文件(通常是exe或dll)的靜態數據區段。所以標準說，這些靜態數據在編譯期就已經具有地址。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stack"&gt;
&lt;h3&gt;2 棧(Stack)&lt;/h3&gt;
&lt;p&gt;棧是最常用的動態數據存儲區，所有函數的non-static對象和函數參數都在程序運行期在棧上分配內存。在數據結構中，術語“棧(Stack)”意指先進後出(FILO，First
In Last
Out)，與“隊列(Queue)”所指的FIFO相對。相對於基於堆的對象分配技術，默認使用棧的對象分配有兩點優勢：&lt;/p&gt;
&lt;p&gt;一、棧的FILO與人的思維方式相同&lt;/p&gt;
&lt;p&gt;現實生活中有許多事例都使用FILO的方式，比如人們必須先提起話筒再撥打號碼，而後掛斷電話之後再放下話筒。使用FILO的棧，可以保證事物的銷燬順序以其誕生順序相反的順序進行，不會產生在掛斷電話之前就放下話筒的尷尬。&lt;/p&gt;
&lt;p&gt;二、棧的分配管理僅需要兩個額外指針：棧頂(esp)和棧底(ebp)指針&lt;/p&gt;
&lt;p&gt;從實現的技術層面而言，棧的管理比其它動態分配技術要簡單很多。I386平臺上的動態棧管理，僅需要棧頂和棧底兩個指針。這兩個指針的存儲顯然不能放置於棧中，置於靜態數據區又有損效率。I386平臺爲管理動態棧專門預留了兩個通用寄存器變量esp與ebp，分別代表棧頂(esp,Extended
Stack Pointer)與棧底(Extended Bottom
Pointer)指針。其中的extended代表它們是32位指針，以區分16位的sp和bp寄存器。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;棧是動態存儲區的特點，表明它的內存佔用將隨着程序的運行而變化。I386平臺上WinNT將應用程序的棧置於程序空間，向下增長。程序初始化時，由操作系統將esp指向系統分配的棧空間的頂部。當程序需要在棧上分配變量時，就將esp減去變量所需字節數，這被稱作“壓棧(Push)”；隨後又要銷燬變量時，就將esp加上變量所需字節數，這被稱作“彈出(Pop)”。esp與ebp兩者之間所夾的空間，就是當前函數正在使用的棧空間。由於棧向下增長，esp(棧頂)的值總是小於ebp(棧底)的值，新分配的變量地址總是小於舊變量的地址。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="heap"&gt;
&lt;h3&gt;3 堆(Heap)和自由存儲區&lt;/h3&gt;
&lt;p&gt;棧中的變量對於分配與釋放的順序有特定要求，這在一定程度上限制了棧的適用範圍。面向對象(OO，Object
Oriented)的程序設計思想也要求能自由地控制變量的分配與銷燬。由此，現代操作系統都提供了被稱作“堆(Heap)”的自由存儲區，以允許由程序員控制的對象創建和銷燬過程。C標準庫函數malloc和free則是對操作系統提供的堆操作的封裝。C++提供的自由存儲區運算符new和delete則通常是malloc和free的又一層封裝。&lt;/p&gt;
&lt;p&gt;操作系統經由malloc和free控制對堆的訪問。堆的存儲管理技術各不相同，簡單的使用雙鏈表管理，複雜的可以比擬一個完整的文件系統。&lt;/p&gt;
&lt;p&gt;由於額外的管理需求，使用系統提供的通用分配器在堆上分配和銷燬變量的代價，無論從空間角度還是效率角度而言，都比在棧上分配對象要高昂很多。對於sizeof上百的大型對象，這樣的高昂代價還是可以接受的，但是對於sizeof只有個位數的小對象，這樣的代價通常是一個數量級的差距。正因爲這個原因，STL不使用new和delete，轉而使用分配子(alllocor)分配對象。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks</title><link href="//farseerfc.me/c-tricks.html" rel="alternate"></link><published>2007-08-28T14:28:00+09:00</published><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ Tricks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;By  FarseerFc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;從今天起，我再將在&lt;a class="reference external" href="http://firechildren.spaces.live.com/"&gt;Live
Space&lt;/a&gt;和&lt;a class="reference external" href="http://76635424.qzone.qq.com/"&gt;QQZone&lt;/a&gt;同時發表一系列文章，暫定名爲“C++Tricks”。&lt;/p&gt;
&lt;p&gt;本文旨在記錄和闡述一些本人學習C++時所得的心得、技巧。總體來看，本文涉及的內容是每一個C++程序員都應該知道的，但是很少見諸C++教材。希望對各位同仁學習C++有所幫助。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;也可以通過QQ或MSN向我索要此文的DOC版或PDF版，會比網頁上的更新的快一點。&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lexical-problems"&gt;
&lt;h2&gt;1      詞法問題(Lexical Problems)&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!139.entry"&gt;1.1 條件運算符(?:)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!140.entry"&gt;1.2 逗號運算符(,)、邏輯運算符(&amp;amp;&amp;amp;,||)與運算符重載的陷阱&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="x86"&gt;
&lt;h3&gt;2      X86體系結構&lt;/h3&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!146.entry"&gt;2.1 X86概述&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!147.entry"&gt;2.2 …&lt;/a&gt;&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ Tricks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;By  FarseerFc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;從今天起，我再將在&lt;a class="reference external" href="http://firechildren.spaces.live.com/"&gt;Live
Space&lt;/a&gt;和&lt;a class="reference external" href="http://76635424.qzone.qq.com/"&gt;QQZone&lt;/a&gt;同時發表一系列文章，暫定名爲“C++Tricks”。&lt;/p&gt;
&lt;p&gt;本文旨在記錄和闡述一些本人學習C++時所得的心得、技巧。總體來看，本文涉及的內容是每一個C++程序員都應該知道的，但是很少見諸C++教材。希望對各位同仁學習C++有所幫助。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;也可以通過QQ或MSN向我索要此文的DOC版或PDF版，會比網頁上的更新的快一點。&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lexical-problems"&gt;
&lt;h2&gt;1      詞法問題(Lexical Problems)&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!139.entry"&gt;1.1 條件運算符(?:)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!140.entry"&gt;1.2 逗號運算符(,)、邏輯運算符(&amp;amp;&amp;amp;,||)與運算符重載的陷阱&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="x86"&gt;
&lt;h3&gt;2      X86體系結構&lt;/h3&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!146.entry"&gt;2.1 X86概述&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!147.entry"&gt;2.2 I386平臺的內存佈局&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!148.entry"&gt;2.3 I386平臺C函數內部的棧分配&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!149.entry"&gt;2.4 I386平臺C函數調用邊界的棧分配&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!150.entry"&gt;2.5 I386平臺的邊界對齊(Align)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!151.entry"&gt;2.6 I386平臺C函數的可變參數表(Variable Arguments)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!152.entry"&gt;2.7 I386平臺的其它函數調用模型&lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="id6"&gt;
&lt;h5&gt;3 過程式編程&lt;/h5&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!154.entry"&gt;3.1 左值右值與常量性(lvalue，rvalue &amp;amp; constant)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!155.entry"&gt;3.2 標號、goto，以及switch的實現&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.3 I386平臺C函數內部的棧分配</title><link href="//farseerfc.me/c-tricks-2-3-i386-stack-allocation-in-c-functions.html" rel="alternate"></link><published>2007-08-28T14:28:00+09:00</published><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks-2-3-i386-stack-allocation-in-c-functions.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.3 I386平臺C函數內部的棧分配&lt;/h2&gt;
&lt;p&gt;函數使用棧來保存局部變量，傳遞函數參數。進入函數時，函數在棧上爲函數中的變量統一預留棧空間，將esp減去相應字節數。當函數執行流程途徑變量聲明語句時，如有需要就調用相應構造函數將變量初始化。當執行流程即將離開聲明所在代碼塊時，以初始化的順序的相反順序逐一調用析構函數。當執行流程離開函數體時，將esp加上相應字節數，歸還棧空間。&lt;/p&gt;
&lt;p&gt;爲了訪問函數變量，必須有方法定位每一個變量。變量相對於棧頂esp的位置在進入函數體時就已確定，但是由於esp會在函數執行期變動，所以將esp的值保存在ebp中，並事先將ebp的值壓棧。隨後，在函數體中通過ebp減去偏移量來訪問變量。以一個最簡單的函數爲例：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int a=0; //a的地址被分配爲ebp-4&lt;/p&gt;
&lt;p&gt;char c=1; //c的地址被分配爲ebp-8&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;產生的彙編代碼爲：&lt;/p&gt;
&lt;p&gt;push ebp ;將ebp壓棧&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;ebp=esp 用棧底備份棧頂指針&lt;/p&gt;
&lt;p&gt;sub …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.3 I386平臺C函數內部的棧分配&lt;/h2&gt;
&lt;p&gt;函數使用棧來保存局部變量，傳遞函數參數。進入函數時，函數在棧上爲函數中的變量統一預留棧空間，將esp減去相應字節數。當函數執行流程途徑變量聲明語句時，如有需要就調用相應構造函數將變量初始化。當執行流程即將離開聲明所在代碼塊時，以初始化的順序的相反順序逐一調用析構函數。當執行流程離開函數體時，將esp加上相應字節數，歸還棧空間。&lt;/p&gt;
&lt;p&gt;爲了訪問函數變量，必須有方法定位每一個變量。變量相對於棧頂esp的位置在進入函數體時就已確定，但是由於esp會在函數執行期變動，所以將esp的值保存在ebp中，並事先將ebp的值壓棧。隨後，在函數體中通過ebp減去偏移量來訪問變量。以一個最簡單的函數爲例：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int a=0; //a的地址被分配爲ebp-4&lt;/p&gt;
&lt;p&gt;char c=1; //c的地址被分配爲ebp-8&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;產生的彙編代碼爲：&lt;/p&gt;
&lt;p&gt;push ebp ;將ebp壓棧&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;ebp=esp 用棧底備份棧頂指針&lt;/p&gt;
&lt;p&gt;sub esp,8 ;esp-=8，爲a和c預留空間，包括邊界對齊&lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],0 ;a=0&lt;/p&gt;
&lt;p&gt;mov byte ptr[ebp-8],1 ;c=1&lt;/p&gt;
&lt;p&gt;add esp,8 ;esp+=8，歸還a和c的空間&lt;/p&gt;
&lt;p&gt;mov esp,ebp ;esp=ebp 從棧底恢復棧頂指針&lt;/p&gt;
&lt;p&gt;pop ebp ;恢復ebp&lt;/p&gt;
&lt;p&gt;ret ;返回&lt;/p&gt;
&lt;p&gt;相應的內存佈局是這樣：&lt;/p&gt;
&lt;p&gt;09992:c=1 &amp;lt;-esp&lt;/p&gt;
&lt;p&gt;09996:a=0&lt;/p&gt;
&lt;p&gt;10000:舊ebp &amp;lt;-ebp&lt;/p&gt;
&lt;p&gt;10004:……&lt;/p&gt;
&lt;p&gt;注:彙編中的pop、push、call、ret語句是棧操作指令，其功能可以用普通指令替換&lt;/p&gt;
&lt;p&gt;push ebp相當於:&lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;mov dword ptr[esp],ebp&lt;/p&gt;
&lt;p&gt;pop ebp相當於：&lt;/p&gt;
&lt;p&gt;mov ebp,dword ptr[esp]&lt;/p&gt;
&lt;p&gt;sub esp,4&lt;/p&gt;
&lt;p&gt;call fun_address相當於：&lt;/p&gt;
&lt;p&gt;push eip&lt;/p&gt;
&lt;p&gt;jmp fun_address&lt;/p&gt;
&lt;p&gt;ret相當於&lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt;帶參數的ret&lt;/p&gt;
&lt;p&gt;ret 8相當於&lt;/p&gt;
&lt;p&gt;add esp,12&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt;所有局部變量都在棧中由函數統一分配，形成了類似逆序數組的結構，可以通過指針逐一訪問。這一特點具有很多有趣性質，比如，考慮如下函數，找出其中的錯誤及其造成的結果：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i,a[10];&lt;/p&gt;
&lt;p&gt;for(i=0;i&amp;lt;=10;++i)a[i]=0;/An error occurs here!&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;這個函數中包含的錯誤，即使是C++新手也很容易發現，這是老生常談的越界訪問問題。但是這個錯誤造成的結果，是很多人沒有想到的。這次的越界訪問，並不會像很多新手預料的那樣造成一個“非法操作”消息，也不會像很多老手估計的那樣會默不作聲，而是導致一個，呃，死循環！&lt;/p&gt;
&lt;p&gt;錯誤的本質顯而易見，我們訪問了a[10]，但是a[10]並不存在。C++標準對於越界訪問只是說“未定義操作”。我們知道，a[10]是數組a所在位置之後的一個位置，但問題是，是誰在這個位置上。是i!&lt;/p&gt;
&lt;p&gt;根據前面的討論，i在數組a之前被聲明，所以在a之前分配在棧上。但是，I386上棧是向下增長的，所以，a的地址低於i的地址。其結果是在循環的最後，a[i]引用到了i自己！接下來的事情就不難預見了，a[i]，也就是i，被重置爲0，然後繼續循環的條件仍然成立……這個循環會一直繼續下去，直到在你的帳單上產生高額電費，直到耗光地球電能，直到太陽停止燃燒……呵呵，或者直到聰明的你把程序Kill了……&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.4 I386平臺C函數調用邊界的棧分配</title><link href="//farseerfc.me/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html" rel="alternate"></link><published>2007-08-28T14:28:00+09:00</published><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.4 I386平臺C函數調用邊界的棧分配&lt;/h2&gt;
&lt;p&gt;當調用一個函數時，主調函數將參數以聲明中相反的順序壓棧，然後將當前的代碼執行指針(eip)壓棧，然後跳轉到被調函數的入口點。在被調函數中，通過將ebp加上一個偏移量來訪問函數參數，以聲明中的順序(即壓棧的相反順序)來確定參數偏移量。被調函數返回時，彈出主調函數壓在棧中的代碼執行指針，跳回主調函數。再由主調函數恢復到調用前的棧。&lt;/p&gt;
&lt;p&gt;函數的返回值不同於函數參數，通過寄存器傳遞。如果返回值類型可以放入32位變量，比如int、short、char、指針等類型，通過eax寄存器傳遞。如果返回值類型是64位變量，如_int64，同過edx+eax傳遞，edx存儲高32位，eax存儲低32位。如果返回值是浮點類型，如float和double，通過專用的浮點數寄存器棧的棧頂返回。如果返回值類型是用戶自定義結構，或C++類類型，通過修改函數簽名，以引用型參數的形式傳回。&lt;/p&gt;
&lt;p&gt;同樣以最簡單的函數爲例：&lt;/p&gt;
&lt;p&gt;void f(){&lt;/p&gt;
&lt;p&gt;int i …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.4 I386平臺C函數調用邊界的棧分配&lt;/h2&gt;
&lt;p&gt;當調用一個函數時，主調函數將參數以聲明中相反的順序壓棧，然後將當前的代碼執行指針(eip)壓棧，然後跳轉到被調函數的入口點。在被調函數中，通過將ebp加上一個偏移量來訪問函數參數，以聲明中的順序(即壓棧的相反順序)來確定參數偏移量。被調函數返回時，彈出主調函數壓在棧中的代碼執行指針，跳回主調函數。再由主調函數恢復到調用前的棧。&lt;/p&gt;
&lt;p&gt;函數的返回值不同於函數參數，通過寄存器傳遞。如果返回值類型可以放入32位變量，比如int、short、char、指針等類型，通過eax寄存器傳遞。如果返回值類型是64位變量，如_int64，同過edx+eax傳遞，edx存儲高32位，eax存儲低32位。如果返回值是浮點類型，如float和double，通過專用的浮點數寄存器棧的棧頂返回。如果返回值類型是用戶自定義結構，或C++類類型，通過修改函數簽名，以引用型參數的形式傳回。&lt;/p&gt;
&lt;p&gt;同樣以最簡單的函數爲例：&lt;/p&gt;
&lt;p&gt;void f(){&lt;/p&gt;
&lt;p&gt;int i=g(1,2);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int g(int a,int b){&lt;/p&gt;
&lt;p&gt;int c=a+b；&lt;/p&gt;
&lt;p&gt;return c;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;產生的彙編代碼如下：&lt;/p&gt;
&lt;p&gt;f:&lt;/p&gt;
&lt;p&gt;push ebp ;備份ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;建立棧底&lt;/p&gt;
&lt;p&gt;sub esp,4 ;爲i分配空間&lt;/p&gt;
&lt;p&gt;mov eax,2 ;準備參數b的值2&lt;/p&gt;
&lt;p&gt;push eax ;將b壓棧&lt;/p&gt;
&lt;p&gt;mov eax,1 ;準備參數a的值1&lt;/p&gt;
&lt;p&gt;push eax ;將a壓棧&lt;/p&gt;
&lt;p&gt;call g ;調用g&lt;/p&gt;
&lt;p&gt;add esp,8 ;將a和b一起彈出，恢復調用前的棧&lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ;將返回值保存進變量i&lt;/p&gt;
&lt;p&gt;mov esp,ebp ;恢復棧頂&lt;/p&gt;
&lt;p&gt;pop ebp ;恢復棧底&lt;/p&gt;
&lt;p&gt;g:&lt;/p&gt;
&lt;p&gt;push ebp ;備份ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;建立棧底&lt;/p&gt;
&lt;p&gt;sub esp,4 ;爲局部變量c在棧中分配內存&lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp+8] ;通過ebp間接讀取參數a的值&lt;/p&gt;
&lt;p&gt;mov ebx,dword ptr[ebp+12] ;通過ebp間接讀取參數b的值&lt;/p&gt;
&lt;p&gt;add eax,ebx ;將a和b的值相加，之和存在eax中&lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ;將和存入變量c&lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp-4] ;將c作爲返回值，代碼優化後會刪除此句&lt;/p&gt;
&lt;p&gt;add esp,4 ;銷燬c的內存&lt;/p&gt;
&lt;p&gt;mov esp,ebp ;恢復棧頂&lt;/p&gt;
&lt;p&gt;pop ebp ;恢復棧底&lt;/p&gt;
&lt;p&gt;ret ;返回函數f&lt;/p&gt;
&lt;p&gt;棧的內存佈局如下：&lt;/p&gt;
&lt;p&gt;100076:c &amp;lt;- g的esp&lt;/p&gt;
&lt;p&gt;100080:f的ebp=100100 &amp;lt;- g的ebp&lt;/p&gt;
&lt;p&gt;100084:f的eip&lt;/p&gt;
&lt;p&gt;100088:a=1&lt;/p&gt;
&lt;p&gt;100092:b=2&lt;/p&gt;
&lt;p&gt;100096:i&lt;/p&gt;
&lt;p&gt;100100:舊ebp &amp;lt;-f的ebp&lt;/p&gt;
&lt;p&gt;100104:……&lt;/p&gt;
&lt;p&gt;注意在函數g的彙編代碼中，訪問函數的局部變量和訪問函數參數的區別。局部變量總是通過將ebp減去偏移量來訪問，函數參數總是通過將ebp加上偏移量來訪問。對於32位變量而言，第一個局部變量位於ebp-4，第二個位於ebp-8，以此類推，32位局部變量在棧中形成一個逆序數組；第一個函數參數位於ebp+8，第二個位於ebp+12，以此類推，32位函數參數在棧中形成一個正序數組。&lt;/p&gt;
&lt;p&gt;由於函數返回值通過寄存器返回，不需要空間分配等操作，所以返回值的代價很低。基於這個原因，舊的C語法約定，不寫明返回值類型的函數，返回值類型爲int。這一規則與現行的C++語法相違背，因爲C++中，不寫明返回值類型的函數返回值類型爲void，表示不返回值。這種語法不兼容性是爲了加強C++的類型安全，但同時也帶來了一些問題。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.5 I386平臺的邊界對齊(Align)</title><link href="//farseerfc.me/c-tricks-2-5-address-alignment.html" rel="alternate"></link><published>2007-08-28T14:28:00+09:00</published><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks-2-5-address-alignment.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h2&gt;2.5 I386平臺的邊界對齊(Align)&lt;/h2&gt;
&lt;p&gt;首先提問，既然I386上sizeof(int)==4、sizeof(char)==1，那麼如下結構(struct)A的sizeof是多少？&lt;/p&gt;
&lt;p&gt;struct A{int i;char c;};&lt;/p&gt;
&lt;p&gt;答案是sizeof(A)==8……1+5=8？&lt;/p&gt;
&lt;p&gt;呵呵，這就是I386上的邊界對齊問題。我們知道，I386上有整整4GB的地址空間，不過並不是每一個字節上都可以放置任何東西的。由於內存總線帶寬等等的技術原因，很多體系結構都要求內存中的變量被放置於某一個邊界的地址上。如果違反這個要求，重則導致停機出錯，輕則減慢運行速度。對於I386平臺而言，類型爲T的變量必須放置在sizeof(T)的整數倍的地址上，char可以隨便放置，short必須放在2的整數倍的地址上，int必須放在4的整數倍的地址上，double必須放在8的整數倍的地址上。如果違反邊界對齊要求 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h2&gt;2.5 I386平臺的邊界對齊(Align)&lt;/h2&gt;
&lt;p&gt;首先提問，既然I386上sizeof(int)==4、sizeof(char)==1，那麼如下結構(struct)A的sizeof是多少？&lt;/p&gt;
&lt;p&gt;struct A{int i;char c;};&lt;/p&gt;
&lt;p&gt;答案是sizeof(A)==8……1+5=8？&lt;/p&gt;
&lt;p&gt;呵呵，這就是I386上的邊界對齊問題。我們知道，I386上有整整4GB的地址空間，不過並不是每一個字節上都可以放置任何東西的。由於內存總線帶寬等等的技術原因，很多體系結構都要求內存中的變量被放置於某一個邊界的地址上。如果違反這個要求，重則導致停機出錯，輕則減慢運行速度。對於I386平臺而言，類型爲T的變量必須放置在sizeof(T)的整數倍的地址上，char可以隨便放置，short必須放在2的整數倍的地址上，int必須放在4的整數倍的地址上，double必須放在8的整數倍的地址上。如果違反邊界對齊要求，從內存中讀取數據必須進行兩次，然後將獨到的兩半數據拼接起來，這會嚴重影響效率。&lt;/p&gt;
&lt;p&gt;由於邊界對齊問題的要求，在計算struct的sizeof的時候，編譯器必須算入額外的字節填充，以保證每一個變量都能自然對齊。比如如下聲明的struct:&lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;實際上相當於聲明瞭這樣一個結構：&lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;char _filling1 [3];//三個字節填充，保證下一個int的對齊&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2；&lt;/p&gt;
&lt;p&gt;char _filling2 [3];//又三個字節填充&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;值得注意的是尾部的3個字節填充，這是爲了可以在一個數組中聲明WASTE變量，並且每一個都自然對齊。因爲有了這些填充，所以sizeof(WASTE)==12。這是一種浪費，因爲只要我們重新安排變量的聲明，就可以減少sizeof：&lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c1,c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;像這樣的安排，sizeof就減少到8，只有2個字節的額外填充。爲了與彙編代碼相兼容，C語言語法規定，編譯器無權擅自安排結構體內變量的佈局順序，必須從左向右逐一排列。所以，妥當安排成員順序以避免內存空間的浪費，就成了我們程序員的責任之一。一般的，總是將結構體的成員按照其sizeof從大到小排列，double在最前，char在最後，這樣總可以將結構的字節填充降至最小。&lt;/p&gt;
&lt;p&gt;C++繼承了C語言關於結構體佈局的規定，所以以上的佈局準則也適用於C++的class的成員變量。C++進一步擴展了佈局規定，同一訪問區段(private、public、protected)中的變量，編譯器無權重新排列，不過編譯器有權排列訪問區段的前後順序。基於這個規則，C++中有的程序員建議給每一個成員變量放在單獨區段，在每一個成員聲明之前都加上private:、public:、protected:標誌，這可以最大限度的利用編譯器的決策優勢。&lt;/p&gt;
&lt;p&gt;在棧中按順序分配的變量，其邊界也受到對齊要求的限制。與在結構中不同的是，棧中的變量還必須保證其後續變量無論是何種類型都可以自由對齊，所以在棧中的變量通常都有平臺相關的對齊最小值。在MSVC編譯器上，這個最小值可以由宏_INTSIZEOF(T)查詢：&lt;/p&gt;
&lt;p&gt;#define _INTSIZEOF(T) ( (sizeof(T) + sizeof(int) - 1) &amp;amp; ~(sizeof(int) -
1) )&lt;/p&gt;
&lt;p&gt;_INTSIZEOF(T)會將sizeof(T)進位到sizeof(int)的整數倍。&lt;/p&gt;
&lt;p&gt;由於在棧中分配變量使用_INTSIZEOF而不是sizeof，在棧上連續分配多個小變量(sizeof小於int的變量)會造成內存浪費，不如使用結構(struct)或數組。也就是說：&lt;/p&gt;
&lt;p&gt;char c1,c2,c3,c4;//使用16字節&lt;/p&gt;
&lt;p&gt;char c[4];//使用4字節&lt;/p&gt;
&lt;p&gt;當然，使用數組的方法在訪問數組變量(比如c[1])時有一次額外的指針運算和提領(dereference)操作，這會有執行效率的損失。這又是一種空間(內存佔用)vs時間(執行效率)的折中，需要程序員自己根據情況權衡利弊。&lt;/p&gt;
&lt;p&gt;sizeof的大小可能比我們預期的大，也可能比我們預期的小。對於空類：&lt;/p&gt;
&lt;p&gt;class Empty {};&lt;/p&gt;
&lt;p&gt;在通常情況下，sizeof(Empty)至少爲1。這是因爲C++語法規定，對於任何實體類型的兩個變量，都必須具有不同的地址。爲了符合語法要求，編譯器會給Empty加入1字節的填充。所以sizeof()的值不可能出現0的情況。可是對於以下的類聲明：&lt;/p&gt;
&lt;p&gt;class A:public Empty{vitual ~A(){}};&lt;/p&gt;
&lt;p&gt;sizeof(A)有可能是6，也有可能是5，也有可能是4！必不可少的四個字節是一個指向虛函數表的指針。一個可能有的字節是Empty的大小，這是是因爲編譯器在特定情況下會將Empty視作一個“空基類”，從而實施“空基類優化”，省掉那毫無作用的一字節填充。另一個字節是A的一字節填充，因爲從語法上講，A沒有成員聲明，理應有1字節填充，而從語義上講，編譯器給A的聲明加入了一個指向虛函數表的指針，從而A就不再是一個“空類”，是否實施這個優化，要看編譯器作者對語法措詞的理解。也就是說，sizeof也會出現4+1+1=4的情況。具體要看編譯器有沒有實施“空基類優化”和“含虛函數表的空類優化”。&lt;/p&gt;
&lt;p&gt;結構和類的空間中可能有填充的字節，這意味着填充字節中可能有數值，雖然這數值並不影響結構的邏輯狀態，但是它也可能不知不覺中影響到你。比如說，你手頭正好有一組依賴於底層硬件(比如多處理器)的函數，他們在操縱連續字節時比手動編碼要快很多，而你想充分利用這種硬件優勢：&lt;/p&gt;
&lt;p&gt;bool BitCompare(void* begin,void* end,void* another);&lt;/p&gt;
&lt;p&gt;這個函數將區間[begin,end)之間的字節與another開始的字節相比較，如果有一位不同就返回false，否則返回true。&lt;/p&gt;
&lt;p&gt;比如你想將這個函數用於你自己的類的operator==中，這樣可以利用硬件加快速度。不過你在動手前要充分考慮，你的class是否真的要比較每一位。如果在類的成員中存在編譯器填充的字節數，那麼應用以上的函數就是不正確的，因爲填充的字節中可以有不同的值。爲了保證你可以用Bitwise
Compare，你必須確保填充的字節中的值也是相同的。這不僅要求你在類的構造函數中初始化類的每一bit而不是每一個成員，也要求你在複製初始化和複製賦值函數中也同時保證bitwise
copy語義，而不是編譯器默認產生的memberwise語義。當然，你可能通過與BitCompare一同提供的BitCopy來完成這個艱鉅的任務。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.6 I386平臺C函數的可變參數表(Variable Arguments)</title><link href="//farseerfc.me/c-tricks-2-6-i386-variable-arguments.html" rel="alternate"></link><published>2007-08-28T14:28:00+09:00</published><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks-2-6-i386-variable-arguments.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h2&gt;2.6 I386平臺C函數的可變參數表(Variable Arguments)&lt;/h2&gt;
&lt;p&gt;基於前文(2.4節)分析，我們可以不通過函數簽名，直接通過指針運算，來得到函數的參數。由於參數的壓棧和彈出操作都由主調函數進行，所以被調函數對於參數的真實數量不需要知曉。因此，函數簽名中的變量聲明不是必需的。爲了支持這種參數使用形式，C語言提供可變參數表。可變參數表的語法形式是在參數表末尾添加三個句點形成的省略號“...”：&lt;/p&gt;
&lt;p&gt;void g(int a,char* c,...);&lt;/p&gt;
&lt;p&gt;省略號之前的逗號是可選的，並不影響詞法語法分析。上面的函數g可以接受2個或2個以上的參數，前兩個參數的類型固定，其後的參數類型未知，參數的個數也未知。爲了知道參數個數，我們必須通過其他方法，比如通過第一個參數傳遞：&lt;/p&gt;
&lt;p&gt;g(3,”Hello”,2,4,5);//調用g並傳遞5個參數，其中後3個爲可變參數。&lt;/p&gt;
&lt;p&gt;在函數的實現代碼中，可以通過2.4節敘述的 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h2&gt;2.6 I386平臺C函數的可變參數表(Variable Arguments)&lt;/h2&gt;
&lt;p&gt;基於前文(2.4節)分析，我們可以不通過函數簽名，直接通過指針運算，來得到函數的參數。由於參數的壓棧和彈出操作都由主調函數進行，所以被調函數對於參數的真實數量不需要知曉。因此，函數簽名中的變量聲明不是必需的。爲了支持這種參數使用形式，C語言提供可變參數表。可變參數表的語法形式是在參數表末尾添加三個句點形成的省略號“...”：&lt;/p&gt;
&lt;p&gt;void g(int a,char* c,...);&lt;/p&gt;
&lt;p&gt;省略號之前的逗號是可選的，並不影響詞法語法分析。上面的函數g可以接受2個或2個以上的參數，前兩個參數的類型固定，其後的參數類型未知，參數的個數也未知。爲了知道參數個數，我們必須通過其他方法，比如通過第一個參數傳遞：&lt;/p&gt;
&lt;p&gt;g(3,”Hello”,2,4,5);//調用g並傳遞5個參數，其中後3個爲可變參數。&lt;/p&gt;
&lt;p&gt;在函數的實現代碼中，可以通過2.4節敘述的，參數在棧中的排列順序，來訪問位於可變參數表的參數。比如:&lt;/p&gt;
&lt;p&gt;void g(int a,char* c...){&lt;/p&gt;
&lt;p&gt;void *pc=&amp;amp;c;int* pi=static_cast&amp;lt;int*&amp;gt;(pc)+1;//將pi指向首個可變參數&lt;/p&gt;
&lt;p&gt;for(int i=0;i&amp;lt;a;i++)std::cout&amp;lt;&amp;lt;pi[i]&amp;lt;&amp;lt;” ”；&lt;/p&gt;
&lt;p&gt;std::cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;std::endl;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;我們甚至可以讓一個函數的所有參數都是可變參數，只要有辦法獲知參數的數量即可。比如，我們約定，在傳遞給addAll的參數都是int，並且最後一個以0結束：&lt;/p&gt;
&lt;p&gt;int addAll(...);&lt;/p&gt;
&lt;p&gt;int a=f(1,4,2,5,7,0);&lt;/p&gt;
&lt;p&gt;那麼addAll可以這樣實現：&lt;/p&gt;
&lt;p&gt;int addAll(...){&lt;/p&gt;
&lt;p&gt;int sum=0;int *p=&amp;amp;sum; //p指向第一個局部變量&lt;/p&gt;
&lt;p&gt;p+=3; //跳過sum，ebp，eip，現在p指向第一個參數&lt;/p&gt;
&lt;p&gt;for(;*p;++p) //如果p不指向0就繼續循環&lt;/p&gt;
&lt;p&gt;sum+=*p;&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;可變參數表的最廣泛應用是C的標準庫函數中的格式化輸入輸出：printf和scanf。&lt;/p&gt;
&lt;p&gt;void printf(char *c,...);&lt;/p&gt;
&lt;p&gt;void scanf(char *c,...);&lt;/p&gt;
&lt;p&gt;兩者都通過它的首個參數指出後續參數表中的參數類型和參數數量。&lt;/p&gt;
&lt;p&gt;如果可變參數表中的參數類型不一樣，那麼操縱可變參數表就需要複雜的指針運算，並且還要時刻注意邊界對齊(align)問題，非常令人頭痛。好在C標準庫提供了用於操縱可變參數表的宏(macro)和結構(struct)，他們被定義在庫文件stdarg.h中:&lt;/p&gt;
&lt;p&gt;typedef struct {char *p;int offset;} va_list;&lt;/p&gt;
&lt;p&gt;#define va_start(valist,arg)&lt;/p&gt;
&lt;p&gt;#define va_arg(valist,type)&lt;/p&gt;
&lt;p&gt;#define va_end(valist)&lt;/p&gt;
&lt;p&gt;其中結構va_list用於指示參數在棧中的位置，宏va_start接受一個va_list和函數的可變參數表之前的參數，通過第一個參數初始化va_list中的相應數據，因此要使用stdarg.h中的宏，你的可變參數表的函數必須至少有一個具名參數。va_arg返回下一個類型爲type的參數，va_end結束可變參數表的使用。還是以上文的addAll爲例，這次寫出它的使用標準宏的版本：&lt;/p&gt;
&lt;p&gt;int addAll(int i,...)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;va_list vl; //定義一個va_list結構&lt;/p&gt;
&lt;p&gt;va_start(vl,i); //用省略號之前的參數初始化vl&lt;/p&gt;
&lt;p&gt;if(i=0)return 0; //如果第一個參數就是0，返回&lt;/p&gt;
&lt;p&gt;int sum=i; //將第一個參數加入sum&lt;/p&gt;
&lt;p&gt;for(;;){&lt;/p&gt;
&lt;p&gt;i=va_arg(vl,int); //取得下一個參數，類型是sum&lt;/p&gt;
&lt;p&gt;if(i==0)break; //如果參數是0，跳出循環&lt;/p&gt;
&lt;p&gt;sum+=i;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;va_end(vl);&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;可以看出，如果參數類型一致，使用標準庫要多些幾行代碼。不過如果參數類型不一致或者未知(printf的情況)，使用標準庫就要方便很多，因爲我們很難猜出編譯器處置邊界對齊(align)等彙編代碼的細節。使用標準庫的代碼是可以移植的，而使用上文所述的其它方法操縱可變參數表都是不可移植的，僅限於在I386平臺上使用。&lt;/p&gt;
&lt;p&gt;縱使可變參數表有使用上的便利性，它的缺陷也有很多，不可移植性和平臺依賴性只是其一，最大的問題在於它的類型不安全性。使用可變參數表就意味着編譯器不對參數作任何類型檢查，這在C中算是一言難盡的歷史遺留問題，在C++中就意味着惡魔reinterpret_cast被你喚醒。C的可變參數表是C++代碼錯誤頻發的根源之一，以至於C++標準將可變參數表列爲即將被廢除的C語言遺留特性。C++語法中的許多新特性，比如重載函數、默認參數值、模板，都可以一定程度上替代可變參數表，並且比可變參數表更加安全。&lt;/p&gt;
&lt;p&gt;可變參數表在C++中惟一值得嘉獎的貢獻，是在模板元編程(TMP)的SFINAE技術中利用可變參數表製作最差匹配重載。根據C++標準中有關函數重載決議的規則，具有可變參數表的函數總是最差匹配，編譯器在被逼無奈走頭無路時纔會選擇可變參數表。利用這一點，我們可以精心製作重載函數來提取類型信息。比如，要判斷一個通過模板傳遞來的類型是不是int：&lt;/p&gt;
&lt;p&gt;long isIntImp(int);&lt;/p&gt;
&lt;p&gt;char isIntImp(...);&lt;/p&gt;
&lt;p&gt;template&amp;lt;typename T&amp;gt;&lt;/p&gt;
&lt;p&gt;struct isInt&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;enum{value=sizeof(isIntImp(T()))==sizeof(long);}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;然後，在一個具有模板參數T的函數中，我們就可以寫&lt;/p&gt;
&lt;p&gt;if(isInt&amp;lt;T&amp;gt;::value)//...&lt;/p&gt;
&lt;p&gt;在這個(不怎麼精緻的)例子中，如果T是int，那麼isIntImp的第一個重載版本就會被選中，返回值類型就是long，這樣value就爲1。否則，編譯器只能選中第二個具有可變參數表的重載版本，返回值類型成爲char，這樣value就爲0。把它說得再明白一些，上文的代碼所表達的意思是：如果類型T是int，那它就是int，否則它就不是int，呵呵簡單吧。這種通過重載決議規則來提取類型信息的技術，在模板元編程中被稱作SFINAE，它和其它模板元編程技術被廣泛運用於STL、Boost等模板庫的開發實現之中。&lt;/p&gt;
&lt;p&gt;值得注意的是，在上文SFINAE的運用中，isIntImp並沒有出現定義而只提供了聲明，因爲我們並沒有實際調用isIntImp函數，而只是讓它參與重載決議並用sizeof判斷其返回值類型。這是C++的一個設計準則的完美體現：不需要的東西可以不出現。由於這一準則，我們避免了在C++中調用具有可變參數表的函數這一危險舉動，而僅僅利用了可變參數表在語法分析過程中的特殊地位，這種對於危險語言特性的巧妙利用是善意而無害的。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.7 I386平臺的其它函數調用模型</title><link href="//farseerfc.me/c-tricks-2-7-i386-calling-conventions.html" rel="alternate"></link><published>2007-08-28T14:28:00+09:00</published><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks-2-7-i386-calling-conventions.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.7 I386平臺的其它函數調用模型&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;上文介紹的只是I386平臺上C函數調用的標準模型，被稱作__cdecl。事實上，Microsoft Visual C++編譯器還支持其它一些函數調用模型，所有調用模型名稱皆以雙下劃線開頭，下面列出所有函數調用模型的異同：&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="cdecl"&gt;
&lt;h3&gt;1 __cdecl&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：主調函數(caller)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__cdecl明確地指出函數使用C函數調用模型，這是默認的調用模型。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stdcall"&gt;
&lt;h3&gt;2 __stdcall&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__stdcall是微軟所謂的標準調用模型。可惜的是它與__cdecl不兼容。幾乎所有的Win32API函數使用這種函數調用模型，希望在DLL之間，或者在程序和WinNT操作系統之間傳遞函數指針的函數也應該使用這種模型。與__cdecl模型的不同之處在於，__stdcall模型下由被調函數恢復堆棧。主調函數在call語句之後，不需要再加上add語句。而被調函數的ret語句則被添加一個參數，代表函數參數堆棧的長度。因此，被調函數需要明確的知曉函數參數的數量和類型，所以在__stdcall模型下不支持可變參數表，所有參數必須寫明 …&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.7 I386平臺的其它函數調用模型&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;上文介紹的只是I386平臺上C函數調用的標準模型，被稱作__cdecl。事實上，Microsoft Visual C++編譯器還支持其它一些函數調用模型，所有調用模型名稱皆以雙下劃線開頭，下面列出所有函數調用模型的異同：&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="cdecl"&gt;
&lt;h3&gt;1 __cdecl&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：主調函數(caller)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__cdecl明確地指出函數使用C函數調用模型，這是默認的調用模型。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stdcall"&gt;
&lt;h3&gt;2 __stdcall&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__stdcall是微軟所謂的標準調用模型。可惜的是它與__cdecl不兼容。幾乎所有的Win32API函數使用這種函數調用模型，希望在DLL之間，或者在程序和WinNT操作系統之間傳遞函數指針的函數也應該使用這種模型。與__cdecl模型的不同之處在於，__stdcall模型下由被調函數恢復堆棧。主調函數在call語句之後，不需要再加上add語句。而被調函數的ret語句則被添加一個參數，代表函數參數堆棧的長度。因此，被調函數需要明確的知曉函數參數的數量和類型，所以在__stdcall模型下不支持可變參數表，所有參數必須寫明。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="thiscall"&gt;
&lt;h3&gt;3 __thiscall&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)，this用ecx傳遞。&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__thiscall是VC編譯器中類的非靜態成員函數(non-static member functon)的默認調用模型。但是如果此成員函數有可變參數表，VC編譯器會使用__cdecl。和__stdcall一樣，__thiscall由被調函數恢復堆棧。比較獨特的是__thiscall會通過ecx寄存器傳遞成員函數的this指針，而__cdecl下this指針是通過在參數表最前面增加一個函數參數來傳遞的。__thiscall是VC編譯器對this指針的使用的一種優化，大大提高了面向對象程序的效率。在VC2003及之前的編譯器上__thiscall不是一個關鍵字，不能被顯式指定。但可以給成員函數顯式指定__cdecl來避免使用__thiscall。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="fastcall"&gt;
&lt;h3&gt;4 __fastcall&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)，前兩個32位函數參數放入ecx和edx中&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;快速函數調用模型，將前兩個32位函數參數放入ecx和edx中，其餘參數再逆序壓棧。使用的是和__thiscall類似的優化技術，加快函數調用，適合運用在小型inline函數上。同樣使用__stdcall形式的被調函數恢復堆棧，所以不支持可變參數表。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pascal"&gt;
&lt;h3&gt;5 __pascal&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：正序(從左至右)&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;過程式編程語言Pascal所使用的函數調用模型，由此得名。也是16位版本的Windows使用的API模型，過時的模型，現在已經廢棄且禁止使用。你會看到有些書本仍會不時提到它，所以需要注意。__pascal是正序壓棧，這與大部分I386函數模型都不相同。與__stdcall一樣，由被調者恢復堆棧，不支持可變參數表。歷史上曾有過的別名PASCAL、pascal、_pascal(單下劃線)，現在都改成了__stdcall的別名，與__pascal(雙下劃線)不同。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;6 其它函數調用模型，以及模型別名。&lt;/h3&gt;
&lt;p&gt;__syscall：操作系統內部使用的函數調用模型，由用戶模式向核心模式跳轉時使用的模型。由於用戶模式和核心模式使用不同的棧，所以沒辦法使用棧來傳遞參數，所有參數通過寄存器傳遞，這限制了參數的數量。用戶模式編程中不允許使用。&lt;/p&gt;
&lt;p&gt;__fortran：數學運算語言fortran使用的函數模型，由此得名。在C中調用由fortran編譯的函數時使用。&lt;/p&gt;
&lt;p&gt;__clrcall：微軟.Net框架使用的函數模型，託管(Managed)C++默認使用，也可以從非託管代碼調用託管函數時使用。參數在託管棧上正序(從左至右)壓棧，不使用普通棧。&lt;/p&gt;
&lt;p&gt;CALLBACK、PASCAL、WINAPI、APIENTRY、APIPRIVATE：I386平臺上是__stdcall的別名&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;WINAPIV：I386平臺上是__cdecl的別名&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;7 函數調用模型的指定&lt;/h3&gt;
&lt;p&gt;函數調用模型的指定方式和inline關鍵字的指定方式相同，事實上，inline可以被看作是C++語言內建的一種函數調用模型。唯一不同的是，聲明函數指針時，也要指明函數調用模型，而inline的指針是不能指明的，根本不存在指向inline函數的指針。比如：&lt;/p&gt;
&lt;p&gt;int CALLBACK GetVersion();&lt;/p&gt;
&lt;p&gt;int (CALLBACK * pf)()=GetVersion;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.1 X86概述</title><link href="//farseerfc.me/c-tricks-2-1-x86-architecture.html" rel="alternate"></link><published>2007-08-27T16:33:00+09:00</published><updated>2007-08-27T16:33:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-27:/c-tricks-2-1-x86-architecture.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="x86"&gt;
&lt;h2&gt;2.1   X86概述&lt;/h2&gt;
&lt;p&gt;所謂X86體系結構，是指以Intel
8086芯片爲首的芯片所沿襲的CPU結構，一些文檔中又被稱作IA32體系結構。包括的芯片有但不限於:Intel
8086至
80486，奔騰(Pentium)系列處理器1至4，賽揚系列處理器，酷睿系列處理器，以及AMD的相應型號產品。X86體系結構在早期屬於16位處理器，自80386之後擴展爲32位處理器，所以一些文檔中又把80386之後的32位處理器體系稱作I386。自Pentium4後期，AMD的Athlon64開始，I386被進一步擴充爲64位處理器，含有64位尋址能力的X86體系結構被稱作X86-64或IA32-64。總之，市售的個人電腦用CPU，除蘋果的Macintosh之外，全部採用X86體系結構芯片。&lt;/p&gt;
&lt;p&gt;在X86早期，16位的尋址能力只支持64KB(2^16=64K)內存，這顯然是不夠的。Intel採用分段尋址的方法，用4位段位+16位偏移量，提供了總共1MB(2^20=1M)的尋址能力。所以在X86的16位編程中，有兩種指針類型 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="x86"&gt;
&lt;h2&gt;2.1   X86概述&lt;/h2&gt;
&lt;p&gt;所謂X86體系結構，是指以Intel
8086芯片爲首的芯片所沿襲的CPU結構，一些文檔中又被稱作IA32體系結構。包括的芯片有但不限於:Intel
8086至
80486，奔騰(Pentium)系列處理器1至4，賽揚系列處理器，酷睿系列處理器，以及AMD的相應型號產品。X86體系結構在早期屬於16位處理器，自80386之後擴展爲32位處理器，所以一些文檔中又把80386之後的32位處理器體系稱作I386。自Pentium4後期，AMD的Athlon64開始，I386被進一步擴充爲64位處理器，含有64位尋址能力的X86體系結構被稱作X86-64或IA32-64。總之，市售的個人電腦用CPU，除蘋果的Macintosh之外，全部採用X86體系結構芯片。&lt;/p&gt;
&lt;p&gt;在X86早期，16位的尋址能力只支持64KB(2^16=64K)內存，這顯然是不夠的。Intel採用分段尋址的方法，用4位段位+16位偏移量，提供了總共1MB(2^20=1M)的尋址能力。所以在X86的16位編程中，有兩種指針類型：長指針(lp,long
pointer)和短指針(sp,short
pointer)，長指針(20位)提供整個內存空間尋址能力，短指針(16位)僅支持同一段中的尋址。在“古代”DOS及Win3.x編程過程中，兩種類型的指針，以及總共1MB的內存大小，常常把程序員們折騰得焦頭爛額。&lt;/p&gt;
&lt;p&gt;自I386之後，CPU纔開始提供32位的尋址能力。有了整整4GB(2^32=4G)的尋址空間，所有指針統一爲長指針(32位)。時至今日，我們仍可以看到微軟文檔中指針變量的lp前綴。由於內存管理的需要，分段機制被保留下來，但這一次不是因爲地址空間太小，而是因爲地址空間遠大於實際內存容量，從而採用了虛擬內存機制。&lt;/p&gt;
&lt;p&gt;在從16位結構向32位結構轉變的過程中，由於向下兼容的歷史原因，曾一度長時間出現硬件32位(I386)、軟件16位(Win3.x)的情況。同樣也是爲了兼容16位軟件，Win9x操作系統(Win95、Win98、WinME)保留了16位代碼和32位代碼。混合代碼的設計使得Win9x及其混亂和不穩定。直到完全32位內核的操作系統WinNT(以及構建於其上的Win2000，WinXP，Win2003)的出現，X86平臺上內存佈局混亂的局面才得以改善。有了從16位至32位移植的經驗和準備，現今的從32位到64位的操作系統移植顯得平穩順利很多。WinXP和WinVista系統都同時發佈了32位版本和64位版本，並且其x86-64系統都實現了對32位軟件的無縫銜接支持。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 1.2 逗號運算符(,)、邏輯運算符(&amp;&amp;,||)與運算符重載的陷阱</title><link href="//farseerfc.me/c-tricks-1-2-trap-in-comma-logical-operator.html" rel="alternate"></link><published>2007-08-22T18:06:00+09:00</published><updated>2007-08-22T18:06:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-22:/c-tricks-1-2-trap-in-comma-logical-operator.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.2   逗號運算符(,)、邏輯運算符(&amp;amp;&amp;amp;,||)與運算符重載的陷阱&lt;/h2&gt;
&lt;p&gt;很多人甚至不知道逗號(,)也是個C++運算符。與語法上要求出現的逗號(比如分隔函數參數的逗號)不同的是，出現在表達式中的逗號運算符在語義上表示多個表達式操作的連續執行，類似於分隔多語句的分號。比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt;(&lt;strong&gt;int&lt;/strong&gt;i=0,j=9;i&amp;lt;10;++i&lt;strong&gt;,&lt;/strong&gt;--j)std::cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;”+”&amp;lt;&amp;lt;j&amp;lt;&amp;lt;”=9\n”;&lt;/p&gt;
&lt;p&gt;在這句語句中，出現了兩個逗號，其中前者是語法上用來分隔聲明的變量的，並非逗號運算符，而後者則是一個逗號運算符。根據C++標準，逗號運算符的執行順序爲從左到右依次執行，返回最後一個子表達式的結果。由於只有最後一個表達式返回結果，所以對於一個語義正常的逗號表達式而言，前幾個子表達式必須具有副作用。同時，從語言的定義中也可以看出，逗號表達式對求值的順序有嚴格要求 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.2   逗號運算符(,)、邏輯運算符(&amp;amp;&amp;amp;,||)與運算符重載的陷阱&lt;/h2&gt;
&lt;p&gt;很多人甚至不知道逗號(,)也是個C++運算符。與語法上要求出現的逗號(比如分隔函數參數的逗號)不同的是，出現在表達式中的逗號運算符在語義上表示多個表達式操作的連續執行，類似於分隔多語句的分號。比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt;(&lt;strong&gt;int&lt;/strong&gt;i=0,j=9;i&amp;lt;10;++i&lt;strong&gt;,&lt;/strong&gt;--j)std::cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;”+”&amp;lt;&amp;lt;j&amp;lt;&amp;lt;”=9\n”;&lt;/p&gt;
&lt;p&gt;在這句語句中，出現了兩個逗號，其中前者是語法上用來分隔聲明的變量的，並非逗號運算符，而後者則是一個逗號運算符。根據C++標準，逗號運算符的執行順序爲從左到右依次執行，返回最後一個子表達式的結果。由於只有最後一個表達式返回結果，所以對於一個語義正常的逗號表達式而言，前幾個子表達式必須具有副作用。同時，從語言的定義中也可以看出，逗號表達式對求值的順序有嚴格要求。&lt;/p&gt;
&lt;p&gt;對求值順序有要求的，除了逗號表達式和條件表達式(參見1.1)，在C++中還有邏輯運算符(&amp;amp;&amp;amp;和||)。邏輯運算相較於數學運算和位運算而言，有個顯著的不同點：邏輯運算在計算到一半時，就有可能已經得到結果，這樣繼續運算另一半就不是必需的。對於A&amp;amp;&amp;amp;B，如果A=false，那麼無論B爲何值，整個的結果都是false；同樣的A||B，如果A=true，那麼不考慮B，結果一定是true。&lt;/p&gt;
&lt;p&gt;C++標準規定，如果邏輯運算到一半(算出A)時，就已經可以確定運算的結果，那麼就不運算剩下的另一半(B)。這種執行語義被稱作“短路”。在其它一些編程語言中，短路語義是可以選擇的：在Ada裏非短路的邏輯運算符爲and和or，短路的邏輯運算符爲and_then和or_else。但是在C++中，邏輯運算符的短路語義是語法上強制的，我們沒有非短路版本的運算符。如果確實需要非短路語義，我們總是可以通過增加一個bool中間變量加以解決。有時，短路對於保證正確執行是必須的，比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char&lt;/strong&gt;*p=getString();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(p&lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;*p)std::cout&amp;lt;&amp;lt;p;&lt;/p&gt;
&lt;p&gt;這段代碼在得到了一個字符串後，在字符串不爲空時輸出它。在C++中判斷一個字符串不爲空需要兩個步驟：判斷指針是否爲0，以及指針不爲0時判斷指針指向的內容是否爲’’。就像條件表達式中討論到的(參見1.1)，在p爲空時提領p是個極其危險的操作。邏輯運算符的短路語義則避免了這種危險。&lt;/p&gt;
&lt;p&gt;以上對逗號運算符與邏輯運算符的討論，僅限於C++標準所定義的運算符語義。爲什麼這樣說呢？這是因爲在C++中，運算符的語義是可以由程序員自行定義的，這種機制叫做運算符重載(operator
overload)。運算符重載可以將人們熟悉的運算符表達式轉換成函數調用，使編程靈活而直觀，是個方便的語言特性。不過有時運算符重載也會使人困擾，那就是當運算符重載遇到求值順序問題時。&lt;/p&gt;
&lt;p&gt;C++中，並不是所有合法運算符都可以被合法地重載。條件運算符雖然對求值順序有要求，但它並不在可重載運算符之列，所以運算符重載機制對它沒有影響。問題在於，逗號運算符和邏輯運算符都可以被合法地重載：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class&lt;/strong&gt; BadThing{/* Some Bad and Stupid Thing*/};&lt;/p&gt;
&lt;p&gt;BadThing&amp;amp; &lt;strong&gt;operator&lt;/strong&gt;,(BadThing&amp;amp;, BadThing&amp;amp;);//重載了逗號運算符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bool&lt;/strong&gt; &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(BadThing&amp;amp;, BadThing&amp;amp;);//重載了&amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;BadThing b1,b2;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(b1&amp;amp;&amp;amp;b2)b1,b2;//被替換成如下形式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(b1,b2))&lt;strong&gt;operator&lt;/strong&gt;,(b1,b2);&lt;/p&gt;
&lt;p&gt;可以看到，重載了運算符之後，對運算符的使用被替換爲相應的函數調用形式。因此，舊有的運算符的執行順序不再適用，取而代之的是函數參數的壓棧順序。&lt;/p&gt;
&lt;p&gt;根據C++標準規定，任何參數必須在進入函數之前壓棧，所以在進入&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;之前，b1、b2就會被求值，這裏不再有短路規則，任何依賴於短路語義的不知不覺間操作BadThing的代碼(可能通過模板)都會混亂。&lt;/p&gt;
&lt;p&gt;短路語義只是一個方面，更重要的在於壓棧順序。鑑於執行效率和舊代碼兼容性等細節問題，C++標準在壓棧順序上給編譯器的開發者留有很大自主性。標準的說辭是，編譯器可能以任何它覺得方便的順序將參數壓棧，從左到右，從右到左，甚至從中間到兩邊，在這一點上我們不能安全地做任何假設。在上面的例子中，編譯器生成的代碼可能先計算b1再計算b2，也可能是相反的順序。再看看編譯器的實際情況，在我試過的所有基於X86體系結構的編譯器中，參數都是以逆向壓棧，即從右到左，有悖於大多數人的閱讀習慣和直覺(別說你是來自伊斯蘭的……)。&lt;/p&gt;
&lt;p&gt;在C時代使用函數調用時，壓棧順序並不是什麼大問題，畢竟大多數人會在函數調用的邊界稍稍小心一些。但是到了C++中，事情變得有些複雜，因爲簡單如a+b的使用，就有可能被運算符重載機制替換爲函數調用。更何況有模板參與之後，我們寫代碼時不能確定對象的真實類型，也就無法預知一個運算符是否真的被重載過，唯一穩妥的方法是，假定任何有可能被重載的運算符的使用都是函數調用。&lt;/p&gt;
&lt;blockquote&gt;
&amp;lt;p style="margin:0;"&amp;gt;&lt;/blockquote&gt;
&lt;p&gt;回到上文的示例中，由於,和&amp;amp;&amp;amp;都被替換爲函數調用，程序的執行順序將成爲壓棧順序，在X86上很有可能是從右到左，與標準定義的運算符的順序正好相反。逗號運算符原本就含有“先…後…”的語義，這種顛倒的執行順序勢必造成程序和程序員的混亂。以我的經驗而言，含有&lt;strong&gt;operator&lt;/strong&gt;,的類，完全沒有辦法和STL或者iostream相互協作，反而會導致巨量的錯誤報告(什麼叫巨量的錯誤報告有概念麼？如果沒有，那說明你還沒玩過範式編程(GP,
Generic
Programming)。去玩玩GP吧，看看你的編譯器對巨量的定義。在我手頭，針對3.5KB的代碼文件傾瀉出3.8&lt;strong&gt;MB&lt;/strong&gt;的錯誤信息的編譯器不在少數……)。有鑑於此，我的結論是，除非你有充足的依據支持你這麼做(比如你的粗暴上司的鍵盤上只剩下逗號能用)，並且你清楚的瞭解這麼做的後果的嚴重性(比如至少要看過此文)，否則我奉勸你，永遠不要碰&lt;strong&gt;operator&lt;/strong&gt;,、&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;以及&lt;strong&gt;operator&lt;/strong&gt;||！&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 1.1 條件運算符(?:)</title><link href="//farseerfc.me/c-tricks-1-1-conditional-operator.html" rel="alternate"></link><published>2007-08-22T18:05:00+09:00</published><updated>2007-08-22T18:05:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-22:/c-tricks-1-1-conditional-operator.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.1   條件運算符(?:)&lt;/h2&gt;
&lt;p&gt;條件運算符(?:)是C++中唯一的三目運算符(trinary
operator)，用於在表達式中作條件判斷，通常可以替換if語句，與Visual
Basic中的iif函數、Excel中的if函數有同樣的作用。語法形式如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;condition&lt;/em&gt; ? &lt;em&gt;true_value&lt;/em&gt; : &lt;em&gt;false_value&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;em&gt;condition
*條件是任何可以轉換爲bool類型的表達式，包括但不僅限於**bool*&lt;/em&gt;、&lt;strong&gt;int&lt;/strong&gt;、指針。與&lt;strong&gt;if&lt;/strong&gt;和&lt;strong&gt;while&lt;/strong&gt;的條件部分稍顯不同的是，這裏不能定義變量，否則會導致語法錯誤。&lt;/p&gt;
&lt;p&gt;另外，條件語句會切實地控制執行流程，而不僅僅是控制返回值。也就是說，兩個返回值表達式中永遠只有一個會被求值，在表達式的執行順序很重要時，這點尤爲值得注意。比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=pi …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.1   條件運算符(?:)&lt;/h2&gt;
&lt;p&gt;條件運算符(?:)是C++中唯一的三目運算符(trinary
operator)，用於在表達式中作條件判斷，通常可以替換if語句，與Visual
Basic中的iif函數、Excel中的if函數有同樣的作用。語法形式如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;condition&lt;/em&gt; ? &lt;em&gt;true_value&lt;/em&gt; : &lt;em&gt;false_value&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;em&gt;condition
*條件是任何可以轉換爲bool類型的表達式，包括但不僅限於**bool*&lt;/em&gt;、&lt;strong&gt;int&lt;/strong&gt;、指針。與&lt;strong&gt;if&lt;/strong&gt;和&lt;strong&gt;while&lt;/strong&gt;的條件部分稍顯不同的是，這裏不能定義變量，否則會導致語法錯誤。&lt;/p&gt;
&lt;p&gt;另外，條件語句會切實地控制執行流程，而不僅僅是控制返回值。也就是說，兩個返回值表達式中永遠只有一個會被求值，在表達式的執行順序很重要時，這點尤爲值得注意。比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=pi&lt;strong&gt;?&lt;/strong&gt;*pi&lt;strong&gt;:&lt;/strong&gt;0;&lt;/p&gt;
&lt;p&gt;這裏，只有當pi的值不爲0時，它纔會被提領(dereference)。這種語義保證了程序的正確性，因爲提領一個空指針將導致致命的運行期錯誤(通常是非法操作的警告)。同時，正因爲條件運算符控制運算流程的特點，使得它不能用類似iif的普通函數來模擬：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; iif(&lt;strong&gt;int&lt;/strong&gt; con,&lt;strong&gt;int&lt;/strong&gt; t,&lt;strong&gt;int&lt;/strong&gt;f){&lt;strong&gt;if&lt;/strong&gt;(c)&lt;strong&gt;return&lt;/strong&gt; t;&lt;strong&gt;return&lt;/strong&gt; f;}//試圖模擬?:&lt;/p&gt;
&lt;p&gt;…//in some function&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=iif(pi,*pi,0);//Error!&lt;/p&gt;
&lt;p&gt;這段代碼會導致上文提到的致命運行期錯誤。C/C++標準規定，參數在被傳遞給函數之前求值，因此無論pi爲何值，都會被提領。又因爲函數傳回一個空指針的情況比較少見，所以這樣的錯誤在調試時很難被發現，一旦發生又勢必造成重大災難。這樣的代碼在實踐中應儘量避免。&lt;/p&gt;
&lt;p&gt;有時，條件運算符控制流程的特點會不知不覺影響我們的代碼。在C時代，最大值MAX通常用宏實現：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#define&lt;/strong&gt;MAX(a,b) ((a)&amp;gt;(b)&lt;strong&gt;?&lt;/strong&gt;(a)&lt;strong&gt;:&lt;/strong&gt;(b))&lt;/p&gt;
&lt;p&gt;需要用額外的括號將宏參數和宏本體保護起來，以免運算符優先級擾亂邏輯，這是宏醜陋的特點之一，這裏暫且不提。矛盾在於，用具有副作用的表達式調用宏時，會出現問題：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=5,j=6;//…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=MAX(++i,++j);&lt;/p&gt;
&lt;p&gt;代碼的作者原意顯然是想先將i,j分別遞增，再將其中較大的一個賦給a。執行這段代碼，當i=5,j=6時，a=8，知道爲什麼嗎？通過宏展開，賦值語句成這樣：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=(++i)&amp;gt;(++j)&lt;strong&gt;?&lt;/strong&gt;(++i)&lt;strong&gt;:&lt;/strong&gt;(++j);//刪除了多餘括號&lt;/p&gt;
&lt;p&gt;在判斷之前，i、j被分別自增一次，然後捨棄:之前的部分，j又被自增一次。執行之後，i=6,j=8。&lt;/p&gt;
&lt;p&gt;MAX的更正確更安全的實現，是利用模板將類型參數化。STL標準算法中就有一個這樣的工具級模版函數std::max。&lt;/p&gt;
&lt;p&gt;條件運算符是表達式而不是語句，這使得它可以出現在任何需要表達式的地方，這擴大了它的適用範圍。在那些語法上只能出現表達式而不能出現語句的地方（比如變量初始化），條件運算符有着不可替代的作用。&lt;/p&gt;
&lt;p&gt;條件運算符優於&lt;strong&gt;if&lt;/strong&gt;語句的另一個場合是“模板元編程”(TMP, Template
MetaProgramming)。在TMP這個古怪奇異的編譯期運算編程技術中，一切舊有的技術和法則被全線擊破，我們所能仰仗的工具，只有模板特化(Specialization)、&lt;strong&gt;typedef&lt;/strong&gt;s、函數聲明(無法調用它們)、以及編譯期常量運算。已經有人很深入地論證過，僅有以上這些，就已經形成了一個“圖靈完善”的計算機語言。我們可以用模板特化技術，來模擬條件分支，循環迭代等一系列複雜的語言結構。由於可以參與編譯期常量運算，條件運算符在TMP世界中很自然地扮演起重要角色。&lt;/p&gt;
&lt;p&gt;比如，給與類型T的一個變量t，我們想聲明一個緩衝區存放t和一個int，緩衝區的大小不小於sizeof(T)也不小於sizeif(int)，我們可以這樣寫：&lt;/p&gt;
&lt;p&gt;char buffer[sizeof(T)&amp;gt;sizeof(int)? sizeof(T): sizeof(int)];&lt;/p&gt;
&lt;p&gt;我們不能用一個if語句替換這個運算：&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;if(sizeof(T)&amp;gt;sizeof(int))i=sizeof(T);&lt;/p&gt;
&lt;p&gt;else i=sizeof(int);&lt;/p&gt;
&lt;p&gt;char buffer[i];//語法錯誤!&lt;/p&gt;
&lt;p&gt;原因在於數組聲明中的下標必須是一個編譯期常量，而不是一個運行期的值，條件表達式的運算可以在編譯期進行，if語句就只能在執行期執行。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>填補信仰、喚醒良知</title><link href="//farseerfc.me/filling-believings-calling-conscience.html" rel="alternate"></link><published>2006-08-07T21:36:00+09:00</published><updated>2006-08-07T21:36:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2006-08-07:/filling-believings-calling-conscience.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;填補信仰、喚醒良知&lt;/p&gt;
&lt;p&gt;我們聽盡了呼籲與號召，對於良知，我不必譴責喪失它的國人，不必盛讚良知的美好。我只想討論，喪失了良知的原因——空缺的信仰。&lt;/p&gt;
&lt;p&gt;一、空缺信仰喪失良知&lt;/p&gt;
&lt;p&gt;現代的國人缺少信仰，以至於喪失良知。曾幾何時，中華民族由良好的信仰凝聚而成。三皇五帝時，族民們以炎黃爲信仰；春秋戰國時，士大夫之族以周制禮樂爲信仰；漢代以後，百姓延習孔孟之說、老聃之道，以儒家學說爲信仰；自大唐起，以佛教爲首的現代宗教紛紛傳入中原，人民開始以它們作爲信仰。&lt;/p&gt;
&lt;p&gt;直至鴉片戰爭、五四運動，西方文化入侵中華，國人開始拋棄國學，轉而去研究科學；文化大革命，十年文化浩劫，人們批判舊的信仰，卻沒有合適的新的信仰前來填補。從此，國人的信仰出現空缺，國人的良知也被一塊塊蠶食殆盡。&lt;/p&gt;
&lt;p&gt;二、信仰、科學、迷信&lt;/p&gt;
&lt;p&gt;在許多國人的心目中，信仰就等於迷信。從小到大的教育告訴我們 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;填補信仰、喚醒良知&lt;/p&gt;
&lt;p&gt;我們聽盡了呼籲與號召，對於良知，我不必譴責喪失它的國人，不必盛讚良知的美好。我只想討論，喪失了良知的原因——空缺的信仰。&lt;/p&gt;
&lt;p&gt;一、空缺信仰喪失良知&lt;/p&gt;
&lt;p&gt;現代的國人缺少信仰，以至於喪失良知。曾幾何時，中華民族由良好的信仰凝聚而成。三皇五帝時，族民們以炎黃爲信仰；春秋戰國時，士大夫之族以周制禮樂爲信仰；漢代以後，百姓延習孔孟之說、老聃之道，以儒家學說爲信仰；自大唐起，以佛教爲首的現代宗教紛紛傳入中原，人民開始以它們作爲信仰。&lt;/p&gt;
&lt;p&gt;直至鴉片戰爭、五四運動，西方文化入侵中華，國人開始拋棄國學，轉而去研究科學；文化大革命，十年文化浩劫，人們批判舊的信仰，卻沒有合適的新的信仰前來填補。從此，國人的信仰出現空缺，國人的良知也被一塊塊蠶食殆盡。&lt;/p&gt;
&lt;p&gt;二、信仰、科學、迷信&lt;/p&gt;
&lt;p&gt;在許多國人的心目中，信仰就等於迷信。從小到大的教育告訴我們，信奉宗教是愚昧而又無知的表現，科學與信仰是矛盾的。是麼？&lt;/p&gt;
&lt;p&gt;我們無法保證社會上的每一個人都接受過良好的教育，我們無法確信最前沿的科學素養能在民衆中普及。在科普與教育力不從心的社會死角，在科學技術尚不能及的文化盲區，我們依舊需要信仰的規範與限制，我們的良知需要信仰！&lt;/p&gt;
&lt;p&gt;信仰不等於迷信。信仰本身無所謂謎與不迷，迷信是持有信仰的人誤解了信仰，盲目遵從的結果。以爲燒過香就可以免遭禍患，以爲捐了錢就可以升入天堂，以爲引火自焚就可以功德圓滿，這便是迷信了。希特勒曾經的人類完善計劃，依照遺傳學的原理，將科學家與運動員強行結爲夫婦孕育生命，希望得到最優秀的人類種族，這便是對科學這種信仰的迷信！&lt;/p&gt;
&lt;p&gt;由此可見，科學與信仰並不是矛盾的硬幣的兩面，從某種意義而言科學本身也是信仰的一種。雖然歷史上宗教往往作爲科學發展的阻礙，可信奉真理的信念一直是推動科學發展的動力。牛頓就曾說過，對自然規律的探詢是爲了更接近上帝。由此可見，信仰與真理，與良知毫無矛盾。&lt;/p&gt;
&lt;p&gt;三、信仰喚醒良知&lt;/p&gt;
&lt;p&gt;很少有人仔細思考過，良知的缺失是由信仰的缺失造成的。信仰是人思想的寄託與依靠，是人行動處世的準則。沒有了信仰的人，思想行爲就缺少了約束的標準，人就更容易因爲一時不成熟的衝動，背叛良知、鑄成錯誤。&lt;/p&gt;
&lt;p&gt;泰國人以佛教爲信仰，泰國的寺廟每天都會有成千上萬人頂禮膜拜。寺廟有一個人盡皆知的不成文規定：不得穿鞋進入。於是在寺廟之外，遊客們可以看到千百雙各式的鞋子有序的擺放在門口。國人每每看到此景，總會詫異地問：沒有人會偷鞋麼？得到的答案極爲簡單：廟前偷鞋會遭報應。由於擁有信仰，泰國人作了壞事會受到良知的譴責，泰國商人售出假貨會徹夜難眠。二戰期間，無數猶太難民被天主教會收留藏匿從而僥倖逃生，這同樣是出於，天主教徒們被自己信奉的教義“衆生生來平等”，所喚醒的良知。&lt;/p&gt;
&lt;p&gt;天下無賊的世界，不能僅靠科普說教來營造。如果脫離了信仰，縱使是教育也無法培養良知。我問過許多修化學的同學，學習化學的意義，結論竟是爲了考試。如果沒有對科學的信仰，我們可以牢記公式定理，卻質疑它們是真理；如果沒有對社會公德的信仰，我們可以熟背交通規則，卻正大光明地闖紅燈；如果沒有對醫療道德的信仰，醫生可以放任傷口發炎，從而留住病人繼續治療……&lt;/p&gt;
&lt;p&gt;國人需要信仰的約束，需要填補信仰的空白，從而喚醒那深埋於每個國人內心深處的良知！&lt;/p&gt;
</content><category term="import"></category></entry></feed>