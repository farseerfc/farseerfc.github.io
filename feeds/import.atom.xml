<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Farseerfc的小窩</title><link href="//farseerfc.github.io/" rel="alternate"></link><link href="//farseerfc.github.io/feeds/import.atom.xml" rel="self"></link><id>//farseerfc.github.io/</id><updated>2011-09-27T02:35:00+09:00</updated><entry><title>關於我的Blogs</title><link href="//farseerfc.github.io/about-my-blogs.html" rel="alternate"></link><updated>2011-09-27T02:35:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2011-09-27:about-my-blogs.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;p&gt; 很久沒有寫過 blog 或者之類的東西了。這邊一直荒廢着。 &lt;/p&gt;
&lt;p&gt; 由於國內被牆的原因，另一個 wordpress ：  &lt;a class="reference external" href="http://fchome.sinaapp.com/"&gt;http://fchome.sinaapp.com/&lt;/a&gt;
 應該會同步更新這裏的內容。 &lt;/p&gt;
&lt;p&gt; 抽空寫點什麼吧。 &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</summary></entry><entry><title>“…if we do this work … ” --Bill Gates</title><link href="//farseerfc.github.io/if-we-do-this-work.html" rel="alternate"></link><updated>2011-03-14T20:34:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2011-03-14:if-we-do-this-work.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 導入自 &lt;a class="reference external" href="http://blog.renren.com/blog/230263946/716517729"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From: Bill Gates&lt;/p&gt;
&lt;p&gt;’-- Sent: Sunday, January 24, 1999 8:41 AM&lt;/p&gt;
&lt;p&gt;Jeff Westorinon; Ben Fathi ;&lt;/p&gt;
&lt;p&gt;TO: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder&lt;/p&gt;
&lt;p&gt;Subject: ACPI extensions&lt;/p&gt;
&lt;p&gt;One thing I find myself wondering about is whether we shouldn’t try and
make the "ACPI" extensions somehow Windows specific.&lt;/p&gt;
&lt;p&gt;It seems unfortunate if we do this work and get our partners to do the
work and the result is that &lt;strong&gt;Linux works great without having to do the work&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maybe there is no way to avoid this problem but it does bother me.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Maybe we could define the APIs so that they work well with NT and not
the others even if they are open.&lt;/p&gt;
&lt;p&gt;Or maybe we could patent something relaled to this.&lt;/p&gt;
&lt;p&gt;From:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf"&gt;http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 如果這就是我至今在 Xen4.0 上得不到 ACPI 3.0 的完善支持的原因，那麼我詛咒 Bill Gates ！ &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="microsoft"></category><category term="linux"></category><category term="acpi"></category></entry><entry><title>[zz]“西廂計劃”原理小解</title><link href="//farseerfc.github.io/zz-introducing-scholarzhang.html" rel="alternate"></link><updated>2010-03-17T09:40:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2010-03-17:zz-introducing-scholarzhang.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;p&gt; 好神奇的想法，先存着，以後慢慢研究 &lt;/p&gt;
&lt;p&gt; 原文： &lt;a class="reference external" href="http://blog.youxu.info/2010/03/14/west-chamber/"&gt;http://blog.youxu.info/2010/03/14/west-
chamber/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 待月西廂下，迎風戶半開。隔牆花影動，疑是玉人來。 &lt;/p&gt;
&lt;p&gt; 最近推上最流行的一個關鍵詞是 ” 西廂計劃 ”,
 這個計劃名字取得很浪漫，客戶端叫做張生，對，就是西廂記裏面那個翻牆去見崔鶯鶯小姐的張生；顯然，服務器端必然叫做崔鶯鶯。客戶端的張生是最重要的部件，可以不依賴於服務端工作。因爲西廂計劃的作者只是簡要的介紹了一下原理，其他報道又語焉不詳，我當時就覺得很好奇，花了昨天一個晚上詳細讀了一下源代碼，終於知道怎麼回事了，覺得原理非常漂亮，所以寫篇文章介紹總結一下。 &lt;/p&gt;
&lt;p&gt; 先說大方向。大家都知道，連接被重置的本質，是因爲收到了破壞連接的一個 TCP
Reset  包。以前劍橋大學有人實驗過，客戶端和服務器都忽略 Reset,
 則通信可以不受影響。但是這個方法其實只有理論價值，因爲絕大多數服務器都不可能忽略 Reset  的 ( 比如 Linux,  需要 root  權限配置 iptables,  而且這本身也把正常的 Reset  給忽略了 ) 。只要服務器不忽略 Reset,
 客戶端再怎麼弄都沒用，因爲服務器會停止發送數據， Reset
 這條連接。所以，很多報道說西廂計劃是忽略 Reset,
 我從源代碼來看應該不是這樣。在我看來，西廂計劃是利用了牆的一個可能的弱點 – 牆只在連接發起的時候把一個 TCP
 連接加入監聽序列，如果牆認爲這個連接終止了，就會從監聽序列中去掉這條記錄，這樣，這條連接上後續的包就不會被監聽。西廂計劃就是讓牆 “ 認爲 ” 這個連接終止的一個絕妙的方法。只要牆認爲這個連接兩端都是死老虎，牆就不會觸發關鍵詞檢測，其後所有的數據，都不存在連接被重置的問題了。 &lt;/p&gt;
&lt;p&gt; 如何讓一個連接置之死地而後生，就是西廂計劃那幫黑客神奇的地方了。這也不是一日之功。首先，這幫牛人發現，牆的是一個入侵檢測系統，把含有關鍵字的包當成一種 “ 入侵 ” 來對待。採取這種設計有很多好處，但缺點是入侵檢測系統可能具有的問題，牆都可能有。西廂計劃主頁上那篇著名的論文就是講這些七七八八的漏洞的。可以說處理這些七七八八的漏洞是非常困難的，迫使牆的設計者 “ 拆東牆，補西牆 ” 。這樣補來補去，外表看起來好像很牛逼的牆，其實有很多本質上無法簡單修補的漏洞，其中有一個致命的，就是 TCP  連接狀態的判定問題。出於入侵檢測系統這種設計的侷限，牆沒有，也沒辦法準確判定一條 TCP
 連接的狀態，而只是根據兩邊收到的數據來 “ 推測 ” 連接的狀態。而所有的關鍵詞檢測功能，都是基於 “ 連接還活着 ” 的這個推測的結果的。因爲牆的規則是在連接發起的時候開始對這條連接的檢測，在連接終止的時候停止對這條連接的檢測，所以，一旦對連接的狀態推測錯誤，把還活着的連接當成已經關閉的連接，牆就會放棄對這條連接上隨後所有的包的檢測，他們都會都透明的穿過牆的入侵檢測。 &lt;/p&gt;
&lt;p&gt; 上面只是想法，具體到 TCP
 協議實現這一層，就要只迷惑牆，還不能觸及我要通信的服務器。最理想的情況下，在任何有效通信之前，就能讓牆出現錯誤判斷，這些，就需要對 TCP  協議有深刻理解了。西廂計劃的那幫黑客，居然真的去讀 TCP  幾百頁的 RFC ，還居然就發現了方法（這裏我假設讀者都知道 TCP
 的三次握手過程和序列號每次加一的規則）。我們都知道，三次握手的時候，在收到服務器的 SYN/ACK
 的時候，客戶端如果發送 ACK  並且序列號 +1
 就算建立連接了，但是客戶端如果發送一個序列號沒 +1  的 FIN
 （表示連接終止，但是服務器知道，這時候連接還沒建立呢， FIN
 這個包狀態是錯的，加上序列號也是錯的，服務器自己一判斷，就知道這個包是壞包，按照標準協議，服務器隨手丟棄了這個包） ,
 但這個包，過牆的時候，在牆看來，是表示連接終止的 ( 牆是 ma de in china,
 是比較山寨的，不維護連接狀態，並且，牆並沒有記下剛纔服務器出去的 SYN/ACK
 的序列號，所以牆不知道序列號錯了）。所以，牆很高興的理解爲連接終止，舒了一口氣去重置其他連接了，而這個連接，就成了殭屍，牆不管你客戶端了，而這時候，好戲纔剛剛開始。 &lt;/p&gt;
&lt;p&gt; 事實上，牆是雙向檢測的（或者說對每個包都檢測的），因此，對服務器和客戶端實現相同的對待方法，所以，牆不管客戶端還不行，假如服務端有關鍵詞傳給客戶端，牆還是有可能要發飆的（這裏說有可能，因爲我也不知道）。所以，最好的辦法就是，讓服務端也給牆一個終止連接的標誌就好了。可是這個說起來簡單，做起來難，怎麼能讓不受自己控制的服務器發一個自己想要的包呢？西廂計劃的那幫黑客，再次去讀幾百頁的 RFC,  令人驚訝的發現，他們居然在 RFC
 上發現了一個可以用的特性。我們上面說了，三次握手的時候，在收到 SYN/ACK
 後，客戶端要給服務器發送一個序列號 +1  的 ACK ，可是，假如我不 +1 呢，直接發 ACK  包給服務器。牆已經認爲你客戶端是死老虎了，不理你了，不知道你搞什麼飛機，讓這個 ACK
 過了。可是服務器一看，不對啊，你給我的不是我期待的那個序列號， RFC
 上說了， TCP  包如果序列號錯了的話，就回復一個 Reset.
 所以，服務器就回復了一個 Reset 。這個 Reset
 過牆的時候，牆一看樂了，服務器也終止連接了，好吧，兩邊都是死老虎了，我就不監聽這條連接了。而至於客戶端，這個服務器過來的 Reset  非常好識別，忽略就是。隨後，客戶端開始正確的發送 ACK,
 至此，三次握手成功，真正的好戲開始，而牆則認爲客戶端和服務器都是死老虎，直接放過。所以，張生就這樣透明的過了牆。至於過牆以後所有的事情，《西廂記》裏面都有記載，各位讀者自行買書學習。 &lt;/p&gt;
&lt;p&gt; 現在的西廂計劃客戶端，即 “ 張生 ” 模塊的防連接重置的原理就是這樣，服務器端，即鶯鶯模塊的實現也是類似的。防 DNS 那個，不懂 DNS
 協議，所以看不懂。我猜想，因爲開發人員都是黑客，所以自然喜歡用最經得起折騰和高度定製的 Linux  開發。現在看西廂計劃的實現，因爲依賴於 Linux  內核模塊 netfilter,
 在 Linux  上如魚得水，但往其他平臺的移植可能是個亟待解決的問題。我覺得，在其他平臺上，可以通過 libpcap  和 libnet
 ，在用戶態實現相同的功能，就是有點麻煩而已，有興趣的懂網絡的可以照西廂計劃原理，在家自行做出此功能；當然，全中國人民都用 Linux  最好 :)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;PS 1:  據說是西廂計劃一個作者畫的原理圖： &lt;a class="reference external" href="http://img.ly/DIi"&gt;http://img.ly/DIi&lt;/a&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;PS 2:  我對 TCP  的理解僅限於課本，如果上面的對技術的理解有錯，請大家指出。 &lt;/div&gt;
&lt;div class="line"&gt;PS 3:  有些漏洞，可能是設計上本質缺陷，不是那麼容易修復的。 &lt;/div&gt;
&lt;div class="line"&gt;PS 4:  除了最後一個圖，本文沒有其他相關鏈接，如需相關資料，自行 Google 。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="zz"></category></entry><entry><title>寫程序讓CPU佔用率保持正弦函數</title><link href="//farseerfc.github.io/sine-cpu.html" rel="alternate"></link><updated>2008-06-02T23:27:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2008-06-02:sine-cpu.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 導入自 &lt;a class="reference external" href="http://blog.renren.com/blog/230263946/298871889"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 據說是一道微軟的面試題。如題，寫程序，讓 Windows 的任務管理器中的性能監視器呈現正弦曲線。 &lt;/p&gt;
&lt;img alt=" 正弦曲線 " class="align-center img-responsive" src="http://fm531.img.xiaonei.com/pic001/20080602/23/14/large_10019p67.jpg"/&gt;
&lt;img alt=" 正弦曲線 " class="align-center img-responsive" src="http://fm541.img.xiaonei.com/pic001/20080602/23/14/large_9935o67.jpg"/&gt;

&lt;p&gt; 潛心鑽研良久，得代碼：（ java ） &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;sincpu&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++){&lt;/span&gt;
            &lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
            &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;calcNextSleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sin&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sleep&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;sleepTime&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleepTime&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;yield&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleepTime&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;period&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(;;){&lt;/span&gt;
            &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sin&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;period&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 多核 CPU 上測試時要注意關掉一個 CPU ： &lt;/p&gt;
&lt;img alt=" 多核 CPU 上測試 " class="align-center img-responsive" src="http://fm411.img.xiaonei.com/pic001/20080602/23/14/large_9946k67.jpg"/&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="java"></category><category term="microsoft"></category></entry><entry><title>關於神創論的一些見解</title><link href="//farseerfc.github.io/some-thought-on-creationism.html" rel="alternate"></link><updated>2008-05-12T11:16:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2008-05-12:some-thought-on-creationism.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 導入自 &lt;a class="reference external" href="http://blog.renren.com/blog/230263946/292274803"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 看到陳驫同學很有感想的一篇神創論與命運日誌，覺得近日很久沒有看到這樣的評論了。想說幾句自己的觀點。 &lt;/p&gt;
&lt;p&gt; 首先我認爲，神創論與宿命論沒有多少關聯，甚至進化論者相較於神創論者更容易接受宿命論的觀點。因爲神創論主張意志的存在，人所具有的個體意志與神的意志，因此在神創論者的眼中事件的結果是可以通過意志來改變的，亦即如果我從物理樓 11 樓跳下，那麼我就可以改變自己死亡時間的宿命。上帝的意志同樣可以左右事件的結果，也就是所謂的宿命不復存在。而進化論者不承認意志獨立於物質世界的存在，你我的思考、行爲，都受到物理學法則諸如量子力學的約束，這就引出了北大物理系教授的那句 “ 宇宙中的一切都是可以計算的 ” ，亦即宿命論。如我我選擇現在從物理樓上跳下，我這一行爲並不是處於個人的獨立意志，乃是想證明這一點，亦即我跳樓這一舉動是有其背後的動機與原因的，就如同計算機的輸入必然導致了輸出，宿命的必然終結於此。 &lt;/p&gt;
&lt;p&gt; 其次，關於事件的複雜度所導致的隨機化，在大量混沌隨機中也存在着如統計學和隨機分形學這樣的規律，並不是否認宿命的充分理由。 &lt;/p&gt;
&lt;p&gt; 關於神創論的合理性問題。我認爲是否相信神的存在只是一個 boolean 二值問題，它爲 true 爲 false 本身並不重要，重要的是確定它的取值之後得到的推論與結果。如果否認神的存在，如現代數學這樣的完美又何以存在，進化論者的解釋是事物最終會向着更好更高級的方向發展，產生現代數學乃至現代科學是發展的必然。而這種論調顯然有悖於物理中以熱力學第二定律爲首的，預言事物會隨時間推演愈發混亂的論斷。更進一步，甚至整個人類、整個生物系統的存在都是有悖於熱力學推論的現象，是某種理論只能以 “ 小概率事件 ” 解釋的現象。 &lt;/p&gt;
&lt;p&gt; 神創論的核心觀點之一，是神的唯一存在性，按照鄒恆明的比喻，這就如同數學中集閤中元素的的唯一性一般至關重要。數學乃至近代科學的發展，其起源在於這種對神性的探求，而不僅僅是好奇心就可以解釋的。反觀東方文化中數學的發展，開始時領先於西方科學千餘每年，但是始終作爲一種 craft-oriented 的實用主義學科。可以說沒有了神的唯一性支持，人們就不能確信自己能找到這樣一種完美高效的學科，只能在實用的基礎上發展其基礎算數。可以想象，沒有神的完美與唯一性，數學必將發展成現代化學或者微軟軟件這樣，龐大而充滿特例，到處都是修補與查表，怎麼會像現在的完美、簡潔與和諧。 &lt;/p&gt;
&lt;p&gt; 神創論者並不是將難題推與 “ 神 ” 然後放任不管，他們相信神是最爲理智的存在，創人時人同樣得到了神的智慧和理智，也就是神可以用人的理智來理解。 &lt;/p&gt;
&lt;p&gt; 引用牛頓《自然哲學的數學原理》中終章的話 “ 太陽、恆星、行星的這個極精緻的結構不可能存在，除非通過一個有理智的和有權能的存在的設計和主宰 …… 他不是作爲宇宙的靈魂，而是作爲一切的主宰而統治所有 ……”&lt;/p&gt;
&lt;p&gt; 以上 ……&lt;/p&gt;
&lt;p&gt;( 發現最近的哲理思維果然慢了不少，寫作思緒也一片混亂 ^_^)&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="creationism"></category></entry><entry><title>由記憶棒誤差故障引發的關於面向對象設計的九點思考</title><link href="//farseerfc.github.io/9-thoughts-about-oop-from-wrongly-insert-memory-stick.html" rel="alternate"></link><updated>2007-09-20T14:38:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-09-20:9-thoughts-about-oop-from-wrongly-insert-memory-stick.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;p&gt; 故障描述 :
MMC Memory Stick Duo 記憶棒未經 Adapter 適配器，直接插入 SD Reader ，致使 MMC 卡入 SD Reader 中。 &lt;/p&gt;
&lt;p&gt; 棧展開：某日下午，無課。忙於數分作業，想查詢用手機拍攝的板書照片。取出手機中的 MMC 。未經裝配 Adapter ，直接插入 SD Reader 。 (A runtime exception was thrown.)
 嘗試翻轉筆記本機身，倒出 MMC ，未果。 (rethrow)
 嘗試用手指甲取出，未果。 (rethrow)
 考慮到有 “ 推入反彈 ” 機制，嘗試將 MMC 推入更深，反彈機制由於類型不匹配而失效，未果。 (rethrow)
(The exception spread across the border of the model.)
 電腦維修技師接手 (catch)
 技師未能發現問題所在，由我解說原委。 (Because the exception lose the information, RTTI was asked to recall the information)
 技師發現問題，嘗試用鑷子鑷出 MMC ，未果。技師開解機箱 (expose the data structure)
 技師製作鉤子，勾出 MMC(hooker link to the structure)
 取出 MMC ，故障解除 &lt;/p&gt;
&lt;p&gt; 故障總結 1. 接收到沒有完全瞭解、或沒有適當工具解決的 exception 時，不要嘗試用不成熟的技術解決，應儘快尋求能解決它的代碼。否則，被反覆 rethrow 的 exception ，尤其是通過模塊邊界的 exception ，有可能由 subclass 退化爲 superclass ，並因此而喪失一些信息。儘量不要讓 exception 丟失信息，必要時，通過 RTTI 機制尋回信息。 &lt;/p&gt;
&lt;p&gt;2. 超負荷運轉，多線程執行，這種種複雜性都有可能導致錯誤，應避免。無論你有多麼信任你的代碼或能力。 &lt;/p&gt;
&lt;p&gt;3. 在設計 class 的 interface 時，相匹配的 interface 應該滿足 is-a 的關係。因此，任何能插入 SD Reader 的 object ，即任何實現了 SD interface 的 object ，都應該 is-a SD card 。這次故障中， interface 接受了 MMC ，但 MMC 不是 SD 。即使這種情況下 throw an exception ，都不能使事態緩和。能提供 compile-time error 時，儘量讓錯誤以 compile-time error 的形式展現，並在事先解決。類型匹配問題是應該能在事先解決的問題。 &lt;/p&gt;
&lt;p&gt;4.Design patterns 中的 Adapter pattern 應該只是迫不得已情況之下的解決方案。只有當你無權改變現狀時，才能使用 Adapter 。如果能改變現狀，應該改變設計以符合 interface 。 &lt;/p&gt;
&lt;p&gt;5. 因爲上條，所有相似功能的對象應具有相同的 interface ，不同的 interface 是本次故障的根源所在。 &lt;/p&gt;
&lt;p&gt;6. 特殊情況下，破壞封裝機制並 expose the data structure 是必要的，應該有方法支持這種做法。 C 的指針和 C# 的 Reflection 技術都以不同的方式支持這種做法。其他的一些語言機制，比如 serializing( 序列化 ) 或 streaming( 流化 ) ，也可以以某種方式間接支持這一做法。當然，機制還應避免這種做法被濫用。 &lt;/p&gt;
&lt;p&gt;7. 相反功能具有相同操作的設計，容易造成使用的混亂，應適當避免。比如 SD Reader 的推入反彈設計，即插入和彈出使用同一個向裏推的操作的設計。同樣的設計還包括， C++ 中的 setNewHandle 使用同一個函數，同時設置和返回 handle 。以及有些書中提倡的，使用同名函數重載的方式，實現 setter/getter 的設計。 &lt;/p&gt;
&lt;p&gt;8. 特殊工具 (hooker) 對於解決特定問題，通常比手工解決有效。不要嫌麻煩而不願意構造特殊工具。 &lt;/p&gt;
&lt;p&gt;9. 棧語義，即 FILO 順序，總在不知不覺中影響我們。違反了 FILO 順序的操作極易造成混亂。本故障發生時正確的處理順序爲：裝配 Adapter
     插入 SD Reader
         讀取數據          停用設備      拔出 SD Reader
 拆解 Adapter
 本次故障的原因就是違反了 FILO 順序，違反了棧語義。 &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="oop"></category></entry><entry><title>Program Development in Java Preface</title><link href="//farseerfc.github.io/program-development-in-java-preface.html" rel="alternate"></link><updated>2007-09-16T13:26:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-09-16:program-development-in-java-preface.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt; 程序開發原理 &lt;/h2&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;—— 抽象、規格與面向對象設計 &lt;/h3&gt;
&lt;p&gt;Barbara Liskov  、 John Guttag  著 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 楊嘉晨等譯 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt; 關於翻譯風格： &lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 多年來閱讀計算機類的著作及譯作，感覺總體的困難在於一大堆沒有標準譯名的技術術語。由於通行於工業界和學術界的還是英文原名和術語，我決定保留大量的英文術語。這樣的翻譯風格借鑑於臺灣著名的譯者和作者侯捷先生。對於譯與不譯的權衡，主要考慮閱讀的流暢，以及讀者的理解能力，或許難免帶有一些主觀色彩。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="preface"&gt;
&lt;h2&gt; 前言 Preface&lt;/h2&gt;
&lt;p&gt; 構建產品級質量的程序 —— 可以在很長一段時間內使用的程序 —— 衆所周知是極其困難的。本書的目標就是改善程序員解決這項任務的效率。我希望讀者在閱讀本書之後成爲一名好程序員。我相信本書的成功在於改善編程技巧，因爲我的學生告訴我這已經發生在他們身上。 &lt;/p&gt;
&lt;p&gt; 怎麼纔算是一名好程序員？是產生整個程序產品的效率。關鍵是要在每一階段減少浪費掉的努力。解決的方法包括：在開始編寫代碼之前就仔細考慮你的實現方案，通過未雨綢繆的方法來編寫代碼，使用嚴格的測試在早期發現錯誤，以及仔細注意模塊化編程，這樣當錯誤出現時，只需要改動極少數代碼就可以修正整個程序。本書涉及所有這些領域的技術。 &lt;/p&gt;
&lt;p&gt; 模塊化編程 (Modularity) 是編寫好程序的關鍵。把程序分解成許多小模塊，每一個模塊通過良好定義的狹窄接口和別的模塊交互作用 (interact) 。有了模塊化，可以修正一部分程序中的錯誤而不考慮程序的其他部分，而且可以僅僅理解一部分程序而不必理解整個程序。沒有模塊化，程序是一大堆有着錯綜複雜的相互關係的部分的拼湊。很難去領悟和修改這樣一個程序，同樣也很難讓它正常工作。 &lt;/p&gt;
&lt;p&gt; 因此本書的重點在於創建模塊化的程序：怎樣把程序組織成一系列精心挑選的模塊。本書認爲模塊化就是抽象 (abstraction) 。每一個模塊意味着一個抽象，比如說指引一系列文檔中的關鍵字的目錄，或者在文檔中使用目錄來查找匹配某個問題的文檔的過程。着重強調面向對象編程思想 —— 在程序中使用數據抽象和對象的思想。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 這本書使用 Java 作爲它的編程示例的語言。我們沒有假定讀者已經熟悉 Java 。儘管可能沒什麼價值，但是本書中的思想是語言無關的，並且可以在任何語言的編程中使用。 &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="how-can-the-book-be-used"&gt;
&lt;h3&gt; 怎樣使用這本書？ How Can the Book Be Used&lt;/h3&gt;
&lt;p&gt; 本書《程序開發原理》有兩種使用方法。其一是作爲課本教材，講述如何用面向對象的方法來設計和實現複雜系統；其二是編程專家使用，幫助他們改善編程技能，增進他們的關於模塊化和 Object-Oriented( 面向對象 ) 設計的知識。 &lt;/p&gt;
&lt;p&gt; 作爲教材使用時，本書一般作爲第二或第三門程序設計課程。我們已經在 MIT 使用本書很多年，給大一大二的本科生教授第二門編程課。在這一階段，學生們已經知道怎樣編寫小程序。課程在兩方面利用這一點：讓學生更仔細地思考小程序，以及教他們如何利用小程序作爲組件構建大型程序。這本書也可以在專業（如軟件工程）後期教學中使用。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 建立在本書基礎上的課程適合於所有計算機科學專業。儘管許多學生可能永遠不會成爲真正的大型程序的設計師，他們可以在開發部門工作，在那兒他們負責設計和實現能與整個結構耦合的子系統。模塊化設計的子系統是這種任務中心，這對那些從事大型程序設計任務的人來說也同樣重要。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-is-this-book-about"&gt;
&lt;h3&gt; 這本書講什麼？ What Is This Book About&lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 通觀全篇三分之二的書致力於討論在構建獨立的程序模塊時產生的問題，剩下的部分討論怎樣運用這些模塊構建大型程序。 &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="program-modules"&gt;
&lt;h4&gt; 程序模塊 Program Modules&lt;/h4&gt;
&lt;p&gt; 這一部分的書集中討論抽象機制 (abstraction
mechanism) 。它討論 procedure( 子程序 ) 和 exception( 異常 ) ，數據抽象，遍歷 (iteration) 抽象，數據抽象系列 (family) 以及多態 (polymorphic) 抽象。 &lt;/p&gt;
&lt;p&gt; 在對抽象的討論中，三個步驟是重要的。首先是決定被抽象的東西到底是什麼：它提供給它的用戶哪些行爲。創造抽象是設計的關鍵，因此本書討論如何在衆多選擇中挑選，以及怎樣才能創造出好的抽象。 &lt;/p&gt;
&lt;p&gt; 第二步是通過爲一個抽象制定一個規格 (specification) 來獲取它的意義。如果沒有一些描述，一個抽象就會含糊不清，而變得沒有使用價值。 specification 則提供了需要的描述。本書定義了一種 specification 的格式，討論了一份好的 specification 應有的屬性，並且提供了許多示例。 &lt;/p&gt;
&lt;p&gt; 第三步是實現抽象。本書討論怎樣設計一份實現，以及在簡潔性和執行性能之間怎樣權衡利弊。書中強調封裝 (encapsulation) 的重要性以及在一份實現中履行規格中定義的行爲的重要性。書中同樣提供一些技術 —— 尤其是不變式斷言 (representation
invariant) 和抽象函數 (abstraction
function)—— 來幫助讀者理解代碼和它的原因。不變式斷言和抽象函數都實現到儘可能的程度，這對於除錯和調試很有用。 &lt;/p&gt;
&lt;p&gt; 關於類型層次 (type
hierarchy) 的材料注重討論使用它作爲抽象的技術 —— 一種把相關聯的一組數據抽象歸入同一系列的技術。這裏很重要的一點是，是否應當將一個類型作爲另一個類型的子類。本書定義了替換原則 —— 通過比較子類和父類的 specification ，來決定是否建立子類關係的方法 &lt;a class="reference external" href="#_ftn1"&gt;[1]&lt;/a&gt; 。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 本書同樣涉及除錯和調試。書中討論怎樣得到足夠數量的測試情況，來準備通過黑箱和白箱測試，它同樣強調了複查 (regression) 測試的重要性。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="programming-in-the-large"&gt;
&lt;h4&gt; 編寫大型程序 Programming in the Large&lt;/h4&gt;
&lt;p&gt; 本書的其後部分講解怎樣用模塊化的方法設計和實現大型程序。它建立在前文有關 abstraction 和 specification 的材料的基礎之上。 &lt;/p&gt;
&lt;p&gt; 編寫大型程序涵蓋四個主要議題。首先講解需求分析 —— 怎樣才能領悟程序中需要什麼。本書討論怎樣實施需求分析，也討論書寫產生的需求規格的方式，通過使用一種描述程序的抽象階段的數據模型。使用這種模型將產生一份更爲正式的 specification ，同時它也使需求檢查更加嚴格，這樣可以更好的領悟需求。 &lt;/p&gt;
&lt;p&gt; 編寫大型程序的第二項議題是程序設計，這通常是一個循序漸進的過程。設計過程圍繞構建有用的抽象來組織，這些抽象作爲整個程序之中理想的構建組建。這些抽象在設計時被仔細的編寫規格，這樣當程序實現時，那些實現抽象的模塊可以獨立地開發。這種設計使用設計筆記編寫文檔，包括描述整個程序結構的模塊間依賴性的圖示。 &lt;/p&gt;
&lt;p&gt; 第三項議題是實現和測試。本書討論了前置設計分析對於實現的必要性，以及怎樣進行設計複審。它同樣討論了設計和實現的順序。這一部分比較了自頂而下與自底而上的組織方式，討論如何使用驅動程序和佔位程序 &lt;a class="reference external" href="#_ftn2"&gt;[2]&lt;/a&gt;(stub) ，並且強調了制定一個事先的順序策略的必要性，以滿足開發組織和客戶的需求。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 本書以一章設計模式 (design pattern) 結束。一些模式在前面的章節介紹過，比如遍歷抽象是算法的主要組建。最後的章節討論前文中沒有涉及到的模式。希望它作爲這一教材的介紹。有興趣的讀者可以繼續閱讀其它書中更完善的討論 &lt;a class="reference external" href="#_ftn3"&gt;[3]&lt;/a&gt; 。 &lt;/div&gt;
&lt;/div&gt;
&lt;hr class="docutils"/&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref1"&gt;[1]&lt;/a&gt;
 譯註：如果子類的 specification 包括了所有父類的 specification ，就是說父類的要求也是子類的要求，或者子類的要求更爲嚴格，那麼可以建立父子關係。而替換原則的說法是，對於具有父子關係的類，任何需要一個父類對象的地方，都可以替換爲一個子類對象。 &lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref2"&gt;[2]&lt;/a&gt;
 譯註：在測試某一組建時，由於其餘組建還未實現，這一組建與其餘組建的接口銜接部分無法工作。此時可以針對這一組建編寫其餘組建的佔位程序 (stub) ，預留出接口的銜接代碼。佔位代碼通常不做任何有價值的事情，只報告組建的銜接部位工作正常。 &lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref3"&gt;[3]&lt;/a&gt;  譯註：作者指的是設計模式的開山之作 —— 《 Design
Patterns—Elements of Reusable Object-Oriented
Software 》 , 作者爲設計模式界著名的 “ 四人幫 ”GoF(Gang of
Four) 。此書詳盡討論了三大類共 23 個廣泛使用的設計模式的適用範圍、依存關係、實現細節以及已有的應用領域等問題。書中以 C++ 和 Smalltalk 爲示例語言，不過書中所涉及的模式適用於所有面向對象的語言。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="Java"></category></entry><entry><title>C++ Tricks 3.2 標號、goto，以及switch的實現</title><link href="//farseerfc.github.io/c-tricks-3-2-label-goto-and-implementation-of-switch.html" rel="alternate"></link><updated>2007-09-16T13:08:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-09-16:c-tricks-3-2-label-goto-and-implementation-of-switch.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h2&gt;3.2  標號、 goto ，以及 switch 的實現 &lt;/h2&gt;
&lt;p&gt;goto 語句及標號 (label) 是最古老的 C 語言特性，也是最早被人們拋棄的語言特性之一。像彙編語言中的 jmp 指令一樣， goto 語句可以跳轉到同一函數體中任何標號位置： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{int i=0;&lt;/p&gt;
&lt;p&gt;Loop: //A label&lt;/p&gt;
&lt;p&gt;++i;&lt;/p&gt;
&lt;p&gt;if(i&amp;lt;10)goto Loop; //Jump to the label&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 在原始而和諧的早期 Fortran 和 Basic 時代，我們沒有 if then
else ，沒有 for 和 while ，甚至沒有函數的概念，一切控制結構都靠 goto( 帶條件的或無條件的 ) 構件。軟件工程師將這樣的代碼稱作 “ 意大利麪條 ” 代碼。實踐證明這樣的代碼極容易造成混亂。 &lt;/p&gt;
&lt;p&gt; 自從證明了結構化的程序可以做意大利麪條做到的任何事情，人們就開始不遺餘力地推廣結構化設計思想，將 goto 像猛獸一般囚禁在牢籠，標號也因此消失。 &lt;/p&gt;
&lt;p&gt; 標號唯一散發餘熱的地方，是在 switch 中控制分支流程。 &lt;/p&gt;
&lt;p&gt; 很多人不甚瞭解 switch 存在的意義，認爲它只是大型嵌套 if then
else 結構的縮略形式，並且比 if 語句多了很多 “ 不合理 ” 的限制。如果你瞭解到 switch 在編譯器內部的實現機制，就不難理解強加在 switch 之上的諸多限制，比如 case 後只能跟一個編譯期整型常量，比如用 break 結束每一個 case 。首先看一個 switch 實例： &lt;/p&gt;
&lt;p&gt;switch (shape.getAngle())&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;case 3: cout&amp;lt;&amp;lt;”Triangle”;break;&lt;/p&gt;
&lt;p&gt;case 4: cout&amp;lt;&amp;lt;”Square”;break;&lt;/p&gt;
&lt;p&gt;case 0:case1: cout&amp;lt;&amp;lt;”Not a sharp!”;break;&lt;/p&gt;
&lt;p&gt;default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 任何程序員都可以寫出與之對應的 if 結構： &lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i==3) cout&amp;lt;&amp;lt;”Triangle”;&lt;/p&gt;
&lt;p&gt;else if(i==4) cout&amp;lt;&amp;lt;”Square”;&lt;/p&gt;
&lt;p&gt;else if(i==0||i==1) cout&amp;lt;&amp;lt;”Not a sharp!”;&lt;/p&gt;
&lt;p&gt;else cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt; 看起來這兩段代碼在語義上是完全一樣的，不是麼？ &lt;/p&gt;
&lt;p&gt; 不！或許代碼的執行結果完全一樣，但是就執行效率而言， switch 版本的更快！ &lt;/p&gt;
&lt;p&gt; 要了解爲什麼 switch 的更快，我們需要知道編譯器是怎樣生成 switch 的實現代碼的： &lt;/p&gt;
&lt;p&gt; 首先，保留 switch 之後由 {} 括起來的語具體，僅將其中 case 、 default 和 break 替換爲真正的標號： &lt;/p&gt;
&lt;p&gt;switch (getAngle(shape))&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 隨後，對於所有出現在 case 之後的常量，列出一張只有 goto 的跳轉表，其順序按 case 後的常量排列： &lt;/p&gt;
&lt;p&gt;goto _case_0;&lt;/p&gt;
&lt;p&gt;goto _case_1;&lt;/p&gt;
&lt;p&gt;goto _case_3;&lt;/p&gt;
&lt;p&gt;goto _case_4;&lt;/p&gt;
&lt;p&gt; 然後，計算 case 之後的常量與跳轉表地址之間的關係，如有需要，在跳轉表中插入空缺的項目： &lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default; // 因爲沒有 case 2 ，所以插入此項以條轉到 default&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt; 假設一個 goto 語句佔用 5 個字節，那麼在本例中， goto 的地址 =case 後的常量 *5+100105&lt;/p&gt;
&lt;p&gt; 之後，生成跳轉代碼，在其餘條件下跳轉至 default ，在已知範圍內按照公式跳轉，全部的實現如下： &lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i&amp;lt;0||i&amp;gt;=5)goto _default;&lt;/p&gt;
&lt;p&gt;i=i*5+100105; // 按照得出的公式算出跳轉地址 &lt;/p&gt;
&lt;p&gt;goto i; // 僞代碼， C 中不允許跳轉到整數，但是彙編允許 &lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default;&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 經過這樣處理整個 switch 結構，使得無論 switch 後的變量爲何值，都可以通過最多兩次跳轉到達目標代碼。相比之下 if 版本的代碼則採用線性的比較和跳轉，在 case 語句很多的情況下效率極低。 &lt;/p&gt;
&lt;p&gt; 由此 , 我們也可以知道 , 爲什麼 case 後跟的一定是編譯期整型常數，因爲編譯器需要根據這個值製作跳轉表。我們可以明白爲什麼 case 與 case 之間應該用 break 分隔，因爲編譯器不改變 switch 語句體的結構， case 其本身只是一個具有語義的標號而已，要想跳出 switch ，就必須用 break 語句。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 3.1 左值右值與常量性(lvalue，rvalue &amp; constant)</title><link href="//farseerfc.github.io/c-tricks-3-1-lvalue-rvalue-constant.html" rel="alternate"></link><updated>2007-09-16T13:07:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-09-16:c-tricks-3-1-lvalue-rvalue-constant.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h2&gt;3.1  左值右值與常量性 (lvalue ， rvalue &amp;amp; constant)&lt;/h2&gt;
&lt;p&gt; 首先要搞清楚的是，什麼是左值，什麼是右值。這裏給出左值右值的定義： &lt;/p&gt;
&lt;p&gt;1 、左值是可以出現在等號 (=) 左邊的值，右值是隻能出現在等號右邊的值。 &lt;/p&gt;
&lt;p&gt;2 、左值是可讀可寫的值，右值是隻讀的值。 &lt;/p&gt;
&lt;p&gt;3 、左值有地址，右值沒有地址。 &lt;/p&gt;
&lt;p&gt; 根據左值右值的第二定義，值的左右性就是值的常量性 —— 常量是右值，非常量是左值。比如： &lt;/p&gt;
&lt;p&gt;1=1;//Error&lt;/p&gt;
&lt;p&gt; 這個複製操作在 C++ 中是語法錯誤， MSVC 給出的錯誤提示爲 “error C2106: '=' :
left operand must be
l-value” ，就是說 ’=’ 的左操作數必須是一個左值，而字面常數 1 是一個右值。可見，嚴格的區分左值右值可以從語法分析的角度找出程序的邏輯錯誤。 &lt;/p&gt;
&lt;p&gt; 根據第二定義，一個左值也是一個右值，因爲左值也可讀，而一個右值不是一個左值，因爲右值不可寫。 &lt;/p&gt;
&lt;p&gt; 通常情況下，聲明的變量是一個左值，除非你指定 const 將它變成一個右值： &lt;/p&gt;
&lt;p&gt;int lv=1;&lt;/p&gt;
&lt;p&gt;const int rv=lv;&lt;/p&gt;
&lt;p&gt; 由於右值的值在程序執行期間不能改變，所以必須用另一個右值初始化它。 &lt;/p&gt;
&lt;p&gt; 一個普通變量只能用右值初始化，如果你想傳遞左值，必須聲明一個引用或一個指針： &lt;/p&gt;
&lt;p&gt;int &amp;amp; ref=lv;// 用引用傳遞左值 &lt;/p&gt;
&lt;p&gt;int * plv=&amp;amp;lv;// 傳遞指針以間接傳遞左值 &lt;/p&gt;
&lt;p&gt; 必須用左值初始化引用，然而，可以用右值初始化常量引用： &lt;/p&gt;
&lt;p&gt;int &amp;amp; r1=1; //Error!&lt;/p&gt;
&lt;p&gt;const int &amp;amp; r2=1; //OK&lt;/p&gt;
&lt;p&gt; 這實際上相當於： &lt;/p&gt;
&lt;p&gt;int _r2=1;&lt;/p&gt;
&lt;p&gt;const int &amp;amp; r2=_r2;&lt;/p&gt;
&lt;p&gt; 這樣的寫法在函數體內沒什麼作用，但是在傳遞函數參數時，它可以避免潛在的 ( 傳遞左值時的 ) 複製操作，同時又可以接受右值。 &lt;/p&gt;
&lt;p&gt; 通常情況下，函數的參數和返回值都只傳回右值，除非你明確的通過引用傳遞左值。 &lt;/p&gt;
&lt;p&gt; 明確了左值與右值的區別，有助於我們寫函數時確定什麼時候應該有 const ，什麼時候不該有。比如，我們寫了一個代表數學中複數的類 Complex ： &lt;/p&gt;
&lt;p&gt;class Complex;&lt;/p&gt;
&lt;p&gt; 然後，我們寫針對 Complex 的運算符重載： operator+ 和 operator= 。問題在於，參數和返回值應該是什麼類型，可選類型有四種： Complex 、 const Complex 、 Complex&amp;amp; 、 const Complex&amp;amp; 。 &lt;/p&gt;
&lt;p&gt; 對於 operator+ ，我們不會改變參數的值，所以可以通過 const
Complex&amp;amp; 傳遞參數。至於返回值類型，由於 int 類型的加法返回右值，所以根據 Do
as the ints do 的原則，返回值類型爲 const Complex ： &lt;/p&gt;
&lt;p&gt;const Complex operator+(const Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt; 對於 operator= ，同樣要思考這些問題。我們寫入第一個參數，所以第一個參數爲 Complex&amp;amp; ，我們只讀取第二個參數，所以第二個參數爲 const
Complex&amp;amp; 。至於返回值，還是 Do as the ints
do 。 int 的賦值返回左值，不信你可以試一試： &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;(i=1)=2;&lt;/p&gt;
&lt;p&gt; 雖然比較傻，先將 i 賦爲 1 ，再將其改爲 2 ，但是這是被 C++ 語法支持的做法，我們就理應遵守。所以返回第一個參數的左值： &lt;/p&gt;
&lt;p&gt;Complex&amp;amp; operator=(Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt;const 是 C++ 引入的語言特性，也被 ANSI
C99 借鑑，在經典版本的 C 語言中是沒有的。關於 const 的歷史，有幾點值得玩味。最初 Bjarne
Stroustrup 引入 const 時，可寫性是和可讀性分開的。那時使用關鍵字 readonly 和 writeonly 。這個特點被首先提交到 C 的 ANSI 標準化委員會 ( 當時還沒有 C++ 標準化的計劃 ) ，但是 ANSI
C 標準只接受了 readonly 的概念，並將其命名爲 const 。隨後，有人發現在多線程同步的環境下，有些變量的值會在編譯器的預料之外改變，爲了防止過度優化破壞這些變量， C++ 又引入關鍵字 violate 。從語義特點來看， violate 是 const 的反義詞，因爲 const 表示不會變的量，而 violate 表示會不按照預期自行變化的量。從語法特點而言， violate 與 const 是極爲相似的，適用於 const 的一切語法規則同樣適用於 violate 。 &lt;/p&gt;
&lt;p&gt; 值的常量性可以被劃分爲兩種：編譯期常量和運行期常量。 C++ 語法並沒有嚴格區分這兩種常量，導致了少許混亂： &lt;/p&gt;
&lt;p&gt;const int i=5;const int * pi=&amp;amp;i;&lt;/p&gt;
&lt;p&gt;const_cast&amp;lt;int&amp;amp;&amp;gt;i=1;// 對於運行期常量，在需要時可以去除它的常量性 &lt;/p&gt;
&lt;p&gt;int a[i];// 對於編譯期常量，可以用它來指定數組大小 &lt;/p&gt;
&lt;p&gt;cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;sizeof(a)/sizeof(a[0])&amp;lt;&amp;lt;*pi;&lt;/p&gt;
&lt;p&gt; 這種將編譯期與運行期常量的特性混用的方法，勢必導致語義的混亂。數組 a 的大小最終是 5 ，因爲採用了 i 的編譯期值，而不管 i 在運行期是否被改變了值。最後一句代碼將（有可能）輸出 551 ，第一個 i 的值作爲一種優化在編譯期綁定，第二個值標明瞭 a 的大小，第三個值通過指針顯示地輸出 i 的運行期真實值。 &lt;/p&gt;
&lt;p&gt; 在 C++ 的近親 C# 的語法中，這兩種常量被嚴格地區分開：編譯期常量由 const 指定，只能是內建類型變量；運行期常量由 readonly 指定，可以是任何類型。永遠不會改變的常量，如圓周率 pi 的值，應該用 const 聲明；而其它有可能改變的常量，皆由 readonly 聲明。 &lt;/p&gt;
&lt;p&gt;C++ 中的 const 的特點更傾向於 C# 中的 readonly ，雖然語法上允許使用 const 的編譯期常量性，但正如上文所展示的，這容易造成混亂。爲了得到 C# 中 const 的語義，在 C++ 中，我們不必迴歸惡魔 #define 的懷抱，可以使用所謂 “ 匿名 enum 技巧 ” 。當匿名聲明一個 enum 類型時，其中的枚舉值就是一個 int 類型的編譯期常量，比如： &lt;/p&gt;
&lt;p&gt;enum{Size=5;};&lt;/p&gt;
&lt;p&gt;int a[Size];&lt;/p&gt;
&lt;p&gt; 這種使用匿名 enum 來聲明編譯期常量的做法，被廣泛應用於 STL 、 boost 等模板庫的實現代碼中。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.2 I386平臺的內存佈局</title><link href="//farseerfc.github.io/c-tricks-2-2-i386-memory-layout.html" rel="alternate"></link><updated>2007-08-28T14:30:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-2-i386-memory-layout.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.2 I386 平臺的內存佈局 &lt;/h2&gt;
&lt;p&gt; 衆所周知， I386 是 32 位體系結構。因此對於絕大多數 I386 平臺的 C++ 編譯器而言， sizeof(int)=sizeof(long)=sizeof(void*)=4 。當然 C++ 標準對此沒有任何保證，我們也不應該試圖編寫依賴於此的代碼。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;32 位指針的可尋址空間爲 4GB 。爲充分利用這麼大的尋址空間，也是爲了支持其它更先進的技術比如多任務技術或者動態鏈接庫技術， WinNT 使用虛擬內存技術，給與每個應用程序全部 4GB 的內存空間。 4GB 的地址被一分爲二，前 2GB 供應用程序自己使用，後 2GB 由系統內核分配和管理。這 2GB 的內存地址，通常被劃分成 3 種內存區使用： &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;1  代碼及靜態數據區 &lt;/h3&gt;
&lt;p&gt; 由代碼加載器從動態鏈接庫鏡像 ( 通常是 exe 或 dll 文件 ) 加載，通常定位到鏡像文件中指定的基址開始的內存區。如果基址所在內存已被佔用，動態連接器會將代碼或數據重定向到其它可用地址。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 在 C++ 中，靜態數據包括：名字空間 (namespace) 和全局 (global) 對象、函數的 static 對象、類的 static 數據成員。這些靜態數據由編譯器分配地址 ( 但可能被重定向 ) ，由靜態連接器寫入代碼文件 ( 通常是 exe 或 dll) 的靜態數據區段。所以標準說，這些靜態數據在編譯期就已經具有地址。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stack"&gt;
&lt;h3&gt;2  棧 (Stack)&lt;/h3&gt;
&lt;p&gt; 棧是最常用的動態數據存儲區，所有函數的 non-static 對象和函數參數都在程序運行期在棧上分配內存。在數據結構中，術語 “ 棧 (Stack)” 意指先進後出 (FILO ， First
In Last
Out) ，與 “ 隊列 (Queue)” 所指的 FIFO 相對。相對於基於堆的對象分配技術，默認使用棧的對象分配有兩點優勢： &lt;/p&gt;
&lt;p&gt; 一、棧的 FILO 與人的思維方式相同 &lt;/p&gt;
&lt;p&gt; 現實生活中有許多事例都使用 FILO 的方式，比如人們必須先提起話筒再撥打號碼，而後掛斷電話之後再放下話筒。使用 FILO 的棧，可以保證事物的銷燬順序以其誕生順序相反的順序進行，不會產生在掛斷電話之前就放下話筒的尷尬。 &lt;/p&gt;
&lt;p&gt; 二、棧的分配管理僅需要兩個額外指針：棧頂 (esp) 和棧底 (ebp) 指針 &lt;/p&gt;
&lt;p&gt; 從實現的技術層面而言，棧的管理比其它動態分配技術要簡單很多。 I386 平臺上的動態棧管理，僅需要棧頂和棧底兩個指針。這兩個指針的存儲顯然不能放置於棧中，置於靜態數據區又有損效率。 I386 平臺爲管理動態棧專門預留了兩個通用寄存器變量 esp 與 ebp ，分別代表棧頂 (esp,Extended
Stack Pointer) 與棧底 (Extended Bottom
Pointer) 指針。其中的 extended 代表它們是 32 位指針，以區分 16 位的 sp 和 bp 寄存器。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 棧是動態存儲區的特點，表明它的內存佔用將隨着程序的運行而變化。 I386 平臺上 WinNT 將應用程序的棧置於程序空間，向下增長。程序初始化時，由操作系統將 esp 指向系統分配的棧空間的頂部。當程序需要在棧上分配變量時，就將 esp 減去變量所需字節數，這被稱作 “ 壓棧 (Push)” ；隨後又要銷燬變量時，就將 esp 加上變量所需字節數，這被稱作 “ 彈出 (Pop)” 。 esp 與 ebp 兩者之間所夾的空間，就是當前函數正在使用的棧空間。由於棧向下增長， esp( 棧頂 ) 的值總是小於 ebp( 棧底 ) 的值，新分配的變量地址總是小於舊變量的地址。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="heap"&gt;
&lt;h3&gt;3  堆 (Heap) 和自由存儲區 &lt;/h3&gt;
&lt;p&gt; 棧中的變量對於分配與釋放的順序有特定要求，這在一定程度上限制了棧的適用範圍。面向對象 (OO ， Object
Oriented) 的程序設計思想也要求能自由地控制變量的分配與銷燬。由此，現代操作系統都提供了被稱作 “ 堆 (Heap)” 的自由存儲區，以允許由程序員控制的對象創建和銷燬過程。 C 標準庫函數 malloc 和 free 則是對操作系統提供的堆操作的封裝。 C++ 提供的自由存儲區運算符 new 和 delete 則通常是 malloc 和 free 的又一層封裝。 &lt;/p&gt;
&lt;p&gt; 操作系統經由 malloc 和 free 控制對堆的訪問。堆的存儲管理技術各不相同，簡單的使用雙鏈表管理，複雜的可以比擬一個完整的文件系統。 &lt;/p&gt;
&lt;p&gt; 由於額外的管理需求，使用系統提供的通用分配器在堆上分配和銷燬變量的代價，無論從空間角度還是效率角度而言，都比在棧上分配對象要高昂很多。對於 sizeof 上百的大型對象，這樣的高昂代價還是可以接受的，但是對於 sizeof 只有個位數的小對象，這樣的代價通常是一個數量級的差距。正因爲這個原因， STL 不使用 new 和 delete ，轉而使用分配子 (alllocor) 分配對象。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks</title><link href="//farseerfc.github.io/c-tricks.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ Tricks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;By  FarseerFc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 從今天起，我再將在 &lt;a class="reference external" href="http://firechildren.spaces.live.com/"&gt;Live
Space&lt;/a&gt; 和 &lt;a class="reference external" href="http://76635424.qzone.qq.com/"&gt;QQZone&lt;/a&gt; 同時發表一系列文章，暫定名爲 “C++Tricks” 。 &lt;/p&gt;
&lt;p&gt; 本文旨在記錄和闡述一些本人學習 C++ 時所得的心得、技巧。總體來看，本文涉及的內容是每一個 C++ 程序員都應該知道的，但是很少見諸 C++ 教材。希望對各位同仁學習 C++ 有所幫助。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 也可以通過 QQ 或 MSN 向我索要此文的 DOC 版或 PDF 版，會比網頁上的更新的快一點。 &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lexical-problems"&gt;
&lt;h2&gt;1       詞法問題 (Lexical Problems)&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!139.entry"&gt;1.1  條件運算符 (?:)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!140.entry"&gt;1.2  逗號運算符 (,) 、邏輯運算符 (&amp;amp;&amp;amp;,||) 與運算符重載的陷阱 &lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="x86"&gt;
&lt;h3&gt;2      X86 體系結構 &lt;/h3&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!146.entry"&gt;2.1 X86 概述 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!147.entry"&gt;2.2 I386 平臺的內存佈局 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!148.entry"&gt;2.3 I386 平臺 C 函數內部的棧分配 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!149.entry"&gt;2.4 I386 平臺 C 函數調用邊界的棧分配 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!150.entry"&gt;2.5 I386 平臺的邊界對齊 (Align)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!151.entry"&gt;2.6 I386 平臺 C 函數的可變參數表 (Variable Arguments)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!152.entry"&gt;2.7 I386 平臺的其它函數調用模型 &lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="id6"&gt;
&lt;h5&gt;3  過程式編程 &lt;/h5&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!154.entry"&gt;3.1  左值右值與常量性 (lvalue ， rvalue &amp;amp; constant)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!155.entry"&gt;3.2  標號、 goto ，以及 switch 的實現 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.3 I386平臺C函數內部的棧分配</title><link href="//farseerfc.github.io/c-tricks-2-3-i386-stack-allocation-in-c-functions.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-3-i386-stack-allocation-in-c-functions.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.3 I386 平臺 C 函數內部的棧分配 &lt;/h2&gt;
&lt;p&gt; 函數使用棧來保存局部變量，傳遞函數參數。進入函數時，函數在棧上爲函數中的變量統一預留棧空間，將 esp 減去相應字節數。當函數執行流程途徑變量聲明語句時，如有需要就調用相應構造函數將變量初始化。當執行流程即將離開聲明所在代碼塊時，以初始化的順序的相反順序逐一調用析構函數。當執行流程離開函數體時，將 esp 加上相應字節數，歸還棧空間。 &lt;/p&gt;
&lt;p&gt; 爲了訪問函數變量，必須有方法定位每一個變量。變量相對於棧頂 esp 的位置在進入函數體時就已確定，但是由於 esp 會在函數執行期變動，所以將 esp 的值保存在 ebp 中，並事先將 ebp 的值壓棧。隨後，在函數體中通過 ebp 減去偏移量來訪問變量。以一個最簡單的函數爲例： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int a=0; //a 的地址被分配爲 ebp-4&lt;/p&gt;
&lt;p&gt;char c=1; //c 的地址被分配爲 ebp-8&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 產生的彙編代碼爲： &lt;/p&gt;
&lt;p&gt;push ebp ; 將 ebp 壓棧 &lt;/p&gt;
&lt;p&gt;mov ebp,esp ;ebp=esp  用棧底備份棧頂指針 &lt;/p&gt;
&lt;p&gt;sub esp,8 ;esp-=8 ，爲 a 和 c 預留空間，包括邊界對齊 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],0 ;a=0&lt;/p&gt;
&lt;p&gt;mov byte ptr[ebp-8],1 ;c=1&lt;/p&gt;
&lt;p&gt;add esp,8 ;esp+=8 ，歸還 a 和 c 的空間 &lt;/p&gt;
&lt;p&gt;mov esp,ebp ;esp=ebp  從棧底恢復棧頂指針 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢復 ebp&lt;/p&gt;
&lt;p&gt;ret ; 返回 &lt;/p&gt;
&lt;p&gt; 相應的內存佈局是這樣： &lt;/p&gt;
&lt;p&gt;09992:c=1 &amp;lt;-esp&lt;/p&gt;
&lt;p&gt;09996:a=0&lt;/p&gt;
&lt;p&gt;10000: 舊 ebp &amp;lt;-ebp&lt;/p&gt;
&lt;p&gt;10004:……&lt;/p&gt;
&lt;p&gt; 注 : 彙編中的 pop 、 push 、 call 、 ret 語句是棧操作指令，其功能可以用普通指令替換 &lt;/p&gt;
&lt;p&gt;push ebp 相當於 :&lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;mov dword ptr[esp],ebp&lt;/p&gt;
&lt;p&gt;pop ebp 相當於： &lt;/p&gt;
&lt;p&gt;mov ebp,dword ptr[esp]&lt;/p&gt;
&lt;p&gt;sub esp,4&lt;/p&gt;
&lt;p&gt;call fun_address 相當於： &lt;/p&gt;
&lt;p&gt;push eip&lt;/p&gt;
&lt;p&gt;jmp fun_address&lt;/p&gt;
&lt;p&gt;ret 相當於 &lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt; 帶參數的 ret&lt;/p&gt;
&lt;p&gt;ret 8 相當於 &lt;/p&gt;
&lt;p&gt;add esp,12&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt; 所有局部變量都在棧中由函數統一分配，形成了類似逆序數組的結構，可以通過指針逐一訪問。這一特點具有很多有趣性質，比如，考慮如下函數，找出其中的錯誤及其造成的結果： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i,a[10];&lt;/p&gt;
&lt;p&gt;for(i=0;i&amp;lt;=10;++i)a[i]=0;/An error occurs here!&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 這個函數中包含的錯誤，即使是 C++ 新手也很容易發現，這是老生常談的越界訪問問題。但是這個錯誤造成的結果，是很多人沒有想到的。這次的越界訪問，並不會像很多新手預料的那樣造成一個 “ 非法操作 ” 消息，也不會像很多老手估計的那樣會默不作聲，而是導致一個，呃，死循環！ &lt;/p&gt;
&lt;p&gt; 錯誤的本質顯而易見，我們訪問了 a[10] ，但是 a[10] 並不存在。 C++ 標準對於越界訪問只是說 “ 未定義操作 ” 。我們知道， a[10] 是數組 a 所在位置之後的一個位置，但問題是，是誰在這個位置上。是 i!&lt;/p&gt;
&lt;p&gt; 根據前面的討論， i 在數組 a 之前被聲明，所以在 a 之前分配在棧上。但是， I386 上棧是向下增長的，所以， a 的地址低於 i 的地址。其結果是在循環的最後， a[i] 引用到了 i 自己！接下來的事情就不難預見了， a[i] ，也就是 i ，被重置爲 0 ，然後繼續循環的條件仍然成立 …… 這個循環會一直繼續下去，直到在你的帳單上產生高額電費，直到耗光地球電能，直到太陽停止燃燒 …… 呵呵，或者直到聰明的你把程序 Kill 了 ……&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.4 I386平臺C函數調用邊界的棧分配</title><link href="//farseerfc.github.io/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.4 I386 平臺 C 函數調用邊界的棧分配 &lt;/h2&gt;
&lt;p&gt; 當調用一個函數時，主調函數將參數以聲明中相反的順序壓棧，然後將當前的代碼執行指針 (eip) 壓棧，然後跳轉到被調函數的入口點。在被調函數中，通過將 ebp 加上一個偏移量來訪問函數參數，以聲明中的順序 ( 即壓棧的相反順序 ) 來確定參數偏移量。被調函數返回時，彈出主調函數壓在棧中的代碼執行指針，跳回主調函數。再由主調函數恢復到調用前的棧。 &lt;/p&gt;
&lt;p&gt; 函數的返回值不同於函數參數，通過寄存器傳遞。如果返回值類型可以放入 32 位變量，比如 int 、 short 、 char 、指針等類型，通過 eax 寄存器傳遞。如果返回值類型是 64 位變量，如 _int64 ，同過 edx+eax 傳遞， edx 存儲高 32 位， eax 存儲低 32 位。如果返回值是浮點類型，如 float 和 double ，通過專用的浮點數寄存器棧的棧頂返回。如果返回值類型是用戶自定義結構，或 C++ 類類型，通過修改函數簽名，以引用型參數的形式傳回。 &lt;/p&gt;
&lt;p&gt; 同樣以最簡單的函數爲例： &lt;/p&gt;
&lt;p&gt;void f(){&lt;/p&gt;
&lt;p&gt;int i=g(1,2);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int g(int a,int b){&lt;/p&gt;
&lt;p&gt;int c=a+b ； &lt;/p&gt;
&lt;p&gt;return c;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 產生的彙編代碼如下： &lt;/p&gt;
&lt;p&gt;f:&lt;/p&gt;
&lt;p&gt;push ebp ; 備份 ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ; 建立棧底 &lt;/p&gt;
&lt;p&gt;sub esp,4 ; 爲 i 分配空間 &lt;/p&gt;
&lt;p&gt;mov eax,2 ; 準備參數 b 的值 2&lt;/p&gt;
&lt;p&gt;push eax ; 將 b 壓棧 &lt;/p&gt;
&lt;p&gt;mov eax,1 ; 準備參數 a 的值 1&lt;/p&gt;
&lt;p&gt;push eax ; 將 a 壓棧 &lt;/p&gt;
&lt;p&gt;call g ; 調用 g&lt;/p&gt;
&lt;p&gt;add esp,8 ; 將 a 和 b 一起彈出，恢復調用前的棧 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ; 將返回值保存進變量 i&lt;/p&gt;
&lt;p&gt;mov esp,ebp ; 恢復棧頂 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢復棧底 &lt;/p&gt;
&lt;p&gt;g:&lt;/p&gt;
&lt;p&gt;push ebp ; 備份 ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ; 建立棧底 &lt;/p&gt;
&lt;p&gt;sub esp,4 ; 爲局部變量 c 在棧中分配內存 &lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp+8] ; 通過 ebp 間接讀取參數 a 的值 &lt;/p&gt;
&lt;p&gt;mov ebx,dword ptr[ebp+12] ; 通過 ebp 間接讀取參數 b 的值 &lt;/p&gt;
&lt;p&gt;add eax,ebx ; 將 a 和 b 的值相加，之和存在 eax 中 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ; 將和存入變量 c&lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp-4] ; 將 c 作爲返回值，代碼優化後會刪除此句 &lt;/p&gt;
&lt;p&gt;add esp,4 ; 銷燬 c 的內存 &lt;/p&gt;
&lt;p&gt;mov esp,ebp ; 恢復棧頂 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢復棧底 &lt;/p&gt;
&lt;p&gt;ret ; 返回函數 f&lt;/p&gt;
&lt;p&gt; 棧的內存佈局如下： &lt;/p&gt;
&lt;p&gt;100076:c &amp;lt;- g 的 esp&lt;/p&gt;
&lt;p&gt;100080:f 的 ebp=100100 &amp;lt;- g 的 ebp&lt;/p&gt;
&lt;p&gt;100084:f 的 eip&lt;/p&gt;
&lt;p&gt;100088:a=1&lt;/p&gt;
&lt;p&gt;100092:b=2&lt;/p&gt;
&lt;p&gt;100096:i&lt;/p&gt;
&lt;p&gt;100100: 舊 ebp &amp;lt;-f 的 ebp&lt;/p&gt;
&lt;p&gt;100104:……&lt;/p&gt;
&lt;p&gt; 注意在函數 g 的彙編代碼中，訪問函數的局部變量和訪問函數參數的區別。局部變量總是通過將 ebp 減去偏移量來訪問，函數參數總是通過將 ebp 加上偏移量來訪問。對於 32 位變量而言，第一個局部變量位於 ebp-4 ，第二個位於 ebp-8 ，以此類推， 32 位局部變量在棧中形成一個逆序數組；第一個函數參數位於 ebp+8 ，第二個位於 ebp+12 ，以此類推， 32 位函數參數在棧中形成一個正序數組。 &lt;/p&gt;
&lt;p&gt; 由於函數返回值通過寄存器返回，不需要空間分配等操作，所以返回值的代價很低。基於這個原因，舊的 C 語法約定，不寫明返回值類型的函數，返回值類型爲 int 。這一規則與現行的 C++ 語法相違背，因爲 C++ 中，不寫明返回值類型的函數返回值類型爲 void ，表示不返回值。這種語法不兼容性是爲了加強 C++ 的類型安全，但同時也帶來了一些問題。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.5 I386平臺的邊界對齊(Align)</title><link href="//farseerfc.github.io/c-tricks-2-5-address-alignment.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-5-address-alignment.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h2&gt;2.5 I386 平臺的邊界對齊 (Align)&lt;/h2&gt;
&lt;p&gt; 首先提問，既然 I386 上 sizeof(int)==4 、 sizeof(char)==1 ，那麼如下結構 (struct)A 的 sizeof 是多少？ &lt;/p&gt;
&lt;p&gt;struct A{int i;char c;};&lt;/p&gt;
&lt;p&gt; 答案是 sizeof(A)==8……1+5=8 ？ &lt;/p&gt;
&lt;p&gt; 呵呵，這就是 I386 上的邊界對齊問題。我們知道， I386 上有整整 4GB 的地址空間，不過並不是每一個字節上都可以放置任何東西的。由於內存總線帶寬等等的技術原因，很多體系結構都要求內存中的變量被放置於某一個邊界的地址上。如果違反這個要求，重則導致停機出錯，輕則減慢運行速度。對於 I386 平臺而言，類型爲 T 的變量必須放置在 sizeof(T) 的整數倍的地址上， char 可以隨便放置， short 必須放在 2 的整數倍的地址上， int 必須放在 4 的整數倍的地址上， double 必須放在 8 的整數倍的地址上。如果違反邊界對齊要求，從內存中讀取數據必須進行兩次，然後將獨到的兩半數據拼接起來，這會嚴重影響效率。 &lt;/p&gt;
&lt;p&gt; 由於邊界對齊問題的要求，在計算 struct 的 sizeof 的時候，編譯器必須算入額外的字節填充，以保證每一個變量都能自然對齊。比如如下聲明的 struct:&lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 實際上相當於聲明瞭這樣一個結構： &lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;char _filling1 [3];// 三個字節填充，保證下一個 int 的對齊 &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2 ； &lt;/p&gt;
&lt;p&gt;char _filling2 [3];// 又三個字節填充 &lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 值得注意的是尾部的 3 個字節填充，這是爲了可以在一個數組中聲明 WASTE 變量，並且每一個都自然對齊。因爲有了這些填充，所以 sizeof(WASTE)==12 。這是一種浪費，因爲只要我們重新安排變量的聲明，就可以減少 sizeof ： &lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c1,c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 像這樣的安排， sizeof 就減少到 8 ，只有 2 個字節的額外填充。爲了與彙編代碼相兼容， C 語言語法規定，編譯器無權擅自安排結構體內變量的佈局順序，必須從左向右逐一排列。所以，妥當安排成員順序以避免內存空間的浪費，就成了我們程序員的責任之一。一般的，總是將結構體的成員按照其 sizeof 從大到小排列， double 在最前， char 在最後，這樣總可以將結構的字節填充降至最小。 &lt;/p&gt;
&lt;p&gt;C++ 繼承了 C 語言關於結構體佈局的規定，所以以上的佈局準則也適用於 C++ 的 class 的成員變量。 C++ 進一步擴展了佈局規定，同一訪問區段 (private 、 public 、 protected) 中的變量，編譯器無權重新排列，不過編譯器有權排列訪問區段的前後順序。基於這個規則， C++ 中有的程序員建議給每一個成員變量放在單獨區段，在每一個成員聲明之前都加上 private: 、 public: 、 protected: 標誌，這可以最大限度的利用編譯器的決策優勢。 &lt;/p&gt;
&lt;p&gt; 在棧中按順序分配的變量，其邊界也受到對齊要求的限制。與在結構中不同的是，棧中的變量還必須保證其後續變量無論是何種類型都可以自由對齊，所以在棧中的變量通常都有平臺相關的對齊最小值。在 MSVC 編譯器上，這個最小值可以由宏 _INTSIZEOF(T) 查詢： &lt;/p&gt;
&lt;p&gt;#define _INTSIZEOF(T) ( (sizeof(T) + sizeof(int) - 1) &amp;amp; ~(sizeof(int) -
1) )&lt;/p&gt;
&lt;p&gt;_INTSIZEOF(T) 會將 sizeof(T) 進位到 sizeof(int) 的整數倍。 &lt;/p&gt;
&lt;p&gt; 由於在棧中分配變量使用 _INTSIZEOF 而不是 sizeof ，在棧上連續分配多個小變量 (sizeof 小於 int 的變量 ) 會造成內存浪費，不如使用結構 (struct) 或數組。也就是說： &lt;/p&gt;
&lt;p&gt;char c1,c2,c3,c4;// 使用 16 字節 &lt;/p&gt;
&lt;p&gt;char c[4];// 使用 4 字節 &lt;/p&gt;
&lt;p&gt; 當然，使用數組的方法在訪問數組變量 ( 比如 c[1]) 時有一次額外的指針運算和提領 (dereference) 操作，這會有執行效率的損失。這又是一種空間 ( 內存佔用 )vs 時間 ( 執行效率 ) 的折中，需要程序員自己根據情況權衡利弊。 &lt;/p&gt;
&lt;p&gt;sizeof 的大小可能比我們預期的大，也可能比我們預期的小。對於空類： &lt;/p&gt;
&lt;p&gt;class Empty {};&lt;/p&gt;
&lt;p&gt; 在通常情況下， sizeof(Empty) 至少爲 1 。這是因爲 C++ 語法規定，對於任何實體類型的兩個變量，都必須具有不同的地址。爲了符合語法要求，編譯器會給 Empty 加入 1 字節的填充。所以 sizeof() 的值不可能出現 0 的情況。可是對於以下的類聲明： &lt;/p&gt;
&lt;p&gt;class A:public Empty{vitual ~A(){}};&lt;/p&gt;
&lt;p&gt;sizeof(A) 有可能是 6 ，也有可能是 5 ，也有可能是 4 ！必不可少的四個字節是一個指向虛函數表的指針。一個可能有的字節是 Empty 的大小，這是是因爲編譯器在特定情況下會將 Empty 視作一個 “ 空基類 ” ，從而實施 “ 空基類優化 ” ，省掉那毫無作用的一字節填充。另一個字節是 A 的一字節填充，因爲從語法上講， A 沒有成員聲明，理應有 1 字節填充，而從語義上講，編譯器給 A 的聲明加入了一個指向虛函數表的指針，從而 A 就不再是一個 “ 空類 ” ，是否實施這個優化，要看編譯器作者對語法措詞的理解。也就是說， sizeof 也會出現 4+1+1=4 的情況。具體要看編譯器有沒有實施 “ 空基類優化 ” 和 “ 含虛函數表的空類優化 ” 。 &lt;/p&gt;
&lt;p&gt; 結構和類的空間中可能有填充的字節，這意味着填充字節中可能有數值，雖然這數值並不影響結構的邏輯狀態，但是它也可能不知不覺中影響到你。比如說，你手頭正好有一組依賴於底層硬件 ( 比如多處理器 ) 的函數，他們在操縱連續字節時比手動編碼要快很多，而你想充分利用這種硬件優勢： &lt;/p&gt;
&lt;p&gt;bool BitCompare(void* begin,void* end,void* another);&lt;/p&gt;
&lt;p&gt; 這個函數將區間 [begin,end) 之間的字節與 another 開始的字節相比較，如果有一位不同就返回 false ，否則返回 true 。 &lt;/p&gt;
&lt;p&gt; 比如你想將這個函數用於你自己的類的 operator== 中，這樣可以利用硬件加快速度。不過你在動手前要充分考慮，你的 class 是否真的要比較每一位。如果在類的成員中存在編譯器填充的字節數，那麼應用以上的函數就是不正確的，因爲填充的字節中可以有不同的值。爲了保證你可以用 Bitwise
Compare ，你必須確保填充的字節中的值也是相同的。這不僅要求你在類的構造函數中初始化類的每一 bit 而不是每一個成員，也要求你在複製初始化和複製賦值函數中也同時保證 bitwise
copy 語義，而不是編譯器默認產生的 memberwise 語義。當然，你可能通過與 BitCompare 一同提供的 BitCopy 來完成這個艱鉅的任務。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.6 I386平臺C函數的可變參數表(Variable Arguments)</title><link href="//farseerfc.github.io/c-tricks-2-6-i386-variable-arguments.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-6-i386-variable-arguments.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h2&gt;2.6 I386 平臺 C 函數的可變參數表 (Variable Arguments)&lt;/h2&gt;
&lt;p&gt; 基於前文 (2.4 節 ) 分析，我們可以不通過函數簽名，直接通過指針運算，來得到函數的參數。由於參數的壓棧和彈出操作都由主調函數進行，所以被調函數對於參數的真實數量不需要知曉。因此，函數簽名中的變量聲明不是必需的。爲了支持這種參數使用形式， C 語言提供可變參數表。可變參數表的語法形式是在參數表末尾添加三個句點形成的省略號 “...” ： &lt;/p&gt;
&lt;p&gt;void g(int a,char* c,...);&lt;/p&gt;
&lt;p&gt; 省略號之前的逗號是可選的，並不影響詞法語法分析。上面的函數 g 可以接受 2 個或 2 個以上的參數，前兩個參數的類型固定，其後的參數類型未知，參數的個數也未知。爲了知道參數個數，我們必須通過其他方法，比如通過第一個參數傳遞： &lt;/p&gt;
&lt;p&gt;g(3,”Hello”,2,4,5);// 調用 g 並傳遞 5 個參數，其中後 3 個爲可變參數。 &lt;/p&gt;
&lt;p&gt; 在函數的實現代碼中，可以通過 2.4 節敘述的，參數在棧中的排列順序，來訪問位於可變參數表的參數。比如 :&lt;/p&gt;
&lt;p&gt;void g(int a,char* c...){&lt;/p&gt;
&lt;p&gt;void *pc=&amp;amp;c;int* pi=static_cast&amp;lt;int*&amp;gt;(pc)+1;// 將 pi 指向首個可變參數 &lt;/p&gt;
&lt;p&gt;for(int i=0;i&amp;lt;a;i++)std::cout&amp;lt;&amp;lt;pi[i]&amp;lt;&amp;lt;” ” ； &lt;/p&gt;
&lt;p&gt;std::cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;std::endl;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 我們甚至可以讓一個函數的所有參數都是可變參數，只要有辦法獲知參數的數量即可。比如，我們約定，在傳遞給 addAll 的參數都是 int ，並且最後一個以 0 結束： &lt;/p&gt;
&lt;p&gt;int addAll(...);&lt;/p&gt;
&lt;p&gt;int a=f(1,4,2,5,7,0);&lt;/p&gt;
&lt;p&gt; 那麼 addAll 可以這樣實現： &lt;/p&gt;
&lt;p&gt;int addAll(...){&lt;/p&gt;
&lt;p&gt;int sum=0;int *p=&amp;amp;sum; //p 指向第一個局部變量 &lt;/p&gt;
&lt;p&gt;p+=3; // 跳過 sum ， ebp ， eip ，現在 p 指向第一個參數 &lt;/p&gt;
&lt;p&gt;for(;*p;++p) // 如果 p 不指向 0 就繼續循環 &lt;/p&gt;
&lt;p&gt;sum+=*p;&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 可變參數表的最廣泛應用是 C 的標準庫函數中的格式化輸入輸出： printf 和 scanf 。 &lt;/p&gt;
&lt;p&gt;void printf(char *c,...);&lt;/p&gt;
&lt;p&gt;void scanf(char *c,...);&lt;/p&gt;
&lt;p&gt; 兩者都通過它的首個參數指出後續參數表中的參數類型和參數數量。 &lt;/p&gt;
&lt;p&gt; 如果可變參數表中的參數類型不一樣，那麼操縱可變參數表就需要複雜的指針運算，並且還要時刻注意邊界對齊 (align) 問題，非常令人頭痛。好在 C 標準庫提供了用於操縱可變參數表的宏 (macro) 和結構 (struct) ，他們被定義在庫文件 stdarg.h 中 :&lt;/p&gt;
&lt;p&gt;typedef struct {char *p;int offset;} va_list;&lt;/p&gt;
&lt;p&gt;#define va_start(valist,arg)&lt;/p&gt;
&lt;p&gt;#define va_arg(valist,type)&lt;/p&gt;
&lt;p&gt;#define va_end(valist)&lt;/p&gt;
&lt;p&gt; 其中結構 va_list 用於指示參數在棧中的位置，宏 va_start 接受一個 va_list 和函數的可變參數表之前的參數，通過第一個參數初始化 va_list 中的相應數據，因此要使用 stdarg.h 中的宏，你的可變參數表的函數必須至少有一個具名參數。 va_arg 返回下一個類型爲 type 的參數， va_end 結束可變參數表的使用。還是以上文的 addAll 爲例，這次寫出它的使用標準宏的版本： &lt;/p&gt;
&lt;p&gt;int addAll(int i,...)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;va_list vl; // 定義一個 va_list 結構 &lt;/p&gt;
&lt;p&gt;va_start(vl,i); // 用省略號之前的參數初始化 vl&lt;/p&gt;
&lt;p&gt;if(i=0)return 0; // 如果第一個參數就是 0 ，返回 &lt;/p&gt;
&lt;p&gt;int sum=i; // 將第一個參數加入 sum&lt;/p&gt;
&lt;p&gt;for(;;){&lt;/p&gt;
&lt;p&gt;i=va_arg(vl,int); // 取得下一個參數，類型是 sum&lt;/p&gt;
&lt;p&gt;if(i==0)break; // 如果參數是 0 ，跳出循環 &lt;/p&gt;
&lt;p&gt;sum+=i;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;va_end(vl);&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 可以看出，如果參數類型一致，使用標準庫要多些幾行代碼。不過如果參數類型不一致或者未知 (printf 的情況 ) ，使用標準庫就要方便很多，因爲我們很難猜出編譯器處置邊界對齊 (align) 等彙編代碼的細節。使用標準庫的代碼是可以移植的，而使用上文所述的其它方法操縱可變參數表都是不可移植的，僅限於在 I386 平臺上使用。 &lt;/p&gt;
&lt;p&gt; 縱使可變參數表有使用上的便利性，它的缺陷也有很多，不可移植性和平臺依賴性只是其一，最大的問題在於它的類型不安全性。使用可變參數表就意味着編譯器不對參數作任何類型檢查，這在 C 中算是一言難盡的歷史遺留問題，在 C++ 中就意味着惡魔 reinterpret_cast 被你喚醒。 C 的可變參數表是 C++ 代碼錯誤頻發的根源之一，以至於 C++ 標準將可變參數表列爲即將被廢除的 C 語言遺留特性。 C++ 語法中的許多新特性，比如重載函數、默認參數值、模板，都可以一定程度上替代可變參數表，並且比可變參數表更加安全。 &lt;/p&gt;
&lt;p&gt; 可變參數表在 C++ 中惟一值得嘉獎的貢獻，是在模板元編程 (TMP) 的 SFINAE 技術中利用可變參數表製作最差匹配重載。根據 C++ 標準中有關函數重載決議的規則，具有可變參數表的函數總是最差匹配，編譯器在被逼無奈走頭無路時纔會選擇可變參數表。利用這一點，我們可以精心製作重載函數來提取類型信息。比如，要判斷一個通過模板傳遞來的類型是不是 int ： &lt;/p&gt;
&lt;p&gt;long isIntImp(int);&lt;/p&gt;
&lt;p&gt;char isIntImp(...);&lt;/p&gt;
&lt;p&gt;template&amp;lt;typename T&amp;gt;&lt;/p&gt;
&lt;p&gt;struct isInt&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;enum{value=sizeof(isIntImp(T()))==sizeof(long);}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 然後，在一個具有模板參數 T 的函數中，我們就可以寫 &lt;/p&gt;
&lt;p&gt;if(isInt&amp;lt;T&amp;gt;::value)//...&lt;/p&gt;
&lt;p&gt; 在這個 ( 不怎麼精緻的 ) 例子中，如果 T 是 int ，那麼 isIntImp 的第一個重載版本就會被選中，返回值類型就是 long ，這樣 value 就爲 1 。否則，編譯器只能選中第二個具有可變參數表的重載版本，返回值類型成爲 char ，這樣 value 就爲 0 。把它說得再明白一些，上文的代碼所表達的意思是：如果類型 T 是 int ，那它就是 int ，否則它就不是 int ，呵呵簡單吧。這種通過重載決議規則來提取類型信息的技術，在模板元編程中被稱作 SFINAE ，它和其它模板元編程技術被廣泛運用於 STL 、 Boost 等模板庫的開發實現之中。 &lt;/p&gt;
&lt;p&gt; 值得注意的是，在上文 SFINAE 的運用中， isIntImp 並沒有出現定義而只提供了聲明，因爲我們並沒有實際調用 isIntImp 函數，而只是讓它參與重載決議並用 sizeof 判斷其返回值類型。這是 C++ 的一個設計準則的完美體現：不需要的東西可以不出現。由於這一準則，我們避免了在 C++ 中調用具有可變參數表的函數這一危險舉動，而僅僅利用了可變參數表在語法分析過程中的特殊地位，這種對於危險語言特性的巧妙利用是善意而無害的。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.7 I386平臺的其它函數調用模型</title><link href="//farseerfc.github.io/c-tricks-2-7-i386-calling-conventions.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-7-i386-calling-conventions.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.7 I386 平臺的其它函數調用模型 &lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 上文介紹的只是 I386 平臺上 C 函數調用的標準模型，被稱作 __cdecl 。事實上， Microsoft Visual C++ 編譯器還支持其它一些函數調用模型，所有調用模型名稱皆以雙下劃線開頭，下面列出所有函數調用模型的異同： &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="cdecl"&gt;
&lt;h3&gt;1 __cdecl&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：逆序 ( 從右至左 )&lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：主調函數 (caller)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__cdecl 明確地指出函數使用 C 函數調用模型，這是默認的調用模型。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stdcall"&gt;
&lt;h3&gt;2 __stdcall&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：逆序 ( 從右至左 )&lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：被調函數 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__stdcall 是微軟所謂的標準調用模型。可惜的是它與 __cdecl 不兼容。幾乎所有的 Win32API 函數使用這種函數調用模型，希望在 DLL 之間，或者在程序和 WinNT 操作系統之間傳遞函數指針的函數也應該使用這種模型。與 __cdecl 模型的不同之處在於， __stdcall 模型下由被調函數恢復堆棧。主調函數在 call 語句之後，不需要再加上 add 語句。而被調函數的 ret 語句則被添加一個參數，代表函數參數堆棧的長度。因此，被調函數需要明確的知曉函數參數的數量和類型，所以在 __stdcall 模型下不支持可變參數表，所有參數必須寫明。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="thiscall"&gt;
&lt;h3&gt;3 __thiscall&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：逆序 ( 從右至左 ) ， this 用 ecx 傳遞。 &lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：被調函數 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__thiscall 是 VC 編譯器中類的非靜態成員函數 (non-static member functon) 的默認調用模型。但是如果此成員函數有可變參數表， VC 編譯器會使用 __cdecl 。和 __stdcall 一樣， __thiscall 由被調函數恢復堆棧。比較獨特的是 __thiscall 會通過 ecx 寄存器傳遞成員函數的 this 指針，而 __cdecl 下 this 指針是通過在參數表最前面增加一個函數參數來傳遞的。 __thiscall 是 VC 編譯器對 this 指針的使用的一種優化，大大提高了面向對象程序的效率。在 VC2003 及之前的編譯器上 __thiscall 不是一個關鍵字，不能被顯式指定。但可以給成員函數顯式指定 __cdecl 來避免使用 __thiscall 。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="fastcall"&gt;
&lt;h3&gt;4 __fastcall&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：逆序 ( 從右至左 ) ，前兩個 32 位函數參數放入 ecx 和 edx 中 &lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：被調函數 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 快速函數調用模型，將前兩個 32 位函數參數放入 ecx 和 edx 中，其餘參數再逆序壓棧。使用的是和 __thiscall 類似的優化技術，加快函數調用，適合運用在小型 inline 函數上。同樣使用 __stdcall 形式的被調函數恢復堆棧，所以不支持可變參數表。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pascal"&gt;
&lt;h3&gt;5 __pascal&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：正序 ( 從左至右 )&lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：被調函數 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 過程式編程語言 Pascal 所使用的函數調用模型，由此得名。也是 16 位版本的 Windows 使用的 API 模型，過時的模型，現在已經廢棄且禁止使用。你會看到有些書本仍會不時提到它，所以需要注意。 __pascal 是正序壓棧，這與大部分 I386 函數模型都不相同。與 __stdcall 一樣，由被調者恢復堆棧，不支持可變參數表。歷史上曾有過的別名 PASCAL 、 pascal 、 _pascal( 單下劃線 ) ，現在都改成了 __stdcall 的別名，與 __pascal( 雙下劃線 ) 不同。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;6  其它函數調用模型，以及模型別名。 &lt;/h3&gt;
&lt;p&gt;__syscall ：操作系統內部使用的函數調用模型，由用戶模式向核心模式跳轉時使用的模型。由於用戶模式和核心模式使用不同的棧，所以沒辦法使用棧來傳遞參數，所有參數通過寄存器傳遞，這限制了參數的數量。用戶模式編程中不允許使用。 &lt;/p&gt;
&lt;p&gt;__fortran ：數學運算語言 fortran 使用的函數模型，由此得名。在 C 中調用由 fortran 編譯的函數時使用。 &lt;/p&gt;
&lt;p&gt;__clrcall ：微軟 .Net 框架使用的函數模型，託管 (Managed)C++ 默認使用，也可以從非託管代碼調用託管函數時使用。參數在託管棧上正序 ( 從左至右 ) 壓棧，不使用普通棧。 &lt;/p&gt;
&lt;p&gt;CALLBACK 、 PASCAL 、 WINAPI 、 APIENTRY 、 APIPRIVATE ： I386 平臺上是 __stdcall 的別名 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;WINAPIV ： I386 平臺上是 __cdecl 的別名 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;7  函數調用模型的指定 &lt;/h3&gt;
&lt;p&gt; 函數調用模型的指定方式和 inline 關鍵字的指定方式相同，事實上， inline 可以被看作是 C++ 語言內建的一種函數調用模型。唯一不同的是，聲明函數指針時，也要指明函數調用模型，而 inline 的指針是不能指明的，根本不存在指向 inline 函數的指針。比如： &lt;/p&gt;
&lt;p&gt;int CALLBACK GetVersion();&lt;/p&gt;
&lt;p&gt;int (CALLBACK * pf)()=GetVersion;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.1 X86概述</title><link href="//farseerfc.github.io/c-tricks-2-1-x86-architecture.html" rel="alternate"></link><updated>2007-08-27T16:33:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-27:c-tricks-2-1-x86-architecture.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="x86"&gt;
&lt;h2&gt;2.1   X86 概述 &lt;/h2&gt;
&lt;p&gt; 所謂 X86 體系結構，是指以 Intel
8086 芯片爲首的芯片所沿襲的 CPU 結構，一些文檔中又被稱作 IA32 體系結構。包括的芯片有但不限於 :Intel
8086 至 80486 ，奔騰 (Pentium) 系列處理器 1 至 4 ，賽揚系列處理器，酷睿系列處理器，以及 AMD 的相應型號產品。 X86 體系結構在早期屬於 16 位處理器，自 80386 之後擴展爲 32 位處理器，所以一些文檔中又把 80386 之後的 32 位處理器體系稱作 I386 。自 Pentium4 後期， AMD 的 Athlon64 開始， I386 被進一步擴充爲 64 位處理器，含有 64 位尋址能力的 X86 體系結構被稱作 X86-64 或 IA32-64 。總之，市售的個人電腦用 CPU ，除蘋果的 Macintosh 之外，全部採用 X86 體系結構芯片。 &lt;/p&gt;
&lt;p&gt; 在 X86 早期， 16 位的尋址能力只支持 64KB(2^16=64K) 內存，這顯然是不夠的。 Intel 採用分段尋址的方法，用 4 位段位 +16 位偏移量，提供了總共 1MB(2^20=1M) 的尋址能力。所以在 X86 的 16 位編程中，有兩種指針類型：長指針 (lp,long
pointer) 和短指針 (sp,short
pointer) ，長指針 (20 位 ) 提供整個內存空間尋址能力，短指針 (16 位 ) 僅支持同一段中的尋址。在 “ 古代 ”DOS 及 Win3.x 編程過程中，兩種類型的指針，以及總共 1MB 的內存大小，常常把程序員們折騰得焦頭爛額。 &lt;/p&gt;
&lt;p&gt; 自 I386 之後， CPU 纔開始提供 32 位的尋址能力。有了整整 4GB(2^32=4G) 的尋址空間，所有指針統一爲長指針 (32 位 ) 。時至今日，我們仍可以看到微軟文檔中指針變量的 lp 前綴。由於內存管理的需要，分段機制被保留下來，但這一次不是因爲地址空間太小，而是因爲地址空間遠大於實際內存容量，從而採用了虛擬內存機制。 &lt;/p&gt;
&lt;p&gt; 在從 16 位結構向 32 位結構轉變的過程中，由於向下兼容的歷史原因，曾一度長時間出現硬件 32 位 (I386) 、軟件 16 位 (Win3.x) 的情況。同樣也是爲了兼容 16 位軟件， Win9x 操作系統 (Win95 、 Win98 、 WinME) 保留了 16 位代碼和 32 位代碼。混合代碼的設計使得 Win9x 及其混亂和不穩定。直到完全 32 位內核的操作系統 WinNT( 以及構建於其上的 Win2000 ， WinXP ， Win2003) 的出現， X86 平臺上內存佈局混亂的局面才得以改善。有了從 16 位至 32 位移植的經驗和準備，現今的從 32 位到 64 位的操作系統移植顯得平穩順利很多。 WinXP 和 WinVista 系統都同時發佈了 32 位版本和 64 位版本，並且其 x86-64 系統都實現了對 32 位軟件的無縫銜接支持。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 1.2 逗號運算符(,)、邏輯運算符(&amp;&amp;,||)與運算符重載的陷阱</title><link href="//farseerfc.github.io/c-tricks-1-2-trap-in-comma-logical-operator.html" rel="alternate"></link><updated>2007-08-22T18:06:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-22:c-tricks-1-2-trap-in-comma-logical-operator.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.2    逗號運算符 (,) 、邏輯運算符 (&amp;amp;&amp;amp;,||) 與運算符重載的陷阱 &lt;/h2&gt;
&lt;p&gt; 很多人甚至不知道逗號 (,) 也是個 C++ 運算符。與語法上要求出現的逗號 ( 比如分隔函數參數的逗號 ) 不同的是，出現在表達式中的逗號運算符在語義上表示多個表達式操作的連續執行，類似於分隔多語句的分號。比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt;(&lt;strong&gt;int&lt;/strong&gt;i=0,j=9;i&amp;lt;10;++i&lt;strong&gt;,&lt;/strong&gt;--j)std::cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;”+”&amp;lt;&amp;lt;j&amp;lt;&amp;lt;”=9\n”;&lt;/p&gt;
&lt;p&gt; 在這句語句中，出現了兩個逗號，其中前者是語法上用來分隔聲明的變量的，並非逗號運算符，而後者則是一個逗號運算符。根據 C++ 標準，逗號運算符的執行順序爲從左到右依次執行，返回最後一個子表達式的結果。由於只有最後一個表達式返回結果，所以對於一個語義正常的逗號表達式而言，前幾個子表達式必須具有副作用。同時，從語言的定義中也可以看出，逗號表達式對求值的順序有嚴格要求。 &lt;/p&gt;
&lt;p&gt; 對求值順序有要求的，除了逗號表達式和條件表達式 ( 參見 1.1) ，在 C++ 中還有邏輯運算符 (&amp;amp;&amp;amp; 和 ||) 。邏輯運算相較於數學運算和位運算而言，有個顯著的不同點：邏輯運算在計算到一半時，就有可能已經得到結果，這樣繼續運算另一半就不是必需的。對於 A&amp;amp;&amp;amp;B ，如果 A=false ，那麼無論 B 爲何值，整個的結果都是 false ；同樣的 A||B ，如果 A=true ，那麼不考慮 B ，結果一定是 true 。 &lt;/p&gt;
&lt;p&gt;C++ 標準規定，如果邏輯運算到一半 ( 算出 A) 時，就已經可以確定運算的結果，那麼就不運算剩下的另一半 (B) 。這種執行語義被稱作 “ 短路 ” 。在其它一些編程語言中，短路語義是可以選擇的：在 Ada 裏非短路的邏輯運算符爲 and 和 or ，短路的邏輯運算符爲 and_then 和 or_else 。但是在 C++ 中，邏輯運算符的短路語義是語法上強制的，我們沒有非短路版本的運算符。如果確實需要非短路語義，我們總是可以通過增加一個 bool 中間變量加以解決。有時，短路對於保證正確執行是必須的，比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char&lt;/strong&gt;*p=getString();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(p&lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;*p)std::cout&amp;lt;&amp;lt;p;&lt;/p&gt;
&lt;p&gt; 這段代碼在得到了一個字符串後，在字符串不爲空時輸出它。在 C++ 中判斷一個字符串不爲空需要兩個步驟：判斷指針是否爲 0 ，以及指針不爲 0 時判斷指針指向的內容是否爲 ’’ 。就像條件表達式中討論到的 ( 參見 1.1) ，在 p 爲空時提領 p 是個極其危險的操作。邏輯運算符的短路語義則避免了這種危險。 &lt;/p&gt;
&lt;p&gt; 以上對逗號運算符與邏輯運算符的討論，僅限於 C++ 標準所定義的運算符語義。爲什麼這樣說呢？這是因爲在 C++ 中，運算符的語義是可以由程序員自行定義的，這種機制叫做運算符重載 (operator
overload) 。運算符重載可以將人們熟悉的運算符表達式轉換成函數調用，使編程靈活而直觀，是個方便的語言特性。不過有時運算符重載也會使人困擾，那就是當運算符重載遇到求值順序問題時。 &lt;/p&gt;
&lt;p&gt;C++ 中，並不是所有合法運算符都可以被合法地重載。條件運算符雖然對求值順序有要求，但它並不在可重載運算符之列，所以運算符重載機制對它沒有影響。問題在於，逗號運算符和邏輯運算符都可以被合法地重載： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class&lt;/strong&gt; BadThing{/* Some Bad and Stupid Thing*/};&lt;/p&gt;
&lt;p&gt;BadThing&amp;amp; &lt;strong&gt;operator&lt;/strong&gt;,(BadThing&amp;amp;, BadThing&amp;amp;);// 重載了逗號運算符 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bool&lt;/strong&gt; &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(BadThing&amp;amp;, BadThing&amp;amp;);// 重載了 &amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;BadThing b1,b2;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(b1&amp;amp;&amp;amp;b2)b1,b2;// 被替換成如下形式： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(b1,b2))&lt;strong&gt;operator&lt;/strong&gt;,(b1,b2);&lt;/p&gt;
&lt;p&gt; 可以看到，重載了運算符之後，對運算符的使用被替換爲相應的函數調用形式。因此，舊有的運算符的執行順序不再適用，取而代之的是函數參數的壓棧順序。 &lt;/p&gt;
&lt;p&gt; 根據 C++ 標準規定，任何參數必須在進入函數之前壓棧，所以在進入 &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp; 之前， b1 、 b2 就會被求值，這裏不再有短路規則，任何依賴於短路語義的不知不覺間操作 BadThing 的代碼 ( 可能通過模板 ) 都會混亂。 &lt;/p&gt;
&lt;p&gt; 短路語義只是一個方面，更重要的在於壓棧順序。鑑於執行效率和舊代碼兼容性等細節問題， C++ 標準在壓棧順序上給編譯器的開發者留有很大自主性。標準的說辭是，編譯器可能以任何它覺得方便的順序將參數壓棧，從左到右，從右到左，甚至從中間到兩邊，在這一點上我們不能安全地做任何假設。在上面的例子中，編譯器生成的代碼可能先計算 b1 再計算 b2 ，也可能是相反的順序。再看看編譯器的實際情況，在我試過的所有基於 X86 體系結構的編譯器中，參數都是以逆向壓棧，即從右到左，有悖於大多數人的閱讀習慣和直覺 ( 別說你是來自伊斯蘭的 ……) 。 &lt;/p&gt;
&lt;p&gt; 在 C 時代使用函數調用時，壓棧順序並不是什麼大問題，畢竟大多數人會在函數調用的邊界稍稍小心一些。但是到了 C++ 中，事情變得有些複雜，因爲簡單如 a+b 的使用，就有可能被運算符重載機制替換爲函數調用。更何況有模板參與之後，我們寫代碼時不能確定對象的真實類型，也就無法預知一個運算符是否真的被重載過，唯一穩妥的方法是，假定任何有可能被重載的運算符的使用都是函數調用。 &lt;/p&gt;
&lt;blockquote&gt;
&amp;lt;p style="margin:0;"&amp;gt;&lt;/blockquote&gt;
&lt;p&gt; 回到上文的示例中，由於 , 和 &amp;amp;&amp;amp; 都被替換爲函數調用，程序的執行順序將成爲壓棧順序，在 X86 上很有可能是從右到左，與標準定義的運算符的順序正好相反。逗號運算符原本就含有 “ 先 … 後 …” 的語義，這種顛倒的執行順序勢必造成程序和程序員的混亂。以我的經驗而言，含有 &lt;strong&gt;operator&lt;/strong&gt;, 的類，完全沒有辦法和 STL 或者 iostream 相互協作，反而會導致巨量的錯誤報告 ( 什麼叫巨量的錯誤報告有概念麼？如果沒有，那說明你還沒玩過範式編程 (GP,
Generic
Programming) 。去玩玩 GP 吧，看看你的編譯器對巨量的定義。在我手頭，針對 3.5KB 的代碼文件傾瀉出 3.8&lt;strong&gt;MB&lt;/strong&gt; 的錯誤信息的編譯器不在少數 ……) 。有鑑於此，我的結論是，除非你有充足的依據支持你這麼做 ( 比如你的粗暴上司的鍵盤上只剩下逗號能用 ) ，並且你清楚的瞭解這麼做的後果的嚴重性 ( 比如至少要看過此文 ) ，否則我奉勸你，永遠不要碰 &lt;strong&gt;operator&lt;/strong&gt;, 、 &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp; 以及 &lt;strong&gt;operator&lt;/strong&gt;|| ！ &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 1.1 條件運算符(?:)</title><link href="//farseerfc.github.io/c-tricks-1-1-conditional-operator.html" rel="alternate"></link><updated>2007-08-22T18:05:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-22:c-tricks-1-1-conditional-operator.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.1    條件運算符 (?:)&lt;/h2&gt;
&lt;p&gt; 條件運算符 (?:) 是 C++ 中唯一的三目運算符 (trinary
operator) ，用於在表達式中作條件判斷，通常可以替換 if 語句，與 Visual
Basic 中的 iif 函數、 Excel 中的 if 函數有同樣的作用。語法形式如下： &lt;/p&gt;
&lt;p&gt;&lt;em&gt;condition&lt;/em&gt; ? &lt;em&gt;true_value&lt;/em&gt; : &lt;em&gt;false_value&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 其中 &lt;em&gt;condition
* 條件是任何可以轉換爲 bool 類型的表達式，包括但不僅限於 **bool*&lt;/em&gt; 、 &lt;strong&gt;int&lt;/strong&gt; 、指針。與 &lt;strong&gt;if&lt;/strong&gt; 和 &lt;strong&gt;while&lt;/strong&gt; 的條件部分稍顯不同的是，這裏不能定義變量，否則會導致語法錯誤。 &lt;/p&gt;
&lt;p&gt; 另外，條件語句會切實地控制執行流程，而不僅僅是控制返回值。也就是說，兩個返回值表達式中永遠只有一個會被求值，在表達式的執行順序很重要時，這點尤爲值得注意。比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=pi&lt;strong&gt;?&lt;/strong&gt;*pi&lt;strong&gt;:&lt;/strong&gt;0;&lt;/p&gt;
&lt;p&gt; 這裏，只有當 pi 的值不爲 0 時，它纔會被提領 (dereference) 。這種語義保證了程序的正確性，因爲提領一個空指針將導致致命的運行期錯誤 ( 通常是非法操作的警告 ) 。同時，正因爲條件運算符控制運算流程的特點，使得它不能用類似 iif 的普通函數來模擬： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; iif(&lt;strong&gt;int&lt;/strong&gt; con,&lt;strong&gt;int&lt;/strong&gt; t,&lt;strong&gt;int&lt;/strong&gt;f){&lt;strong&gt;if&lt;/strong&gt;(c)&lt;strong&gt;return&lt;/strong&gt; t;&lt;strong&gt;return&lt;/strong&gt; f;}// 試圖模擬 ?:&lt;/p&gt;
&lt;p&gt;…//in some function&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=iif(pi,*pi,0);//Error!&lt;/p&gt;
&lt;p&gt; 這段代碼會導致上文提到的致命運行期錯誤。 C/C++ 標準規定，參數在被傳遞給函數之前求值，因此無論 pi 爲何值，都會被提領。又因爲函數傳回一個空指針的情況比較少見，所以這樣的錯誤在調試時很難被發現，一旦發生又勢必造成重大災難。這樣的代碼在實踐中應儘量避免。 &lt;/p&gt;
&lt;p&gt; 有時，條件運算符控制流程的特點會不知不覺影響我們的代碼。在 C 時代，最大值 MAX 通常用宏實現： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#define&lt;/strong&gt;MAX(a,b) ((a)&amp;gt;(b)&lt;strong&gt;?&lt;/strong&gt;(a)&lt;strong&gt;:&lt;/strong&gt;(b))&lt;/p&gt;
&lt;p&gt; 需要用額外的括號將宏參數和宏本體保護起來，以免運算符優先級擾亂邏輯，這是宏醜陋的特點之一，這裏暫且不提。矛盾在於，用具有副作用的表達式調用宏時，會出現問題： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=5,j=6;//…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=MAX(++i,++j);&lt;/p&gt;
&lt;p&gt; 代碼的作者原意顯然是想先將 i,j 分別遞增，再將其中較大的一個賦給 a 。執行這段代碼，當 i=5,j=6 時， a=8 ，知道爲什麼嗎？通過宏展開，賦值語句成這樣： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=(++i)&amp;gt;(++j)&lt;strong&gt;?&lt;/strong&gt;(++i)&lt;strong&gt;:&lt;/strong&gt;(++j);// 刪除了多餘括號 &lt;/p&gt;
&lt;p&gt; 在判斷之前， i 、 j 被分別自增一次，然後捨棄 : 之前的部分， j 又被自增一次。執行之後， i=6,j=8 。 &lt;/p&gt;
&lt;p&gt;MAX 的更正確更安全的實現，是利用模板將類型參數化。 STL 標準算法中就有一個這樣的工具級模版函數 std::max 。 &lt;/p&gt;
&lt;p&gt; 條件運算符是表達式而不是語句，這使得它可以出現在任何需要表達式的地方，這擴大了它的適用範圍。在那些語法上只能出現表達式而不能出現語句的地方（比如變量初始化），條件運算符有着不可替代的作用。 &lt;/p&gt;
&lt;p&gt; 條件運算符優於 &lt;strong&gt;if&lt;/strong&gt; 語句的另一個場合是 “ 模板元編程 ”(TMP, Template
MetaProgramming) 。在 TMP 這個古怪奇異的編譯期運算編程技術中，一切舊有的技術和法則被全線擊破，我們所能仰仗的工具，只有模板特化 (Specialization) 、 &lt;strong&gt;typedef&lt;/strong&gt;s 、函數聲明 ( 無法調用它們 ) 、以及編譯期常量運算。已經有人很深入地論證過，僅有以上這些，就已經形成了一個 “ 圖靈完善 ” 的計算機語言。我們可以用模板特化技術，來模擬條件分支，循環迭代等一系列複雜的語言結構。由於可以參與編譯期常量運算，條件運算符在 TMP 世界中很自然地扮演起重要角色。 &lt;/p&gt;
&lt;p&gt; 比如，給與類型 T 的一個變量 t ，我們想聲明一個緩衝區存放 t 和一個 int ，緩衝區的大小不小於 sizeof(T) 也不小於 sizeif(int) ，我們可以這樣寫： &lt;/p&gt;
&lt;p&gt;char buffer[sizeof(T)&amp;gt;sizeof(int)? sizeof(T): sizeof(int)];&lt;/p&gt;
&lt;p&gt; 我們不能用一個 if 語句替換這個運算： &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;if(sizeof(T)&amp;gt;sizeof(int))i=sizeof(T);&lt;/p&gt;
&lt;p&gt;else i=sizeof(int);&lt;/p&gt;
&lt;p&gt;char buffer[i];// 語法錯誤 !&lt;/p&gt;
&lt;p&gt; 原因在於數組聲明中的下標必須是一個編譯期常量，而不是一個運行期的值，條件表達式的運算可以在編譯期進行， if 語句就只能在執行期執行。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>填補信仰、喚醒良知</title><link href="//farseerfc.github.io/filling-believings-calling-conscience.html" rel="alternate"></link><updated>2006-08-07T21:36:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2006-08-07:filling-believings-calling-conscience.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;p&gt; 填補信仰、喚醒良知 &lt;/p&gt;
&lt;p&gt; 我們聽盡了呼籲與號召，對於良知，我不必譴責喪失它的國人，不必盛讚良知的美好。我只想討論，喪失了良知的原因 —— 空缺的信仰。 &lt;/p&gt;
&lt;p&gt; 一、空缺信仰喪失良知 &lt;/p&gt;
&lt;p&gt; 現代的國人缺少信仰，以至於喪失良知。曾幾何時，中華民族由良好的信仰凝聚而成。三皇五帝時，族民們以炎黃爲信仰；春秋戰國時，士大夫之族以周制禮樂爲信仰；漢代以後，百姓延習孔孟之說、老聃之道，以儒家學說爲信仰；自大唐起，以佛教爲首的現代宗教紛紛傳入中原，人民開始以它們作爲信仰。 &lt;/p&gt;
&lt;p&gt; 直至鴉片戰爭、五四運動，西方文化入侵中華，國人開始拋棄國學，轉而去研究科學；文化大革命，十年文化浩劫，人們批判舊的信仰，卻沒有合適的新的信仰前來填補。從此，國人的信仰出現空缺，國人的良知也被一塊塊蠶食殆盡。 &lt;/p&gt;
&lt;p&gt; 二、信仰、科學、迷信 &lt;/p&gt;
&lt;p&gt; 在許多國人的心目中，信仰就等於迷信。從小到大的教育告訴我們，信奉宗教是愚昧而又無知的表現，科學與信仰是矛盾的。是麼？ &lt;/p&gt;
&lt;p&gt; 我們無法保證社會上的每一個人都接受過良好的教育，我們無法確信最前沿的科學素養能在民衆中普及。在科普與教育力不從心的社會死角，在科學技術尚不能及的文化盲區，我們依舊需要信仰的規範與限制，我們的良知需要信仰！ &lt;/p&gt;
&lt;p&gt; 信仰不等於迷信。信仰本身無所謂謎與不迷，迷信是持有信仰的人誤解了信仰，盲目遵從的結果。以爲燒過香就可以免遭禍患，以爲捐了錢就可以升入天堂，以爲引火自焚就可以功德圓滿，這便是迷信了。希特勒曾經的人類完善計劃，依照遺傳學的原理，將科學家與運動員強行結爲夫婦孕育生命，希望得到最優秀的人類種族，這便是對科學這種信仰的迷信！ &lt;/p&gt;
&lt;p&gt; 由此可見，科學與信仰並不是矛盾的硬幣的兩面，從某種意義而言科學本身也是信仰的一種。雖然歷史上宗教往往作爲科學發展的阻礙，可信奉真理的信念一直是推動科學發展的動力。牛頓就曾說過，對自然規律的探詢是爲了更接近上帝。由此可見，信仰與真理，與良知毫無矛盾。 &lt;/p&gt;
&lt;p&gt; 三、信仰喚醒良知 &lt;/p&gt;
&lt;p&gt; 很少有人仔細思考過，良知的缺失是由信仰的缺失造成的。信仰是人思想的寄託與依靠，是人行動處世的準則。沒有了信仰的人，思想行爲就缺少了約束的標準，人就更容易因爲一時不成熟的衝動，背叛良知、鑄成錯誤。 &lt;/p&gt;
&lt;p&gt; 泰國人以佛教爲信仰，泰國的寺廟每天都會有成千上萬人頂禮膜拜。寺廟有一個人盡皆知的不成文規定：不得穿鞋進入。於是在寺廟之外，遊客們可以看到千百雙各式的鞋子有序的擺放在門口。國人每每看到此景，總會詫異地問：沒有人會偷鞋麼？得到的答案極爲簡單：廟前偷鞋會遭報應。由於擁有信仰，泰國人作了壞事會受到良知的譴責，泰國商人售出假貨會徹夜難眠。二戰期間，無數猶太難民被天主教會收留藏匿從而僥倖逃生，這同樣是出於，天主教徒們被自己信奉的教義 “ 衆生生來平等 ” ，所喚醒的良知。 &lt;/p&gt;
&lt;p&gt; 天下無賊的世界，不能僅靠科普說教來營造。如果脫離了信仰，縱使是教育也無法培養良知。我問過許多修化學的同學，學習化學的意義，結論竟是爲了考試。如果沒有對科學的信仰，我們可以牢記公式定理，卻質疑它們是真理；如果沒有對社會公德的信仰，我們可以熟背交通規則，卻正大光明地闖紅燈；如果沒有對醫療道德的信仰，醫生可以放任傷口發炎，從而留住病人繼續治療 ……&lt;/p&gt;
&lt;p&gt; 國人需要信仰的約束，需要填補信仰的空白，從而喚醒那深埋於每個國人內心深處的良知！ &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</summary></entry></feed>