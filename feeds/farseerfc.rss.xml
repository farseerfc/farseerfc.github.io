<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Farseerfc的小窩</title><link>//farseerfc.github.io/</link><description></description><atom:link href="//farseerfc.github.io/feeds/farseerfc.rss.xml" rel="self"></atom:link><lastBuildDate>Fri, 12 Dec 2014 17:06:00 +0900</lastBuildDate><item><title>從非緩衝輸入流到 Linux 控制檯的歷史</title><link>//farseerfc.github.io/from-unbuffered-stdin-to-history-of-linux-tty.html</link><description>&lt;html&gt;&lt;body&gt;
&lt;p&gt; 這篇也是源自於水源 C 板上板友的一個問題，涉及 Linux 上的控制檯的實現方式和歷史原因。因爲內容比較長，所以在這裏再排版一下發出來。 &lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1418138991,file,M.1418138991.A.html"&gt; 原帖在這裏 &lt;/a&gt;  。 &lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt; 可以設置不帶緩衝的標準輸入流嗎？ &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;WaterElement(UnChanged)  於 2014 年 12 月 09 日 23:29:51  星期二   問到： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 請問對於標準輸入流可以設置不帶緩衝嗎？比如以下程序 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 似乎還是需要在命令行輸入後按回車纔會讓 &lt;code class="code"&gt;
fgets&lt;/code&gt;
  返回，不帶緩衝究竟體現在哪裏？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt; 這和緩存無關，是控制檯的實現方式的問題。 &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 再講細節一點，這裏有很多個程序和設備。以下按 linux  的情況講： &lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 終端模擬器窗口（比如 xterm ）收到鍵盤事件 &lt;/li&gt;
&lt;li&gt; 終端模擬器 (xterm) 把鍵盤事件發給虛擬終端  pty1&lt;/li&gt;
&lt;li&gt;pty1  檢查目前的輸入狀態，把鍵盤事件轉換成 stdin  的輸入，發給你的程序 &lt;/li&gt;
&lt;li&gt; 你的程序的 c  庫從 stdin  讀入一個輸入，處理 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 標準庫說的輸入緩存是在 4  的這一步進行的。而行輸入是在 3  的這一步被緩存起來的。 &lt;/p&gt;
&lt;p&gt; 終端 pty 有多種狀態，一般控制檯程序所在的狀態叫「回顯行緩存」狀態，這個狀態的意思是 :&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 所有普通字符的按鍵，會回顯到屏幕上，同時記錄在行緩存區裏。 &lt;/li&gt;
&lt;li&gt; 處理退格 ( &lt;kbd class="kbd"&gt;
BackSpace&lt;/kbd&gt;
 ) ，刪除 ( &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;
 ) 按鍵爲刪掉字符，左右按鍵移動光標。 &lt;/li&gt;
&lt;li&gt; 收到回車的時候把整個一行的內容發給 stdin 。 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 參考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Cooked_mode"&gt;http://en.wikipedia.org/wiki/Cooked_mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 同時在 Linux/Unix 下可以發特殊控制符號給 pty 讓它進入「 raw 」狀態，這種狀態下按鍵不會被回顯，顯示什麼內容都靠你程序自己控制。如果你想得到每一個按鍵事件需要用 raw 狀態，這需要自己控制回顯自己處理緩衝，簡單點的方法是用 readline  這樣的庫（基本就是「回顯行緩存」的高級擴展，支持了 Home/End ，支持歷史）或者 ncurses  這樣的庫（在 raw 狀態下實現了一個簡單的窗口 /  事件處理框架）。 &lt;/p&gt;
&lt;p&gt; 參考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/POSIX_terminal_interface#History"&gt;http://en.wikipedia.org/wiki/POSIX_terminal_interface#History&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 除此之外， &lt;kbd class="kbd"&gt;
Ctrl-C&lt;/kbd&gt;
  轉換到 &lt;span class="caps"&gt;SIGINT&lt;/span&gt;  ， &lt;kbd class="kbd"&gt;
Ctrl-D&lt;/kbd&gt;
  轉換到 &lt;span class="caps"&gt;EOF&lt;/span&gt;  這種也是在 3  這一步做的。 &lt;/p&gt;
&lt;p&gt; 以及，有些終端模擬器提供的 &lt;kbd class="kbd"&gt;
Ctrl-Shift-C&lt;/kbd&gt;
  表示複製這種是在 2  這一步做的。 &lt;/p&gt;
&lt;p&gt; 以上是 Linux/unix  的方式。  Windows 的情況大體類似，只是細節上有很多地方不一樣： &lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 窗口事件的接收者是創建 cmd  窗口的 Win32  子系統。 &lt;/li&gt;
&lt;li&gt;Win32 子系統接收到事件之後，傳遞給位於命令行子系統的 cmd  程序 &lt;/li&gt;
&lt;li&gt;cmd  程序再傳遞給你的程序。 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Windows 上同樣有類似行緩存模式和 raw 模式的區別，只不過實現細節不太一樣。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="strace"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;strace 查看了下 &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WaterElement(UnChanged)  於 2014 年 12 月 10 日 21:53:54  星期三   回復： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 感謝 FC 的詳盡解答。 &lt;/p&gt;
&lt;p&gt; 用 strace 查看了下，設置標準輸入沒有緩存的話讀每個字符都會調用一次 &lt;code class="code"&gt;
read&lt;/code&gt;
  系統調用，   比如輸入 abc ： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;read(0, abc
"a", 1)                         = 1
read(0, "b", 1)                         = 1
read(0, "c", 1)                         = 1
read(0, "\n", 1)                        = 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果有緩存的話就只調用一次了 &lt;code class="code"&gt;
read&lt;/code&gt;
  系統調用了： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;read(0, abc
"abc\n", 1024)                  = 4
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="raw-mode"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt; 如果想感受一下 raw mode&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 沒錯，這個是你的進程內 C 庫做的緩存， tty 屬於字符設備所以是一個一個字符塞給你的   程序的。 &lt;/p&gt;
&lt;p&gt; 如果想感受一下 raw mode  可以試試下面這段程序（沒有檢測錯誤返回值） &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;termios.h&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ttyfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/* reset tty - useful also for restoring the terminal when this process&lt;/span&gt;
&lt;span class="cm"&gt;   wishes to temporarily relinquish the tty&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="cm"&gt;/* flush and reset */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="cm"&gt;/* put terminal in raw mode - see termio(7I) for modes */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;raw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* copy original and then modify below */&lt;/span&gt;

    &lt;span class="cm"&gt;/* input modes - clear indicated ones giving: no break, no CR to NL,&lt;/span&gt;
&lt;span class="cm"&gt;       no parity check, no strip char, no start/stop output (sic) control */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_iflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BRKINT&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICRNL&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;INPCK&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISTRIP&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IXON&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* output modes - clear giving: no post processing such as NL to CR+NL */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_oflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OPOST&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* control modes - set 8 bit chars */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cflag&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CS8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* local modes - clear giving: echoing off, canonical off (no erase with&lt;/span&gt;
&lt;span class="cm"&gt;       backspace, ^U,...),  no extended functions, no signal chars (^Z,^C) */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_lflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ECHO&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICANON&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IEXTEN&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISIG&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* control chars - set return condition: min number of bytes and timer */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after 5 bytes or .8 seconds&lt;/span&gt;
&lt;span class="cm"&gt;                                                after first byte seen      */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* immediate - anything       */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after two bytes, no timer  */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after a byte or .8 seconds */&lt;/span&gt;

    &lt;span class="cm"&gt;/* put terminal in raw mode after flushing */&lt;/span&gt;
    &lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;atexit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt; 終端上的字符編程 &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;vander( 大青蛙 )  於 2014 年 12 月 12 日 08:52:20  星期五   問到： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 學習了！ &lt;/p&gt;
&lt;p&gt; 進一步想請教一下 fc 大神。如果我在 Linux 上做終端上的字符編程，是否除了用 ncurses 庫之外，也可以不用該庫而直接與終端打交道，就是你所說的直接在 raw 模式？另外，終端類型 vt100 和 linux 的差別在哪裏？爲什麼 Kevin Boone 的 KBox 配置手冊裏面說必須把終端類型設成 linux ，而且要加上 terminfo 文件，才能讓終端上的 vim 正常工作？ term info 文件又是幹什麼的？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;Linux 控制檯的歷史 &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 嗯理論上可以不用 ncurses  庫直接在 raw  模式操縱終端。 &lt;/p&gt;
&lt;p&gt; 這裏稍微聊一下 terminfo/termcap 的歷史，詳細的歷史和吐槽參考 &lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater’s Handbook&lt;/a&gt;
 第 6 章 Terminal Insanity 。 &lt;/p&gt;
&lt;p&gt; 首先一個真正意義上的終端就是一個輸入設備（通常是鍵盤）加上一個輸出設備（打印機或者顯示器）。很顯然不同的終端的能力不同，比如如果輸出設備是打印機的話，顯示出來的字符就不能刪掉了（但是能覆蓋），而且輸出了一行之後就不能回到那一行了。再比如顯示器終端有的支持粗體和下劃線，有的支持顏色，而有的什麼都不支持。早期 Unix 工作在電傳打字機（ TeleTYpe ）終端上，後來 Unix 被 port 到越來越多的機器上，然後越來越多類型的終端會被連到 Unix 上，很可能同一臺 Unix 主機連了多個不同類型的終端。由於是不同廠商提供的不同的終端，能力各有不同，自然控制他們工作的方式也是不一樣的。所有終端都支持回顯行編輯模式，所以一般的面向行的程序還比較好寫，但是那時候要撰寫支持所有終端的「全屏」程序就非常痛苦，這種情況就像現在瀏覽器沒有統一標準下寫 HTML 要測試各種瀏覽器兼容性一樣。   通常的做法是 &lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 使用最小功能子集 &lt;/li&gt;
&lt;li&gt; 假設終端是某個特殊設備，不管別的設備。 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 水源的代碼源頭 Firebird2000  就是那樣的一個程序，只支持固定大小的 vt102 終端。 &lt;/p&gt;
&lt;p&gt; 這時有一個劃時代意義的程序出現了，就是 vi ，試圖要做到「全屏可視化編輯」。這在現在看起來很簡單，但是在當時基本是天方夜譚。 vi  的做法是提出一層抽象，記錄它所需要的所有終端操作，然後有一個終端類型數據庫，把那些操作映射到終端類型的具體指令上。當然並不是所有操作在所有終端類型上都支持，所以會有一堆 fallback ，比如要「強調」某段文字，在彩色終端上可能 fallback  到紅色，在黑白終端上可能 fallback  到粗體。 &lt;/p&gt;
&lt;p&gt;vi  一出現大家都覺得好頂讚，然後想要寫更多類似 vi  這樣的全屏程序。然後 vi  的作者就把終端抽象的這部分數據庫放出來形成一個單獨的項目，叫 termcap  （ Terminal
Capibility ），對應的描述終端的數據庫就是 termcap  格式。然後 termcap  只是一個數據庫（所以無狀態）還不夠方便易用，所以後來又有人用 termcap  實現了 curses  。 &lt;/p&gt;
&lt;p&gt; 再後來大家用 curses/termcap  的時候漸漸發現這個數據庫有一點不足：它是爲 vi  設計的，所以只實現了 vi  需要的那部分終端能力。然後對它改進的努力就形成了新的 terminfo  數據庫和 pcurses  和後來的 ncurses  。然後 &lt;span class="caps"&gt;VIM&lt;/span&gt;  出現了自然也用 terminfo  實現這部分終端操作。 &lt;/p&gt;
&lt;p&gt; 然後麼就是 X  出現了， xterm  出現了，大家都用顯示器了，然後 xterm  爲了兼容各種老程序加入了各種老終端的模擬模式。不過因爲最普及的終端是 vt100  所以 xterm  默認是工作在兼容 vt100  的模式下。然後接下來各種新程序（偷懶不用 *curses 的那些）都以 xterm/vt100  的方式寫。 &lt;/p&gt;
&lt;p&gt; 嗯到此爲止是 Unix  世界的黑歷史。 &lt;/p&gt;
&lt;p&gt; 知道這段歷史的話就可以明白爲什麼需要 &lt;span class="caps"&gt;TERM&lt;/span&gt;  變量配合 terminfo  數據庫纔能用一些 Unix  下的全屏程序了。類比一下的話這就是現代瀏覽器的  user-agent 。 &lt;/p&gt;
&lt;p&gt; 然後話題回到 Linux  。大家知道 Linux  早期代碼不是一個 &lt;span class="caps"&gt;OS&lt;/span&gt; ，而是 Linus  大神想在他的嶄新蹭亮的 386-&lt;span class="caps"&gt;PC&lt;/span&gt;  上遠程登錄他學校的 Unix  主機，接收郵件和逛水源（咳咳）。於是 Linux  最早的那部分代碼並不是一個通用 &lt;span class="caps"&gt;OS&lt;/span&gt;  而只是一個 bootloader  加一個終端模擬器。所以現在 Linux  內核裏還留有他當年實現的終端模擬器的部分代碼，而這個終端模擬器的終端類型就是 linux  啦。然後他當時是爲了逛水源嘛所以 linux  終端基本上是 vt102  的一個接近完整子集。 &lt;/p&gt;
&lt;p&gt; 說到這裏脈絡大概應該清晰了， xterm 終端類型基本模擬 vt100 ， linux 終端類型基本模擬 vt102 。這兩個的區別其實很細微，都是同一個廠商的兩代產品嘛。有差別的地方差不多就是 &lt;kbd class="kbd"&gt;
Home&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
End&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageUp&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageDown&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;

 這些不在 &lt;span class="caps"&gt;ASCII&lt;/span&gt;  控制字符表裏的按鍵的映射關係不同。 &lt;/p&gt;
&lt;p&gt; 嗯這也就解釋了爲什麼在 linux 環境的圖形界面的終端裏 telnet  上水源的話，上面這些按鍵會錯亂 ……  如果設置終端類型是 linux/vt102  的話就不會亂了。在 linux  的 &lt;span class="caps"&gt;TTY&lt;/span&gt;  裏 telnet  也不會亂的樣子。 &lt;/p&gt;
&lt;p&gt; 寫到這裏纔發現貌似有點長 ……  總之可以參考 &lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater’s Handbook&lt;/a&gt;  裏的相關歷史評論和吐槽，那一段非常有意思。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Fri, 12 Dec 2014 17:06:00 +0900</pubDate><guid>tag:farseerfc.github.io,2014-12-12:from-unbuffered-stdin-to-history-of-linux-tty.html</guid><category>c</category><category>linux</category><category>stdio</category><category>tty</category><category>unix</category><category>ugh</category><category>ncurses</category><category>termcap</category><category>terminfo</category></item><item><title>KDE5 Plasma 之跳動賣萌的活動按鈕</title><link>//farseerfc.github.io/jumping-kde5-plasma-activities-button.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 今天嘗試 &lt;span class="caps"&gt;KDE5&lt;/span&gt; Plasma  的活動的時候無意間發現這個現象。只要把活動按鈕拖出桌面，它就會在桌面邊緣來回跳動。   視頻如下： &lt;/p&gt;

&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/SSbf97jGSpI"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;div align="left" class="embed-responsive embed-responsive-16by9"&gt;&lt;embed align="middle" allowfullscreen="true" allowscriptaccess="always" class="embed-responsive-item" quality="high" src="http://player.youku.com/player.php/sid/XODQ0NjM2MzQ4/v.swf" type="application/x-shockwave-flash"&gt;&lt;/embed&gt;&lt;/div&gt;&lt;p&gt; 當然你可以把它再拖回來，所以這個問題還無傷大雅，只是賣萌。 &lt;/p&gt;
&lt;p&gt; 比比之前 Gnome3  那個跳動的界面真是好太多了： &lt;/p&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/TRQJdRHYwrw"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;div align="left" class="embed-responsive embed-responsive-16by9"&gt;&lt;embed align="middle" allowfullscreen="true" allowscriptaccess="always" class="embed-responsive-item" quality="high" src="http://player.youku.com/player.php/sid/XNjc4MjQ5NjE2/v.swf" type="application/x-shockwave-flash"&gt;&lt;/embed&gt;&lt;/div&gt;&lt;p&gt; 順便，今天還看到一個賣萌的 &lt;span class="caps"&gt;KDE5&lt;/span&gt; Plasma  靜音圖標的翻譯： &lt;/p&gt;
&lt;blockquote class="twitter-tweet" lang="zh-tw"&gt;&lt;p&gt;KDE5 のミュート画面の中国語翻訳、「静音」のはずだが「镜音」になっている。 Vocaloid ファンのネタだか、単なる入力ミスだか分からない。 &lt;a href="http://t.co/ipyHjXMscR"&gt;pic.twitter.com/ipyHjXMscR&lt;/a&gt;&lt;/p&gt;— Jiachen &lt;span class="caps"&gt;YANG&lt;/span&gt; (@farseerfc) &lt;a href="https://twitter.com/farseerfc/status/541944351270518784"&gt;2014 12 月 8 日 &lt;/a&gt;&lt;/blockquote&gt;&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 09 Dec 2014 01:54:00 +0900</pubDate><guid>tag:farseerfc.github.io,2014-12-09:jumping-kde5-plasma-activities-button.html</guid><category>kde5</category><category>plasma</category><category>linux</category><category>gnome3</category></item><item><title>嫁給我好麼</title><link>//farseerfc.github.io/marry-me.html</link><description>&lt;html&gt;&lt;body&gt;&lt;img alt=" 嫁給我好麼 " class="img-responsive" src="/images/marry-me.png"/&gt;

&lt;p&gt; 上面那個是裝飾 …… 可以玩的是下面這個： &lt;/p&gt;
&lt;script src="/static/three.min.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/FirstPersonControls.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/helvetiker_regular.typeface.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/214game.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;div id="game_area" style="width: 600px; height: 450px; margin-left: 10px;"&gt;
&lt;/div&gt;
&lt;p style="margin-left: 100px; margin-top: 10px; "&gt;*  用 &lt;span class="caps"&gt;WASD&lt;/span&gt;←→  移動，需要 WebGL  支持 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Wed, 20 Feb 2013 20:42:00 +0900</pubDate><guid>tag:farseerfc.github.io,2013-02-20:marry-me.html</guid><category>will</category><category>you</category><category>marry</category><category>me</category></item><item><title>ICSE 2012</title><link>//farseerfc.github.io/icse2012.html</link><description>&lt;html&gt;&lt;body&gt;
&lt;div class="section" id="june-6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;June 6&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="keynote-1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id2"&gt;Keynote 1&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 沒怎麼聽懂，只記得講到了 finance is not money 但是沒聽懂這個和軟件有什麼關係。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cost-estimation-for-distributed-software-project"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id3"&gt;Cost Estimation for Distributed Software Project&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 講到他們試圖改善現有的模型去更精確地評估軟件開發的開銷。 &lt;/p&gt;
&lt;p&gt; 他們會給 PM 建議之前的項目的歷史數據，然後對於新項目，他們建議歷史上已有的項目的數據，從而幫助 PM 得到更精確的評估。他們試圖儘量減少項目評估對 PM  的經驗的需求，從而幫助即使經驗很少的 PM 也能準確評估項目的開銷。 &lt;/p&gt;
&lt;p&gt; 他們的觀點： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Context-specfic solutions needed!&lt;/p&gt;
&lt;p&gt; 我們需要更上下文相關的解決方案！ &lt;/p&gt;
&lt;p&gt;Early user paticipation is key!&lt;/p&gt;
&lt;p&gt; 早期用戶的參與是關鍵 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="characterizing-logging-practices-in-open-source-software"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id4"&gt;Characterizing Logging Practices in Open-Source Software&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Common mistakes in logging messages&lt;/p&gt;
&lt;p&gt; 在日誌記錄中容易犯的錯誤 &lt;/p&gt;
&lt;p&gt; 他們學習了歷史上的 log 記錄，然後試圖找到重複修改的輸出 log 的語句，確定 log  中存在的問題。他們首先確定修改是事後修改。 &lt;/p&gt;
&lt;p&gt; 通常的修改的比例（ 9027 個修改） &lt;/p&gt;
&lt;table border="1" class="table-hover table-striped docutils table"&gt;
&lt;colgroup&gt;
&lt;col width="10%"&gt;&lt;/col&gt;
&lt;col width="90%"&gt;&lt;/col&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;45%&lt;/td&gt;
&lt;td&gt; 靜態文本 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;27%&lt;/td&gt;
&lt;td&gt; 打印出的變量 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;26%&lt;/td&gt;
&lt;td&gt; 調試等級 verbosity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2%&lt;/td&gt;
&lt;td&gt; 日誌輸出的位置 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; 他們發現有調試等級的變化，是因爲安全漏洞之類的原因，或者在開銷和數據   之間的權衡。 &lt;/p&gt;
&lt;p&gt; 大多數對 log 的變量的修改都是爲了增加一個參數。他們之前的 LogEnhancer 是爲了   解決這個問題而提出的，通過靜態檢查，提醒程序員是否忘記了某個參數 &lt;/p&gt;
&lt;p&gt; 對 text 的修改是因爲要改掉過時的代碼信息，避免誤導用戶。 &lt;/p&gt;
&lt;p&gt; 他們的實驗是採用了基於 code clone  的技術，找到所有 log 語句，然後找不一致   的 clone ，然後自動提出建議。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="combine-functional-and-imperative-pgrm-for-multicore-sw-scala-java"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id5"&gt;Combine Functional and Imperative Pgrm for Multicore Sw: Scala &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; Java&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 趨勢：到處都是多核，但是併發程序呢？ &lt;/p&gt;
&lt;p&gt; 他們研究的對象是 Scala 和 Java ，因爲可以編譯後確認 JVM 字節碼的語義。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Java:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt; 共享內存 &lt;/li&gt;
&lt;li&gt; 顯示創建的線程 &lt;/li&gt;
&lt;li&gt; 手動同步 &lt;/li&gt;
&lt;li&gt;Wait/Notify 機制 &lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Scala:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt; 高階函數 &lt;/li&gt;
&lt;li&gt;Actors,  消息傳遞 &lt;/li&gt;
&lt;li&gt;lists, filters, iterators&lt;/li&gt;
&lt;li&gt;while&lt;/li&gt;
&lt;li&gt; 共享狀態 , &lt;span class="caps"&gt;OO&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;import java.*  能從 java 導入任何庫 &lt;/li&gt;
&lt;li&gt;auto type inferance  自動類型推導 &lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 實驗的參與者都經過 4 周的訓練，實驗項目是工業等級的開發項目 &lt;/p&gt;
&lt;p&gt; 結果： &lt;/p&gt;
&lt;p&gt;scala  的項目平均比 java 多花 38% 的時間，主要都是花在 Test 和 debug 上的時間。 &lt;/p&gt;
&lt;p&gt; 程序員的經驗和總體時間相關，但是對 test 和 debug 沒有顯著影響。 &lt;/p&gt;
&lt;p&gt;scala 的爲了讓編程更有效率的設計，導致 debug 更困難。比如類型推導， debug  的時候需要手動推導，來理解正在發生什麼。 &lt;/p&gt;
&lt;p&gt;scala 的程序比 java 小，中位數 2.6% ，平均 15.2%&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt; 性能比較： &lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt; 單核： scala 的線性程序的性能比 java 好 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;4 核： &lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;scala 7s @ 4 threads&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;java 4si @ 8 threads&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;median&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;83s scala&lt;/li&gt;
&lt;li&gt;98s java&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;32core: best scala 34s @ 64 threads&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt; 結論 &lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;java 有更好的 scalability&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;scala 類型推導 &lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;45% 說對攜帶碼有幫助 &lt;/li&gt;
&lt;li&gt;85% 說導致程序錯誤 &lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt; 調試 &lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;23% 認爲 scala 簡單 &lt;/li&gt;
&lt;li&gt;77% 認爲 java 簡單 &lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;multi-paradigram are better&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sound-empirical-evidence-in-software-testing"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id6"&gt;Sound Empirical Evidence in Software Testing&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Test data generation  測試數據自動生成 &lt;/p&gt;
&lt;p&gt;Large Empirical Studies - not always possible&lt;/p&gt;
&lt;p&gt;For open source software - big enough&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="identifing-linux-bug-fixing-patch"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;Identifing Linux Bug Fixing Patch&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;current practice:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;manual&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Current research:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;keywords in commits&lt;/li&gt;
&lt;li&gt;link bug reports in bugzilla&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Try to solve classification problem&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;issue&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;pre-identified&lt;/li&gt;
&lt;li&gt;post-identified&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;data&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;from commit log&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;feature extraction&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;text pre-process stemmed non-stop words&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;model learning&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;research questions&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="active-refinement-of-clone-anomaly-reports"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;Active Refinement of Clone Anomaly Reports&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;motivating&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;code clones, clone groups&lt;/li&gt;
&lt;li&gt;clone used to detect bugs&lt;/li&gt;
&lt;li&gt;anomaly : inconsistent clone group
many anomaly clone are note bug, high false positive&lt;/li&gt;
&lt;/ul&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;approach&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;reorder by sorted bug reports&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr class="docutils"/&gt;
&lt;div class="section" id="june7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;June7&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="keynotes-2-sustainability-with-software-an-industrial-perspective"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;Keynotes 2: Sustainability with Software - An Industrial Perspective&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Sustainability&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Classic View: Idenpendent view with overlap&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Social&lt;/li&gt;
&lt;li&gt;Environment&lt;/li&gt;
&lt;li&gt;Economic&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Nested viw&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Environment&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Social&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Economic&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;Triple bottom line&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;economic&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;-global business, networks , global econ&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;env&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;natural res, climate change, population grow&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;social&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;awareness, connectivity, accountability&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;div class="section" id="green-it"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id11"&gt;Green &lt;span class="caps"&gt;IT&lt;/span&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;reduce &lt;span class="caps"&gt;IT&lt;/span&gt; energy&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;more than 50% cooling - doing nothing&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;mini e-waste: not properly recycled&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;80% in &lt;span class="caps"&gt;EU&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;75% in &lt;span class="caps"&gt;US&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;foster dematerialization&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In-Memory Technology: Expected Sustainable Benefits&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-can-we-do"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id12"&gt;What can we do?&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;consider all software lifecycle phases in your design&lt;/li&gt;
&lt;li&gt;avoid energy expensive behavior in your codes&lt;/li&gt;
&lt;li&gt;design lean architectures&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="green-by-it"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id13"&gt;Green by &lt;span class="caps"&gt;IT&lt;/span&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2% green &lt;span class="caps"&gt;IT&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;98% green &lt;span class="caps"&gt;IT&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="on-how-often-code-is-cloned-across-repositories"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;On How Often code is cloned across repositories&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Line based hashing code clone detection&lt;/p&gt;
&lt;p&gt;never do anything harder than sorting&lt;/p&gt;
&lt;p&gt;hashing a window of 5 lines of normalized (tokenized) code, dropping
3/4 of the hashing&lt;/p&gt;
&lt;p&gt; 把 ccfinder 一個月的工作縮短到了 3, 4 天。沒有比較 presion 和 recall 。 &lt;/p&gt;
&lt;table border="1" class="table-hover table-striped docutils table"&gt;
&lt;colgroup&gt;
&lt;col width="11%"&gt;&lt;/col&gt;
&lt;col width="89%"&gt;&lt;/col&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;14%&lt;/td&gt;
&lt;td&gt;type1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16%&lt;/td&gt;
&lt;td&gt;type2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;17%&lt;/td&gt;
&lt;td&gt;type3 (not really type2)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="graph-based-analysis-and-prediction-for-sw-evolution"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;Graph-based analysis and prediction for sw evolution&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="graph-are-everywhere"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id16"&gt;graph are everywhere&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;internet topology&lt;/li&gt;
&lt;li&gt;social net&lt;/li&gt;
&lt;li&gt;chemistry&lt;/li&gt;
&lt;li&gt;biology&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;in sw
- func call graph
- module dependency graph&lt;/p&gt;
&lt;p&gt;developer interaction graph
- commit logs
- bug reports&lt;/p&gt;
&lt;p&gt;experiment 11 oss, 27~171 release, &amp;gt; 9 years&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="predictors"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id17"&gt;predictors&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;NodeRank&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;similar to pagerank of google&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;measure relative importance of each node&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;func call graph with noderank&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;compare rank with severity scale on bugzilla&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;correlation between noderank and BugSeverity&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;func level 0.48 ~ 0.86 varies among projects.&lt;/li&gt;
&lt;li&gt;model level &amp;gt; func level&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;ModularityRatio&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;cohesion/coupling ratio: IntraDep(M)/InterDep(M)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;forecast mantencance effort&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;use for&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;identify modules that need redesign or refactoring&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;EditDistance&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;bug-based developer collaboration graphs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="caps"&gt;ED&lt;/span&gt;(G1,G2)=|V1|+|V2|-2|V1 交 V2|+|E1|+|E2|-2|E1 交 E2|&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;use for&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;release planning&lt;/li&gt;
&lt;li&gt;resource allocation&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;graph metrics&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;graph diameter&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;average node degree indicates reuse&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;clustering coefficient&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;assortativity&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;num of cycles&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id18"&gt;Conclusion&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;"Actionable intelligence" from graph evolution&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;studie 11 large long-live projs&lt;/li&gt;
&lt;li&gt;predictors&lt;/li&gt;
&lt;li&gt;identify pivotal moments in evolution&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-make-long-term-contributors-willingness-and-opportunity-in-oss"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;What make long term contributors: willingness and opportunity in &lt;span class="caps"&gt;OSS&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class="caps"&gt;OSS&lt;/span&gt; don’t work without contributors form community&lt;/p&gt;
&lt;p&gt;mozilla (2000-2008)&lt;/p&gt;
&lt;p&gt;10^2.2 &lt;span class="caps"&gt;LTC&lt;/span&gt; &amp;lt;- 2 order -&amp;gt; 10^4.2 new contributors &amp;lt;- 3.5 order -&amp;gt; 10^7.7 users&lt;/p&gt;
&lt;p&gt;gnome (1999-2007)&lt;/p&gt;
&lt;p&gt;10^2.5 &lt;span class="caps"&gt;LTC&lt;/span&gt; &amp;lt;- 1.5 order -&amp;gt; 10^4.0 new contributors &amp;lt;- 3.5 order -&amp;gt; 10^6.5 users&lt;/p&gt;
&lt;div class="section" id="approach"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id20"&gt;approach&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;read issues of 20 &lt;span class="caps"&gt;LTC&lt;/span&gt; and 20 non-&lt;span class="caps"&gt;LTC&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;suvery 56 (36 non-&lt;span class="caps"&gt;LTC&lt;/span&gt; and 20 &lt;span class="caps"&gt;LTC&lt;/span&gt;)&lt;/li&gt;
&lt;li&gt;extract practices published on project web sites&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="summeray"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id21"&gt;summeray&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Ability/Willingness distinguishes LTCs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Environment&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;macro-climate&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;popularity&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;micro-climate&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;attention&lt;/li&gt;
&lt;li&gt;bumber of peers&lt;/li&gt;
&lt;li&gt;performance of peers&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;regression model&lt;/p&gt;
&lt;p&gt;newcomers to &lt;span class="caps"&gt;LTC&lt;/span&gt; conversion drops&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;actions in first month predicts LTCs&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;24% recall&lt;/li&gt;
&lt;li&gt;37% precision&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="develop-of-auxiliary-functions-should-you-be-agile"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id22"&gt;develop of auxiliary functions: should you be agile?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;a empirial assessment of pair programming and test-first programming&lt;/p&gt;
&lt;p&gt;can agile help auxiliary functions?&lt;/p&gt;
&lt;div class="section" id="experiment"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id23"&gt;experiment&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;pair vs solo&lt;/li&gt;
&lt;li&gt;test-first vs test-last&lt;/li&gt;
&lt;li&gt;students vs professors&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="research-questions"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id24"&gt;research questions&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;r1: can pair help obtain more correct impl&lt;/li&gt;
&lt;li&gt;r2: can test-first&lt;/li&gt;
&lt;li&gt;r3: dst test1 encourage the impl or more test cases?&lt;/li&gt;
&lt;li&gt;r4: does test1 course more coverage&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="result"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id25"&gt;result&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;test-first&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;higher coverage&lt;/li&gt;
&lt;li&gt;non change with correctness&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;pair&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;improve on correctness&lt;/li&gt;
&lt;li&gt;longer total programming time&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="static-detection-of-resource-contention-problems-in-server-side-script"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id26"&gt;Static Detection of Resource Contention Problems in Server-side script&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Addressed the race condition of accessing database or filesystem of &lt;span class="caps"&gt;PHP&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="amplifying-tests-to-validate-exception-handling-code"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id27"&gt;Amplifying Tests to Validate Exception Handling Code&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 異常處理的代碼不但難寫，而且難以驗證。各種組合情況難以估計，尤其是手機   系統上。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-tactic-centric-approach-automating-traceability-of-quality-concerns"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id28"&gt;A tactic-centric approach automating traceability of quality concerns&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;tactic traceability information models&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Wed, 06 Jun 2012 10:42:00 +0900</pubDate><guid>tag:farseerfc.github.io,2012-06-06:icse2012.html</guid><category>icse</category><category>software</category></item><item><title>MSR 2012 @ ICSE</title><link>//farseerfc.github.io/msr2012.html</link><description>&lt;html&gt;&lt;body&gt;
&lt;div class="section" id="mining-software-repository-2012-icse"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;Mining Software Repository 2012 @ &lt;span class="caps"&gt;ICSE&lt;/span&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt; 參加了今年的 MSR ，會場在 University of Zurich 。一大早來到大學，註冊有點小插曲，顯然瑞士人搞不清楚中國人的名字， 3 個楊（ Yang ）姓的中國人的名牌被搞錯了。然後堀田學長的所屬被寫作了 “Japan, Japan” ，成爲了全日本的代表。 &lt;/p&gt;
&lt;div class="section" id="msr-microsoft-research-talk-msr-mining-software-repositories"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id4"&gt;&lt;span class="caps"&gt;MSR&lt;/span&gt;(MicroSoft Research) talk @ &lt;span class="caps"&gt;MSR&lt;/span&gt;(Mining Software Repositories)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 首先是來自微軟亞洲研究院（ MicroSoft Research @ Asia, &lt;span class="caps"&gt;MSR&lt;/span&gt; Asia ）的 Keynots ，於是就變成了 MSR 在 MSR 的演講。 MSR 的張冬梅（ Dongmei Zhang ）女士的演講分爲關於 Software Analysis 和 XIAO 的兩部分。 XIAO 是 MSRA 開發的 Code Clone
Detector ，似乎我要給井上研做的就是這個。想更多瞭解 Xiao 的細節，不過張女士   演講結束的時候的鼓掌導致了話筒的小故障。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="towards-improving-bts-with-game-mechanisms"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id5"&gt;Towards Improving &lt;span class="caps"&gt;BTS&lt;/span&gt; with Game Mechanisms&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 感覺這篇的內容基本上就是關於 &lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.joelonsoftware.com/items/2008/09/15.html"&gt;http://www.joelonsoftware.com/items/2008/09/15.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 這裏寫到的東西，然後說同樣的理論是否可以用於 Issue Tracking 之類的事情上。個人感覺這個意義不大， stackoverflow 之所以成功是因爲它把開源社區本身就具有的名譽體系具現化了，本着大家都喜歡被別人奉爲大牛的心態，就如同 wikipedia 一樣。同樣的理論如果用於公司內部的 Issue Tracking 系統上，會得到完全不同的東西吧。就像 MSDN 的組織方式雖然和 wikipedia 是一樣的，但是在 MSDN  裏找信息的感覺和在 wikipedia 完全不一樣。個人不太看好這個方向。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ghtorrent"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id6"&gt;GHTorrent&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 這篇的 slide 在這裏可以看到： &lt;a class="reference external" href="http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524"&gt;http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Data exporter for github. Github 的主要數據，代碼，已經可以通過 git 接口獲得了， wiki 是 git 的形式保存的。所以這個項目的目的就是暴露別的數據，主要是 issue tracking ， code comments ，這種。代碼訪問 github api ，然後用分佈式實現以克服 api 的限制，然後提供 torrents 形式的 history 下載。 github api 獲得的 json 數據以 bson 的形式保存在 MongoDB 裏，解析過的有了 Schema 之後的數據保存   在 MySQL 裏並可以導出 SQL 。 &lt;/p&gt;
&lt;p&gt; 個人的想法，覺得數據如果能夠更統一，全部存在 Git 裏或許更好，像 Wiki 一樣。同樣是要暴露全部歷史記錄的目的，用 Torrent 自己實現的歷史遠不如用 Git 的接口實現的歷史記錄方便吧， git blame 之類的也更方便追蹤 code comment 之類的作者信息。當然對 git 的 raw date 直接讀寫，需要對 git 的內部原理有足夠的理解，   或許只有 github 的人有這種能力了。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="topic-mining"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;Topic Mining&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 用得兩個參數， &lt;span class="caps"&gt;DE&lt;/span&gt;  和 &lt;span class="caps"&gt;AIC&lt;/span&gt; ，完全不能理解，過後研究。實驗針對了 Firefox,
Mylyn, Eclipse 三個軟件。試圖從 Repo 中分析源代碼的 identifier 和 comments ，找到 topic 和 bug 之間的關係，比如怎樣的 topic 更容易導致 bug 。得出的結論似乎也很曖昧，只是說核心功能被報告的 bug 更多，但是不知道原因。這只能表示核心   功能受到更多關注和更多測試吧，並不能說明核心功能就容易產生 bug 。 &lt;/p&gt;
&lt;p&gt; 不過這個的 Slide 做得很漂亮，很容易理解。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="secold"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;SeCold&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A linked data platform for mining software repositories&lt;/p&gt;
&lt;p&gt; 沒聽懂這個項目的目的。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-evolution-of-software"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;The evolution of software&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 第二天的 Keynotes ，關於將 Social Media 和 Software Development 相結合的想法。或許就是 Github 賴以成功的基礎。講到代碼中的 comment, Tags, uBlog, blog 之類   的 social 的特性和 IDE 的融合的趨勢。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="do-faster-releases-imporve-software-quality"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;Do Faster Releases Imporve Software Quality?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 使用 Firefox 作爲例子。 &lt;/p&gt;
&lt;p&gt; 結論是快速發佈導致 bug 更多，更容易 crash ，但是 bug 更快得到修復，並且用戶   更快轉向新的發佈。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="security-vs-performance-bugs-in-firefox"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;Security vs Performance Bugs in Firefox&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Performance bugs are regression, blocks release.&lt;/p&gt;
&lt;/div&gt;
&lt;hr class="docutils"/&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt; 一些感想 &lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="commit"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id13"&gt; 基於自然語義分析的 commit 分割 &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt; 經常工具（比如 git ）的使用者並沒有按照工具設計者的意圖使用工具，這給 MSR
 帶來很多困難。舉個例子， git 有非常完美的 branch 系統，通常期望 git 的使用者能夠在一次 commit 裏 commit 一個功能，比如一個 bug 的修復，或者一個 feature 的   添加，但是事實上經常有很多邏輯上的 commit 被合併在一個裏面了。 &lt;/p&gt;
&lt;p&gt; 或許這不是使用者的錯，而是工具仍然不夠人性的表現。或許我們可以自動把   一次的 commit 按照語義分割成多個。 &lt;/p&gt;
&lt;p&gt; 分割之後，可以更容易地把 issue 和 commit 關聯，也更容易組織更多的研究。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="slides"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id14"&gt; 關於這次發表中大家用的 slides 系統 &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt; 題目爲 “Incorporating Version Histories in Information Retrieval Based
Bug Localization” 的人用的 slide 是 beamer 的。公式很多， overlay 很多，列表很多，圖片很少，典型的 beamer 做出的 slide 。思維導圖用得很不錯。今天一天   有至少 3 個 slide 是用 beamer 做的。 &lt;/p&gt;
&lt;p&gt; 題目爲 “Towards Improving Bug Tracking Systems with Game Mechanisms”
 的人用了 prezi ，圖片很多，過度很多。但是比如沒有頁號沒有頁眉頁腳，正式   會議的場合不太方便。 &lt;/p&gt;
&lt;p&gt; 至少有六個以上用了 Apple Keynotes ， Keynotes 做出來的東西真的和 Powerpoint  做出來的很難區別，其中兩個人用了初始的主題所以才看出來。 &lt;/p&gt;
&lt;p&gt; 剩下的自然是 PPT 。 MSRA 的張女士做的雖然是 PPT ，倒是有很多 beamer 的感覺，比如頁眉頁腳和 overlay 的用法。這些如果都是 PPT 做出來的，會多很多額外的   人力吧。 &lt;/p&gt;
&lt;p&gt; 值得一提的是有一個題目爲 “Green Mining: A Methodology of Relating
Software Change to Power Consumption” 的人的 slide 全是 “ 劣質 ” 的手繪漫畫，效果意外地好，很低碳很環保很綠色很可愛。具體效果可以參考下面的動畫，雖然   現場看到的不是一個版本： &lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv"&gt;http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id15"&gt; 微軟是個腹黑娘！ &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt; 嘛雖然這也不是什麼新聞了。 MSR2012 的 Mining Challenge 的贊助商是微軟，管理   組織者來自微軟研究院，獎品是 Xbox 和 Kinect 。然後今年的題目是： &lt;/p&gt;
&lt;pre class="literal-block"&gt;
Mining Android Bug
&lt;/pre&gt;
&lt;p&gt; 我看到了微軟滿滿的怨氣 ……&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Sat, 02 Jun 2012 10:42:00 +0900</pubDate><guid>tag:farseerfc.github.io,2012-06-02:msr2012.html</guid><category>msr</category><category>icse</category><category>mining</category><category>software</category><category>repository</category></item><item><title>Pyssy 項目</title><link>//farseerfc.github.io/pyssy.html</link><description>&lt;html&gt;&lt;body&gt;&lt;div class="section" id="id1"&gt;
&lt;h2&gt; 簡介 &lt;/h2&gt;
&lt;p&gt;Pyssy  是用於 &lt;a class="reference external" href="https://bbs.sjtu.edu.cn"&gt; 上海交通大學飲水思源站 &lt;/a&gt;  的一系列 Python  腳本和工具。 &lt;/p&gt;
&lt;p&gt;Pyssy  被有意設計爲既可以託管寄宿在 &lt;span class="caps"&gt;SAE&lt;/span&gt; &lt;a class="footnote-reference" href="#sae" id="id3"&gt;[1]&lt;/a&gt;  上，也可以在單機上獨立使用。 &lt;/p&gt;
&lt;p&gt; 項目地址： &lt;a class="reference external" href="http://pyssy.sinaapp.com/"&gt;http://pyssy.sinaapp.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github 上的源代碼地址： &lt;a class="reference external" href="https://github.com/yssy-d3/pyssy"&gt;https://github.com/yssy-d3/pyssy&lt;/a&gt;&lt;/p&gt;
&lt;table class="table-hover footnote  table-striped docutils table" frame="void" id="sae" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;/col&gt;&lt;col&gt;&lt;/col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://sae.sina.com.cn/"&gt;Sina App Engine&lt;/a&gt;  ，新浪雲平臺，類似 &lt;a class="reference external" href="https://appengine.google.com/"&gt;Google App Engine&lt;/a&gt;  的東西。 &lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt; 依賴關係 &lt;/h2&gt;
&lt;p&gt;Pyssy  使用 &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt;  作爲網頁服務器，並且使用 Memcached  或者 Redis  作爲抓取 &lt;em&gt; 水源 Web&lt;/em&gt;  的緩存。 &lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;SAE&lt;/span&gt; Python  環境下請開啓 Memcached  支持。 &lt;/p&gt;
&lt;p&gt; 本地環境下請安裝 Redis-py  並運行 redis-server  服務器程序。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Mon, 02 Apr 2012 12:42:00 +0900</pubDate><guid>tag:farseerfc.github.io,2012-04-02:pyssy.html</guid><category>python</category><category>sjtu</category><category>yssy</category></item><item><title>PyRuby</title><link>//farseerfc.github.io/mix-ruby.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 今天在 GitHub 上閒逛的時候看到一個叫做 &lt;a class="reference external" href="https://github.com/danielfm/pyruby"&gt;PyRuby&lt;/a&gt;  的項目。項目的 Readme 說得很好： &lt;/p&gt;
&lt;pre class="literal-block"&gt;
PyRuby - Some Ruby for your Python!
PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful.

Usage
All you have to do is import the ruby module:

import ruby
From now on you should be able to write Ruby code within a regular Python module. An example:

1.upto(10) { |n| puts n }
&lt;/pre&gt;
&lt;p&gt; 甚至 &lt;a class="reference external" href="http://pypi.python.org/pypi/pyruby/1.0.0"&gt;PyPI&lt;/a&gt;  上還有這個項目的包。 &lt;/p&gt;
&lt;p&gt; 一開始我還以爲這又是一個野心勃勃的基於 PyPy 的 Ruby 實現，或者某種 trick 在 Python 裏面直接調用 Ruby 解釋器。 &lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt; 然後我想看看這個的源代碼 &lt;/h2&gt;
&lt;p&gt; 只有一個 ruby.py 文件，內容是： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"""&lt;/span&gt;

&lt;span class="s"&gt;                              `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:`&lt;/span&gt;
&lt;span class="s"&gt;                       .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms.&lt;/span&gt;
&lt;span class="s"&gt;                  `:ohmdys+//::/::--::::////:-.```......`````.://:-`         `/dNs.&lt;/span&gt;
&lt;span class="s"&gt;               .+hNds:`-:-:///::------::///++///:--....--::///::-`.///.        `oMm/&lt;/span&gt;
&lt;span class="s"&gt;             /hNmo.`   ``    `....```````````      ...------:::-:/+/-.:/:`       /NMs&lt;/span&gt;
&lt;span class="s"&gt;            oMd/`      `::::--.---://+`           //`     `````-:::::+/-`::.`     :NM+&lt;/span&gt;
&lt;span class="s"&gt;            yN`       -+.`         `/`           o.               ``::.-:. ``      :NN:&lt;/span&gt;
&lt;span class="s"&gt;           :Nm        -             ./           :    `.-://///:-.   `-` ``         :NN-&lt;/span&gt;
&lt;span class="s"&gt;          /NM/           .-:::-.`   `/            `:sdmdhyMMMMMMNNmy/`               :mNo`&lt;/span&gt;
&lt;span class="s"&gt;        :hMd:          /dmddddNNmdy+-.          `smmy/-```hMMMMMMMhydm/ `-.``     `...:mMm+.&lt;/span&gt;
&lt;span class="s"&gt;      -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+-      dMN-`-+hmmmmdhhhhdddmMN-`-/o:    .-::::/oydms-&lt;/span&gt;
&lt;span class="s"&gt;     oNMo:+/::.         ``...--:/+ohNMNhs-      :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms.&lt;/span&gt;
&lt;span class="s"&gt;    .MMo:/`o:.:+sso+:-`             sM+           ./-`       /mNh+-....-/ymNNdo::--/shd+`  -`:mm:&lt;/span&gt;
&lt;span class="s"&gt;    /MM-o ./ ohhsooohNmy::sh.      `yM/                       `:oyyyyyyhys+:.` hy    `/Nh`  : -NN.&lt;/span&gt;
&lt;span class="s"&gt;    -MM// -: ``   y: odddhh+     -omNh-          `--.` ``          ````    .:ohMMs.    +Ms  /  yMo&lt;/span&gt;
&lt;span class="s"&gt;     hMoo .+.    :Mh  ````    `/hNd/.`           ohdddy::...`..`      `-/sdmdyo+NMNh+- :Mh  /  sMs&lt;/span&gt;
&lt;span class="s"&gt;     .mmh:..:.  :NMm       `-/dMNM+         ./+++/:`.hM:`.````.` `-/shmNmh+-`  /Mmooso.hM/ .: `mM/&lt;/span&gt;
&lt;span class="s"&gt;      .mNs://: .NMNMs-   -:-.`/+-sms.   `  `shyyyhy`sNd`   `.:+sdmmmdMM-.    .oNM+    :m/ `s``yMh&lt;/span&gt;
&lt;span class="s"&gt;       -mMo  . sMNdMNNh+-.        .ydyoyy`        ``+o::+shdddhs+:-.:MM.`.-+hNMMh-    `.`-/::dNs`&lt;/span&gt;
&lt;span class="s"&gt;        -NM-   mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.`    `/mMMdmmddNMm+`      ..-/hNh-&lt;/span&gt;
&lt;span class="s"&gt;         sMy   NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs  `..:+ymMMMMd+--yNh.        `+hNh:&lt;/span&gt;
&lt;span class="s"&gt;         -Mm   NMMM/yMh  -NM-`..--:NMo:--.`+My         :MNoydmNMMNmhdMh` -dNs`        `yMd:&lt;/span&gt;
&lt;span class="s"&gt;         `MN   mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/          yMy`&lt;/span&gt;
&lt;span class="s"&gt;          MN   yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-.      `yMMNs.          /My&lt;/span&gt;
&lt;span class="s"&gt;         `MN   :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM-      ./hNNy-           /Nd`&lt;/span&gt;
&lt;span class="s"&gt;         -Mh    dMydMmsNMNdNNMMmmmNMMMdddhys+yMo``       /Nm:  `:yNNdo.           .sNd.&lt;/span&gt;
&lt;span class="s"&gt;         +Ms    .mMsMN::NN:.:MN: `.+NM.      +Mo          +Mm+ymNdo-            .omm+`&lt;/span&gt;
&lt;span class="s"&gt;         yM:     .hNMd+:sMN. oMm.   oMo      +Mh   ```.:+shMNmy+-``.-:-..-//-`:yNmo`&lt;/span&gt;
&lt;span class="s"&gt;         mM.       :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/`&lt;/span&gt;
&lt;span class="s"&gt;        .Mm        ``  .-:/+osyyhhddddddddddhhyysoo+/:-.  `./+//--+oo/--+ymmy/.&lt;/span&gt;
&lt;span class="s"&gt;        :Mh   .:   `+:`        `.------------`      ```-////:/++/:../ydNdo:`&lt;/span&gt;
&lt;span class="s"&gt;        +Ms   `/`    :+o+:-```              ``..-::///++///:-.`-+ydNdo:`&lt;/span&gt;
&lt;span class="s"&gt;        oMs     :/:.``  `..---.``` ````````..-:/:::---.`  `-ohmmh+:`&lt;/span&gt;
&lt;span class="s"&gt;        /Mh       .://///:::-----.-----.......`       `-+hmmy+-&lt;/span&gt;
&lt;span class="s"&gt;         sMy`                                ``````-+ydmy+-&lt;/span&gt;
&lt;span class="s"&gt;          /mNs-`                        `./ohmNMNNNmy+-&lt;/span&gt;
&lt;span class="s"&gt;            /yNmho/:.``````````.-:/+syhdNmdyso+/-.`&lt;/span&gt;
&lt;span class="s"&gt;              `:+ydmNMNNNNNNNNNmdhys+/:.`&lt;/span&gt;
&lt;span class="s"&gt;                     ``.....`&lt;/span&gt;

&lt;span class="s"&gt;    LOL U MAD?&lt;/span&gt;
&lt;span class="s"&gt;"""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 是的 …… 的確 …… 這種嘗試把 Python 和 Ruby 放在一起的想法絕對是瘋了 ……&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Fri, 02 Mar 2012 23:09:00 +0900</pubDate><guid>tag:farseerfc.github.io,2012-03-02:mix-ruby.html</guid><category>python</category><category>ruby</category></item><item><title>關於C++模板的類型轉換的討論</title><link>//farseerfc.github.io/discuss-cpp-template-downcast.html</link><description>&lt;html&gt;&lt;body&gt;
&lt;p&gt; 這兩天在飲水思源的 C 板，關於 C++ 模板的類型轉換的一個討論，後面是我的解答。 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt; 討論地址 &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html"&gt;http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt; 原問題 &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt; 今天在書上看到模板演繹的時候可以允許 cast-down ，於是我寫了個東西： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;_Test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BB&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DD&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//f(b);&lt;/span&gt;
    &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 奇怪的是重載決議的時候， &lt;code class="code"&gt;
f&lt;/code&gt;
  的情況下它就不讓我特化的 &lt;code class="code"&gt;
f&amp;lt;A&amp;gt;&lt;/code&gt;
  進來。 &lt;/p&gt;
&lt;p&gt; 但是在 &lt;code class="code"&gt;
ff&lt;/code&gt;
  的情況下， &lt;code class="code"&gt;
ff&amp;lt;BB&amp;lt;long&amp;gt;&amp;gt;&lt;/code&gt;
  卻進來了。 &lt;/p&gt;
&lt;p&gt; 在 VC10 和 GCC3.4 下測試 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt; 我的解答 &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt; 我們來設身處地地作爲編譯器，看一遍到底發生了什麼。 &lt;/p&gt;
&lt;p&gt; 約定符號 &lt;code class="code"&gt;
#&lt;/code&gt;
 : &lt;code class="code"&gt;
A#B&lt;/code&gt;
  是把 &lt;code class="code"&gt;
B&lt;/code&gt;
  帶入 &lt;code class="code"&gt;
A&amp;lt;T&amp;gt;&lt;/code&gt;
  的參數 &lt;code class="code"&gt;
T&lt;/code&gt;
  之後實例化得到的結果。 &lt;/p&gt;
&lt;div class="section" id="ff"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt; 首先看 ff 的情況。 &lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 處理到這句的時候，編譯器看到了 &lt;code class="code"&gt;
DD&amp;lt;long&amp;gt;&lt;/code&gt;
  的實例化，於是去實例化 &lt;code class="code"&gt;
DD#long&lt;/code&gt;
  ，繼而實例化了 &lt;code class="code"&gt;
BB#long&lt;/code&gt;
  。 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 這句，首先計算重載函數集合。 &lt;/p&gt;
&lt;p&gt; 第一步，需要從參數 &lt;code class="code"&gt;
DD#long -&amp;gt; BB&amp;lt;T&amp;gt;&lt;/code&gt;
  推斷 &lt;code class="code"&gt;
ff&amp;lt;T&amp;gt;&lt;/code&gt;
  的 &lt;code class="code"&gt;
T&lt;/code&gt;
  。根據函數模板參數推斷規則： &lt;/p&gt;
&lt;pre class="literal-block"&gt;
:code:`class_template_name&amp;lt;T&amp;gt;`  類型的參數，可以用於推斷 :code:`T`  。 &lt;/pre&gt;
&lt;p&gt; 於是編譯器推斷 &lt;code class="code"&gt;
T&lt;/code&gt;
  爲 &lt;code class="code"&gt;
long&lt;/code&gt;
  。這裏就算不是 &lt;code class="code"&gt;
BB&lt;/code&gt;
  而是完全無關的 &lt;code class="code"&gt;
CC&lt;/code&gt;
  都可以推斷成功，只要 &lt;code class="code"&gt;
CC&lt;/code&gt;
  也是一個 &lt;code class="code"&gt;
CC&amp;lt;T&amp;gt;&lt;/code&gt;
  形式的模板。 &lt;/p&gt;
&lt;p&gt; 第二步，模板特化匹配。因爲只有一個模板，所以匹配了最泛化的 &lt;code class="code"&gt;
ff&amp;lt;T&amp;gt;&lt;/code&gt;
  。 &lt;/p&gt;
&lt;p&gt; 第三步，模板實例化。 &lt;/p&gt;
&lt;p&gt; 推斷了 &lt;code class="code"&gt;
long -&amp;gt; T&lt;/code&gt;
  之後，編譯器實例化 &lt;code class="code"&gt;
ff#long&lt;/code&gt;
  。 &lt;/p&gt;
&lt;p&gt; 重載函數集合： &lt;code class="code"&gt;
{ff#long}&lt;/code&gt;
&lt;/p&gt;
&lt;p&gt; 然後重載抉擇找到唯一的可匹配的實例 &lt;code class="code"&gt;
ff#long&lt;/code&gt;
  ，檢查實際參數 &lt;code class="code"&gt;
DD#long&lt;/code&gt;
  可以隱式轉換到形式參數 &lt;code class="code"&gt;
BB#long&lt;/code&gt;
  ，從而生成了這次函數調用。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="f"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt; 再來看 f 的情況。 &lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 計算候選重載函數集合。 &lt;/p&gt;
&lt;p&gt; 第一步，對所有 &lt;code class="code"&gt;
f&lt;/code&gt;
  模板推斷實參。根據函數模板參數推斷規則： &lt;/p&gt;
&lt;pre class="literal-block"&gt;
 帶有 :code:`T`  類型的參數，可以用於推斷 :code:`T`  。 &lt;/pre&gt;
&lt;p&gt; 於是 &lt;code class="code"&gt;
B -&amp;gt; T&lt;/code&gt;
  被推斷出來了。 &lt;/p&gt;
&lt;p&gt; 第二步，模板特化匹配。 &lt;/p&gt;
&lt;p&gt; 這裏 &lt;code class="code"&gt;
B&lt;/code&gt;
  不是 &lt;code class="code"&gt;
A&lt;/code&gt;
  ，所以不能用 &lt;code class="code"&gt;
f&amp;lt;A&amp;gt;&lt;/code&gt;
  特化，只能用 &lt;code class="code"&gt;
f&amp;lt;T&amp;gt;&lt;/code&gt;
  模板。 &lt;/p&gt;
&lt;p&gt; 第三步，模板實例化。 &lt;/p&gt;
&lt;p&gt;&lt;code class="code"&gt;
B&lt;/code&gt;
  帶入 &lt;code class="code"&gt;
f&amp;lt;T&amp;gt;&lt;/code&gt;
  實例化成 &lt;code class="code"&gt;
f#B&lt;/code&gt;
  的過程中，實例化 &lt;code class="code"&gt;
traits#B&lt;/code&gt;
  。 &lt;/p&gt;
&lt;p&gt; 由於沒有針對 &lt;code class="code"&gt;
B&lt;/code&gt;
  的特化，所以用 &lt;code class="code"&gt;
traits&amp;lt;T&amp;gt;&lt;/code&gt;
  模板， &lt;code class="code"&gt;
traits#B::value=false&lt;/code&gt;
  ，進而 &lt;code class="code"&gt;
enable_if#false&lt;/code&gt;
  沒有 &lt;code class="code"&gt;
type&lt;/code&gt;
  ，出錯。 &lt;/p&gt;
&lt;p&gt; 唯一的模板匹配出錯，重載函數集合爲空， SFINAE 原則不能找到合適的匹配，於是報錯。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Sun, 26 Feb 2012 05:54:57 +0900</pubDate><guid>tag:farseerfc.github.io,2012-02-26:discuss-cpp-template-downcast.html</guid><category>template</category><category>C</category></item><item><title>嘗試一下 Pelican</title><link>//farseerfc.github.io/try-pelican.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 似乎一夜之間所有的 &lt;a class="reference external" href="http://blog.yxwang.me/2011/11/migrated-to-octopress/"&gt; 極客們 &lt;/a&gt;
&lt;a class="reference external" href="http://xoyo.name/2012/02/migrate-to-octopress/"&gt; 都 &lt;/a&gt;
&lt;a class="reference external" href="http://blog.xdite.net/posts/2011/10/07/what-is-octopress/"&gt; 有了 &lt;/a&gt;
&lt;a class="reference external" href="http://www.yangzhiping.com/tech/octopress.html"&gt; 自己 &lt;/a&gt;
 的 &lt;a class="reference external" href="http://pages.github.com/#user__organization_pages"&gt;Github 主頁 &lt;/a&gt;
 和 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt;  博客。就像所有人在他們的博客中指出的，靜態博客的確比傳統的 WordPress 方式具有更多優勢。自從看到這些我就一直在想着自己搭一個 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt;  。 &lt;/p&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt; 但是似乎 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt;  不適合我 &lt;/h2&gt;
&lt;p&gt; 一上手就被 &lt;a class="reference external" href="http://octopress.org/docs/setup/"&gt;Octopress 的搭建步驟 &lt;/a&gt;  煩到了。 &lt;a class="reference external" href="http://beginrescueend.com/"&gt;&lt;span class="caps"&gt;RVM&lt;/span&gt;&lt;/a&gt;  是什麼？ &lt;a class="reference external" href="https://github.com/sstephenson/rbenv"&gt;rbenv&lt;/a&gt;  又是什麼？看來 Ruby  社區的快節奏發展已經超過了我的想象，他們似乎需要一套發行版管理器來調和不同版本之間的 Ruby  的兼容性問題。雖然同樣的兼容性問題在 Python  社區也有 &lt;a class="footnote-reference" href="#id10" id="id8"&gt;[1]&lt;/a&gt;  ，不過總覺得 Python  至少還沒到需要一個發行版管理器的程度 &lt;a class="footnote-reference" href="#id11" id="id9"&gt;[2]&lt;/a&gt;  。 &lt;/p&gt;
&lt;p&gt; 真正的問題是我手上還沒有一個可以讓我隨便玩的 Linux  環境（真的想要 …… ）。而無論是 &lt;a class="reference external" href="http://beginrescueend.com/"&gt;&lt;span class="caps"&gt;RVM&lt;/span&gt;&lt;/a&gt;  還是 &lt;a class="reference external" href="https://github.com/sstephenson/rbenv"&gt;rbenv&lt;/a&gt;  似乎都只支持 Unix/Linux/MacOSX  。身爲極客就註定不能用 Windows  麼？（或許是的 …… ）。 &lt;/p&gt;
&lt;p&gt; 剩下的問題就是 Ruby  和 Python  兩大陣營的對立問題了。我不熟悉 &lt;a class="reference external" href="http://daringfireball.net/projects/markdown/"&gt;Markdown&lt;/a&gt;  ，相對來說比較喜歡 &lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;ReST&lt;/a&gt;  。似乎無論哪邊都要依賴 &lt;a class="reference external" href="http://pygments.org/"&gt;Pygments&lt;/a&gt;  作爲代碼着色器，那麼其實 Rubyist  也至少需要安裝 Python  。我傾向於不依賴任何 Ruby  組件，最好沒有 C  擴展的純 Python  實現。 &lt;/p&gt;
&lt;p&gt; 於是我開始在 Github  上找 Python  的靜態博客引擎。 &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt;  的作者 &lt;a class="reference external" href="https://github.com/mitsuhiko"&gt;mitsuhiko&lt;/a&gt;  寫的 &lt;a class="reference external" href="https://github.com/mitsuhiko/rstblog"&gt;rstblog&lt;/a&gt;  看起來不錯，不過似乎沒有多少人在用。 &lt;a class="reference external" href="http://ringce.com/hyde"&gt;Hyde&lt;/a&gt;  似乎很完善，不過默認的標記語言是 MarkDown  ，又依賴於幾個 Ruby  組建，而且官方網站的設計實在太前衛。最終我看到了 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt;  。 &lt;/p&gt;
&lt;table class="table-hover footnote  table-striped docutils table" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;/col&gt;&lt;col&gt;&lt;/col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id8"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt; 比如 Python 2.x  與 3.x  之間看似難以跨越的鴻溝，以及 &lt;a class="reference external" href="http://pypy.org/"&gt;PyPy&lt;/a&gt;  、 &lt;a class="reference external" href="http://python.org/"&gt;CPython&lt;/a&gt;  、 &lt;a class="reference external" href="http://www.stackless.com/"&gt;Stackless&lt;/a&gt;  、 &lt;a class="reference external" href="http://cython.org/"&gt;Cython&lt;/a&gt;  等各個實現之間的微妙差別。 &lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="table-hover footnote  table-striped docutils table" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;/col&gt;&lt;col&gt;&lt;/col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id9"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt; 是的，我們有 &lt;a class="reference external" href="http://packages.python.org/distribute/easy_install.html"&gt;easy_install&lt;/a&gt;  ，我們有 &lt;a class="reference external" href="http://www.pip-installer.org/en/latest/index.html"&gt;pip&lt;/a&gt;  ，不過這些都是包管理器，都是裝好特定的 Python 實現之後的事情。 Python 實現本身還不需要包管理器來管理。 Python  的版本問題基本上也只需要 &lt;a class="reference external" href="http://docs.python.org/release/3.0.1/library/2to3.html"&gt;2to3.py&lt;/a&gt;  和 &lt;a class="reference external" href="http://www.startcodon.com/wordpress/?cat=8"&gt;3to2.py&lt;/a&gt;  這樣的輕量級轉換器就可以了，你不需要爲了安裝多個軟件而在硬盤裏留下多個不同版本的 Python  。如果爲了引用的穩定性，你可以用 &lt;a class="reference external" href="http://pypi.python.org/pypi/virtualenv"&gt;virtualenv&lt;/a&gt;  ，不過這又是另一回事情了。 &lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h2&gt; 那麼就 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt;  吧 &lt;/h2&gt;
&lt;p&gt; 對我而言， &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt;  相比於 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt;  有幾個好處： &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 純 Python  實現。這意味着我可以換用任何 Python  解釋器而不必擔心兼容性問題。比如我就換成了 &lt;a class="reference external" href="http://pypy.org/"&gt;PyPy&lt;/a&gt; 。 &lt;/li&gt;
&lt;li&gt; 多語言支持。因爲 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt;  的作者似乎是個法國人。不過這個似乎大部分人不需要 ……  我是想儘量把一篇博客寫成三種語言作爲鍛鍊吧。 &lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;ReST&lt;/a&gt;  。這樣我就可以用 &lt;a class="reference external" href="http://webpages.charter.net/edreamleo/front.html"&gt;Leo&lt;/a&gt;  的 @auto-rst  直接寫  ReST 了。簡單方便快捷有效。 &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt; 不過似乎 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt;  的關注度不如 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt;  那麼高，現在一些部分還有細微的問題： &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;pelican-import  從 WordPress  導入的時候對中文、日文的支持似乎很成問題。 &lt;/li&gt;
&lt;li&gt; 日期格式、時區、字符集、和多語言功能的結合度還不夠。 &lt;strong&gt; 我在嘗試改善它。 &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt; 模板還不夠豐富。 &lt;/li&gt;
&lt;li&gt; 插件也不夠多 ……&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt; 希望這麼優秀的工具能夠受到更多關注，以上這些問題都是增加關注度之後很快就能解決的問題。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="settings-py"&gt;
&lt;h2&gt; 我的設置  settings.py&lt;/h2&gt;
&lt;p&gt; 安裝 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt;  很容易，一句話就夠了： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; pip install pelican
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然後把文章寫成 ReST 的格式，放在 `pages` 文件夾裏面。 ( 重新 ) 生成只要： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; pelican -s settings.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上傳到  Github:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; git commit -am &lt;span class="s2"&gt;"Commit message"&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; git push
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 就這麼簡單。附上我的配置文件： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class="n"&gt;TIMEZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'Asia/Tokyo'&lt;/span&gt;

&lt;span class="n"&gt;DATE_FORMATS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;'en'&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="s"&gt;'usa'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;'%a, &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt; %b %Y'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="s"&gt;'zh'&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="s"&gt;'chs'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;'%Y-%m-&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;, %a'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="s"&gt;'jp'&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="s"&gt;'jpn'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;'%Y/%m/&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt; (%a)'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;# windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx&lt;/span&gt;
&lt;span class="n"&gt;LOCALE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;'usa'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'chs'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'jpn'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;        &lt;span class="c"&gt;# windows&lt;/span&gt;
          &lt;span class="s"&gt;'en_US'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'zh_CN'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'ja_JP'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c"&gt;# Unix/Linux&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_LANG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'zh'&lt;/span&gt;

&lt;span class="n"&gt;SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'Farseerfc Blog'&lt;/span&gt;
&lt;span class="n"&gt;AUTHOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'Jiachen Yang'&lt;/span&gt;

&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'farseerfcgithub'&lt;/span&gt;
&lt;span class="n"&gt;GITHUB_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'https://github.com/farseerfc'&lt;/span&gt;
&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'http://farseerfc.github.com'&lt;/span&gt;
&lt;span class="n"&gt;TAG_FEED&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'feeds/&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.atom.xml'&lt;/span&gt;

&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;'twitter'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'http://twitter.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'github'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'https://github.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'facebook'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'http://www.facebook.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'weibo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'http://weibo.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'renren'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'http://www.renren.com/farseer'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="n"&gt;TWITTER_USERNAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'farseerfc'&lt;/span&gt;

&lt;span class="n"&gt;THEME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;'notmyidea'&lt;/span&gt;
&lt;span class="n"&gt;CSS_FILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"wide.css"&lt;/span&gt;

&lt;span class="n"&gt;DEFAULT_CATEGORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;'Others'&lt;/span&gt;
&lt;span class="n"&gt;OUTPUT_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'.'&lt;/span&gt;
&lt;span class="n"&gt;PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'posts'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Fri, 24 Feb 2012 17:33:00 +0900</pubDate><guid>tag:farseerfc.github.io,2012-02-24:try-pelican.html</guid><category>python</category><category>pelican</category></item><item><title>關於我的Blogs</title><link>//farseerfc.github.io/about-my-blogs.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;p&gt; 很久沒有寫過 blog 或者之類的東西了。這邊一直荒廢着。 &lt;/p&gt;
&lt;p&gt; 由於國內被牆的原因，另一個 wordpress ：  &lt;a class="reference external" href="http://fchome.sinaapp.com/"&gt;http://fchome.sinaapp.com/&lt;/a&gt;  應該會同步更新這裏的內容。 &lt;/p&gt;
&lt;p&gt; 抽空寫點什麼吧。 &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 27 Sep 2011 02:35:00 +0900</pubDate><guid>tag:farseerfc.github.io,2011-09-27:about-my-blogs.html</guid></item><item><title>“…if we do this work … ” —Bill Gates</title><link>//farseerfc.github.io/if-we-do-this-work.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 導入自 &lt;a class="reference external" href="http://blog.renren.com/blog/230263946/716517729"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From: Bill Gates&lt;/p&gt;
&lt;p&gt;’— Sent: Sunday, January 24, 1999 8:41 &lt;span class="caps"&gt;AM&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Jeff Westorinon; Ben Fathi ;&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;TO&lt;/span&gt;: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder&lt;/p&gt;
&lt;p&gt;Subject: &lt;span class="caps"&gt;ACPI&lt;/span&gt; extensions&lt;/p&gt;
&lt;p&gt;One thing I find myself wondering about is whether we shouldn’t try and
make the "&lt;span class="caps"&gt;ACPI&lt;/span&gt;" extensions somehow Windows specific.&lt;/p&gt;
&lt;p&gt;It seems unfortunate if we do this work and get our partners to do the
work and the result is that &lt;strong&gt;Linux works great without having to do the work&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maybe there is no way to avoid this problem but it does bother me.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Maybe we could define the APIs so that they work well with &lt;span class="caps"&gt;NT&lt;/span&gt; and not
the others even if they are open.&lt;/p&gt;
&lt;p&gt;Or maybe we could patent something relaled to this.&lt;/p&gt;
&lt;p&gt;From:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf"&gt;http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/&lt;span class="caps"&gt;PX03020&lt;/span&gt;.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 如果這就是我至今在 Xen4.0 上得不到 ACPI 3.0 的完善支持的原因，那麼我詛咒 Bill Gates ！ &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Mon, 14 Mar 2011 20:34:00 +0900</pubDate><guid>tag:farseerfc.github.io,2011-03-14:if-we-do-this-work.html</guid><category>microsoft</category><category>linux</category><category>acpi</category></item><item><title>[zz]“西廂計劃”原理小解</title><link>//farseerfc.github.io/zz-introducing-scholarzhang.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;p&gt; 好神奇的想法，先存着，以後慢慢研究 &lt;/p&gt;
&lt;p&gt; 原文： &lt;a class="reference external" href="http://blog.youxu.info/2010/03/14/west-chamber/"&gt;http://blog.youxu.info/2010/03/14/west- chamber/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 待月西廂下，迎風戶半開。隔牆花影動，疑是玉人來。 &lt;/p&gt;
&lt;p&gt; 最近推上最流行的一個關鍵詞是 ” 西廂計劃 ”,  這個計劃名字取得很浪漫，客戶端叫做張生，對，就是西廂記裏面那個翻牆去見崔鶯鶯小姐的張生；顯然，服務器端必然叫做崔鶯鶯。客戶端的張生是最重要的部件，可以不依賴於服務端工作。因爲西廂計劃的作者只是簡要的介紹了一下原理，其他報道又語焉不詳，我當時就覺得很好奇，花了昨天一個晚上詳細讀了一下源代碼，終於知道怎麼回事了，覺得原理非常漂亮，所以寫篇文章介紹總結一下。 &lt;/p&gt;
&lt;p&gt; 先說大方向。大家都知道，連接被重置的本質，是因爲收到了破壞連接的一個 &lt;span class="caps"&gt;TCP&lt;/span&gt;
Reset  包。以前劍橋大學有人實驗過，客戶端和服務器都忽略 Reset,
 則通信可以不受影響。但是這個方法其實只有理論價值，因爲絕大多數服務器都不可能忽略 Reset  的 ( 比如 Linux,  需要 root  權限配置 iptables,  而且這本身也把正常的 Reset  給忽略了 ) 。只要服務器不忽略 Reset,
 客戶端再怎麼弄都沒用，因爲服務器會停止發送數據， Reset
 這條連接。所以，很多報道說西廂計劃是忽略 Reset,
 我從源代碼來看應該不是這樣。在我看來，西廂計劃是利用了牆的一個可能的弱點 – 牆只在連接發起的時候把一個 &lt;span class="caps"&gt;TCP&lt;/span&gt;  連接加入監聽序列，如果牆認爲這個連接終止了，就會從監聽序列中去掉這條記錄，這樣，這條連接上後續的包就不會被監聽。西廂計劃就是讓牆 “ 認爲 ” 這個連接終止的一個絕妙的方法。只要牆認爲這個連接兩端都是死老虎，牆就不會觸發關鍵詞檢測，其後所有的數據，都不存在連接被重置的問題了。 &lt;/p&gt;
&lt;p&gt; 如何讓一個連接置之死地而後生，就是西廂計劃那幫黑客神奇的地方了。這也不是一日之功。首先，這幫牛人發現，牆的是一個入侵檢測系統，把含有關鍵字的包當成一種 “ 入侵 ” 來對待。採取這種設計有很多好處，但缺點是入侵檢測系統可能具有的問題，牆都可能有。西廂計劃主頁上那篇著名的論文就是講這些七七八八的漏洞的。可以說處理這些七七八八的漏洞是非常困難的，迫使牆的設計者 “ 拆東牆，補西牆 ” 。這樣補來補去，外表看起來好像很牛逼的牆，其實有很多本質上無法簡單修補的漏洞，其中有一個致命的，就是 &lt;span class="caps"&gt;TCP&lt;/span&gt;  連接狀態的判定問題。出於入侵檢測系統這種設計的侷限，牆沒有，也沒辦法準確判定一條 &lt;span class="caps"&gt;TCP&lt;/span&gt;  連接的狀態，而只是根據兩邊收到的數據來 “ 推測 ” 連接的狀態。而所有的關鍵詞檢測功能，都是基於 “ 連接還活着 ” 的這個推測的結果的。因爲牆的規則是在連接發起的時候開始對這條連接的檢測，在連接終止的時候停止對這條連接的檢測，所以，一旦對連接的狀態推測錯誤，把還活着的連接當成已經關閉的連接，牆就會放棄對這條連接上隨後所有的包的檢測，他們都會都透明的穿過牆的入侵檢測。 &lt;/p&gt;
&lt;p&gt; 上面只是想法，具體到 &lt;span class="caps"&gt;TCP&lt;/span&gt;
 協議實現這一層，就要只迷惑牆，還不能觸及我要通信的服務器。最理想的情況下，在任何有效通信之前，就能讓牆出現錯誤判斷，這些，就需要對 &lt;span class="caps"&gt;TCP&lt;/span&gt;  協議有深刻理解了。西廂計劃的那幫黑客，居然真的去讀 &lt;span class="caps"&gt;TCP&lt;/span&gt;  幾百頁的 &lt;span class="caps"&gt;RFC&lt;/span&gt; ，還居然就發現了方法（這裏我假設讀者都知道 &lt;span class="caps"&gt;TCP&lt;/span&gt;
 的三次握手過程和序列號每次加一的規則）。我們都知道，三次握手的時候，在收到服務器的 &lt;span class="caps"&gt;SYN&lt;/span&gt;/&lt;span class="caps"&gt;ACK&lt;/span&gt;
 的時候，客戶端如果發送 &lt;span class="caps"&gt;ACK&lt;/span&gt;  並且序列號 +1
 就算建立連接了，但是客戶端如果發送一個序列號沒 +1  的 &lt;span class="caps"&gt;FIN&lt;/span&gt;
 （表示連接終止，但是服務器知道，這時候連接還沒建立呢， &lt;span class="caps"&gt;FIN&lt;/span&gt;
 這個包狀態是錯的，加上序列號也是錯的，服務器自己一判斷，就知道這個包是壞包，按照標準協議，服務器隨手丟棄了這個包） ,
 但這個包，過牆的時候，在牆看來，是表示連接終止的 ( 牆是 ma de in china,
 是比較山寨的，不維護連接狀態，並且，牆並沒有記下剛纔服務器出去的 &lt;span class="caps"&gt;SYN&lt;/span&gt;/&lt;span class="caps"&gt;ACK&lt;/span&gt;
 的序列號，所以牆不知道序列號錯了）。所以，牆很高興的理解爲連接終止，舒了一口氣去重置其他連接了，   而這個連接，就成了殭屍，牆不管你客戶端了，而這時候，好戲纔剛剛開始。 &lt;/p&gt;
&lt;p&gt; 事實上，牆是雙向檢測的（或者說對每個包都檢測的），因此，對服務器和客戶端實現相同的對待方法，所以，牆不管客戶端還不行，假如服務端有關鍵詞傳給客戶端，牆還是有可能要發飆的（這裏說有可能，因爲我也不知道）。所以，最好的辦法就是，讓服務端也給牆一個終止連接的標誌就好了。可是這個說起來簡單，做起來難，怎麼能讓不受自己控制的服務器發一個自己想要的包呢？西廂計劃的那幫黑客，再次去讀幾百頁的 &lt;span class="caps"&gt;RFC&lt;/span&gt;,  令人驚訝的發現，他們居然在 &lt;span class="caps"&gt;RFC&lt;/span&gt;
 上發現了一個可以用的特性。我們上面說了，三次握手的時候，在收到 &lt;span class="caps"&gt;SYN&lt;/span&gt;/&lt;span class="caps"&gt;ACK&lt;/span&gt;
 後，客戶端要給服務器發送一個序列號 +1  的 ACK ，可是，假如我不 +1 呢，直接發 &lt;span class="caps"&gt;ACK&lt;/span&gt;  包給服務器。牆已經認爲你客戶端是死老虎了，不理你了，不知道你搞什麼飛機，讓這個 &lt;span class="caps"&gt;ACK&lt;/span&gt;
 過了。可是服務器一看，不對啊，你給我的不是我期待的那個序列號， &lt;span class="caps"&gt;RFC&lt;/span&gt;
 上說了， &lt;span class="caps"&gt;TCP&lt;/span&gt;  包如果序列號錯了的話，就回復一個 Reset.
 所以，服務器就回復了一個 Reset 。這個 Reset
 過牆的時候，牆一看樂了，服務器也終止連接了，好吧，兩邊都是死老虎了，我就不監聽這條連接了。而至於客戶端，這個服務器過來的 Reset  非常好識別，忽略就是。隨後，客戶端開始正確的發送 &lt;span class="caps"&gt;ACK&lt;/span&gt;,
 至此，三次握手成功，真正的好戲開始，而牆則認爲客戶端和服務器都是死老虎，直接放過。所以，張生就這樣透明的過了牆。   至於過牆以後所有的事情，《西廂記》裏面都有記載，各位讀者自行買書學習。 &lt;/p&gt;
&lt;p&gt; 現在的西廂計劃客戶端，即 “ 張生 ” 模塊的防連接重置的原理就是這樣，服務器端，即鶯鶯模塊的實現也是類似的。防 DNS 那個，不懂 &lt;span class="caps"&gt;DNS&lt;/span&gt;
 協議，所以看不懂。我猜想，因爲開發人員都是黑客，所以自然喜歡用最經得起折騰和高度定製的 Linux  開發。現在看西廂計劃的實現，因爲依賴於 Linux  內核模塊 netfilter,
 在 Linux  上如魚得水，但往其他平臺的移植可能是個亟待解決的問題。我覺得，在其他平臺上，可以通過 libpcap  和 libnet
 ，在用戶態實現相同的功能，就是有點麻煩而已，有興趣的懂網絡的可以照西廂計劃原理，在家自行做出此功能；當然，全中國人民都用 Linux  最好  :)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;span class="caps"&gt;PS&lt;/span&gt; 1:  據說是西廂計劃一個作者畫的原理圖： &lt;a class="reference external" href="http://img.ly/DIi"&gt;http://img.ly/DIi&lt;/a&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;span class="caps"&gt;PS&lt;/span&gt; 2:  我對 &lt;span class="caps"&gt;TCP&lt;/span&gt;  的理解僅限於課本，如果上面的對技術的理解有錯，請大家指出。 &lt;/div&gt;
&lt;div class="line"&gt;&lt;span class="caps"&gt;PS&lt;/span&gt; 3:  有些漏洞，可能是設計上本質缺陷，不是那麼容易修復的。 &lt;/div&gt;
&lt;div class="line"&gt;&lt;span class="caps"&gt;PS&lt;/span&gt; 4:  除了最後一個圖，本文沒有其他相關鏈接，如需相關資料，自行 Google 。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Wed, 17 Mar 2010 09:40:00 +0900</pubDate><guid>tag:farseerfc.github.io,2010-03-17:zz-introducing-scholarzhang.html</guid><category>zz</category></item><item><title>寫程序讓CPU佔用率保持正弦函數</title><link>//farseerfc.github.io/sine-cpu.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 導入自 &lt;a class="reference external" href="http://blog.renren.com/blog/230263946/298871889"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 據說是一道微軟的面試題。如題，寫程序，讓 Windows 的任務管理器中的性能監視器呈現正弦曲線。 &lt;/p&gt;
&lt;img alt=" 正弦曲線 " class="img-responsive align-center" src="http://fm531.img.xiaonei.com/pic001/20080602/23/14/large_10019p67.jpg"/&gt;
&lt;img alt=" 正弦曲線 " class="img-responsive align-center" src="http://fm541.img.xiaonei.com/pic001/20080602/23/14/large_9935o67.jpg"/&gt;

&lt;p&gt; 潛心鑽研良久，得代碼：（ java ） &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;sincpu&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++){&lt;/span&gt;
            &lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
            &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;calcNextSleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sin&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sleep&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;sleepTime&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleepTime&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;yield&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleepTime&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;period&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(;;){&lt;/span&gt;
            &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sin&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;period&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 多核 CPU 上測試時要注意關掉一個 CPU ： &lt;/p&gt;
&lt;img alt=" 多核 CPU 上測試 " class="img-responsive align-center" src="http://fm411.img.xiaonei.com/pic001/20080602/23/14/large_9946k67.jpg"/&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Mon, 02 Jun 2008 23:27:00 +0900</pubDate><guid>tag:farseerfc.github.io,2008-06-02:sine-cpu.html</guid><category>java</category><category>microsoft</category></item><item><title>關於神創論的一些見解</title><link>//farseerfc.github.io/some-thought-on-creationism.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 導入自 &lt;a class="reference external" href="http://blog.renren.com/blog/230263946/292274803"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 看到陳驫同學很有感想的一篇神創論與命運日誌，覺得近日很久沒有看到這樣的評論了。想說幾句自己的觀點。 &lt;/p&gt;
&lt;p&gt; 首先我認爲，神創論與宿命論沒有多少關聯，甚至進化論者相較於神創論者更容易接受宿命論的觀點。因爲神創論主張意志的存在，人所具有的個體意志與神的意志，因此在神創論者的眼中事件的結果是可以通過意志來改變的，亦即如果我從物理樓 11 樓跳下，那麼我就可以改變自己死亡時間的宿命。上帝的意志同樣可以左右事件的結果，也就是所謂的宿命不復存在。而進化論者不承認意志獨立於物質世界的存在，你我的思考、行爲，都受到物理學法則諸如量子力學的約束，這就引出了北大物理系教授的那句 “ 宇宙中的一切都是可以計算的 ” ，亦即宿命論。如我我選擇現在從物理樓上跳下，我這一行爲並不是處於個人的獨立意志，乃是想證明這一點，亦即我跳樓這一舉動是有其背後的動機與原因的，就如同計算機的輸入必然導致了輸出，宿命的必然終結於此。 &lt;/p&gt;
&lt;p&gt; 其次，關於事件的複雜度所導致的隨機化，在大量混沌隨機中也存在着如統計學和隨機分形學這樣的規律，並不是否認宿命的充分理由。 &lt;/p&gt;
&lt;p&gt; 關於神創論的合理性問題。我認爲是否相信神的存在只是一個 boolean 二值問題，它爲 true 爲 false 本身並不重要，重要的是確定它的取值之後得到的推論與結果。如果否認神的存在，如現代數學這樣的完美又何以存在，進化論者的解釋是事物最終會向着更好更高級的方向發展，產生現代數學乃至現代科學是發展的必然。而這種論調顯然有悖於物理中以熱力學第二定律爲首的，預言事物會隨時間推演愈發混亂的論斷。更進一步，甚至整個人類、整個生物系統的存在都是有悖於熱力學推論的現象，是某種理論只能以 “ 小概率事件 ” 解釋的現象。 &lt;/p&gt;
&lt;p&gt; 神創論的核心觀點之一，是神的唯一存在性，按照鄒恆明的比喻，這就如同數學中集閤中元素的的唯一性一般至關重要。數學乃至近代科學的發展，其起源在於這種對神性的探求，而不僅僅是好奇心就可以解釋的。反觀東方文化中數學的發展，開始時領先於西方科學千餘每年，但是始終作爲一種 craft-oriented 的實用主義學科。可以說沒有了神的唯一性支持，人們就不能確信自己能找到這樣一種完美高效的學科，只能在實用的基礎上發展其基礎算數。可以想象，沒有神的完美與唯一性，數學必將發展成現代化學或者微軟軟件這樣，龐大而充滿特例，到處都是修補與查表，怎麼會像現在的完美、簡潔與和諧。 &lt;/p&gt;
&lt;p&gt; 神創論者並不是將難題推與 “ 神 ” 然後放任不管，他們相信神是最爲理智的存在，創人時人同樣得到了神的智慧和理智，也就是神可以用人的理智來理解。 &lt;/p&gt;
&lt;p&gt; 引用牛頓《自然哲學的數學原理》中終章的話 “ 太陽、恆星、行星的這個極精緻的結構不可能存在，除非通過一個有理智的和有權能的存在的設計和主宰 …… 他不是作爲宇宙的靈魂，而是作爲一切的主宰而統治所有 ……”&lt;/p&gt;
&lt;p&gt; 以上 ……&lt;/p&gt;
&lt;p&gt;( 發現最近的哲理思維果然慢了不少，寫作思緒也一片混亂 ^_^)&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Mon, 12 May 2008 11:16:00 +0900</pubDate><guid>tag:farseerfc.github.io,2008-05-12:some-thought-on-creationism.html</guid><category>creationism</category></item><item><title>由記憶棒誤差故障引發的關於面向對象設計的九點思考</title><link>//farseerfc.github.io/9-thoughts-about-oop-from-wrongly-insert-memory-stick.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;p&gt; 故障描述 :
&lt;span class="caps"&gt;MMC&lt;/span&gt; Memory Stick Duo 記憶棒未經 Adapter 適配器，直接插入 SD Reader ，致使 MMC 卡入 SD Reader 中。 &lt;/p&gt;
&lt;p&gt; 棧展開：某日下午，無課。忙於數分作業，想查詢用手機拍攝的板書照片。取出手機中的 MMC 。未經裝配 Adapter ，直接插入 SD Reader 。 (A runtime exception was thrown.)
 嘗試翻轉筆記本機身，倒出 MMC ，未果。 (rethrow)
 嘗試用手指甲取出，未果。 (rethrow)
 考慮到有 “ 推入反彈 ” 機制，嘗試將 MMC 推入更深，反彈機制由於類型不匹配而失效，未果。 (rethrow)
(The exception spread across the border of the model.)
 電腦維修技師接手 (catch)
 技師未能發現問題所在，由我解說原委。 (Because the exception lose the information, &lt;span class="caps"&gt;RTTI&lt;/span&gt; was asked to recall the information)
 技師發現問題，嘗試用鑷子鑷出 MMC ，未果。技師開解機箱 (expose the data structure)
 技師製作鉤子，勾出 MMC(hooker link to the structure)  取出 MMC ，故障解除 &lt;/p&gt;
&lt;p&gt; 故障總結  1. 接收到沒有完全瞭解、或沒有適當工具解決的 exception 時，不要嘗試用不成熟的技術解決，應儘快尋求能解決它的代碼。否則，被反覆 rethrow 的 exception ，尤其是通過模塊邊界的 exception ，有可能由 subclass 退化爲 superclass ，並因此而喪失一些信息。儘量不要讓 exception 丟失信息，必要時，通過 RTTI 機制尋回信息。 &lt;/p&gt;
&lt;p&gt;2. 超負荷運轉，多線程執行，這種種複雜性都有可能導致錯誤，應避免。無論你有多麼信任你的代碼或能力。 &lt;/p&gt;
&lt;p&gt;3. 在設計 class 的 interface 時，相匹配的 interface 應該滿足 is-a 的關係。因此，任何能插入 SD Reader 的 object ，即任何實現了 SD interface 的 object ，都應該 is-a &lt;span class="caps"&gt;SD&lt;/span&gt; card 。這次故障中， interface 接受了 MMC ，但 MMC 不是 SD 。即使這種情況下 throw an exception ，都不能使事態緩和。能提供 compile-time error 時，儘量讓錯誤以 compile-time error 的形式展現，並在事先解決。類型匹配問題是應該能在事先解決的問題。 &lt;/p&gt;
&lt;p&gt;4.Design patterns 中的 Adapter pattern 應該只是迫不得已情況之下的解決方案。只有當你無權改變現狀時，才能使用 Adapter 。如果能改變現狀，應該改變設計以符合 interface 。 &lt;/p&gt;
&lt;p&gt;5. 因爲上條，所有相似功能的對象應具有相同的 interface ，不同的 interface 是本次故障的根源所在。 &lt;/p&gt;
&lt;p&gt;6. 特殊情況下，破壞封裝機制並 expose the data structure 是必要的，應該有方法支持這種做法。 C 的指針和 C# 的 Reflection 技術都以不同的方式支持這種做法。其他的一些語言機制，比如 serializing( 序列化 ) 或 streaming( 流化 ) ，也可以以某種方式間接支持這一做法。當然，機制還應避免這種做法被濫用。 &lt;/p&gt;
&lt;p&gt;7. 相反功能具有相同操作的設計，容易造成使用的混亂，應適當避免。比如 SD Reader 的推入反彈設計，即插入和彈出使用同一個向裏推的操作的設計。同樣的設計還包括， C++ 中的 setNewHandle 使用同一個函數，同時設置和返回 handle 。以及有些書中提倡的，使用同名函數重載的方式，實現 setter/getter 的設計。 &lt;/p&gt;
&lt;p&gt;8. 特殊工具 (hooker) 對於解決特定問題，通常比手工解決有效。不要嫌麻煩而不願意構造特殊工具。 &lt;/p&gt;
&lt;p&gt;9. 棧語義，即 FILO 順序，總在不知不覺中影響我們。違反了 FILO 順序的操作極易造成混亂。本故障發生時正確的處理順序爲：裝配 Adapter
     插入 SD Reader
         讀取數據          停用設備      拔出 SD Reader
 拆解 Adapter  本次故障的原因就是違反了 FILO 順序，違反了棧語義。 &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Thu, 20 Sep 2007 14:38:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-09-20:9-thoughts-about-oop-from-wrongly-insert-memory-stick.html</guid><category>oop</category></item><item><title>Program Development in Java Preface</title><link>//farseerfc.github.io/program-development-in-java-preface.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt; 程序開發原理 &lt;/h2&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;—— 抽象、規格與面向對象設計 &lt;/h3&gt;
&lt;p&gt;Barbara Liskov  、 John Guttag  著 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 楊嘉晨等譯 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt; 關於翻譯風格： &lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 多年來閱讀計算機類的著作及譯作，感覺總體的困難在於一大堆沒有標準譯名的技術術語。由於通行於工業界和學術界的還是英文原名和術語，我決定保留大量的英文術語。這樣的翻譯風格借鑑於臺灣著名的譯者和作者侯捷先生。對於譯與不譯的權衡，主要考慮閱讀的流暢，以及讀者的理解能力，或許難免帶有一些主觀色彩。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="preface"&gt;
&lt;h2&gt; 前言  Preface&lt;/h2&gt;
&lt;p&gt; 構建產品級質量的程序 —— 可以在很長一段時間內使用的程序 —— 衆所周知是極其困難的。本書的目標就是改善程序員解決這項任務的效率。我希望讀者在閱讀本書之後成爲一名好程序員。我相信本書的成功在於改善編程技巧，因爲我的學生告訴我這已經發生在他們身上。 &lt;/p&gt;
&lt;p&gt; 怎麼纔算是一名好程序員？是產生整個程序產品的效率。關鍵是要在每一階段減少浪費掉的努力。解決的方法包括：在開始編寫代碼之前就仔細考慮你的實現方案，通過未雨綢繆的方法來編寫代碼，使用嚴格的測試在早期發現錯誤，以及仔細注意模塊化編程，這樣當錯誤出現時，只需要改動極少數代碼就可以修正整個程序。本書涉及所有這些領域的技術。 &lt;/p&gt;
&lt;p&gt; 模塊化編程 (Modularity) 是編寫好程序的關鍵。把程序分解成許多小模塊，每一個模塊通過良好定義的狹窄接口和別的模塊交互作用 (interact) 。有了模塊化，可以修正一部分程序中的錯誤而不考慮程序的其他部分，而且可以僅僅理解一部分程序而不必理解整個程序。沒有模塊化，程序是一大堆有着錯綜複雜的相互關係的部分的拼湊。很難去領悟和修改這樣一個程序，同樣也很難讓它正常工作。 &lt;/p&gt;
&lt;p&gt; 因此本書的重點在於創建模塊化的程序：怎樣把程序組織成一系列精心挑選的模塊。本書認爲模塊化就是抽象 (abstraction) 。每一個模塊意味着一個抽象，比如說指引一系列文檔中的關鍵字的目錄，或者在文檔中使用目錄來查找匹配某個問題的文檔的過程。着重強調面向對象編程思想 —— 在程序中使用數據抽象和對象的思想。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 這本書使用 Java 作爲它的編程示例的語言。我們沒有假定讀者已經熟悉 Java 。儘管可能沒什麼價值，但是本書中的思想是語言無關的，並且可以在任何語言的編程中使用。 &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="how-can-the-book-be-used"&gt;
&lt;h3&gt; 怎樣使用這本書？ How Can the Book Be Used&lt;/h3&gt;
&lt;p&gt; 本書《程序開發原理》有兩種使用方法。其一是作爲課本教材，講述如何用面向對象的方法來設計和實現複雜系統；其二是編程專家使用，幫助他們改善編程技能，增進他們的關於模塊化和 Object-Oriented( 面向對象 ) 設計的知識。 &lt;/p&gt;
&lt;p&gt; 作爲教材使用時，本書一般作爲第二或第三門程序設計課程。我們已經在 MIT 使用本書很多年，給大一大二的本科生教授第二門編程課。在這一階段，學生們已經知道怎樣編寫小程序。課程在兩方面利用這一點：讓學生更仔細地思考小程序，以及教他們如何利用小程序作爲組件構建大型程序。這本書也可以在專業（如軟件工程）後期教學中使用。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 建立在本書基礎上的課程適合於所有計算機科學專業。儘管許多學生可能永遠不會成爲真正的大型程序的設計師，他們可以在開發部門工作，在那兒他們負責設計和實現能與整個結構耦合的子系統。模塊化設計的子系統是這種任務中心，這對那些從事大型程序設計任務的人來說也同樣重要。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-is-this-book-about"&gt;
&lt;h3&gt; 這本書講什麼？ What Is This Book About&lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 通觀全篇三分之二的書致力於討論在構建獨立的程序模塊時產生的問題，剩下的部分討論怎樣運用這些模塊構建大型程序。 &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="program-modules"&gt;
&lt;h4&gt; 程序模塊 Program Modules&lt;/h4&gt;
&lt;p&gt; 這一部分的書集中討論抽象機制 (abstraction mechanism) 。它討論 procedure( 子程序 ) 和 exception( 異常 ) ，數據抽象，遍歷 (iteration) 抽象，數據抽象系列 (family) 以及多態 (polymorphic) 抽象。 &lt;/p&gt;
&lt;p&gt; 在對抽象的討論中，三個步驟是重要的。首先是決定被抽象的東西到底是什麼：它提供給它的用戶哪些行爲。創造抽象是設計的關鍵，因此本書討論如何在衆多選擇中挑選，以及怎樣才能創造出好的抽象。 &lt;/p&gt;
&lt;p&gt; 第二步是通過爲一個抽象制定一個規格 (specification) 來獲取它的意義。如果沒有一些描述，一個抽象就會含糊不清，而變得沒有使用價值。 specification 則提供了需要的描述。本書定義了一種 specification 的格式，討論了一份好的 specification 應有的屬性，並且提供了許多示例。 &lt;/p&gt;
&lt;p&gt; 第三步是實現抽象。本書討論怎樣設計一份實現，以及在簡潔性和執行性能之間怎樣權衡利弊。書中強調封裝 (encapsulation) 的重要性以及在一份實現中履行規格中定義的行爲的重要性。書中同樣提供一些技術 —— 尤其是不變式斷言 (representation
invariant) 和抽象函數 (abstraction function)—— 來幫助讀者理解代碼和它的原因。不變式斷言和抽象函數都實現到儘可能的程度，這對於除錯和調試很有用。 &lt;/p&gt;
&lt;p&gt; 關於類型層次 (type
hierarchy) 的材料注重討論使用它作爲抽象的技術 —— 一種把相關聯的一組數據抽象歸入同一系列的技術。這裏很重要的一點是，是否應當將一個類型作爲另一個類型的子類。本書定義了替換原則 —— 通過比較子類和父類的 specification ，來決定是否建立子類關係的方法 &lt;a class="reference external" href="#_ftn1"&gt;[1]&lt;/a&gt; 。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 本書同樣涉及除錯和調試。書中討論怎樣得到足夠數量的測試情況，來準備通過黑箱和白箱測試，它同樣強調了複查 (regression) 測試的重要性。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="programming-in-the-large"&gt;
&lt;h4&gt; 編寫大型程序 Programming in the Large&lt;/h4&gt;
&lt;p&gt; 本書的其後部分講解怎樣用模塊化的方法設計和實現大型程序。它建立在前文有關 abstraction 和 specification 的材料的基礎之上。 &lt;/p&gt;
&lt;p&gt; 編寫大型程序涵蓋四個主要議題。首先講解需求分析 —— 怎樣才能領悟程序中需要什麼。本書討論怎樣實施需求分析，也討論書寫產生的需求規格的方式，通過使用一種描述程序的抽象階段的數據模型。使用這種模型將產生一份更爲正式的 specification ，同時它也使需求檢查更加嚴格，這樣可以更好的領悟需求。 &lt;/p&gt;
&lt;p&gt; 編寫大型程序的第二項議題是程序設計，這通常是一個循序漸進的過程。設計過程圍繞構建有用的抽象來組織，這些抽象作爲整個程序之中理想的構建組建。這些抽象在設計時被仔細的編寫規格，這樣當程序實現時，那些實現抽象的模塊可以獨立地開發。這種設計使用設計筆記編寫文檔，包括描述整個程序結構的模塊間依賴性的圖示。 &lt;/p&gt;
&lt;p&gt; 第三項議題是實現和測試。本書討論了前置設計分析對於實現的必要性，以及怎樣進行設計複審。它同樣討論了設計和實現的順序。這一部分比較了自頂而下與自底而上的組織方式，討論如何使用驅動程序和佔位程序 &lt;a class="reference external" href="#_ftn2"&gt;[2]&lt;/a&gt;(stub) ，並且強調了制定一個事先的順序策略的必要性，以滿足開發組織和客戶的需求。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 本書以一章設計模式 (design pattern) 結束。一些模式在前面的章節介紹過，比如遍歷抽象是算法的主要組建。最後的章節討論前文中沒有涉及到的模式。希望它作爲這一教材的介紹。有興趣的讀者可以繼續閱讀其它書中更完善的討論 &lt;a class="reference external" href="#_ftn3"&gt;[3]&lt;/a&gt; 。 &lt;/div&gt;
&lt;/div&gt;
&lt;hr class="docutils"/&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref1"&gt;[1]&lt;/a&gt;  譯註：如果子類的 specification 包括了所有父類的 specification ，就是說父類的要求也是子類的要求，或者子類的要求更爲嚴格，那麼可以建立父子關係。而替換原則的說法是，對於具有父子關係的類，任何需要一個父類對象的地方，都可以替換爲一個子類對象。 &lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref2"&gt;[2]&lt;/a&gt;  譯註：在測試某一組建時，由於其餘組建還未實現，這一組建與其餘組建的接口銜接部分無法工作。此時可以針對這一組建編寫其餘組建的佔位程序 (stub) ，預留出接口的銜接代碼。佔位代碼通常不做任何有價值的事情，只報告組建的銜接部位工作正常。 &lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref3"&gt;[3]&lt;/a&gt;  譯註：作者指的是設計模式的開山之作 —— 《 Design
Patterns—Elements of Reusable Object-Oriented
Software 》 , 作者爲設計模式界著名的 “ 四人幫 ”GoF(Gang of Four) 。此書詳盡討論了三大類共 23 個廣泛使用的設計模式的適用範圍、依存關係、實現細節以及已有的應用領域等問題。書中以 C++ 和 Smalltalk 爲示例語言，不過書中所涉及的模式適用於所有面向對象的語言。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Sun, 16 Sep 2007 13:26:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-09-16:program-development-in-java-preface.html</guid><category>Java</category></item><item><title>C++ Tricks 3.2 標號、goto，以及switch的實現</title><link>//farseerfc.github.io/c-tricks-3-2-label-goto-and-implementation-of-switch.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h2&gt;3.2  標號、 goto ，以及 switch 的實現 &lt;/h2&gt;
&lt;p&gt;goto 語句及標號 (label) 是最古老的 C 語言特性，也是最早被人們拋棄的語言特性之一。像彙編語言中的 jmp 指令一樣， goto 語句可以跳轉到同一函數體中任何標號位置： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{int i=0;&lt;/p&gt;
&lt;p&gt;Loop: //A label&lt;/p&gt;
&lt;p&gt;++i;&lt;/p&gt;
&lt;p&gt;if(i&amp;lt;10)goto Loop; //Jump to the label&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 在原始而和諧的早期 Fortran 和 Basic 時代，我們沒有 if then else ，沒有 for 和 while ，甚至沒有函數的概念，一切控制結構都靠 goto( 帶條件的或無條件的 ) 構件。軟件工程師將這樣的代碼稱作 “ 意大利麪條 ” 代碼。實踐證明這樣的代碼極容易造成混亂。 &lt;/p&gt;
&lt;p&gt; 自從證明了結構化的程序可以做意大利麪條做到的任何事情，人們就開始不遺餘力地推廣結構化設計思想，將 goto 像猛獸一般囚禁在牢籠，標號也因此消失。 &lt;/p&gt;
&lt;p&gt; 標號唯一散發餘熱的地方，是在 switch 中控制分支流程。 &lt;/p&gt;
&lt;p&gt; 很多人不甚瞭解 switch 存在的意義，認爲它只是大型嵌套 if then else 結構的縮略形式，並且比 if 語句多了很多 “ 不合理 ” 的限制。如果你瞭解到 switch 在編譯器內部的實現機制，就不難理解強加在 switch 之上的諸多限制，比如 case 後只能跟一個編譯期整型常量，比如用 break 結束每一個 case 。首先看一個 switch 實例： &lt;/p&gt;
&lt;p&gt;switch (shape.getAngle())&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;case 3: cout&amp;lt;&amp;lt;”Triangle”;break;&lt;/p&gt;
&lt;p&gt;case 4: cout&amp;lt;&amp;lt;”Square”;break;&lt;/p&gt;
&lt;p&gt;case 0:case1: cout&amp;lt;&amp;lt;”Not a sharp!”;break;&lt;/p&gt;
&lt;p&gt;default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 任何程序員都可以寫出與之對應的 if 結構： &lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i==3) cout&amp;lt;&amp;lt;”Triangle”;&lt;/p&gt;
&lt;p&gt;else if(i==4) cout&amp;lt;&amp;lt;”Square”;&lt;/p&gt;
&lt;p&gt;else if(i==0||i==1) cout&amp;lt;&amp;lt;”Not a sharp!”;&lt;/p&gt;
&lt;p&gt;else cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt; 看起來這兩段代碼在語義上是完全一樣的，不是麼？ &lt;/p&gt;
&lt;p&gt; 不！或許代碼的執行結果完全一樣，但是就執行效率而言， switch 版本的更快！ &lt;/p&gt;
&lt;p&gt; 要了解爲什麼 switch 的更快，我們需要知道編譯器是怎樣生成 switch 的實現代碼的： &lt;/p&gt;
&lt;p&gt; 首先，保留 switch 之後由 {} 括起來的語具體，僅將其中 case 、 default 和 break 替換爲真正的標號： &lt;/p&gt;
&lt;p&gt;switch (getAngle(shape))&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 隨後，對於所有出現在 case 之後的常量，列出一張只有 goto 的跳轉表，其順序按 case 後的常量排列： &lt;/p&gt;
&lt;p&gt;goto _case_0;&lt;/p&gt;
&lt;p&gt;goto _case_1;&lt;/p&gt;
&lt;p&gt;goto _case_3;&lt;/p&gt;
&lt;p&gt;goto _case_4;&lt;/p&gt;
&lt;p&gt; 然後，計算 case 之後的常量與跳轉表地址之間的關係，如有需要，在跳轉表中插入空缺的項目： &lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default; // 因爲沒有 case 2 ，所以插入此項以條轉到 default&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt; 假設一個 goto 語句佔用 5 個字節，那麼在本例中， goto 的地址 =case 後的常量 *5+100105&lt;/p&gt;
&lt;p&gt; 之後，生成跳轉代碼，在其餘條件下跳轉至 default ，在已知範圍內按照公式跳轉，全部的實現如下： &lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i&amp;lt;0||i&amp;gt;=5)goto _default;&lt;/p&gt;
&lt;p&gt;i=i*5+100105; // 按照得出的公式算出跳轉地址 &lt;/p&gt;
&lt;p&gt;goto i; // 僞代碼， C 中不允許跳轉到整數，但是彙編允許 &lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default;&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 經過這樣處理整個 switch 結構，使得無論 switch 後的變量爲何值，都可以通過最多兩次跳轉到達目標代碼。相比之下 if 版本的代碼則採用線性的比較和跳轉，在 case 語句很多的情況下效率極低。 &lt;/p&gt;
&lt;p&gt; 由此 , 我們也可以知道 , 爲什麼 case 後跟的一定是編譯期整型常數，因爲編譯器需要根據這個值製作跳轉表。我們可以明白爲什麼 case 與 case 之間應該用 break 分隔，因爲編譯器不改變 switch 語句體的結構， case 其本身只是一個具有語義的標號而已，要想跳出 switch ，就必須用 break 語句。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Sun, 16 Sep 2007 13:08:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-09-16:c-tricks-3-2-label-goto-and-implementation-of-switch.html</guid><category>C++</category></item><item><title>C++ Tricks 3.1 左值右值與常量性(lvalue，rvalue &amp; constant)</title><link>//farseerfc.github.io/c-tricks-3-1-lvalue-rvalue-constant.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h2&gt;3.1  左值右值與常量性 (lvalue ， rvalue &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; constant)&lt;/h2&gt;
&lt;p&gt; 首先要搞清楚的是，什麼是左值，什麼是右值。這裏給出左值右值的定義： &lt;/p&gt;
&lt;p&gt;1 、左值是可以出現在等號 (=) 左邊的值，右值是隻能出現在等號右邊的值。 &lt;/p&gt;
&lt;p&gt;2 、左值是可讀可寫的值，右值是隻讀的值。 &lt;/p&gt;
&lt;p&gt;3 、左值有地址，右值沒有地址。 &lt;/p&gt;
&lt;p&gt; 根據左值右值的第二定義，值的左右性就是值的常量性 —— 常量是右值，非常量是左值。比如： &lt;/p&gt;
&lt;p&gt;1=1;//Error&lt;/p&gt;
&lt;p&gt; 這個複製操作在 C++ 中是語法錯誤， MSVC 給出的錯誤提示爲 “error C2106: ‘=’ :
left operand must be l-value” ，就是說 ’=’ 的左操作數必須是一個左值，而字面常數 1 是一個右值。可見，嚴格的區分左值右值可以從語法分析的角度找出程序的邏輯錯誤。 &lt;/p&gt;
&lt;p&gt; 根據第二定義，一個左值也是一個右值，因爲左值也可讀，而一個右值不是一個左值，因爲右值不可寫。 &lt;/p&gt;
&lt;p&gt; 通常情況下，聲明的變量是一個左值，除非你指定 const 將它變成一個右值： &lt;/p&gt;
&lt;p&gt;int lv=1;&lt;/p&gt;
&lt;p&gt;const int rv=lv;&lt;/p&gt;
&lt;p&gt; 由於右值的值在程序執行期間不能改變，所以必須用另一個右值初始化它。 &lt;/p&gt;
&lt;p&gt; 一個普通變量只能用右值初始化，如果你想傳遞左值，必須聲明一個引用或一個指針： &lt;/p&gt;
&lt;p&gt;int &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; ref=lv;// 用引用傳遞左值 &lt;/p&gt;
&lt;p&gt;int * plv=&amp;amp;lv;// 傳遞指針以間接傳遞左值 &lt;/p&gt;
&lt;p&gt; 必須用左值初始化引用，然而，可以用右值初始化常量引用： &lt;/p&gt;
&lt;p&gt;int &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; r1=1; //Error!&lt;/p&gt;
&lt;p&gt;const int &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; r2=1; //&lt;span class="caps"&gt;OK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 這實際上相當於： &lt;/p&gt;
&lt;p&gt;int _r2=1;&lt;/p&gt;
&lt;p&gt;const int &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; r2=_r2;&lt;/p&gt;
&lt;p&gt; 這樣的寫法在函數體內沒什麼作用，但是在傳遞函數參數時，它可以避免潛在的 ( 傳遞左值時的 ) 複製操作，同時又可以接受右值。 &lt;/p&gt;
&lt;p&gt; 通常情況下，函數的參數和返回值都只傳回右值，除非你明確的通過引用傳遞左值。 &lt;/p&gt;
&lt;p&gt; 明確了左值與右值的區別，有助於我們寫函數時確定什麼時候應該有 const ，什麼時候不該有。比如，我們寫了一個代表數學中複數的類 Complex ： &lt;/p&gt;
&lt;p&gt;class Complex;&lt;/p&gt;
&lt;p&gt; 然後，我們寫針對 Complex 的運算符重載： operator+ 和 operator= 。問題在於，參數和返回值應該是什麼類型，可選類型有四種： Complex 、 const Complex 、 Complex&amp;amp; 、 const Complex&amp;amp; 。 &lt;/p&gt;
&lt;p&gt; 對於 operator+ ，我們不會改變參數的值，所以可以通過 const
Complex&amp;amp; 傳遞參數。至於返回值類型，由於 int 類型的加法返回右值，所以根據 Do
as the ints do 的原則，返回值類型爲 const Complex ： &lt;/p&gt;
&lt;p&gt;const Complex operator+(const Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt; 對於 operator= ，同樣要思考這些問題。我們寫入第一個參數，所以第一個參數爲 Complex&amp;amp; ，我們只讀取第二個參數，所以第二個參數爲 const
Complex&amp;amp; 。至於返回值，還是 Do as the ints do 。 int 的賦值返回左值，不信你可以試一試： &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;(i=1)=2;&lt;/p&gt;
&lt;p&gt; 雖然比較傻，先將 i 賦爲 1 ，再將其改爲 2 ，但是這是被 C++ 語法支持的做法，我們就理應遵守。所以返回第一個參數的左值： &lt;/p&gt;
&lt;p&gt;Complex&amp;amp; operator=(Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt;const 是 C++ 引入的語言特性，也被 ANSI
C99 借鑑，在經典版本的 C 語言中是沒有的。關於 const 的歷史，有幾點值得玩味。最初 Bjarne
Stroustrup 引入 const 時，可寫性是和可讀性分開的。那時使用關鍵字 readonly 和 writeonly 。這個特點被首先提交到 C 的 ANSI 標準化委員會 ( 當時還沒有 C++ 標準化的計劃 ) ，但是 ANSI C 標準只接受了 readonly 的概念，並將其命名爲 const 。隨後，有人發現在多線程同步的環境下，有些變量的值會在編譯器的預料之外改變，爲了防止過度優化破壞這些變量， C++ 又引入關鍵字 violate 。從語義特點來看， violate 是 const 的反義詞，因爲 const 表示不會變的量，而 violate 表示會不按照預期自行變化的量。從語法特點而言， violate 與 const 是極爲相似的，適用於 const 的一切語法規則同樣適用於 violate 。 &lt;/p&gt;
&lt;p&gt; 值的常量性可以被劃分爲兩種：編譯期常量和運行期常量。 C++ 語法並沒有嚴格區分這兩種常量，導致了少許混亂： &lt;/p&gt;
&lt;p&gt;const int i=5;const int * pi=&amp;amp;i;&lt;/p&gt;
&lt;p&gt;const_cast&amp;lt;int&amp;amp;&amp;gt;i=1;// 對於運行期常量，在需要時可以去除它的常量性 &lt;/p&gt;
&lt;p&gt;int a[i];// 對於編譯期常量，可以用它來指定數組大小 &lt;/p&gt;
&lt;p&gt;cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;sizeof(a)/sizeof(a[0])&amp;lt;&amp;lt;*pi;&lt;/p&gt;
&lt;p&gt; 這種將編譯期與運行期常量的特性混用的方法，勢必導致語義的混亂。數組 a 的大小最終是 5 ，因爲採用了 i 的編譯期值，而不管 i 在運行期是否被改變了值。最後一句代碼將（有可能）輸出 551 ，第一個 i 的值作爲一種優化在編譯期綁定，第二個值標明瞭 a 的大小，第三個值通過指針顯示地輸出 i 的運行期真實值。 &lt;/p&gt;
&lt;p&gt; 在 C++ 的近親 C# 的語法中，這兩種常量被嚴格地區分開：編譯期常量由 const 指定，只能是內建類型變量；運行期常量由 readonly 指定，可以是任何類型。永遠不會改變的常量，如圓周率 pi 的值，應該用 const 聲明；而其它有可能改變的常量，皆由 readonly 聲明。 &lt;/p&gt;
&lt;p&gt;C++ 中的 const 的特點更傾向於 C# 中的 readonly ，雖然語法上允許使用 const 的編譯期常量性，但正如上文所展示的，這容易造成混亂。爲了得到 C# 中 const 的語義，在 C++ 中，我們不必迴歸惡魔 #define 的懷抱，可以使用所謂 “ 匿名 enum 技巧 ” 。當匿名聲明一個 enum 類型時，其中的枚舉值就是一個 int 類型的編譯期常量，比如： &lt;/p&gt;
&lt;p&gt;enum{Size=5;};&lt;/p&gt;
&lt;p&gt;int a[Size];&lt;/p&gt;
&lt;p&gt; 這種使用匿名 enum 來聲明編譯期常量的做法，被廣泛應用於 STL 、 boost 等模板庫的實現代碼中。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Sun, 16 Sep 2007 13:07:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-09-16:c-tricks-3-1-lvalue-rvalue-constant.html</guid><category>C++</category></item><item><title>C++ Tricks 2.2 I386平臺的內存佈局</title><link>//farseerfc.github.io/c-tricks-2-2-i386-memory-layout.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.2 I386 平臺的內存佈局 &lt;/h2&gt;
&lt;p&gt; 衆所周知， I386 是 32 位體系結構。因此對於絕大多數 I386 平臺的 C++ 編譯器而言， sizeof(int)=sizeof(long)=sizeof(void*)=4 。當然 C++ 標準對此沒有任何保證，我們也不應該試圖編寫依賴於此的代碼。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;32 位指針的可尋址空間爲 4GB 。爲充分利用這麼大的尋址空間，也是爲了支持其它更先進的技術比如多任務技術或者動態鏈接庫技術， WinNT 使用虛擬內存技術，給與每個應用程序全部 4GB 的內存空間。 4GB 的地址被一分爲二，前 2GB 供應用程序自己使用，後 2GB 由系統內核分配和管理。這 2GB 的內存地址，通常被劃分成 3 種內存區使用： &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;1  代碼及靜態數據區 &lt;/h3&gt;
&lt;p&gt; 由代碼加載器從動態鏈接庫鏡像 ( 通常是 exe 或 dll 文件 ) 加載，通常定位到鏡像文件中指定的基址開始的內存區。如果基址所在內存已被佔用，動態連接器會將代碼或數據重定向到其它可用地址。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 在 C++ 中，靜態數據包括：名字空間 (namespace) 和全局 (global) 對象、函數的 static 對象、類的 static 數據成員。這些靜態數據由編譯器分配地址 ( 但可能被重定向 ) ，由靜態連接器寫入代碼文件 ( 通常是 exe 或 dll) 的靜態數據區段。所以標準說，這些靜態數據在編譯期就已經具有地址。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stack"&gt;
&lt;h3&gt;2  棧 (Stack)&lt;/h3&gt;
&lt;p&gt; 棧是最常用的動態數據存儲區，所有函數的 non-static 對象和函數參數都在程序運行期在棧上分配內存。在數據結構中，術語 “ 棧 (Stack)” 意指先進後出 (&lt;span class="caps"&gt;FILO&lt;/span&gt; ， First
In Last Out) ，與 “ 隊列 (Queue)” 所指的 FIFO 相對。相對於基於堆的對象分配技術，默認使用棧的對象分配有兩點優勢： &lt;/p&gt;
&lt;p&gt; 一、棧的 FILO 與人的思維方式相同 &lt;/p&gt;
&lt;p&gt; 現實生活中有許多事例都使用 FILO 的方式，比如人們必須先提起話筒再撥打號碼，而後掛斷電話之後再放下話筒。使用 FILO 的棧，可以保證事物的銷燬順序以其誕生順序相反的順序進行，不會產生在掛斷電話之前就放下話筒的尷尬。 &lt;/p&gt;
&lt;p&gt; 二、棧的分配管理僅需要兩個額外指針：棧頂 (esp) 和棧底 (ebp) 指針 &lt;/p&gt;
&lt;p&gt; 從實現的技術層面而言，棧的管理比其它動態分配技術要簡單很多。 I386 平臺上的動態棧管理，僅需要棧頂和棧底兩個指針。這兩個指針的存儲顯然不能放置於棧中，置於靜態數據區又有損效率。 I386 平臺爲管理動態棧專門預留了兩個通用寄存器變量 esp 與 ebp ，分別代表棧頂 (esp,Extended
Stack Pointer) 與棧底 (Extended Bottom Pointer) 指針。其中的 extended 代表它們是 32 位指針，以區分 16 位的 sp 和 bp 寄存器。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 棧是動態存儲區的特點，表明它的內存佔用將隨着程序的運行而變化。 I386 平臺上 WinNT 將應用程序的棧置於程序空間，向下增長。程序初始化時，由操作系統將 esp 指向系統分配的棧空間的頂部。當程序需要在棧上分配變量時，就將 esp 減去變量所需字節數，這被稱作 “ 壓棧 (Push)” ；隨後又要銷燬變量時，就將 esp 加上變量所需字節數，這被稱作 “ 彈出 (Pop)” 。 esp 與 ebp 兩者之間所夾的空間，就是當前函數正在使用的棧空間。由於棧向下增長， esp( 棧頂 ) 的值總是小於 ebp( 棧底 ) 的值，新分配的變量地址總是小於舊變量的地址。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="heap"&gt;
&lt;h3&gt;3  堆 (Heap) 和自由存儲區 &lt;/h3&gt;
&lt;p&gt; 棧中的變量對於分配與釋放的順序有特定要求，這在一定程度上限制了棧的適用範圍。面向對象 (&lt;span class="caps"&gt;OO&lt;/span&gt; ， Object Oriented) 的程序設計思想也要求能自由地控制變量的分配與銷燬。由此，現代操作系統都提供了被稱作 “ 堆 (Heap)” 的自由存儲區，以允許由程序員控制的對象創建和銷燬過程。 C 標準庫函數 malloc 和 free 則是對操作系統提供的堆操作的封裝。 C++ 提供的自由存儲區運算符 new 和 delete 則通常是 malloc 和 free 的又一層封裝。 &lt;/p&gt;
&lt;p&gt; 操作系統經由 malloc 和 free 控制對堆的訪問。堆的存儲管理技術各不相同，簡單的使用雙鏈表管理，複雜的可以比擬一個完整的文件系統。 &lt;/p&gt;
&lt;p&gt; 由於額外的管理需求，使用系統提供的通用分配器在堆上分配和銷燬變量的代價，無論從空間角度還是效率角度而言，都比在棧上分配對象要高昂很多。對於 sizeof 上百的大型對象，這樣的高昂代價還是可以接受的，但是對於 sizeof 只有個位數的小對象，這樣的代價通常是一個數量級的差距。正因爲這個原因， STL 不使用 new 和 delete ，轉而使用分配子 (alllocor) 分配對象。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:30:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:c-tricks-2-2-i386-memory-layout.html</guid><category>C++</category></item><item><title>C++ Tricks</title><link>//farseerfc.github.io/c-tricks.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ Tricks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;By  FarseerFc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 從今天起，我再將在 &lt;a class="reference external" href="http://firechildren.spaces.live.com/"&gt;Live
Space&lt;/a&gt; 和 &lt;a class="reference external" href="http://76635424.qzone.qq.com/"&gt;QQZone&lt;/a&gt; 同時發表一系列文章，暫定名爲 “C++Tricks” 。 &lt;/p&gt;
&lt;p&gt; 本文旨在記錄和闡述一些本人學習 C++ 時所得的心得、技巧。總體來看，本文涉及的內容是每一個 C++ 程序員都應該知道的，但是很少見諸 C++ 教材。希望對各位同仁學習 C++ 有所幫助。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 也可以通過 QQ 或 MSN 向我索要此文的 DOC 版或 PDF 版，會比網頁上的更新的快一點。 &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lexical-problems"&gt;
&lt;h2&gt;1       詞法問題 (Lexical Problems)&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!139.entry"&gt;1.1  條件運算符 (?:)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!140.entry"&gt;1.2  逗號運算符 (,) 、邏輯運算符 (&amp;amp;&amp;amp;,||) 與運算符重載的陷阱 &lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="x86"&gt;
&lt;h3&gt;2      X86 體系結構 &lt;/h3&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!146.entry"&gt;2.1 X86 概述 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!147.entry"&gt;2.2 I386 平臺的內存佈局 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!148.entry"&gt;2.3 I386 平臺 C 函數內部的棧分配 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!149.entry"&gt;2.4 I386 平臺 C 函數調用邊界的棧分配 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!150.entry"&gt;2.5 I386 平臺的邊界對齊 (Align)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!151.entry"&gt;2.6 I386 平臺 C 函數的可變參數表 (Variable Arguments)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!152.entry"&gt;2.7 I386 平臺的其它函數調用模型 &lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="id6"&gt;
&lt;h5&gt;3  過程式編程 &lt;/h5&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!154.entry"&gt;3.1  左值右值與常量性 (lvalue ， rvalue &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; constant)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!155.entry"&gt;3.2  標號、 goto ，以及 switch 的實現 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:28:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:c-tricks.html</guid><category>C++</category></item><item><title>C++ Tricks 2.3 I386平臺C函數內部的棧分配</title><link>//farseerfc.github.io/c-tricks-2-3-i386-stack-allocation-in-c-functions.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.3 I386 平臺 C 函數內部的棧分配 &lt;/h2&gt;
&lt;p&gt; 函數使用棧來保存局部變量，傳遞函數參數。進入函數時，函數在棧上爲函數中的變量統一預留棧空間，將 esp 減去相應字節數。當函數執行流程途徑變量聲明語句時，如有需要就調用相應構造函數將變量初始化。當執行流程即將離開聲明所在代碼塊時，以初始化的順序的相反順序逐一調用析構函數。當執行流程離開函數體時，將 esp 加上相應字節數，歸還棧空間。 &lt;/p&gt;
&lt;p&gt; 爲了訪問函數變量，必須有方法定位每一個變量。變量相對於棧頂 esp 的位置在進入函數體時就已確定，但是由於 esp 會在函數執行期變動，所以將 esp 的值保存在 ebp 中，並事先將 ebp 的值壓棧。隨後，在函數體中通過 ebp 減去偏移量來訪問變量。以一個最簡單的函數爲例： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int a=0; //a 的地址被分配爲 ebp-4&lt;/p&gt;
&lt;p&gt;char c=1; //c 的地址被分配爲 ebp-8&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 產生的彙編代碼爲： &lt;/p&gt;
&lt;p&gt;push ebp ; 將 ebp 壓棧 &lt;/p&gt;
&lt;p&gt;mov ebp,esp ;ebp=esp  用棧底備份棧頂指針 &lt;/p&gt;
&lt;p&gt;sub esp,8 ;esp-=8 ，爲 a 和 c 預留空間，包括邊界對齊 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],0 ;a=0&lt;/p&gt;
&lt;p&gt;mov byte ptr[ebp-8],1 ;c=1&lt;/p&gt;
&lt;p&gt;add esp,8 ;esp+=8 ，歸還 a 和 c 的空間 &lt;/p&gt;
&lt;p&gt;mov esp,ebp ;esp=ebp  從棧底恢復棧頂指針 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢復 ebp&lt;/p&gt;
&lt;p&gt;ret ; 返回 &lt;/p&gt;
&lt;p&gt; 相應的內存佈局是這樣： &lt;/p&gt;
&lt;p&gt;09992:c=1 &amp;lt;-esp&lt;/p&gt;
&lt;p&gt;09996:a=0&lt;/p&gt;
&lt;p&gt;10000: 舊 ebp &amp;lt;-ebp&lt;/p&gt;
&lt;p&gt;10004:……&lt;/p&gt;
&lt;p&gt; 注 : 彙編中的 pop 、 push 、 call 、 ret 語句是棧操作指令，其功能可以用普通指令替換 &lt;/p&gt;
&lt;p&gt;push ebp 相當於 :&lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;mov dword ptr[esp],ebp&lt;/p&gt;
&lt;p&gt;pop ebp 相當於： &lt;/p&gt;
&lt;p&gt;mov ebp,dword ptr[esp]&lt;/p&gt;
&lt;p&gt;sub esp,4&lt;/p&gt;
&lt;p&gt;call fun_address 相當於： &lt;/p&gt;
&lt;p&gt;push eip&lt;/p&gt;
&lt;p&gt;jmp fun_address&lt;/p&gt;
&lt;p&gt;ret 相當於 &lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt; 帶參數的 ret&lt;/p&gt;
&lt;p&gt;ret 8 相當於 &lt;/p&gt;
&lt;p&gt;add esp,12&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt; 所有局部變量都在棧中由函數統一分配，形成了類似逆序數組的結構，可以通過指針逐一訪問。這一特點具有很多有趣性質，比如，考慮如下函數，找出其中的錯誤及其造成的結果： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i,a[10];&lt;/p&gt;
&lt;p&gt;for(i=0;i&amp;lt;=10;++i)a[i]=0;/An error occurs here!&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 這個函數中包含的錯誤，即使是 C++ 新手也很容易發現，這是老生常談的越界訪問問題。但是這個錯誤造成的結果，是很多人沒有想到的。這次的越界訪問，並不會像很多新手預料的那樣造成一個 “ 非法操作 ” 消息，也不會像很多老手估計的那樣會默不作聲，而是導致一個，呃，死循環！ &lt;/p&gt;
&lt;p&gt; 錯誤的本質顯而易見，我們訪問了 a[10] ，但是 a[10] 並不存在。 C++ 標準對於越界訪問只是說 “ 未定義操作 ” 。我們知道， a[10] 是數組 a 所在位置之後的一個位置，但問題是，是誰在這個位置上。是 i!&lt;/p&gt;
&lt;p&gt; 根據前面的討論， i 在數組 a 之前被聲明，所以在 a 之前分配在棧上。但是， I386 上棧是向下增長的，所以， a 的地址低於 i 的地址。其結果是在循環的最後， a[i] 引用到了 i 自己！接下來的事情就不難預見了， a[i] ，也就是 i ，被重置爲 0 ，然後繼續循環的條件仍然成立 …… 這個循環會一直繼續下去，直到在你的帳單上產生高額電費，直到耗光地球電能，直到太陽停止燃燒 …… 呵呵，或者直到聰明的你把程序 Kill 了 ……&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:28:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:c-tricks-2-3-i386-stack-allocation-in-c-functions.html</guid><category>C++</category></item><item><title>C++ Tricks 2.4 I386平臺C函數調用邊界的棧分配</title><link>//farseerfc.github.io/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.4 I386 平臺 C 函數調用邊界的棧分配 &lt;/h2&gt;
&lt;p&gt; 當調用一個函數時，主調函數將參數以聲明中相反的順序壓棧，然後將當前的代碼執行指針 (eip) 壓棧，然後跳轉到被調函數的入口點。在被調函數中，通過將 ebp 加上一個偏移量來訪問函數參數，以聲明中的順序 ( 即壓棧的相反順序 ) 來確定參數偏移量。被調函數返回時，彈出主調函數壓在棧中的代碼執行指針，跳回主調函數。再由主調函數恢復到調用前的棧。 &lt;/p&gt;
&lt;p&gt; 函數的返回值不同於函數參數，通過寄存器傳遞。如果返回值類型可以放入 32 位變量，比如 int 、 short 、 char 、指針等類型，通過 eax 寄存器傳遞。如果返回值類型是 64 位變量，如 _int64 ，同過 edx+eax 傳遞， edx 存儲高 32 位， eax 存儲低 32 位。如果返回值是浮點類型，如 float 和 double ，通過專用的浮點數寄存器棧的棧頂返回。如果返回值類型是用戶自定義結構，或 C++ 類類型，通過修改函數簽名，以引用型參數的形式傳回。 &lt;/p&gt;
&lt;p&gt; 同樣以最簡單的函數爲例： &lt;/p&gt;
&lt;p&gt;void f(){&lt;/p&gt;
&lt;p&gt;int i=g(1,2);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int g(int a,int b){&lt;/p&gt;
&lt;p&gt;int c=a+b ； &lt;/p&gt;
&lt;p&gt;return c;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 產生的彙編代碼如下： &lt;/p&gt;
&lt;p&gt;f:&lt;/p&gt;
&lt;p&gt;push ebp ; 備份 ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ; 建立棧底 &lt;/p&gt;
&lt;p&gt;sub esp,4 ; 爲 i 分配空間 &lt;/p&gt;
&lt;p&gt;mov eax,2 ; 準備參數 b 的值 2&lt;/p&gt;
&lt;p&gt;push eax ; 將 b 壓棧 &lt;/p&gt;
&lt;p&gt;mov eax,1 ; 準備參數 a 的值 1&lt;/p&gt;
&lt;p&gt;push eax ; 將 a 壓棧 &lt;/p&gt;
&lt;p&gt;call g ; 調用 g&lt;/p&gt;
&lt;p&gt;add esp,8 ; 將 a 和 b 一起彈出，恢復調用前的棧 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ; 將返回值保存進變量 i&lt;/p&gt;
&lt;p&gt;mov esp,ebp ; 恢復棧頂 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢復棧底 &lt;/p&gt;
&lt;p&gt;g:&lt;/p&gt;
&lt;p&gt;push ebp ; 備份 ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ; 建立棧底 &lt;/p&gt;
&lt;p&gt;sub esp,4 ; 爲局部變量 c 在棧中分配內存 &lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp+8] ; 通過 ebp 間接讀取參數 a 的值 &lt;/p&gt;
&lt;p&gt;mov ebx,dword ptr[ebp+12] ; 通過 ebp 間接讀取參數 b 的值 &lt;/p&gt;
&lt;p&gt;add eax,ebx ; 將 a 和 b 的值相加，之和存在 eax 中 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ; 將和存入變量 c&lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp-4] ; 將 c 作爲返回值，代碼優化後會刪除此句 &lt;/p&gt;
&lt;p&gt;add esp,4 ; 銷燬 c 的內存 &lt;/p&gt;
&lt;p&gt;mov esp,ebp ; 恢復棧頂 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢復棧底 &lt;/p&gt;
&lt;p&gt;ret ; 返回函數 f&lt;/p&gt;
&lt;p&gt; 棧的內存佈局如下： &lt;/p&gt;
&lt;p&gt;100076:c &amp;lt;- g 的 esp&lt;/p&gt;
&lt;p&gt;100080:f 的 ebp=100100 &amp;lt;- g 的 ebp&lt;/p&gt;
&lt;p&gt;100084:f 的 eip&lt;/p&gt;
&lt;p&gt;100088:a=1&lt;/p&gt;
&lt;p&gt;100092:b=2&lt;/p&gt;
&lt;p&gt;100096:i&lt;/p&gt;
&lt;p&gt;100100: 舊 ebp &amp;lt;-f 的 ebp&lt;/p&gt;
&lt;p&gt;100104:……&lt;/p&gt;
&lt;p&gt; 注意在函數 g 的彙編代碼中，訪問函數的局部變量和訪問函數參數的區別。局部變量總是通過將 ebp 減去偏移量來訪問，函數參數總是通過將 ebp 加上偏移量來訪問。對於 32 位變量而言，第一個局部變量位於 ebp-4 ，第二個位於 ebp-8 ，以此類推， 32 位局部變量在棧中形成一個逆序數組；第一個函數參數位於 ebp+8 ，第二個位於 ebp+12 ，以此類推， 32 位函數參數在棧中形成一個正序數組。 &lt;/p&gt;
&lt;p&gt; 由於函數返回值通過寄存器返回，不需要空間分配等操作，所以返回值的代價很低。基於這個原因，舊的 C 語法約定，不寫明返回值類型的函數，返回值類型爲 int 。這一規則與現行的 C++ 語法相違背，因爲 C++ 中，不寫明返回值類型的函數返回值類型爲 void ，表示不返回值。這種語法不兼容性是爲了加強 C++ 的類型安全，但同時也帶來了一些問題。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:28:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html</guid><category>C++</category></item><item><title>C++ Tricks 2.5 I386平臺的邊界對齊(Align)</title><link>//farseerfc.github.io/c-tricks-2-5-address-alignment.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h2&gt;2.5 I386 平臺的邊界對齊 (Align)&lt;/h2&gt;
&lt;p&gt; 首先提問，既然 I386 上 sizeof(int)==4 、 sizeof(char)==1 ，那麼如下結構 (struct)A 的 sizeof 是多少？ &lt;/p&gt;
&lt;p&gt;struct A{int i;char c;};&lt;/p&gt;
&lt;p&gt; 答案是 sizeof(A)==8……1+5=8 ？ &lt;/p&gt;
&lt;p&gt; 呵呵，這就是 I386 上的邊界對齊問題。我們知道， I386 上有整整 4GB 的地址空間，不過並不是每一個字節上都可以放置任何東西的。由於內存總線帶寬等等的技術原因，很多體系結構都要求內存中的變量被放置於某一個邊界的地址上。如果違反這個要求，重則導致停機出錯，輕則減慢運行速度。對於 I386 平臺而言，類型爲 T 的變量必須放置在 sizeof(T) 的整數倍的地址上， char 可以隨便放置， short 必須放在 2 的整數倍的地址上， int 必須放在 4 的整數倍的地址上， double 必須放在 8 的整數倍的地址上。如果違反邊界對齊要求，從內存中讀取數據必須進行兩次，然後將獨到的兩半數據拼接起來，這會嚴重影響效率。 &lt;/p&gt;
&lt;p&gt; 由於邊界對齊問題的要求，在計算 struct 的 sizeof 的時候，編譯器必須算入額外的字節填充，以保證每一個變量都能自然對齊。比如如下聲明的 struct:&lt;/p&gt;
&lt;p&gt;struct &lt;span class="caps"&gt;WASTE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 實際上相當於聲明瞭這樣一個結構： &lt;/p&gt;
&lt;p&gt;struct &lt;span class="caps"&gt;WASTE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;char _filling1 [3];// 三個字節填充，保證下一個 int 的對齊 &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2 ； &lt;/p&gt;
&lt;p&gt;char _filling2 [3];// 又三個字節填充 &lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 值得注意的是尾部的 3 個字節填充，這是爲了可以在一個數組中聲明 WASTE 變量，並且每一個都自然對齊。因爲有了這些填充，所以 sizeof(&lt;span class="caps"&gt;WASTE&lt;/span&gt;)==12 。這是一種浪費，因爲只要我們重新安排變量的聲明，就可以減少 sizeof ： &lt;/p&gt;
&lt;p&gt;struct &lt;span class="caps"&gt;WASTE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c1,c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 像這樣的安排， sizeof 就減少到 8 ，只有 2 個字節的額外填充。爲了與彙編代碼相兼容， C 語言語法規定，編譯器無權擅自安排結構體內變量的佈局順序，必須從左向右逐一排列。所以，妥當安排成員順序以避免內存空間的浪費，就成了我們程序員的責任之一。一般的，總是將結構體的成員按照其 sizeof 從大到小排列， double 在最前， char 在最後，這樣總可以將結構的字節填充降至最小。 &lt;/p&gt;
&lt;p&gt;C++ 繼承了 C 語言關於結構體佈局的規定，所以以上的佈局準則也適用於 C++ 的 class 的成員變量。 C++ 進一步擴展了佈局規定，同一訪問區段 (private 、 public 、 protected) 中的變量，編譯器無權重新排列，不過編譯器有權排列訪問區段的前後順序。基於這個規則， C++ 中有的程序員建議給每一個成員變量放在單獨區段，在每一個成員聲明之前都加上 private: 、 public: 、 protected: 標誌，這可以最大限度的利用編譯器的決策優勢。 &lt;/p&gt;
&lt;p&gt; 在棧中按順序分配的變量，其邊界也受到對齊要求的限制。與在結構中不同的是，棧中的變量還必須保證其後續變量無論是何種類型都可以自由對齊，所以在棧中的變量通常都有平臺相關的對齊最小值。在 MSVC 編譯器上，這個最小值可以由宏 _INTSIZEOF(T) 查詢： &lt;/p&gt;
&lt;p&gt;#define _INTSIZEOF(T) ( (sizeof(T) + sizeof(int) - 1) &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; ~(sizeof(int) -
1) )&lt;/p&gt;
&lt;p&gt;_INTSIZEOF(T) 會將 sizeof(T) 進位到 sizeof(int) 的整數倍。 &lt;/p&gt;
&lt;p&gt; 由於在棧中分配變量使用 _INTSIZEOF 而不是 sizeof ，在棧上連續分配多個小變量 (sizeof 小於 int 的變量 ) 會造成內存浪費，不如使用結構 (struct) 或數組。也就是說： &lt;/p&gt;
&lt;p&gt;char c1,c2,c3,c4;// 使用 16 字節 &lt;/p&gt;
&lt;p&gt;char c[4];// 使用 4 字節 &lt;/p&gt;
&lt;p&gt; 當然，使用數組的方法在訪問數組變量 ( 比如 c[1]) 時有一次額外的指針運算和提領 (dereference) 操作，這會有執行效率的損失。這又是一種空間 ( 內存佔用 )vs 時間 ( 執行效率 ) 的折中，需要程序員自己根據情況權衡利弊。 &lt;/p&gt;
&lt;p&gt;sizeof 的大小可能比我們預期的大，也可能比我們預期的小。對於空類： &lt;/p&gt;
&lt;p&gt;class Empty {};&lt;/p&gt;
&lt;p&gt; 在通常情況下， sizeof(Empty) 至少爲 1 。這是因爲 C++ 語法規定，對於任何實體類型的兩個變量，都必須具有不同的地址。爲了符合語法要求，編譯器會給 Empty 加入 1 字節的填充。所以 sizeof() 的值不可能出現 0 的情況。可是對於以下的類聲明： &lt;/p&gt;
&lt;p&gt;class A:public Empty{vitual ~A(){}};&lt;/p&gt;
&lt;p&gt;sizeof(A) 有可能是 6 ，也有可能是 5 ，也有可能是 4 ！必不可少的四個字節是一個指向虛函數表的指針。一個可能有的字節是 Empty 的大小，這是是因爲編譯器在特定情況下會將 Empty 視作一個 “ 空基類 ” ，從而實施 “ 空基類優化 ” ，省掉那毫無作用的一字節填充。另一個字節是 A 的一字節填充，因爲從語法上講， A 沒有成員聲明，理應有 1 字節填充，而從語義上講，編譯器給 A 的聲明加入了一個指向虛函數表的指針，從而 A 就不再是一個 “ 空類 ” ，是否實施這個優化，要看編譯器作者對語法措詞的理解。也就是說， sizeof 也會出現 4+1+1=4 的情況。具體要看編譯器有沒有實施 “ 空基類優化 ” 和 “ 含虛函數表的空類優化 ” 。 &lt;/p&gt;
&lt;p&gt; 結構和類的空間中可能有填充的字節，這意味着填充字節中可能有數值，雖然這數值並不影響結構的邏輯狀態，但是它也可能不知不覺中影響到你。比如說，你手頭正好有一組依賴於底層硬件 ( 比如多處理器 ) 的函數，他們在操縱連續字節時比手動編碼要快很多，而你想充分利用這種硬件優勢： &lt;/p&gt;
&lt;p&gt;bool BitCompare(void* begin,void* end,void* another);&lt;/p&gt;
&lt;p&gt; 這個函數將區間 [begin,end) 之間的字節與 another 開始的字節相比較，如果有一位不同就返回 false ，否則返回 true 。 &lt;/p&gt;
&lt;p&gt; 比如你想將這個函數用於你自己的類的 operator== 中，這樣可以利用硬件加快速度。不過你在動手前要充分考慮，你的 class 是否真的要比較每一位。如果在類的成員中存在編譯器填充的字節數，那麼應用以上的函數就是不正確的，因爲填充的字節中可以有不同的值。爲了保證你可以用 Bitwise
Compare ，你必須確保填充的字節中的值也是相同的。這不僅要求你在類的構造函數中初始化類的每一 bit 而不是每一個成員，也要求你在複製初始化和複製賦值函數中也同時保證 bitwise copy 語義，而不是編譯器默認產生的 memberwise 語義。當然，你可能通過與 BitCompare 一同提供的 BitCopy 來完成這個艱鉅的任務。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:28:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:c-tricks-2-5-address-alignment.html</guid><category>C++</category></item><item><title>C++ Tricks 2.6 I386平臺C函數的可變參數表(Variable Arguments)</title><link>//farseerfc.github.io/c-tricks-2-6-i386-variable-arguments.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h2&gt;2.6 I386 平臺 C 函數的可變參數表 (Variable Arguments)&lt;/h2&gt;
&lt;p&gt; 基於前文 (2.4 節 ) 分析，我們可以不通過函數簽名，直接通過指針運算，來得到函數的參數。由於參數的壓棧和彈出操作都由主調函數進行，所以被調函數對於參數的真實數量不需要知曉。因此，函數簽名中的變量聲明不是必需的。爲了支持這種參數使用形式， C 語言提供可變參數表。可變參數表的語法形式是在參數表末尾添加三個句點形成的省略號 “…” ： &lt;/p&gt;
&lt;p&gt;void g(int a,char* c,…);&lt;/p&gt;
&lt;p&gt; 省略號之前的逗號是可選的，並不影響詞法語法分析。上面的函數 g 可以接受 2 個或 2 個以上的參數，前兩個參數的類型固定，其後的參數類型未知，參數的個數也未知。爲了知道參數個數，我們必須通過其他方法，比如通過第一個參數傳遞： &lt;/p&gt;
&lt;p&gt;g(3,”Hello”,2,4,5);// 調用 g 並傳遞 5 個參數，其中後 3 個爲可變參數。 &lt;/p&gt;
&lt;p&gt; 在函數的實現代碼中，可以通過 2.4 節敘述的，參數在棧中的排列順序，來訪問位於可變參數表的參數。比如 :&lt;/p&gt;
&lt;p&gt;void g(int a,char* c…){&lt;/p&gt;
&lt;p&gt;void *pc=&amp;amp;c;int* pi=static_cast&amp;lt;int*&amp;gt;(pc)+1;// 將 pi 指向首個可變參數 &lt;/p&gt;
&lt;p&gt;for(int i=0;i&amp;lt;a;i++)std::cout&amp;lt;&amp;lt;pi[i]&amp;lt;&amp;lt;” ” ； &lt;/p&gt;
&lt;p&gt;std::cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;std::endl;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 我們甚至可以讓一個函數的所有參數都是可變參數，只要有辦法獲知參數的數量即可。比如，我們約定，在傳遞給 addAll 的參數都是 int ，並且最後一個以 0 結束： &lt;/p&gt;
&lt;p&gt;int addAll(…);&lt;/p&gt;
&lt;p&gt;int a=f(1,4,2,5,7,0);&lt;/p&gt;
&lt;p&gt; 那麼 addAll 可以這樣實現： &lt;/p&gt;
&lt;p&gt;int addAll(…){&lt;/p&gt;
&lt;p&gt;int sum=0;int *p=&amp;amp;sum; //p 指向第一個局部變量 &lt;/p&gt;
&lt;p&gt;p+=3; // 跳過 sum ， ebp ， eip ，現在 p 指向第一個參數 &lt;/p&gt;
&lt;p&gt;for(;*p;++p) // 如果 p 不指向 0 就繼續循環 &lt;/p&gt;
&lt;p&gt;sum+=*p;&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 可變參數表的最廣泛應用是 C 的標準庫函數中的格式化輸入輸出： printf 和 scanf 。 &lt;/p&gt;
&lt;p&gt;void printf(char *c,…);&lt;/p&gt;
&lt;p&gt;void scanf(char *c,…);&lt;/p&gt;
&lt;p&gt; 兩者都通過它的首個參數指出後續參數表中的參數類型和參數數量。 &lt;/p&gt;
&lt;p&gt; 如果可變參數表中的參數類型不一樣，那麼操縱可變參數表就需要複雜的指針運算，並且還要時刻注意邊界對齊 (align) 問題，非常令人頭痛。好在 C 標準庫提供了用於操縱可變參數表的宏 (macro) 和結構 (struct) ，他們被定義在庫文件 stdarg.h 中 :&lt;/p&gt;
&lt;p&gt;typedef struct {char *p;int offset;} va_list;&lt;/p&gt;
&lt;p&gt;#define va_start(valist,arg)&lt;/p&gt;
&lt;p&gt;#define va_arg(valist,type)&lt;/p&gt;
&lt;p&gt;#define va_end(valist)&lt;/p&gt;
&lt;p&gt; 其中結構 va_list 用於指示參數在棧中的位置，宏 va_start 接受一個 va_list 和函數的可變參數表之前的參數，通過第一個參數初始化 va_list 中的相應數據，因此要使用 stdarg.h 中的宏，你的可變參數表的函數必須至少有一個具名參數。 va_arg 返回下一個類型爲 type 的參數， va_end 結束可變參數表的使用。還是以上文的 addAll 爲例，這次寫出它的使用標準宏的版本： &lt;/p&gt;
&lt;p&gt;int addAll(int i,…)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;va_list vl; // 定義一個 va_list 結構 &lt;/p&gt;
&lt;p&gt;va_start(vl,i); // 用省略號之前的參數初始化 vl&lt;/p&gt;
&lt;p&gt;if(i=0)return 0; // 如果第一個參數就是 0 ，返回 &lt;/p&gt;
&lt;p&gt;int sum=i; // 將第一個參數加入 sum&lt;/p&gt;
&lt;p&gt;for(;;){&lt;/p&gt;
&lt;p&gt;i=va_arg(vl,int); // 取得下一個參數，類型是 sum&lt;/p&gt;
&lt;p&gt;if(i==0)break; // 如果參數是 0 ，跳出循環 &lt;/p&gt;
&lt;p&gt;sum+=i;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;va_end(vl);&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 可以看出，如果參數類型一致，使用標準庫要多些幾行代碼。不過如果參數類型不一致或者未知 (printf 的情況 ) ，使用標準庫就要方便很多，因爲我們很難猜出編譯器處置邊界對齊 (align) 等彙編代碼的細節。使用標準庫的代碼是可以移植的，而使用上文所述的其它方法操縱可變參數表都是不可移植的，僅限於在 I386 平臺上使用。 &lt;/p&gt;
&lt;p&gt; 縱使可變參數表有使用上的便利性，它的缺陷也有很多，不可移植性和平臺依賴性只是其一，最大的問題在於它的類型不安全性。使用可變參數表就意味着編譯器不對參數作任何類型檢查，這在 C 中算是一言難盡的歷史遺留問題，在 C++ 中就意味着惡魔 reinterpret_cast 被你喚醒。 C 的可變參數表是 C++ 代碼錯誤頻發的根源之一，以至於 C++ 標準將可變參數表列爲即將被廢除的 C 語言遺留特性。 C++ 語法中的許多新特性，比如重載函數、默認參數值、模板，都可以一定程度上替代可變參數表，並且比可變參數表更加安全。 &lt;/p&gt;
&lt;p&gt; 可變參數表在 C++ 中惟一值得嘉獎的貢獻，是在模板元編程 (&lt;span class="caps"&gt;TMP&lt;/span&gt;) 的 SFINAE 技術中利用可變參數表製作最差匹配重載。根據 C++ 標準中有關函數重載決議的規則，具有可變參數表的函數總是最差匹配，編譯器在被逼無奈走頭無路時纔會選擇可變參數表。利用這一點，我們可以精心製作重載函數來提取類型信息。比如，要判斷一個通過模板傳遞來的類型是不是 int ： &lt;/p&gt;
&lt;p&gt;long isIntImp(int);&lt;/p&gt;
&lt;p&gt;char isIntImp(…);&lt;/p&gt;
&lt;p&gt;template&amp;lt;typename T&amp;gt;&lt;/p&gt;
&lt;p&gt;struct isInt&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;enum{value=sizeof(isIntImp(T()))==sizeof(long);}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 然後，在一個具有模板參數 T 的函數中，我們就可以寫 &lt;/p&gt;
&lt;p&gt;if(isInt&amp;lt;T&amp;gt;::value)//…&lt;/p&gt;
&lt;p&gt; 在這個 ( 不怎麼精緻的 ) 例子中，如果 T 是 int ，那麼 isIntImp 的第一個重載版本就會被選中，返回值類型就是 long ，這樣 value 就爲 1 。否則，編譯器只能選中第二個具有可變參數表的重載版本，返回值類型成爲 char ，這樣 value 就爲 0 。把它說得再明白一些，上文的代碼所表達的意思是：如果類型 T 是 int ，那它就是 int ，否則它就不是 int ，呵呵簡單吧。這種通過重載決議規則來提取類型信息的技術，在模板元編程中被稱作 SFINAE ，它和其它模板元編程技術被廣泛運用於 STL 、 Boost 等模板庫的開發實現之中。 &lt;/p&gt;
&lt;p&gt; 值得注意的是，在上文 SFINAE 的運用中， isIntImp 並沒有出現定義而只提供了聲明，因爲我們並沒有實際調用 isIntImp 函數，而只是讓它參與重載決議並用 sizeof 判斷其返回值類型。這是 C++ 的一個設計準則的完美體現：不需要的東西可以不出現。由於這一準則，我們避免了在 C++ 中調用具有可變參數表的函數這一危險舉動，而僅僅利用了可變參數表在語法分析過程中的特殊地位，這種對於危險語言特性的巧妙利用是善意而無害的。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:28:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:c-tricks-2-6-i386-variable-arguments.html</guid><category>C++</category></item><item><title>C++ Tricks 2.7 I386平臺的其它函數調用模型</title><link>//farseerfc.github.io/c-tricks-2-7-i386-calling-conventions.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.7 I386 平臺的其它函數調用模型 &lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 上文介紹的只是 I386 平臺上 C 函數調用的標準模型，被稱作 __cdecl 。事實上， Microsoft Visual C++ 編譯器還支持其它一些函數調用模型，所有調用模型名稱皆以雙下劃線開頭，下面列出所有函數調用模型的異同： &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="cdecl"&gt;
&lt;h3&gt;1 __cdecl&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：逆序 ( 從右至左 )&lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：主調函數 (caller)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__cdecl 明確地指出函數使用 C 函數調用模型，這是默認的調用模型。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stdcall"&gt;
&lt;h3&gt;2 __stdcall&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：逆序 ( 從右至左 )&lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：被調函數 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__stdcall 是微軟所謂的標準調用模型。可惜的是它與 __cdecl 不兼容。幾乎所有的 Win32API 函數使用這種函數調用模型，希望在 DLL 之間，或者在程序和 WinNT 操作系統之間傳遞函數指針的函數也應該使用這種模型。與 __cdecl 模型的不同之處在於， __stdcall 模型下由被調函數恢復堆棧。主調函數在 call 語句之後，不需要再加上 add 語句。而被調函數的 ret 語句則被添加一個參數，代表函數參數堆棧的長度。因此，被調函數需要明確的知曉函數參數的數量和類型，所以在 __stdcall 模型下不支持可變參數表，所有參數必須寫明。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="thiscall"&gt;
&lt;h3&gt;3 __thiscall&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：逆序 ( 從右至左 ) ， this 用 ecx 傳遞。 &lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：被調函數 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__thiscall 是 VC 編譯器中類的非靜態成員函數 (non-static member functon) 的默認調用模型。但是如果此成員函數有可變參數表， VC 編譯器會使用 __cdecl 。和 __stdcall 一樣， __thiscall 由被調函數恢復堆棧。比較獨特的是 __thiscall 會通過 ecx 寄存器傳遞成員函數的 this 指針，而 __cdecl 下 this 指針是通過在參數表最前面增加一個函數參數來傳遞的。 __thiscall 是 VC 編譯器對 this 指針的使用的一種優化，大大提高了面向對象程序的效率。在 VC2003 及之前的編譯器上 __thiscall 不是一個關鍵字，不能被顯式指定。但可以給成員函數顯式指定 __cdecl 來避免使用 __thiscall 。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="fastcall"&gt;
&lt;h3&gt;4 __fastcall&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：逆序 ( 從右至左 ) ，前兩個 32 位函數參數放入 ecx 和 edx 中 &lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：被調函數 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 快速函數調用模型，將前兩個 32 位函數參數放入 ecx 和 edx 中，其餘參數再逆序壓棧。使用的是和 __thiscall 類似的優化技術，加快函數調用，適合運用在小型 inline 函數上。同樣使用 __stdcall 形式的被調函數恢復堆棧，所以不支持可變參數表。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pascal"&gt;
&lt;h3&gt;5 __pascal&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：正序 ( 從左至右 )&lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：被調函數 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 過程式編程語言 Pascal 所使用的函數調用模型，由此得名。也是 16 位版本的 Windows 使用的 API 模型，過時的模型，現在已經廢棄且禁止使用。你會看到有些書本仍會不時提到它，所以需要注意。 __pascal 是正序壓棧，這與大部分 I386 函數模型都不相同。與 __stdcall 一樣，由被調者恢復堆棧，不支持可變參數表。歷史上曾有過的別名 PASCAL 、 pascal 、 _pascal( 單下劃線 ) ，現在都改成了 __stdcall 的別名，與 __pascal( 雙下劃線 ) 不同。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;6  其它函數調用模型，以及模型別名。 &lt;/h3&gt;
&lt;p&gt;__syscall ：操作系統內部使用的函數調用模型，由用戶模式向核心模式跳轉時使用的模型。由於用戶模式和核心模式使用不同的棧，所以沒辦法使用棧來傳遞參數，所有參數通過寄存器傳遞，這限制了參數的數量。用戶模式編程中不允許使用。 &lt;/p&gt;
&lt;p&gt;__fortran ：數學運算語言 fortran 使用的函數模型，由此得名。在 C 中調用由 fortran 編譯的函數時使用。 &lt;/p&gt;
&lt;p&gt;__clrcall ：微軟 .Net 框架使用的函數模型，託管 (Managed)C++ 默認使用，也可以從非託管代碼調用託管函數時使用。參數在託管棧上正序 ( 從左至右 ) 壓棧，不使用普通棧。 &lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;CALLBACK&lt;/span&gt; 、 &lt;span class="caps"&gt;PASCAL&lt;/span&gt; 、 &lt;span class="caps"&gt;WINAPI&lt;/span&gt; 、 &lt;span class="caps"&gt;APIENTRY&lt;/span&gt; 、 &lt;span class="caps"&gt;APIPRIVATE&lt;/span&gt; ： I386 平臺上是 __stdcall 的別名 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;span class="caps"&gt;WINAPIV&lt;/span&gt; ： I386 平臺上是 __cdecl 的別名 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;7  函數調用模型的指定 &lt;/h3&gt;
&lt;p&gt; 函數調用模型的指定方式和 inline 關鍵字的指定方式相同，事實上， inline 可以被看作是 C++ 語言內建的一種函數調用模型。唯一不同的是，聲明函數指針時，也要指明函數調用模型，而 inline 的指針是不能指明的，根本不存在指向 inline 函數的指針。比如： &lt;/p&gt;
&lt;p&gt;int &lt;span class="caps"&gt;CALLBACK&lt;/span&gt; GetVersion();&lt;/p&gt;
&lt;p&gt;int (&lt;span class="caps"&gt;CALLBACK&lt;/span&gt; * pf)()=GetVersion;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Tue, 28 Aug 2007 14:28:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-28:c-tricks-2-7-i386-calling-conventions.html</guid><category>C++</category></item><item><title>C++ Tricks 2.1 X86概述</title><link>//farseerfc.github.io/c-tricks-2-1-x86-architecture.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="x86"&gt;
&lt;h2&gt;2.1   X86 概述 &lt;/h2&gt;
&lt;p&gt; 所謂 X86 體系結構，是指以 Intel
8086 芯片爲首的芯片所沿襲的 CPU 結構，一些文檔中又被稱作 IA32 體系結構。包括的芯片有但不限於 :Intel
8086 至  80486 ，奔騰 (Pentium) 系列處理器 1 至 4 ，賽揚系列處理器，酷睿系列處理器，以及 AMD 的相應型號產品。 X86 體系結構在早期屬於 16 位處理器，自 80386 之後擴展爲 32 位處理器，所以一些文檔中又把 80386 之後的 32 位處理器體系稱作 I386 。自 Pentium4 後期， AMD 的 Athlon64 開始， I386 被進一步擴充爲 64 位處理器，含有 64 位尋址能力的 X86 體系結構被稱作 X86-64 或 IA32-64 。總之，市售的個人電腦用 CPU ，除蘋果的 Macintosh 之外，全部採用 X86 體系結構芯片。 &lt;/p&gt;
&lt;p&gt; 在 X86 早期， 16 位的尋址能力只支持 64KB(2^16=64K) 內存，這顯然是不夠的。 Intel 採用分段尋址的方法，用 4 位段位 +16 位偏移量，提供了總共 1MB(2^20=1M) 的尋址能力。所以在 X86 的 16 位編程中，有兩種指針類型：長指針 (lp,long
pointer) 和短指針 (sp,short pointer) ，長指針 (20 位 ) 提供整個內存空間尋址能力，短指針 (16 位 ) 僅支持同一段中的尋址。在 “ 古代 ”DOS 及 Win3.x 編程過程中，兩種類型的指針，以及總共 1MB 的內存大小，常常把程序員們折騰得焦頭爛額。 &lt;/p&gt;
&lt;p&gt; 自 I386 之後， CPU 纔開始提供 32 位的尋址能力。有了整整 4GB(2^32=4G) 的尋址空間，所有指針統一爲長指針 (32 位 ) 。時至今日，我們仍可以看到微軟文檔中指針變量的 lp 前綴。由於內存管理的需要，分段機制被保留下來，但這一次不是因爲地址空間太小，而是因爲地址空間遠大於實際內存容量，從而採用了虛擬內存機制。 &lt;/p&gt;
&lt;p&gt; 在從 16 位結構向 32 位結構轉變的過程中，由於向下兼容的歷史原因，曾一度長時間出現硬件 32 位 (I386) 、軟件 16 位 (Win3.x) 的情況。同樣也是爲了兼容 16 位軟件， Win9x 操作系統 (Win95 、 Win98 、 WinME) 保留了 16 位代碼和 32 位代碼。混合代碼的設計使得 Win9x 及其混亂和不穩定。直到完全 32 位內核的操作系統 WinNT( 以及構建於其上的 Win2000 ， WinXP ， Win2003) 的出現， X86 平臺上內存佈局混亂的局面才得以改善。有了從 16 位至 32 位移植的經驗和準備，現今的從 32 位到 64 位的操作系統移植顯得平穩順利很多。 WinXP 和 WinVista 系統都同時發佈了 32 位版本和 64 位版本，並且其 x86-64 系統都實現了對 32 位軟件的無縫銜接支持。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Mon, 27 Aug 2007 16:33:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-27:c-tricks-2-1-x86-architecture.html</guid><category>C++</category></item><item><title>C++ Tricks 1.2 逗號運算符(,)、邏輯運算符(&amp;&amp;,||)與運算符重載的陷阱</title><link>//farseerfc.github.io/c-tricks-1-2-trap-in-comma-logical-operator.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.2    逗號運算符 (,) 、邏輯運算符 (&amp;amp;&amp;amp;,||) 與運算符重載的陷阱 &lt;/h2&gt;
&lt;p&gt; 很多人甚至不知道逗號 (,) 也是個 C++ 運算符。與語法上要求出現的逗號 ( 比如分隔函數參數的逗號 ) 不同的是，出現在表達式中的逗號運算符在語義上表示多個表達式操作的連續執行，類似於分隔多語句的分號。比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt;(&lt;strong&gt;int&lt;/strong&gt;i=0,j=9;i&amp;lt;10;++i&lt;strong&gt;,&lt;/strong&gt;—j)std::cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;”+”&amp;lt;&amp;lt;j&amp;lt;&amp;lt;”=9\n”;&lt;/p&gt;
&lt;p&gt; 在這句語句中，出現了兩個逗號，其中前者是語法上用來分隔聲明的變量的，並非逗號運算符，而後者則是一個逗號運算符。根據 C++ 標準，逗號運算符的執行順序爲從左到右依次執行，返回最後一個子表達式的結果。由於只有最後一個表達式返回結果，所以對於一個語義正常的逗號表達式而言，前幾個子表達式必須具有副作用。同時，從語言的定義中也可以看出，逗號表達式對求值的順序有嚴格要求。 &lt;/p&gt;
&lt;p&gt; 對求值順序有要求的，除了逗號表達式和條件表達式 ( 參見 1.1) ，在 C++ 中還有邏輯運算符 (&amp;amp;&amp;amp; 和 ||) 。邏輯運算相較於數學運算和位運算而言，有個顯著的不同點：邏輯運算在計算到一半時，就有可能已經得到結果，這樣繼續運算另一半就不是必需的。對於 A&amp;amp;&amp;amp;B ，如果 A=false ，那麼無論 B 爲何值，整個的結果都是 false ；同樣的 A||B ，如果 A=true ，那麼不考慮 B ，結果一定是 true 。 &lt;/p&gt;
&lt;p&gt;C++ 標準規定，如果邏輯運算到一半 ( 算出 A) 時，就已經可以確定運算的結果，那麼就不運算剩下的另一半 (B) 。這種執行語義被稱作 “ 短路 ” 。在其它一些編程語言中，短路語義是可以選擇的：在 Ada 裏非短路的邏輯運算符爲 and 和 or ，短路的邏輯運算符爲 and_then 和 or_else 。但是在 C++ 中，邏輯運算符的短路語義是語法上強制的，我們沒有非短路版本的運算符。如果確實需要非短路語義，我們總是可以通過增加一個 bool 中間變量加以解決。有時，短路對於保證正確執行是必須的，比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char&lt;/strong&gt;*p=getString();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(p&lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;*p)std::cout&amp;lt;&amp;lt;p;&lt;/p&gt;
&lt;p&gt; 這段代碼在得到了一個字符串後，在字符串不爲空時輸出它。在 C++ 中判斷一個字符串不爲空需要兩個步驟：判斷指針是否爲 0 ，以及指針不爲 0 時判斷指針指向的內容是否爲 ’’ 。就像條件表達式中討論到的 ( 參見 1.1) ，在 p 爲空時提領 p 是個極其危險的操作。邏輯運算符的短路語義則避免了這種危險。 &lt;/p&gt;
&lt;p&gt; 以上對逗號運算符與邏輯運算符的討論，僅限於 C++ 標準所定義的運算符語義。爲什麼這樣說呢？這是因爲在 C++ 中，運算符的語義是可以由程序員自行定義的，這種機制叫做運算符重載 (operator overload) 。運算符重載可以將人們熟悉的運算符表達式轉換成函數調用，使編程靈活而直觀，是個方便的語言特性。不過有時運算符重載也會使人困擾，那就是當運算符重載遇到求值順序問題時。 &lt;/p&gt;
&lt;p&gt;C++ 中，並不是所有合法運算符都可以被合法地重載。條件運算符雖然對求值順序有要求，但它並不在可重載運算符之列，所以運算符重載機制對它沒有影響。問題在於，逗號運算符和邏輯運算符都可以被合法地重載： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class&lt;/strong&gt; BadThing{/* Some Bad and Stupid Thing*/};&lt;/p&gt;
&lt;p&gt;BadThing&amp;amp; &lt;strong&gt;operator&lt;/strong&gt;,(BadThing&amp;amp;, BadThing&amp;amp;);// 重載了逗號運算符 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bool&lt;/strong&gt; &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(BadThing&amp;amp;, BadThing&amp;amp;);// 重載了 &amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;BadThing b1,b2;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(b1&amp;amp;&amp;amp;b2)b1,b2;// 被替換成如下形式： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(b1,b2))&lt;strong&gt;operator&lt;/strong&gt;,(b1,b2);&lt;/p&gt;
&lt;p&gt; 可以看到，重載了運算符之後，對運算符的使用被替換爲相應的函數調用形式。因此，舊有的運算符的執行順序不再適用，取而代之的是函數參數的壓棧順序。 &lt;/p&gt;
&lt;p&gt; 根據 C++ 標準規定，任何參數必須在進入函數之前壓棧，所以在進入 &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp; 之前， b1 、 b2 就會被求值，這裏不再有短路規則，任何依賴於短路語義的不知不覺間操作 BadThing 的代碼 ( 可能通過模板 ) 都會混亂。 &lt;/p&gt;
&lt;p&gt; 短路語義只是一個方面，更重要的在於壓棧順序。鑑於執行效率和舊代碼兼容性等細節問題， C++ 標準在壓棧順序上給編譯器的開發者留有很大自主性。標準的說辭是，編譯器可能以任何它覺得方便的順序將參數壓棧，從左到右，從右到左，甚至從中間到兩邊，在這一點上我們不能安全地做任何假設。在上面的例子中，編譯器生成的代碼可能先計算 b1 再計算 b2 ，也可能是相反的順序。再看看編譯器的實際情況，在我試過的所有基於 X86 體系結構的編譯器中，參數都是以逆向壓棧，即從右到左，有悖於大多數人的閱讀習慣和直覺 ( 別說你是來自伊斯蘭的 ……) 。 &lt;/p&gt;
&lt;p&gt; 在 C 時代使用函數調用時，壓棧順序並不是什麼大問題，畢竟大多數人會在函數調用的邊界稍稍小心一些。但是到了 C++ 中，事情變得有些複雜，因爲簡單如 a+b 的使用，就有可能被運算符重載機制替換爲函數調用。更何況有模板參與之後，我們寫代碼時不能確定對象的真實類型，也就無法預知一個運算符是否真的被重載過，唯一穩妥的方法是，假定任何有可能被重載的運算符的使用都是函數調用。 &lt;/p&gt;
&lt;blockquote&gt;
&amp;lt;p style="margin:0;"&amp;gt;&lt;/blockquote&gt;
&lt;p&gt; 回到上文的示例中，由於 , 和 &amp;amp;&amp;amp; 都被替換爲函數調用，程序的執行順序將成爲壓棧順序，在 X86 上很有可能是從右到左，與標準定義的運算符的順序正好相反。逗號運算符原本就含有 “ 先 … 後 …” 的語義，這種顛倒的執行順序勢必造成程序和程序員的混亂。以我的經驗而言，含有 &lt;strong&gt;operator&lt;/strong&gt;, 的類，完全沒有辦法和 STL 或者 iostream 相互協作，反而會導致巨量的錯誤報告 ( 什麼叫巨量的錯誤報告有概念麼？如果沒有，那說明你還沒玩過範式編程 (&lt;span class="caps"&gt;GP&lt;/span&gt;,
Generic
Programming) 。去玩玩 GP 吧，看看你的編譯器對巨量的定義。在我手頭，針對 3.5KB 的代碼文件傾瀉出 3.8&lt;strong&gt;&lt;span class="caps"&gt;MB&lt;/span&gt;&lt;/strong&gt; 的錯誤信息的編譯器不在少數 ……) 。有鑑於此，我的結論是，除非你有充足的依據支持你這麼做 ( 比如你的粗暴上司的鍵盤上只剩下逗號能用 ) ，並且你清楚的瞭解這麼做的後果的嚴重性 ( 比如至少要看過此文 ) ，否則我奉勸你，永遠不要碰 &lt;strong&gt;operator&lt;/strong&gt;, 、 &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp; 以及 &lt;strong&gt;operator&lt;/strong&gt;|| ！ &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Wed, 22 Aug 2007 18:06:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-22:c-tricks-1-2-trap-in-comma-logical-operator.html</guid><category>C++</category></item><item><title>C++ Tricks 1.1 條件運算符(?:)</title><link>//farseerfc.github.io/c-tricks-1-1-conditional-operator.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.1    條件運算符 (?:)&lt;/h2&gt;
&lt;p&gt; 條件運算符 (?:) 是 C++ 中唯一的三目運算符 (trinary
operator) ，用於在表達式中作條件判斷，通常可以替換 if 語句，與 Visual Basic 中的 iif 函數、 Excel 中的 if 函數有同樣的作用。語法形式如下： &lt;/p&gt;
&lt;p&gt;&lt;em&gt;condition&lt;/em&gt; ? &lt;em&gt;true_value&lt;/em&gt; : &lt;em&gt;false_value&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 其中 &lt;em&gt;condition
* 條件是任何可以轉換爲 bool 類型的表達式，包括但不僅限於 **bool*&lt;/em&gt; 、 &lt;strong&gt;int&lt;/strong&gt; 、指針。與 &lt;strong&gt;if&lt;/strong&gt; 和 &lt;strong&gt;while&lt;/strong&gt; 的條件部分稍顯不同的是，這裏不能定義變量，否則會導致語法錯誤。 &lt;/p&gt;
&lt;p&gt; 另外，條件語句會切實地控制執行流程，而不僅僅是控制返回值。也就是說，兩個返回值表達式中永遠只有一個會被求值，在表達式的執行順序很重要時，這點尤爲值得注意。比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=pi&lt;strong&gt;?&lt;/strong&gt;*pi&lt;strong&gt;:&lt;/strong&gt;0;&lt;/p&gt;
&lt;p&gt; 這裏，只有當 pi 的值不爲 0 時，它纔會被提領 (dereference) 。這種語義保證了程序的正確性，因爲提領一個空指針將導致致命的運行期錯誤 ( 通常是非法操作的警告 ) 。同時，正因爲條件運算符控制運算流程的特點，使得它不能用類似 iif 的普通函數來模擬： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; iif(&lt;strong&gt;int&lt;/strong&gt; con,&lt;strong&gt;int&lt;/strong&gt; t,&lt;strong&gt;int&lt;/strong&gt;f){&lt;strong&gt;if&lt;/strong&gt;(c)&lt;strong&gt;return&lt;/strong&gt; t;&lt;strong&gt;return&lt;/strong&gt; f;}// 試圖模擬 ?:&lt;/p&gt;
&lt;p&gt;…//in some function&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=iif(pi,*pi,0);//Error!&lt;/p&gt;
&lt;p&gt; 這段代碼會導致上文提到的致命運行期錯誤。 C/C++ 標準規定，參數在被傳遞給函數之前求值，因此無論 pi 爲何值，都會被提領。又因爲函數傳回一個空指針的情況比較少見，所以這樣的錯誤在調試時很難被發現，一旦發生又勢必造成重大災難。這樣的代碼在實踐中應儘量避免。 &lt;/p&gt;
&lt;p&gt; 有時，條件運算符控制流程的特點會不知不覺影響我們的代碼。在 C 時代，最大值 MAX 通常用宏實現： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#define&lt;/strong&gt;&lt;span class="caps"&gt;MAX&lt;/span&gt;(a,b) ((a)&amp;gt;(b)&lt;strong&gt;?&lt;/strong&gt;(a)&lt;strong&gt;:&lt;/strong&gt;(b))&lt;/p&gt;
&lt;p&gt; 需要用額外的括號將宏參數和宏本體保護起來，以免運算符優先級擾亂邏輯，這是宏醜陋的特點之一，這裏暫且不提。矛盾在於，用具有副作用的表達式調用宏時，會出現問題： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=5,j=6;//…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=&lt;span class="caps"&gt;MAX&lt;/span&gt;(++i,++j);&lt;/p&gt;
&lt;p&gt; 代碼的作者原意顯然是想先將 i,j 分別遞增，再將其中較大的一個賦給 a 。執行這段代碼，當 i=5,j=6 時， a=8 ，知道爲什麼嗎？通過宏展開，賦值語句成這樣： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=(++i)&amp;gt;(++j)&lt;strong&gt;?&lt;/strong&gt;(++i)&lt;strong&gt;:&lt;/strong&gt;(++j);// 刪除了多餘括號 &lt;/p&gt;
&lt;p&gt; 在判斷之前， i 、 j 被分別自增一次，然後捨棄 : 之前的部分， j 又被自增一次。執行之後， i=6,j=8 。 &lt;/p&gt;
&lt;p&gt;MAX 的更正確更安全的實現，是利用模板將類型參數化。 STL 標準算法中就有一個這樣的工具級模版函數 std::max 。 &lt;/p&gt;
&lt;p&gt; 條件運算符是表達式而不是語句，這使得它可以出現在任何需要表達式的地方，這擴大了它的適用範圍。在那些語法上只能出現表達式而不能出現語句的地方（比如變量初始化），條件運算符有着不可替代的作用。 &lt;/p&gt;
&lt;p&gt; 條件運算符優於 &lt;strong&gt;if&lt;/strong&gt; 語句的另一個場合是 “ 模板元編程 ”(&lt;span class="caps"&gt;TMP&lt;/span&gt;, Template
MetaProgramming) 。在 TMP 這個古怪奇異的編譯期運算編程技術中，一切舊有的技術和法則被全線擊破，我們所能仰仗的工具，只有模板特化 (Specialization) 、 &lt;strong&gt;typedef&lt;/strong&gt;s 、函數聲明 ( 無法調用它們 ) 、以及編譯期常量運算。已經有人很深入地論證過，僅有以上這些，就已經形成了一個 “ 圖靈完善 ” 的計算機語言。我們可以用模板特化技術，來模擬條件分支，循環迭代等一系列複雜的語言結構。由於可以參與編譯期常量運算，條件運算符在 TMP 世界中很自然地扮演起重要角色。 &lt;/p&gt;
&lt;p&gt; 比如，給與類型 T 的一個變量 t ，我們想聲明一個緩衝區存放 t 和一個 int ，緩衝區的大小不小於 sizeof(T) 也不小於 sizeif(int) ，我們可以這樣寫： &lt;/p&gt;
&lt;p&gt;char buffer[sizeof(T)&amp;gt;sizeof(int)? sizeof(T): sizeof(int)];&lt;/p&gt;
&lt;p&gt; 我們不能用一個 if 語句替換這個運算： &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;if(sizeof(T)&amp;gt;sizeof(int))i=sizeof(T);&lt;/p&gt;
&lt;p&gt;else i=sizeof(int);&lt;/p&gt;
&lt;p&gt;char buffer[i];// 語法錯誤 !&lt;/p&gt;
&lt;p&gt; 原因在於數組聲明中的下標必須是一個編譯期常量，而不是一個運行期的值，條件表達式的運算可以在編譯期進行， if 語句就只能在執行期執行。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Wed, 22 Aug 2007 18:05:00 +0900</pubDate><guid>tag:farseerfc.github.io,2007-08-22:c-tricks-1-1-conditional-operator.html</guid><category>C++</category></item><item><title>填補信仰、喚醒良知</title><link>//farseerfc.github.io/filling-believings-calling-conscience.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;p&gt; 填補信仰、喚醒良知 &lt;/p&gt;
&lt;p&gt; 我們聽盡了呼籲與號召，對於良知，我不必譴責喪失它的國人，不必盛讚良知的美好。我只想討論，喪失了良知的原因 —— 空缺的信仰。 &lt;/p&gt;
&lt;p&gt; 一、空缺信仰喪失良知 &lt;/p&gt;
&lt;p&gt; 現代的國人缺少信仰，以至於喪失良知。曾幾何時，中華民族由良好的信仰凝聚而成。三皇五帝時，族民們以炎黃爲信仰；春秋戰國時，士大夫之族以周制禮樂爲信仰；漢代以後，百姓延習孔孟之說、老聃之道，以儒家學說爲信仰；自大唐起，以佛教爲首的現代宗教紛紛傳入中原，人民開始以它們作爲信仰。 &lt;/p&gt;
&lt;p&gt; 直至鴉片戰爭、五四運動，西方文化入侵中華，國人開始拋棄國學，轉而去研究科學；文化大革命，十年文化浩劫，人們批判舊的信仰，卻沒有合適的新的信仰前來填補。從此，國人的信仰出現空缺，國人的良知也被一塊塊蠶食殆盡。 &lt;/p&gt;
&lt;p&gt; 二、信仰、科學、迷信 &lt;/p&gt;
&lt;p&gt; 在許多國人的心目中，信仰就等於迷信。從小到大的教育告訴我們，信奉宗教是愚昧而又無知的表現，科學與信仰是矛盾的。是麼？ &lt;/p&gt;
&lt;p&gt; 我們無法保證社會上的每一個人都接受過良好的教育，我們無法確信最前沿的科學素養能在民衆中普及。在科普與教育力不從心的社會死角，在科學技術尚不能及的文化盲區，我們依舊需要信仰的規範與限制，我們的良知需要信仰！ &lt;/p&gt;
&lt;p&gt; 信仰不等於迷信。信仰本身無所謂謎與不迷，迷信是持有信仰的人誤解了信仰，盲目遵從的結果。以爲燒過香就可以免遭禍患，以爲捐了錢就可以升入天堂，以爲引火自焚就可以功德圓滿，這便是迷信了。希特勒曾經的人類完善計劃，依照遺傳學的原理，將科學家與運動員強行結爲夫婦孕育生命，希望得到最優秀的人類種族，這便是對科學這種信仰的迷信！ &lt;/p&gt;
&lt;p&gt; 由此可見，科學與信仰並不是矛盾的硬幣的兩面，從某種意義而言科學本身也是信仰的一種。雖然歷史上宗教往往作爲科學發展的阻礙，可信奉真理的信念一直是推動科學發展的動力。牛頓就曾說過，對自然規律的探詢是爲了更接近上帝。由此可見，信仰與真理，與良知毫無矛盾。 &lt;/p&gt;
&lt;p&gt; 三、信仰喚醒良知 &lt;/p&gt;
&lt;p&gt; 很少有人仔細思考過，良知的缺失是由信仰的缺失造成的。信仰是人思想的寄託與依靠，是人行動處世的準則。沒有了信仰的人，思想行爲就缺少了約束的標準，人就更容易因爲一時不成熟的衝動，背叛良知、鑄成錯誤。 &lt;/p&gt;
&lt;p&gt; 泰國人以佛教爲信仰，泰國的寺廟每天都會有成千上萬人頂禮膜拜。寺廟有一個人盡皆知的不成文規定：不得穿鞋進入。於是在寺廟之外，遊客們可以看到千百雙各式的鞋子有序的擺放在門口。國人每每看到此景，總會詫異地問：沒有人會偷鞋麼？得到的答案極爲簡單：廟前偷鞋會遭報應。由於擁有信仰，泰國人作了壞事會受到良知的譴責，泰國商人售出假貨會徹夜難眠。二戰期間，無數猶太難民被天主教會收留藏匿從而僥倖逃生，這同樣是出於，天主教徒們被自己信奉的教義 “ 衆生生來平等 ” ，所喚醒的良知。 &lt;/p&gt;
&lt;p&gt; 天下無賊的世界，不能僅靠科普說教來營造。如果脫離了信仰，縱使是教育也無法培養良知。我問過許多修化學的同學，學習化學的意義，結論竟是爲了考試。如果沒有對科學的信仰，我們可以牢記公式定理，卻質疑它們是真理；如果沒有對社會公德的信仰，我們可以熟背交通規則，卻正大光明地闖紅燈；如果沒有對醫療道德的信仰，醫生可以放任傷口發炎，從而留住病人繼續治療 ……&lt;/p&gt;
&lt;p&gt; 國人需要信仰的約束，需要填補信仰的空白，從而喚醒那深埋於每個國人內心深處的良知！ &lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">farseerfc</dc:creator><pubDate>Mon, 07 Aug 2006 21:36:00 +0900</pubDate><guid>tag:farseerfc.github.io,2006-08-07:filling-believings-calling-conscience.html</guid></item></channel></rss>