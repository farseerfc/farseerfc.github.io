<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Farseerfc的小窩</title><link href="//farseerfc.me/" rel="alternate"></link><link href="//farseerfc.me/feeds/all-zh.atom.xml" rel="self"></link><id>//farseerfc.me/</id><updated>2020-02-04T16:59:00+09:00</updated><entry><title>ZFS 分層架構設計</title><link href="//farseerfc.me/zfs-layered-architecture-design.html" rel="alternate"></link><published>2020-02-04T16:59:00+09:00</published><updated>2020-02-04T16:59:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2020-02-04:/zfs-layered-architecture-design.html</id><summary type="html">
&lt;p&gt;ZFS 在設計之初源自於 Sun 內部多次重寫 UFS 的嘗試，背負了重構 Solaris
諸多內核子系統的重任，從而不同於 Linux 的文件系統只負責文件系統的功能而把其餘功能（比如內存髒頁管理，
IO調度）交給內核更底層的子系統， ZFS 的整體設計更層次化並更獨立，很多部分可能和 Linux/FreeBSD
內核已有的子系統有功能重疊。&lt;/p&gt;
&lt;p&gt;似乎很多關於 ZFS 的視頻演講和幻燈片有講到子系統架構，但是找了半天也沒找到網上關於這個的說明文檔。
於是寫下這篇筆記試圖從 ZFS 的早期開發歷程開始，記錄一下 ZFS 分層架構中各個子系統之間的分工。
也有幾段 OpenZFS Summit 視頻佐以記錄那段歷史。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
The Birth of ZFS by Jeff Bonwick&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/dcV2PaMTAJ4"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Story Time (Q&amp;amp;A) with Matt and Jeff …&lt;/div&gt;&lt;/div&gt;</summary><content type="html">
&lt;p&gt;ZFS 在設計之初源自於 Sun 內部多次重寫 UFS 的嘗試，背負了重構 Solaris
諸多內核子系統的重任，從而不同於 Linux 的文件系統只負責文件系統的功能而把其餘功能（比如內存髒頁管理，
IO調度）交給內核更底層的子系統， ZFS 的整體設計更層次化並更獨立，很多部分可能和 Linux/FreeBSD
內核已有的子系統有功能重疊。&lt;/p&gt;
&lt;p&gt;似乎很多關於 ZFS 的視頻演講和幻燈片有講到子系統架構，但是找了半天也沒找到網上關於這個的說明文檔。
於是寫下這篇筆記試圖從 ZFS 的早期開發歷程開始，記錄一下 ZFS 分層架構中各個子系統之間的分工。
也有幾段 OpenZFS Summit 視頻佐以記錄那段歷史。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
The Birth of ZFS by Jeff Bonwick&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/dcV2PaMTAJ4"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Story Time (Q&amp;amp;A) with Matt and Jeff&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/yNKZQBsTX08"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
ZFS First Mount by Mark Shellenbaum&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/xMH5rCL8S2k"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
ZFS past &amp;amp; future by Mark Maybee&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/c1ek1tFjhH8"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;早期架構&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;早期 ZFS 在開發時大體可以分爲上下三層，分別是 ZPL， DMU 和 SPA ，這三層分別由三組人負責。&lt;/p&gt;
&lt;p&gt;最初在 Sun 內部帶領 ZFS 開發的是 &lt;a class="reference external" href="https://blogs.oracle.com/bonwick/"&gt;Jeff Bonwick&lt;/a&gt;
，他首先有了對 ZFS 整體架構的構思，然後遊說 Sun 高層，親自組建起了 ZFS
開發團隊，招募了當時剛從大學畢業的 &lt;a class="reference external" href="http://open-zfs.org/wiki/User:Mahrens"&gt;Matt Ahrens&lt;/a&gt;
。作爲和 Sun 高層談妥的條件， Jeff 也必須負責 Solaris 整體的 Storage &amp;amp; Filesystem Team
，於是他又從 Solaris 的 Storage Team 抽調了 UFS 部分的負責人 Mark Shellenbaum 和
Mark Maybee 來開發 ZFS 。而如今昔日昇陽已然日落， Jeff
成立了獨立公司繼續開拓服務器存儲領域， Matt 是 OpenZFS 項目的負責人，兩位 Mark 則留在了
Sun/Oracle 成爲了 Oracle ZFS 分支的維護者。&lt;/p&gt;
&lt;p&gt;在開發早期，作爲分工， Jeff 負責 ZFS 設計中最底層的 SPA ，提供多個存儲設備組成的存儲池抽象；
Matt 負責 ZFS 設計中最至關重要的 DMU 引擎，在塊設備基礎上提供具有事務語義的對象存儲；
而兩位 Mark 負責 ZFS 設計中直接面向用戶的 ZPL ，在 DMU 基礎上提供完整 POSIX 文件系統語義。
ZFS 設計中這最初的分工也體現在了 ZFS 現在子系統分層的架構上，繼續影響（增強或者限制） ZFS
今後發展的方向。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;子系統整體架構&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先 ZFS 整體架構如下圖，其中圓圈是 ZFS 給內核層的外部接口，方框是 ZFS 內部子系統（
我給方框的子系統加上了超鏈接）：&lt;/p&gt;
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;

&lt;!-- Generated by graphviz version 2.40.1 (20161225.0304)
 --&gt;
&lt;!-- Title: ZFS_Layer_Architecture Pages: 1 --&gt;
&lt;svg class="svg-responsive" height="626pt" viewbox="0.00 0.00 806.50 626.00" width="807pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
&lt;g class="graph" id="graph0" transform="scale(1 1) rotate(0) translate(4 622)"&gt;
&lt;title&gt;ZFS_Layer_Architecture&lt;/title&gt;
&lt;polygon fill="#ffffff" points="-4,4 -4,-622 802.5,-622 802.5,4 -4,4" stroke="transparent"&gt;&lt;/polygon&gt;
&lt;g class="cluster" id="clust4"&gt;
&lt;title&gt;clusterTOL&lt;/title&gt;
&lt;g id="a_clust4"&gt;&lt;a xlink:href="#tol" xlink:title="TOL"&gt;
&lt;polygon fill="none" points="493.5,-355 493.5,-574 583.5,-574 583.5,-355 493.5,-355" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="538.5" y="-558.8"&gt;TOL&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;g class="cluster" id="clust9"&gt;
&lt;title&gt;clusterSPA&lt;/title&gt;
&lt;g id="a_clust9"&gt;&lt;a xlink:href="#spa" xlink:title="SPA"&gt;
&lt;polygon fill="none" points="415.5,-64 415.5,-283 649.5,-283 649.5,-64 415.5,-64" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="532.5" y="-267.8"&gt;SPA&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- Filesystem API --&gt;
&lt;g class="node" id="node1"&gt;
&lt;title&gt;Filesystem API&lt;/title&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="62.5" y="-596.3"&gt;Filesystem API&lt;/text&gt;
&lt;/g&gt;
&lt;!-- VFS --&gt;
&lt;g class="node" id="node5"&gt;
&lt;title&gt;VFS&lt;/title&gt;
&lt;ellipse cx="62.5" cy="-525" fill="none" rx="30.5947" ry="18" stroke="#000000"&gt;&lt;/ellipse&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="62.5" y="-521.3"&gt;VFS&lt;/text&gt;
&lt;/g&gt;
&lt;!-- Filesystem API&amp;#45;&amp;gt;VFS --&gt;
&lt;g class="edge" id="edge1"&gt;
&lt;title&gt;Filesystem API-&amp;gt;VFS&lt;/title&gt;
&lt;path d="M62.5,-581.8446C62.5,-573.3401 62.5,-563.0076 62.5,-553.4964" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="66.0001,-553.2481 62.5,-543.2482 59.0001,-553.2482 66.0001,-553.2481" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- Block device API --&gt;
&lt;g class="node" id="node2"&gt;
&lt;title&gt;Block device API&lt;/title&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="437.5" y="-596.3"&gt;Block device API&lt;/text&gt;
&lt;/g&gt;
&lt;!-- /dev/zvol/... --&gt;
&lt;g class="node" id="node6"&gt;
&lt;title&gt;/dev/zvol/...&lt;/title&gt;
&lt;ellipse cx="421.5" cy="-525" fill="none" rx="63.8893" ry="18" stroke="#000000"&gt;&lt;/ellipse&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="421.5" y="-521.3"&gt;/dev/zvol/...&lt;/text&gt;
&lt;/g&gt;
&lt;!-- Block device API&amp;#45;&amp;gt;/dev/zvol/... --&gt;
&lt;g class="edge" id="edge2"&gt;
&lt;title&gt;Block device API-&amp;gt;/dev/zvol/...&lt;/title&gt;
&lt;path d="M433.6268,-581.8446C431.7795,-573.1849 429.5277,-562.6301 427.4684,-552.9768" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="430.8469,-552.0379 425.3375,-542.9882 424.001,-553.4984 430.8469,-552.0379" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZFS Management API (libzfs) --&gt;
&lt;g class="node" id="node3"&gt;
&lt;title&gt;ZFS Management API (libzfs)&lt;/title&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="684.5" y="-596.3"&gt;ZFS Management API (libzfs)&lt;/text&gt;
&lt;/g&gt;
&lt;!-- /dev/zfs ioctl --&gt;
&lt;g class="node" id="node7"&gt;
&lt;title&gt;/dev/zfs ioctl&lt;/title&gt;
&lt;ellipse cx="684.5" cy="-525" fill="none" rx="69.5877" ry="18" stroke="#000000"&gt;&lt;/ellipse&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="684.5" y="-521.3"&gt;/dev/zfs ioctl&lt;/text&gt;
&lt;/g&gt;
&lt;!-- ZFS Management API (libzfs)&amp;#45;&amp;gt;/dev/zfs ioctl --&gt;
&lt;g class="edge" id="edge3"&gt;
&lt;title&gt;ZFS Management API (libzfs)-&amp;gt;/dev/zfs ioctl&lt;/title&gt;
&lt;path d="M684.5,-581.8446C684.5,-573.3401 684.5,-563.0076 684.5,-553.4964" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="688.0001,-553.2481 684.5,-543.2482 681.0001,-553.2482 688.0001,-553.2481" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- NFS/Samba API (libshare) --&gt;
&lt;g class="node" id="node4"&gt;
&lt;title&gt;NFS/Samba API (libshare)&lt;/title&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="246.5" y="-596.3"&gt;NFS/Samba API (libshare)&lt;/text&gt;
&lt;/g&gt;
&lt;!-- NFS/CIFS vop_rwlock --&gt;
&lt;g class="node" id="node8"&gt;
&lt;title&gt;NFS/CIFS vop_rwlock&lt;/title&gt;
&lt;ellipse cx="225.5" cy="-525" fill="none" rx="114.2798" ry="18" stroke="#000000"&gt;&lt;/ellipse&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="225.5" y="-521.3"&gt;NFS/CIFS vop_rwlock&lt;/text&gt;
&lt;/g&gt;
&lt;!-- NFS/Samba API (libshare)&amp;#45;&amp;gt;NFS/CIFS vop_rwlock --&gt;
&lt;g class="edge" id="edge4"&gt;
&lt;title&gt;NFS/Samba API (libshare)-&amp;gt;NFS/CIFS vop_rwlock&lt;/title&gt;
&lt;path d="M241.4165,-581.8446C238.966,-573.0928 235.9735,-562.4053 233.2473,-552.669" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="236.6034,-551.6741 230.5367,-542.9882 229.8627,-553.5616 236.6034,-551.6741" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- VFS&amp;#45;&amp;gt;NFS/CIFS vop_rwlock --&gt;
&lt;g class="edge" id="edge5"&gt;
&lt;title&gt;VFS-&amp;gt;NFS/CIFS vop_rwlock&lt;/title&gt;
&lt;path d="M93.0625,-525C95.6653,-525 98.2682,-525 100.871,-525" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="100.9106,-528.5001 110.9105,-525 100.9105,-521.5001 100.9106,-528.5001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZPL --&gt;
&lt;g class="node" id="node9"&gt;
&lt;title&gt;ZPL&lt;/title&gt;
&lt;g id="a_node9"&gt;&lt;a xlink:href="#zpl" xlink:title="ZPL"&gt;
&lt;polygon fill="none" points="367.5,-471 313.5,-471 313.5,-435 367.5,-435 367.5,-471" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="340.5" y="-449.3"&gt;ZPL&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- VFS&amp;#45;&amp;gt;ZPL --&gt;
&lt;g class="edge" id="edge6"&gt;
&lt;title&gt;VFS-&amp;gt;ZPL&lt;/title&gt;
&lt;path d="M86.3025,-513.3546C91.5594,-511.0472 97.1562,-508.7886 102.5,-507 171.7912,-483.808 255.7337,-467.3568 303.1418,-459.0894" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="303.9854,-462.4959 313.2493,-457.3547 302.8013,-455.5968 303.9854,-462.4959" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZVOL --&gt;
&lt;g class="node" id="node10"&gt;
&lt;title&gt;ZVOL&lt;/title&gt;
&lt;g id="a_node10"&gt;&lt;a xlink:href="#zvol" xlink:title="ZVOL"&gt;
&lt;polygon fill="none" points="483,-471 424,-471 424,-435 483,-435 483,-471" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="453.5" y="-449.3"&gt;ZVOL&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- /dev/zvol/...&amp;#45;&amp;gt;ZVOL --&gt;
&lt;g class="edge" id="edge7"&gt;
&lt;title&gt;/dev/zvol/...-&amp;gt;ZVOL&lt;/title&gt;
&lt;path d="M429.575,-506.8314C433.1102,-498.8771 437.336,-489.369 441.2456,-480.5723" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="444.4532,-481.9729 445.3163,-471.4133 438.0565,-479.1299 444.4532,-481.9729" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- DSL --&gt;
&lt;g class="node" id="node11"&gt;
&lt;title&gt;DSL&lt;/title&gt;
&lt;g id="a_node11"&gt;&lt;a xlink:href="#dsl" xlink:title="DSL"&gt;
&lt;polygon fill="none" points="557.5,-543 503.5,-543 503.5,-507 557.5,-507 557.5,-543" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="530.5" y="-521.3"&gt;DSL&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- /dev/zfs ioctl&amp;#45;&amp;gt;DSL --&gt;
&lt;g class="edge" id="edge10"&gt;
&lt;title&gt;/dev/zfs ioctl-&amp;gt;DSL&lt;/title&gt;
&lt;path d="M614.5895,-525C598.9983,-525 583.4071,-525 567.8159,-525" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="567.5703,-521.5001 557.5703,-525 567.5703,-528.5001 567.5703,-521.5001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- VDEV --&gt;
&lt;g class="node" id="node20"&gt;
&lt;title&gt;VDEV&lt;/title&gt;
&lt;g id="a_node20"&gt;&lt;a xlink:href="#vdev" xlink:title="VDEV"&gt;
&lt;polygon fill="none" points="546,-108 487,-108 487,-72 546,-72 546,-108" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="516.5" y="-86.3"&gt;VDEV&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- /dev/zfs ioctl&amp;#45;&amp;gt;VDEV --&gt;
&lt;g class="edge" id="edge29"&gt;
&lt;title&gt;/dev/zfs ioctl-&amp;gt;VDEV&lt;/title&gt;
&lt;path d="M689.2656,-506.9623C696.0025,-479.8344 707.5,-426.8236 707.5,-381 707.5,-381 707.5,-381 707.5,-234 707.5,-186.6526 686.8759,-174.3079 650.5,-144 623.0063,-121.0926 584.5356,-106.9458 555.8638,-98.9099" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="556.7296,-95.5186 546.165,-96.3181 554.9223,-102.2812 556.7296,-95.5186" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- DMU --&gt;
&lt;g class="node" id="node13"&gt;
&lt;title&gt;DMU&lt;/title&gt;
&lt;g id="a_node13"&gt;&lt;a xlink:href="#dmu" xlink:title="DMU"&gt;
&lt;polygon fill="none" points="555.5,-399 501.5,-399 501.5,-363 555.5,-363 555.5,-399" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="528.5" y="-377.3"&gt;DMU&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- NFS/CIFS vop_rwlock&amp;#45;&amp;gt;DMU --&gt;
&lt;g class="edge" id="edge15"&gt;
&lt;title&gt;NFS/CIFS vop_rwlock-&amp;gt;DMU&lt;/title&gt;
&lt;path d="M285.6968,-509.563C314.41,-500.7092 348.5163,-487.9433 376.5,-471 396.6786,-458.7825 395.9728,-448.2337 415.5,-435 439.4387,-418.7766 469.0038,-404.835 491.8877,-395.1832" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="493.3442,-398.3685 501.2501,-391.3152 490.6713,-391.8989 493.3442,-398.3685" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZAP --&gt;
&lt;g class="node" id="node12"&gt;
&lt;title&gt;ZAP&lt;/title&gt;
&lt;g id="a_node12"&gt;&lt;a xlink:href="#zap" xlink:title="ZAP"&gt;
&lt;polygon fill="none" points="555.5,-471 501.5,-471 501.5,-435 555.5,-435 555.5,-471" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="528.5" y="-449.3"&gt;ZAP&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- ZPL&amp;#45;&amp;gt;ZAP --&gt;
&lt;g class="edge" id="edge8"&gt;
&lt;title&gt;ZPL-&amp;gt;ZAP&lt;/title&gt;
&lt;path d="M367.5472,-469.1304C396.6265,-484.3281 444.0019,-502.8552 483.5,-489 490.6397,-486.4955 497.4881,-482.3291 503.5943,-477.7013" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="505.9521,-480.293 511.4185,-471.2173 501.4855,-474.9032 505.9521,-480.293" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZPL&amp;#45;&amp;gt;DMU --&gt;
&lt;g class="edge" id="edge12"&gt;
&lt;title&gt;ZPL-&amp;gt;DMU&lt;/title&gt;
&lt;path d="M367.7478,-440.7581C372.3191,-438.7848 377.0292,-436.8006 381.5,-435 418.7731,-419.9886 462.0037,-404.312 491.8902,-393.7414" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="493.2174,-396.9848 501.4861,-390.3607 490.8913,-390.3825 493.2174,-396.9848" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZIL --&gt;
&lt;g class="node" id="node15"&gt;
&lt;title&gt;ZIL&lt;/title&gt;
&lt;g id="a_node15"&gt;&lt;a xlink:href="#zil" xlink:title="ZIL"&gt;
&lt;polygon fill="none" points="480.5,-327 426.5,-327 426.5,-291 480.5,-291 480.5,-327" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="453.5" y="-305.3"&gt;ZIL&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- ZPL&amp;#45;&amp;gt;ZIL --&gt;
&lt;g class="edge" id="edge16"&gt;
&lt;title&gt;ZPL-&amp;gt;ZIL&lt;/title&gt;
&lt;path d="M354.8115,-434.7623C374.5947,-409.5518 410.4107,-363.9103 433.0226,-335.0952" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="435.8847,-337.1173 439.3047,-327.0896 430.3778,-332.7959 435.8847,-337.1173" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZVOL&amp;#45;&amp;gt;DMU --&gt;
&lt;g class="edge" id="edge13"&gt;
&lt;title&gt;ZVOL-&amp;gt;DMU&lt;/title&gt;
&lt;path d="M472.4257,-434.8314C481.4857,-426.1337 492.4809,-415.5783 502.3265,-406.1265" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="504.7904,-408.613 509.5804,-399.1628 499.9426,-403.5633 504.7904,-408.613" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- DSL&amp;#45;&amp;gt;ZAP --&gt;
&lt;g class="edge" id="edge9"&gt;
&lt;title&gt;DSL-&amp;gt;ZAP&lt;/title&gt;
&lt;path d="M529.9953,-506.8314C529.7814,-499.131 529.5271,-489.9743 529.2894,-481.4166" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="532.7879,-481.3122 529.0115,-471.4133 525.7906,-481.5066 532.7879,-481.3122" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- DSL&amp;#45;&amp;gt;DMU --&gt;
&lt;g class="edge" id="edge14"&gt;
&lt;title&gt;DSL-&amp;gt;DMU&lt;/title&gt;
&lt;path d="M545.614,-506.7768C552.8549,-496.8586 560.7524,-483.9858 564.5,-471 568.9365,-455.6274 569.1365,-450.3135 564.5,-435 561.5436,-425.2355 556.1748,-415.6229 550.47,-407.2762" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="553.2129,-405.0973 544.4905,-399.0831 547.5586,-409.2239 553.2129,-405.0973" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZAP&amp;#45;&amp;gt;DMU --&gt;
&lt;g class="edge" id="edge11"&gt;
&lt;title&gt;ZAP-&amp;gt;DMU&lt;/title&gt;
&lt;path d="M528.5,-434.8314C528.5,-427.131 528.5,-417.9743 528.5,-409.4166" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="532.0001,-409.4132 528.5,-399.4133 525.0001,-409.4133 532.0001,-409.4132" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ARC --&gt;
&lt;g class="node" id="node14"&gt;
&lt;title&gt;ARC&lt;/title&gt;
&lt;g id="a_node14"&gt;&lt;a xlink:href="#arc" xlink:title="ARC"&gt;
&lt;polygon fill="none" points="555.5,-327 501.5,-327 501.5,-291 555.5,-291 555.5,-327" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="528.5" y="-305.3"&gt;ARC&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- DMU&amp;#45;&amp;gt;ARC --&gt;
&lt;g class="edge" id="edge17"&gt;
&lt;title&gt;DMU-&amp;gt;ARC&lt;/title&gt;
&lt;path d="M528.5,-362.8314C528.5,-355.131 528.5,-345.9743 528.5,-337.4166" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="532.0001,-337.4132 528.5,-327.4133 525.0001,-337.4133 532.0001,-337.4132" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- MetaSlab --&gt;
&lt;g class="node" id="node19"&gt;
&lt;title&gt;MetaSlab&lt;/title&gt;
&lt;g id="a_node19"&gt;&lt;a xlink:href="#metaslab" xlink:title="MetaSlab"&gt;
&lt;polygon fill="none" points="641,-180 556,-180 556,-144 641,-144 641,-180" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="598.5" y="-158.3"&gt;MetaSlab&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- DMU&amp;#45;&amp;gt;MetaSlab --&gt;
&lt;g class="edge" id="edge23"&gt;
&lt;title&gt;DMU-&amp;gt;MetaSlab&lt;/title&gt;
&lt;path d="M555.6383,-368.3974C585.2203,-352.9755 630.9457,-323.7894 650.5,-283 663.3726,-256.1483 661.6355,-243.6173 650.5,-216 646.1775,-205.2796 638.5956,-195.4983 630.5361,-187.2948" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="632.7442,-184.5652 623.0801,-180.2228 627.927,-189.644 632.7442,-184.5652" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZIO --&gt;
&lt;g class="node" id="node16"&gt;
&lt;title&gt;ZIO&lt;/title&gt;
&lt;g id="a_node16"&gt;&lt;a xlink:href="#zio" xlink:title="ZIO"&gt;
&lt;polygon fill="none" points="555.5,-252 501.5,-252 501.5,-216 555.5,-216 555.5,-252" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="528.5" y="-230.3"&gt;ZIO&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- ARC&amp;#45;&amp;gt;ZIO --&gt;
&lt;g class="edge" id="edge20"&gt;
&lt;title&gt;ARC-&amp;gt;ZIO&lt;/title&gt;
&lt;path d="M528.5,-290.8446C528.5,-282.3401 528.5,-272.0076 528.5,-262.4964" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="532.0001,-262.2481 528.5,-252.2482 525.0001,-262.2482 532.0001,-262.2481" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- L2ARC --&gt;
&lt;g class="node" id="node17"&gt;
&lt;title&gt;L2ARC&lt;/title&gt;
&lt;g id="a_node17"&gt;&lt;a xlink:href="#l2arc" xlink:title="L2ARC"&gt;
&lt;polygon fill="none" points="641.5,-252 573.5,-252 573.5,-216 641.5,-216 641.5,-252" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="607.5" y="-230.3"&gt;L2ARC&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- ARC&amp;#45;&amp;gt;L2ARC --&gt;
&lt;g class="edge" id="edge21"&gt;
&lt;title&gt;ARC-&amp;gt;L2ARC&lt;/title&gt;
&lt;path d="M554.9972,-290.9209C558.2877,-288.3716 561.5341,-285.6973 564.5,-283 572.1249,-276.0657 579.7661,-267.8645 586.4472,-260.1753" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="589.4807,-262.0092 593.2739,-252.1166 584.1396,-257.4845 589.4807,-262.0092" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZIL&amp;#45;&amp;gt;ZIO --&gt;
&lt;g class="edge" id="edge19"&gt;
&lt;title&gt;ZIL-&amp;gt;ZIO&lt;/title&gt;
&lt;path d="M480.869,-292.5464C484.9519,-289.5928 488.9697,-286.3728 492.5,-283 499.3026,-276.501 505.7319,-268.5881 511.2235,-261.0336" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="514.3671,-262.6436 517.2054,-252.436 508.6211,-258.6456 514.3671,-262.6436" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- SLOG --&gt;
&lt;g class="node" id="node18"&gt;
&lt;title&gt;SLOG&lt;/title&gt;
&lt;g id="a_node18"&gt;&lt;a xlink:href="#slog" xlink:title="SLOG"&gt;
&lt;polygon fill="none" points="483,-252 424,-252 424,-216 483,-216 483,-252" stroke="#0000ff"&gt;&lt;/polygon&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="453.5" y="-230.3"&gt;SLOG&lt;/text&gt;
&lt;/a&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;!-- ZIL&amp;#45;&amp;gt;SLOG --&gt;
&lt;g class="edge" id="edge18"&gt;
&lt;title&gt;ZIL-&amp;gt;SLOG&lt;/title&gt;
&lt;path d="M453.5,-290.8446C453.5,-282.3401 453.5,-272.0076 453.5,-262.4964" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="457.0001,-262.2481 453.5,-252.2482 450.0001,-262.2482 457.0001,-262.2481" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZIO&amp;#45;&amp;gt;MetaSlab --&gt;
&lt;g class="edge" id="edge24"&gt;
&lt;title&gt;ZIO-&amp;gt;MetaSlab&lt;/title&gt;
&lt;path d="M546.164,-215.8314C554.4732,-207.2848 564.5264,-196.9443 573.5918,-187.6198" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="576.1369,-190.023 580.5982,-180.4133 571.1179,-185.1435 576.1369,-190.023" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- ZIO&amp;#45;&amp;gt;VDEV --&gt;
&lt;g class="edge" id="edge28"&gt;
&lt;title&gt;ZIO-&amp;gt;VDEV&lt;/title&gt;
&lt;path d="M526.9802,-215.7623C524.9334,-191.201 521.2706,-147.2474 518.8628,-118.3541" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="522.3259,-117.7644 518.0075,-108.0896 515.3501,-118.3458 522.3259,-117.7644" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- L2ARC&amp;#45;&amp;gt;ZIO --&gt;
&lt;g class="edge" id="edge22"&gt;
&lt;title&gt;L2ARC-&amp;gt;ZIO&lt;/title&gt;
&lt;path d="M573.4775,-234C570.8786,-234 568.2797,-234 565.6807,-234" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="565.6563,-230.5001 555.6563,-234 565.6562,-237.5001 565.6563,-230.5001" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- L2ARC&amp;#45;&amp;gt;VDEV --&gt;
&lt;g class="edge" id="edge26"&gt;
&lt;title&gt;L2ARC-&amp;gt;VDEV&lt;/title&gt;
&lt;path d="M581.9503,-215.8625C570.0905,-206.3385 556.6295,-193.7883 547.5,-180 535.0104,-161.137 527.0138,-136.7121 522.2764,-118.0676" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="525.6279,-117.032 519.9132,-108.1105 518.8171,-118.6485 525.6279,-117.032" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- SLOG&amp;#45;&amp;gt;VDEV --&gt;
&lt;g class="edge" id="edge25"&gt;
&lt;title&gt;SLOG-&amp;gt;VDEV&lt;/title&gt;
&lt;path d="M461.479,-215.7623C472.3192,-190.9846 491.7938,-146.4714 504.4277,-117.5939" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="507.7841,-118.6541 508.5858,-108.0896 501.371,-115.8483 507.7841,-118.6541" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- MetaSlab&amp;#45;&amp;gt;VDEV --&gt;
&lt;g class="edge" id="edge27"&gt;
&lt;title&gt;MetaSlab-&amp;gt;VDEV&lt;/title&gt;
&lt;path d="M577.8079,-143.8314C567.8052,-135.0485 555.645,-124.3712 544.8001,-114.8489" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="547.0092,-112.1308 537.1854,-108.1628 542.3906,-117.3909 547.0092,-112.1308" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;!-- physical storage devices --&gt;
&lt;g class="node" id="node21"&gt;
&lt;title&gt;physical storage devices&lt;/title&gt;
&lt;path d="M613,-32.7273C613,-34.5331 569.7472,-36 516.5,-36 463.2528,-36 420,-34.5331 420,-32.7273 420,-32.7273 420,-3.2727 420,-3.2727 420,-1.4669 463.2528,0 516.5,0 569.7472,0 613,-1.4669 613,-3.2727 613,-3.2727 613,-32.7273 613,-32.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;path d="M613,-32.7273C613,-30.9214 569.7472,-29.4545 516.5,-29.4545 463.2528,-29.4545 420,-30.9214 420,-32.7273" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;text fill="#000000" font-family="Times,serif" font-size="14.00" text-anchor="middle" x="516.5" y="-14.3"&gt;physical storage devices&lt;/text&gt;
&lt;/g&gt;
&lt;!-- VDEV&amp;#45;&amp;gt;physical storage devices --&gt;
&lt;g class="edge" id="edge30"&gt;
&lt;title&gt;VDEV-&amp;gt;physical storage devices&lt;/title&gt;
&lt;path d="M516.5,-71.8314C516.5,-64.131 516.5,-54.9743 516.5,-46.4166" fill="none" stroke="#000000"&gt;&lt;/path&gt;
&lt;polygon fill="#000000" points="520.0001,-46.4132 516.5,-36.4133 513.0001,-46.4133 520.0001,-46.4132" stroke="#000000"&gt;&lt;/polygon&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;/svg&gt;
&lt;p&gt;接下來從底層往上介紹一下各個子系統的全稱和職能。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="spa"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;SPA&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Storage Pool Allocator&lt;/p&gt;
&lt;p&gt;從內核提供的多個塊設備中抽象出存儲池的子系統。 SPA 進一步分爲 ZIO 和 VDEV 兩大部分和其餘一些小的子系統。&lt;/p&gt;
&lt;p&gt;SPA 對 DMU 提供的接口不同於傳統的塊設備接口，完全利用了 CoW 文件系統對寫入位置不敏感的特點。
傳統的塊設備接口通常是寫入時指定一個寫入地址，把緩衝區寫到磁盤指定的位置上，而 DMU 可以讓 SPA
做兩種操作：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;code class="code"&gt;
write&lt;/code&gt;
 ， DMU 交給 SPA 一個數據塊的內存指針， SPA
負責找設備寫入這個數據塊，然後返回給 DMU 一個 block pointer 。&lt;/li&gt;
&lt;li&gt;&lt;code class="code"&gt;
read&lt;/code&gt;
 ，DMU 交給 SPA 一個 block pointer ，SPA 讀取設備並返回給 DMU
完整的數據塊。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是說，在 DMU 讓 SPA 寫數據塊時， DMU 還不知道 SPA 會寫入的地方，這完全由 SPA 判斷，
這一點通常被稱爲 Write Anywhere ，在別的 CoW 文件系統比如 Btrfs 和 WAFL 中也有這個特點。
反過來 SPA 想要對一個數據塊操作時，也完全不清楚這個數據塊用於什麼目的，屬於什麼文件或者文件系統結構。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="vdev"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;VDEV&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Virtual DEVice&lt;/p&gt;
&lt;p&gt;VDEV 在 ZFS 中的作用相當於 Linux 內核的 Device Mapper 層或者 FreeBSD GEOM 層，提供
Stripe/Mirror/RAIDZ 之類的多設備存儲池管理和抽象。 ZFS 中的 vdev
形成一個樹狀結構，在樹的底層是從內核提供的物理設備，
其上是虛擬的塊設備。每個虛擬塊設備對上對下都是塊設備接口，除了底層的物理設備之外，位於中間層的
vdev 需要負責地址映射、容量轉換等計算過程。&lt;/p&gt;
&lt;p&gt;除了用於存儲數據的 Stripe/Mirror/RAIDZ 之類的 VDEV ，還有一些特殊用途的 VDEV
，包括提供二級緩存的 L2ARC 設備，以及提供 ZIL 高速日誌的 SLOG 設備。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="zio"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;ZIO&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
ZIO Pipeline by George Wilson&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/qkA5HhfzsvM"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ZFS I/O&lt;/p&gt;
&lt;p&gt;作用相當於內核的 IO scheduler 和 pagecache write back 機制。
OpenZFS Summit 有个演讲整理了 ZIO 流水线的工作原理。
ZIO 內部使用流水線和事件驅動機制，避免讓上層的 ZFS 線程阻塞等待在 IO 操作上。
ZIO 把一個上層的寫請求轉換成多個寫操作，負責把這些寫操作合併到
transaction group 提交事務組。 ZIO 也負責將讀寫請求按同步還是異步分成不同的讀寫優先級並實施優先級調度，
在 &lt;a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler"&gt;OpenZFS 項目 wiki 頁有一篇描述 ZIO 調度&lt;/a&gt;
的細節。&lt;/p&gt;
&lt;p&gt;除了調度之外， ZIO 層還負責在讀寫流水線中拆解和拼裝數據塊。上層 DMU 交給 SPA 的數據塊有固定大小，
目前默認是 128KiB ，pool 整體的參數可以調整塊大小在 4KiB 到 8MiB 之間。ZIO
拿到整塊大小的數據塊之後，在流水線中可以對數據塊做諸如以下操作：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;用壓縮算法，壓縮/解壓數據塊。&lt;/li&gt;
&lt;li&gt;查詢 dedup table ，對數據塊去重。&lt;/li&gt;
&lt;li&gt;加密/解密數據塊。&lt;/li&gt;
&lt;li&gt;計算數據塊的校驗和。&lt;/li&gt;
&lt;li&gt;如果底層分配器不能分配完整的 128KiB （或 zpool 設置的大小），那麼嘗試分配多個小塊，然後用多個
512B 的指針間接塊連起多個小塊的，拼裝成一個虛擬的大塊，這個機制叫
&lt;a class="reference external" href="https://utcc.utoronto.ca/~cks/space/blog/solaris/ZFSGangBlocks"&gt;gang block&lt;/a&gt;
。通常 ZFS 中用到 gang block 時，整個存儲池處於極度空間不足的情況，由 gang block
造成嚴重性能下降，而 gang block 的意義在於在空間接近要滿的時候也能 CoW
寫入一些元數據，釋放亟需的存儲空間。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可見經過 ZIO 流水線之後，數據塊不再是統一大小，這使得 ZFS 用在 4K 對齊的磁盤或者 SSD
上有了一些新的挑戰。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="metaslab"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;MetaSlab&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
MetaSlab Allocation Performance by Paul Dagnelie&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/LZpaTGNvalE"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;MetaSlab 是 ZFS 的塊分配器。 VDEV 把存儲設備抽象成存儲池之後， MetaSlab
負責實際從存儲設備上分配數據塊，跟蹤記錄可用空間和已用空間。&lt;/p&gt;
&lt;p&gt;叫 MetaSlab 這個名字是因爲 Jeff 最初同時也給 Solaris 內核寫過
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Slab_allocation"&gt;slab 分配器&lt;/a&gt;
，一開始設計 SPA 的時候 Jeff 想在 SPA 中也利用 Solaris 的 slab
分配器對磁盤空間使用類似的分配算法。後來 MetaSlab 逐漸不再使用 slab 算法，只有名字留了下來。&lt;/p&gt;
&lt;p&gt;MetaSlab 的結構很接近於 FreeBSD UFS 的 cylinder group ，或者 ext2/3/4 的 block group
，或者 xfs 的 allocation group ，目的都是讓存儲分配策略「局域化」，
或者說讓近期分配的數據塊的物理地址比較接近。在存儲設備上創建 zpool
的時候，首先會儘量在存儲設備上分配 200 個左右的 MetaSlab ，隨後給 zpool
增加設備的話使用接近的 MetaSlab 大小。每個 MetaSlab 是連續的一整塊空間，在 MetaSlab
內對數據塊空間做分配和釋放。磁盤中存儲的 MetaSlab 的分配情況是按需載入內存的，系統
import zpool 時不需要載入所有 MetaSlab 到內存，而只需加載一小部分。當前載入內存的 MetaSlab
剩餘空間告急時，會載入別的 MetaSlab 嘗試分配，而從某個 MetaSlab 釋放空間不需要載入 MetaSlab
。&lt;/p&gt;
&lt;p&gt;OpenZFS Summit 也有一個對 MetaSlab 分配器性能的介紹，可以看到很多分配器內的細節。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="arc"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;ARC&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
ELI5: ZFS Caching Explain Like I'm 5: How the ZFS Adaptive Replacement Cache works&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/1Wo3i2gkAIk"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Adaptive Replacement Cache&lt;/p&gt;
&lt;p&gt;ARC 的作用相當於 Linux/Solaris/FreeBSD 中傳統的 page/buffer cache 。
和傳統 pagecache 使用 LRU (Least Recently Used) 之類的算法剔除緩存頁不同， ARC
算法試圖在 LRU 和 LFU(Least Frequently Used) 之間尋找平衡，從而複製大文件之類的線性大量
IO 操作不至於讓緩存失效率猛增。最近 FOSDEM 2019 有一個介紹 ZFS ARC 工作原理的視頻。&lt;/p&gt;
&lt;p&gt;不過 ZFS 採用它自有的 ARC 一個顯著缺點在於，不能和內核已有的 pagecache 機制相互配合，尤其在
系統內存壓力很大的情況下，內核與 ZFS 無關的其餘部分可能難以通知 ARC 釋放內存。所以 ARC
是 ZFS 消耗內存的大戶之一（另一個是可選的 dedup table），也是
&lt;a class="reference external" href="http://open-zfs.org/wiki/Performance_tuning#Adaptive_Replacement_Cache"&gt;ZFS 性能調優&lt;/a&gt;
的重中之重。&lt;/p&gt;
&lt;p&gt;當然， ZFS 採用 ARC 不依賴於內核已有的 pagecache 機制除了 LFU 平衡的好處之外，也有別的有利的一面。
系統中多次讀取因 snapshot 或者 dedup 而共享的數據塊的話，在 ZFS 的 ARC 機制下，同樣的
block pointer 只會被緩存一次；而傳統的 pagecache 因爲基於 inode 判斷是否有共享，
所以即使這些文件有共享頁面（比如 btrfs/xfs 的 reflink 形成的），也會多次讀入內存。 Linux
的 btrfs 和 xfs 在 VFS 層面有共用的 reflink 機制之後，正在努力着手改善這種局面，而 ZFS
因爲 ARC 所以從最初就避免了這種浪費。&lt;/p&gt;
&lt;p&gt;和很多傳言所說的不同， ARC 的內存壓力問題不僅在 Linux 內核會有，在 FreeBSD 和
Solaris/Illumos 上也是同樣，這個在
&lt;a class="reference external" href="https://youtu.be/xMH5rCL8S2k?t=997"&gt;ZFS First Mount by Mark Shellenbaum 的問答環節 16:37 左右有提到&lt;/a&gt;
。其中 Mark Shellenbaum 提到 Matt 覺得讓 ARC 併入現有 pagecache
子系統的工作量太大，難以實現。&lt;/p&gt;
&lt;p&gt;因爲 ARC 工作在 ZIO 上層，所以 ARC 中緩存的數據是經過 ZIO
從存儲設備中讀取出來之後解壓、解密等處理之後的，原始的數據。最近 ZFS 的版本有支持一種新特性叫
&lt;a class="reference external" href="https://www.illumos.org/issues/6950"&gt;Compressed ARC&lt;/a&gt;
，打破 ARC 和 VDEV 中間 ZIO 的壁壘，把壓縮的數據直接緩存在 ARC
中。這麼做是因爲壓縮解壓很快的情況下，壓縮的 ARC 能節省不少內存，讓更多數據保留在 ARC
中從而提升緩存利用率，並且在有 L2ARC 的情況下也能增加 L2ARC 能存儲的緩存。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="l2arc"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;L2ARC&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Level 2 Adaptive Replacement Cache&lt;/p&gt;
&lt;p&gt;這是用 ARC 算法實現的二級緩存，保存於高速存儲設備上。常見用法是給 ZFS pool 配置一塊 SSD
作爲 L2ARC 高速緩存，減輕內存 ARC 的負擔並增加緩存命中率。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="slog"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;SLOG&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Separate intent LOG&lt;/p&gt;
&lt;p&gt;SLOG 是額外的日誌記錄設備。 SLOG 之於 ZIL 有點像 L2ARC 之餘 ARC ， L2ARC 是把內存中的
ARC 放入額外的高速存儲設備，而 SLOG 是把原本和別的數據塊存儲在一起的 ZIL
放到額外的高速存儲設備。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tol"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;TOL&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Transactional Object Layer&lt;/p&gt;
&lt;p&gt;這一部分子系統在數據塊的基礎上提供一個事務性的對象語義層，這裏事務性是指，
對對象的修改處於明確的狀態，不會因爲突然斷電之類的原因導致狀態不一致。TOL
中最主要的部分是 DMU 層。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="dmu"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;DMU&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Data Management Unit&lt;/p&gt;
&lt;p&gt;在塊的基礎上提供「對象（object）」的抽象。每個「對象」可以是一個文件，或者是別的 ZFS 內部需要記錄的東西。&lt;/p&gt;
&lt;p&gt;DMU 這個名字最初是 Jeff 想類比於操作系統中內存管理的 MMU(Memory Management Unit)，
Jeff 希望 ZFS 中增加和刪除文件就像內存分配一樣簡單，增加和移除塊設備就像增加內存一樣簡單，
由 DMU 負責從存儲池中分配和釋放數據塊，對上提供事務性語義，管理員不需要管理文件存儲在什麼存儲設備上。
這裏事務性語義指對文件的修改要麼完全成功，要麼完全失敗，不會處於中間狀態，這靠 DMU 的 CoW
語義實現。&lt;/p&gt;
&lt;p&gt;DMU 實現了對象級別的 CoW 語義，從而任何經過了 DMU 做讀寫的子系統都具有了 CoW 的特徵，
這不僅包括文件、文件夾這些 ZPL 層需要的東西，也包括文件系統內部用的 spacemap 之類的設施。
相反，不經過 DMU 的子系統則可能沒法保證事務語義。這裏一個特例是 ZIL ，一定程度上繞過了 DMU
直接寫日誌。說一定程度是因爲 ZIL 仍然靠 DMU 來擴展長度，當一個塊寫滿日誌之後需要等 DMU
分配一個新塊，在分配好的塊內寫日誌則不需要經過 DMU 。所有經過 DMU 子系統的對象都有 CoW
語義，也意味着 ZFS 中不能對某些文件可選地關閉 CoW ，不能提供數據庫應用的 direct IO 之類的接口。&lt;/p&gt;
&lt;p&gt;「對象（object）」抽象是 DMU 最重要的抽象，一個對象的大小可變，佔用一個或者多個數據塊（
默認一個數據塊 128KiB ）。上面提到 SPA 的時候也講了 DMU 和 SPA 之間不同於普通塊設備抽象的接口，這使得 DMU
按整塊的大小分配空間。當對象使用多個數據塊存儲時， DMU 提供間接塊（indirect block）來引用這些數據塊。
間接塊很像傳統 Unix 文件系統（Solaris UFS 或者 Linux ext2）中的一級二級三級間接塊，
一個間接塊存儲很多塊指針（block pointer），多個間接塊形成樹狀結構，最終一個塊指針可以引用到一個對象。
更現代的文件系統比如 ext4/xfs/btrfs/ntfs 提供了 extent 抽象，可以指向一個連續範圍的存儲塊，
而 ZFS 不使用類似 extent 的抽象。DMU 採用間接塊而不是 extent
，使得 ZFS 的空間分配更趨向碎片化，爲了避免碎片化造成的性能影響，需要儘量延遲寫入使得一次寫入能在磁盤上
儘量連續，這裏 ARC 提供的緩存和 ZIO 提供的流水線對延遲寫入避免碎片有至關重要的幫助。&lt;/p&gt;
&lt;p&gt;有了「對象（object）」的抽象之後， DMU 進一步實現了「對象集（objectset）」的抽象，
一個對象集中保存一系列按順序編號的 dnode （ ZFS 中類似 inode 的數據結構），每個 dnode 有足夠空間
指向一個對象的最多三個塊指針，如果對象需要更多數據塊可以使用間接塊，如果對象很小也可以直接壓縮進
dnode 。隨後 DSL 又進一步用對象集來實現數據集（dataset）抽象，提供比如文件系統（filesystem
）、快照（snapshot）、克隆（clone）之類的抽象。一個對象集中的對象可以通過 dnode 編號相互引用，
就像普通文件系統的硬鏈接引用 inode 編號那樣。&lt;/p&gt;
&lt;p&gt;上面也提到因爲 SPA 和 DMU 分離， SPA 完全不知道數據塊用於什麼目的；這一點其實對 DMU 也是類似，
DMU 雖然能從某個對象找到它所佔用的數據塊，但是 DMU 完全不知道這個對象在文件系統或者存儲池中是
用來存儲什麼的。當 DMU 讀取數據遇到壞塊（block pointer 中的校驗和與 block pointer
指向的數據塊內容不一致）時，它知道這個數據塊在哪兒（具體哪個設備上的哪個地址），
但是不知道這個數據塊是否和別的對象共享，不知道搬動這個數據塊的影響，也沒法從對象反推出文件系統路徑，
（除了明顯開銷很高地掃一遍整個存儲池）。所以 DMU 在遇到讀取錯誤（普通的讀操作或者 scrub/resilver
操作中）時，只能選擇在同樣的地址，原地寫入數據塊的備份（如果能找到或者推算出備份的話）。&lt;/p&gt;
&lt;p&gt;或許有人會疑惑，既然從 SPA 無法根據數據地址反推出對象，在 DMU 也無法根據對象反推出文件，那麼
zfs 在遇到數據損壞時是如何在診斷信息中給出損壞的文件路徑的呢？這其實基於 ZPL 的一個黑魔法：
&lt;a class="reference external" href="https://utcc.utoronto.ca/~cks/space/blog/solaris/ZFSPathLookupTrick"&gt;在 dnode 記錄父級 dnode 的編號&lt;/a&gt;
。因爲是個黑魔法，這個記錄不總是對的，所以只能用於診斷信息，不能基於這個實現別的文件系統功能。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="zap"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;ZAP&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ZFS Attribute Processor&lt;/p&gt;
&lt;p&gt;在 DMU 提供的「對象」抽象基礎上提供緊湊的 name/value 映射存儲，
從而文件夾內容列表、文件擴展屬性之類的都是基於 ZAP 來存。 ZAP 在內部分爲兩種存儲表達：
microZAP 和 fatZAP 。&lt;/p&gt;
&lt;p&gt;一個 microZAP 佔用一整塊數據塊，能存 name 長度小於 50 字符並且 value 是 uint64_t 的表項，
每個表項 64 字節。 fatZAP 則是個樹狀結構，能存更多更複雜的東西。可見 microZAP
非常適合表述一個普通大小的文件夾裏面包含到很多普通文件 inode （ZFS 是 dnode）的引用。&lt;/p&gt;
&lt;p&gt;在 &lt;a class="reference external" href="https://youtu.be/xMH5rCL8S2k?t=526"&gt;ZFS First Mount by Mark Shellenbaum 的8:48左右&lt;/a&gt;
提到，最初 ZPL 中關於文件的所有屬性（包括訪問時間、權限、大小之類所有文件都有的）都是基於
ZAP 來存，也就是說每個文件都有個 ZAP ，其中有叫做 size 呀 owner
之類的鍵值對，就像是個 JSON 對象那樣，這讓 ZPL 一開始很容易設計原型並且擴展。然後文件夾內容列表有另一種數據結構
ZDS（ZFS Directory Service），後來常見的文件屬性在 ZPL 有了專用的緊湊數據結構，而 ZDS 則漸漸融入了 ZAP 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="dsl"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;DSL&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Dataset and Snapshot Layer&lt;/p&gt;
&lt;p&gt;數據集和快照層，負責創建和管理快照、克隆等數據集類型，跟蹤它們的寫入大小，最終刪除它們。
由於 DMU 層面已經負責了對象的寫時複製語義和對象集的概念，所以 DSL 層面不需要直接接觸寫文件之類來自 ZPL
的請求，無論有沒有快照對 DMU 層面一樣採用寫時複製的方式修改文件數據。
不過在刪除快照和克隆之類的時候，則需要 DSL 參與計算沒有和別的數據集共享的數據塊並且刪除它們。&lt;/p&gt;
&lt;p&gt;DSL 管理數據集時，也負責管理數據集上附加的屬性。ZFS 每個數據集有個屬性列表，這些用 ZAP 存儲，
DSL 則需要根據數據集的上下級關係，計算出繼承的屬性，最終指導 ZIO 層面的讀寫行爲。&lt;/p&gt;
&lt;p&gt;除了管理數據集， DSL 層面也提供了 zfs 中 send/receive 的能力。 ZFS 在 send 時從 DSL
層找到快照引用到的所有數據塊，把它們直接發往管道，在 receive 端則直接接收數據塊並重組數據塊指針。
因爲 DSL 提供的 send/receive 工作在 DMU 之上，所以在 DSL 看到的數據塊是 DMU
的數據塊，下層 SPA 完成的數據壓縮、加密、去重等工作，對 DMU 層完全透明。所以在最初的
send/receive 實現中，假如數據塊已經壓縮，需要在 send 端經過 SPA 解壓，再 receive
端則重新壓縮。最近 ZFS 的 send/receive 逐漸打破 DMU 與 SPA
的壁壘，支持了直接發送已壓縮或加密的數據塊的能力。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="zil"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;ZIL&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ZFS Intent Log&lt;/p&gt;
&lt;p&gt;記錄兩次完整事務語義提交之間的日誌，用來加速實現 fsync 之類的文件事務語義。&lt;/p&gt;
&lt;p&gt;原本 CoW 的文件系統不需要日誌結構來保證文件系統結構的一致性，在 DMU
保證了對象級別事務語義的前提下，每次完整的 transaction group commit
都保證了文件系統一致性，掛載時也直接找到最後一個 transaction group 從它開始掛載即可。
不過在 ZFS 中，做一次完整的 transaction group commit 是個比較耗時的操作，
在寫入文件的數據塊之後，還需要更新整個 object set ，然後更新 meta-object set
，最後更新 uberblock ，爲了滿足事務語義這些操作沒法並行完成，所以整個 pool
提交一次需要等待好幾次磁盤寫操作返回，短則一兩秒，長則幾分鐘，
如果事務中有要刪除快照等非常耗時的操作可能還要等更久，在此期間提交的事務沒法保證一致。&lt;/p&gt;
&lt;p&gt;對上層應用程序而言，通常使用 fsync 或者 fdatasync 之類的系統調用，確保文件內容本身的事務一致性。
如果要讓每次 fsync/fdatasync 等待整個 transaction group commit
完成，那會嚴重拖慢很多應用程序，而如果它們不等待直接返回，則在突發斷電時沒有保證一致性。
從而 ZFS 有了 ZIL ，記錄兩次 transaction group 的 commit 之間發生的 fsync
，突然斷電後下次 import zpool 時首先找到最近一次 transaction group ，在它基礎上重放
ZIL 中記錄的寫請求和 fsync 請求，從而滿足 fsync API 要求的事務語義。&lt;/p&gt;
&lt;p&gt;顯然對 ZIL 的寫操作需要繞過 DMU 直接寫入數據塊，所以 ZIL 本身是以日誌系統的方式組織的，每次寫
ZIL 都是在已經分配的 ZIL 塊的末尾添加數據，分配新的 ZIL 塊仍然需要經過 DMU
的空間分配。&lt;/p&gt;
&lt;p&gt;傳統日誌型文件系統中對 data 開啓日誌支持會造成每次文件系統寫入操作需要寫兩次到設備上，
一次寫入日誌，再一次覆蓋文件系統內容；在
ZIL 實現中則不需要重複寫兩次， DMU 讓 SPA 寫入數據之後 ZIL 可以直接記錄新數據塊的
block pointer ，所以使用 ZIL 不會導致傳統日誌型文件系統中雙倍寫入放大的問題。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="zvol"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id18"&gt;ZVOL&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ZFS VOLume&lt;/p&gt;
&lt;p&gt;有點像 loopback block device ，暴露一個塊設備的接口，其上可以創建別的
FS 。對 ZFS 而言實現 ZVOL 的意義在於它是比文件更簡單的接口，所以在實現完整 ZPL
之前，一開始就先實現了 ZVOL ，而且
&lt;a class="reference external" href="https://youtu.be/xMH5rCL8S2k?t=298"&gt;早期 Solaris 沒有 thin provisioning storage pool 的時候可以用 ZVOL 模擬很大的塊設備，當時 Solaris 的 UFS 團隊用它來測試 UFS 對 TB 級存儲的支持情況&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;因爲 ZVOL 基於 DMU 上層，所以 DMU 所有的文件系統功能，比如 snapshot / dedup / compression
都可以用在 ZVOL 上，從而讓 ZVOL 上層的傳統文件系統也具有類似的功能。並且 ZVOL 也具有了 ARC
緩存的能力，和 dedup 結合之下，非常適合於在一個宿主機 ZFS
上提供對虛擬機文件系統鏡像的存儲，可以節省不少存儲空間和內存佔用開銷。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="zpl"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id19"&gt;ZPL&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ZFS Posix Layer&lt;/p&gt;
&lt;p&gt;提供符合 POSIX 文件系統語義的抽象，也就是包括文件、目錄、軟鏈接、套接字這些抽象以及
inode 訪問時間、權限那些抽象，ZPL 是 ZFS 中對一個普通 FS 而言用戶直接接觸的部分。
ZPL 可以說是 ZFS 最複雜的子系統，也是 ZFS 作爲一個文件系統而言最關鍵的部分。&lt;/p&gt;
&lt;p&gt;ZPL 的實現中直接使用了 ZAP 和 DMU 提供的抽象，比如每個 ZPL 文件用一個 DMU 對象表達，每個
ZPL 目錄用一個 ZAP 對象表達，然後 DMU 對象集對應到 ZPL 下的一個文件系統。
也就是說 ZPL 負責把操作系統 VFS 抽象層的那些文件系統操作接口，翻譯映射到基於 DMU 和 ZAP
的抽象上。傳統 Unix 中的管道、套接字、軟鏈接之類的沒有什麼數據內容的東西則在 ZPL 直接用 dnode
實現出來。 ZPL 也需要進一步實現文件權限、所有者、訪問日期、擴展屬性之類雜七雜八的文件系統功能。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://youtu.be/xMH5rCL8S2k?t=456"&gt;在 ZFS First Mount by Mark Shellenbaum&lt;/a&gt;
中介紹了很多在最初實現 ZPL 過程中的坎坷， ZPL 的困難之處在於需要兼容現有應用程序對傳統文件系統
API 的使用方式，所以他們需要大量兼容性測試。視頻中講到非常有意思的一件事是， ZFS
在設計時不想重複 Solaris UFS 設計中的很多缺陷，於是實現 VFS API 時有諸多取捨和再設計。
其中他們遇到了 &lt;code class="code"&gt;
VOP_RWLOCK&lt;/code&gt;
 ，這個是 UFS 提供的文件級別讀寫鎖。對一些應用尤其是
NFS 而言，文件讀寫鎖能保證應用層的一致性，而對另一些應用比如數據庫而言，
文件鎖的粒度太大造成了性能問題。在設計 ZPL 的時候他們不想在 ZFS 中提供 &lt;code class="code"&gt;
VOP_RWLOCK&lt;/code&gt;

，這讓 NFS 開發者們很難辦（要記得 NFS 也是 Solaris 對 Unix 世界貢獻的一大發明）。
最終 ZFS 把 DMU 的內部細節也暴露給了 NFS ，讓 NFS 基於 DMU 的對象創建時間（ TXG id
）而不是文件鎖來保證 NFS 的一致性。結果是現在 ZFS 中也有照顧 NFS 的代碼，後來也加入了
Samba/CIFS 的支持，從而在 ZFS 上設置 NFS export 時是通過 ZFS 的機制而非系統原生的 NFS
export 機制。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="zfs"></category><category term="layered"></category><category term="architecture"></category><category term="SPA"></category><category term="DMU"></category><category term="ZPL"></category><category term="ZIO"></category><category term="VDEV"></category><category term="ARC"></category><category term="ZAP"></category><category term="DSL"></category><category term="ZIL"></category><category term="ZVOL"></category></entry><entry><title>和萌狼交換問題</title><link href="//farseerfc.me/question-exchange-horo.html" rel="alternate"></link><published>2020-01-05T17:51:00+09:00</published><updated>2020-01-05T17:51:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2020-01-05:/question-exchange-horo.html</id><summary type="html">&lt;p&gt;很抱歉萌狼很早就提過交換問題的事，被我一直咕咕了許久。 &lt;del&gt;拖延症晚期有藥麼&lt;/del&gt;&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;我的提問和萌狼的回答&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://blog.yoitsu.moe/life/question_exchange_farseerfc.html"&gt;可以去萌狼的博客上看呀&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="q1"&gt;
&lt;h2&gt;Q1：除了博客的「关于」页面以外，还愿意再向咱介绍一下自己嘛？&lt;/h2&gt;
&lt;p&gt;介紹自己啊。 &lt;del&gt;寫了刪刪了寫，不知道該介紹點啥&lt;/del&gt; 就說點自己的興趣？&lt;/p&gt;
&lt;p&gt;喜歡自由開源軟件，喜歡 Arch Linux 。喜歡這些倒不是出於 RMS 和 FSF 那樣道義上的原因，
我覺得商業軟件公司要賺錢吃飯也是無可厚非的。&lt;/p&gt;
&lt;p&gt;喜歡自由軟件是因爲，當我需要知道它到底怎麼工作的時候，有可能去挖代碼，必要的話能去改代碼。
當然我一個人肯定不能讀所有在用的軟件，但是我知道我有讀和修改代碼的權利的話，
那麼我認識的朋友們也同樣有這樣的權利，我不認識的廣大社區有千千萬萬的人也同樣有這樣的權利，
從而我相信當我遇到問題的時候不至於卡在某些人某些公司某些集體的決策上而無法解決。&lt;/p&gt;
&lt;p&gt;基於這個理由，我對開源社區也同樣有公開全部細節的期待。我喜歡 Arch Linux
因爲即便它的內部決策只是一小波人，但是導致決策的討論以及決策的執行方式全是公開的，可以在網上翻閱，
可以追根溯源，這讓我有種安心感。就像我不喜歡 Manjaro 的一點是它有太多細節是翻閱不到的，
雖然它也是開源社區，但是打包細節翻閱不到，包列表翻閱不到，決策的制定和執行的過程也翻閱不到 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;很抱歉萌狼很早就提過交換問題的事，被我一直咕咕了許久。 &lt;del&gt;拖延症晚期有藥麼&lt;/del&gt;&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;我的提問和萌狼的回答&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://blog.yoitsu.moe/life/question_exchange_farseerfc.html"&gt;可以去萌狼的博客上看呀&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="q1"&gt;
&lt;h2&gt;Q1：除了博客的「关于」页面以外，还愿意再向咱介绍一下自己嘛？&lt;/h2&gt;
&lt;p&gt;介紹自己啊。 &lt;del&gt;寫了刪刪了寫，不知道該介紹點啥&lt;/del&gt; 就說點自己的興趣？&lt;/p&gt;
&lt;p&gt;喜歡自由開源軟件，喜歡 Arch Linux 。喜歡這些倒不是出於 RMS 和 FSF 那樣道義上的原因，
我覺得商業軟件公司要賺錢吃飯也是無可厚非的。&lt;/p&gt;
&lt;p&gt;喜歡自由軟件是因爲，當我需要知道它到底怎麼工作的時候，有可能去挖代碼，必要的話能去改代碼。
當然我一個人肯定不能讀所有在用的軟件，但是我知道我有讀和修改代碼的權利的話，
那麼我認識的朋友們也同樣有這樣的權利，我不認識的廣大社區有千千萬萬的人也同樣有這樣的權利，
從而我相信當我遇到問題的時候不至於卡在某些人某些公司某些集體的決策上而無法解決。&lt;/p&gt;
&lt;p&gt;基於這個理由，我對開源社區也同樣有公開全部細節的期待。我喜歡 Arch Linux
因爲即便它的內部決策只是一小波人，但是導致決策的討論以及決策的執行方式全是公開的，可以在網上翻閱，
可以追根溯源，這讓我有種安心感。就像我不喜歡 Manjaro 的一點是它有太多細節是翻閱不到的，
雖然它也是開源社區，但是打包細節翻閱不到，包列表翻閱不到，決策的制定和執行的過程也翻閱不到，
通常就只是在他們的論壇上發個通知了事，這我很不喜歡。&lt;/p&gt;
&lt;p&gt;除了喜歡自由開源軟件之外，可能我在網上比較有特點的地方是用繁體字了吧，
也曾經年幼時在水木社區和別人因爲這個吵過嘴，也在
&lt;a class="reference external" href="https://zhuanlan.zhihu.com/p/24586802"&gt;知乎上寫過篇「在知乎用繁體字是怎樣一種體驗」&lt;/a&gt; 。
致力於在我存在的地方爲繁體字愛好者們提供一個安逸的環境，不過好像最近也不見很多反對的聲音了。&lt;/p&gt;
&lt;p&gt;除了網上之外，現實中的自己嘛，特點可能算是不知道自己屬於哪兒了……一個漂泊的人。
小時候8歲前在陝西長大，把自己當作陝西人，但是身邊的鄰里街坊們卻以河南人和江浙人居多。
廠辦環境，好幾個大型重工都從江浙搬到了陝西秦川一帶，加上國共內戰的時候河南黃河缺口造成的難民慌西逃，
構成了當時廠辦的主要人口拿着城市戶口，反而是當地的陝西人都是農民戶口，
於是和廠辦子弟們形成了鮮明的隔閡。我對社會主義，對蘇式廠辦，對整個國家結構的理解大概也是從那兒來的。
跟着鄰里們學會了河南話，在家裏說普通話，從老一輩們身上又學會了江浙的語調。
都說一個廠辦是一個社會的縮影，那時候的環境可能算聚集了全國東南西北的樣子吧。
8、9歲左右隨父母到了上海，因爲不會說上海話受同學們排擠，倒也不是很在意，漸漸和同學們學起了上海話，
可能還參雜點爺爺奶奶的江蘇方言。十多年後考入大學，五湖四海的同學都有，就不算是在上海了。
大學畢業來了日本，一晃又是7年過去。至此我大概比起同齡人接觸到更多全國各地的人，
也分不清自己的歸屬地了。但有一條，我知道自己是個中國人，爲自己是個中國人自豪，覺得雖在他鄉，
該爲中國做點自己的貢獻。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="q2"&gt;
&lt;h2&gt;Q2：现在这个名字是怎么想到的呢？&lt;/h2&gt;
&lt;p&gt;farseerfc 這個名字嘛，來自 firechild 這個更早的網名，和魔獸爭霸裏面 farseer
這個英雄。 farseer 本算是 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Linguistic_purism_in_English"&gt;Anglish&lt;/a&gt;
，以日耳曼語系的構詞法再造的英語詞，對應拉丁構詞法的話 far = tele ， seer = visioner
，於是 farseer 也就是 tele-visioner ，看得遠的人，電視一詞 television 的原本的詞幹的衍生詞。
不過說爲什麼選 farseer 這個名字，更多是爲了符合 fc 這個縮寫，而 fc 來自 firechild 這個詞。
再深挖黑歷史也不再有什麼意義了， farseerfc 作爲網名只是一直以來的習慣吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="q3"&gt;
&lt;h2&gt;Q3：觉得咱俩之间最令汝印象深刻的时候是什么？&lt;/h2&gt;
&lt;p&gt;近期來看，印象最深刻的可能算是起草 &lt;a class="reference external" href="https://fars.ee/~readme.html"&gt;Arch Linux 中文社区交流群指引&lt;/a&gt;
吧，看得出萌狼對社區發展的熱心和好意。&lt;/p&gt;
&lt;p&gt;再往前，印象深刻的時候可能是萌狼用 Pelican 搭博客吧，最初認識萌狼的時候覺得是 MediaWiki
方面的行家，還以爲博客也會繼續用 MediaWiki 打造，沒想到能吃了 Pelican
的安利，外加萌狼寫博文的產量着實讓人望塵莫及。&lt;/p&gt;
&lt;p&gt;然後 ArchWiki 上 Beginner's Guide 被刪除之後，萌狼的博客多了一篇爲新人們寫的入門安裝手冊，
配有完整截圖指引，詳盡程度令人感嘆。感覺得到萌狼作爲一個「過來人」對新人們的照顧。
每次羣中鬧起爭執，老用戶們對新人發起調侃的時候，也是萌狼站出來爲新人們解圍，
幫助有能力的人適應羣裏的討論環境。或許最初寫交流羣指引的時候也是出於這樣的良苦用心吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="q4"&gt;
&lt;h2&gt;Q4：对咱的印象怎么样？&lt;/h2&gt;
&lt;p&gt;最早來 Arch Linux CN 的時候，似乎萌狼還不叫萌狼？不記得那時候用的名字了。只記得來自 AOSC
，和那邊一衆談笑風聲，着實令人羨慕，經常跑他們的聚會也令人羨慕。&lt;/p&gt;
&lt;p&gt;後來有了萌狼的名字，群裏的狼們也漸漸多了起來，一時間都分不清哪個狼是哪個了。
不過萌狼的口癖和說話方式總是在狼羣中非常有標誌性。&lt;/p&gt;
&lt;p&gt;後來似乎發生了好多事情，我不知道的事情，也不敢妄加揣測。萌狼開始變身音遊大佬，
羣裏的別的狼們漸漸也各忙東西。不知道什麼原因，萌狼會偶爾退群，想問下前因後果，
又覺得自己不該多管閒事。不過無論萌狼退羣多少次，總是在默默關心着社區發展，
關心着新人融入社區的環境。&lt;/p&gt;
&lt;p&gt;似乎萌狼加入了 FSF ？玩起了 Parabola ，玩起了 linux-libre 。有能跑起完全自由的發行版的設備，
這一點也非常令人羨慕。似乎有很多設備，但是似乎又很不滿於現狀。看得出萌狼爲了理想放棄了很多東西，
或許大家都是如此吧，也或許只是我多心。&lt;/p&gt;
&lt;p&gt;還有就是萌狼用 Gnome ，感覺 AOSC 那邊很多人都用 Gnome ，給 Gnome 貢獻翻譯之類的，
萌狼或許也是其中一員。DE 黨爭是水羣久勝不衰的話題，或許我也有些責任，但是我覺得以發行版角度而言 DE
多樣性非常重要，萌狼在社區中的作用也不可或缺。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="q5-gnu-linux"&gt;
&lt;h2&gt;Q5：在汝用过的 GNU/Linux 发行版之间汝最喜欢的是哪一个，为啥咧？&lt;/h2&gt;
&lt;p&gt;最喜歡的當然是 Arch Linux 啦，喜歡的理由前面 Q1 算是提到了一些。其實別的發行版的很多特性也很眼饞，
眼饞 Fedora Silverblue 的 A/B 更新機制，眼饞 Fedora 的 SELinux 和諸多企業級特性支援，眼饞
openSUSE 的 OBS 和 btrfs 支持，眼饞 debian 的小巧和細化打包，眼饞 NixOS 的函數式包管理，
眼饞 Gentoo 的可定製性，眼饞 Parabola / GuixSD 的完全自由。&lt;/p&gt;
&lt;p&gt;但是總得來說， Arch Linux 提供的基礎足夠讓我折騰系統成自己喜歡的方式，足夠順手，
也在需要軟件的時候足夠自己打包使用，不需要等待某些遠在天邊的議會做決策，或許是讓我留在
Arch Linux 的原因吧（當然更大原因可能是因爲慣性）。發行版之間的技術區別可能並不那麼重要，
重要的是該幹活的時候能找到幹活的人，這一點 Arch Linux 還是有很多人在認真做事情的。
沒有繁瑣的議會投票表決，沒有細碎的打包步驟，用最快的方式把活幹了，這在我看來是最重要的。&lt;/p&gt;
&lt;p&gt;或許有一天，幹活的人沒了，或者我想要的特殊特性因爲太複雜沒人想帶頭幹，而別的發行版有，
那時可能我會換去別的發行版吧。又或許我會自己幹，誰知道呢。&lt;/p&gt;
&lt;p&gt;比起發行版之爭，甚至比起 Linux/Windows/macOS 的桌面系統地位之爭，可能日後更關鍵的是別的平臺
比如 Android 在手持設備甚至物聯網設備上的興起導致的 PC 桌面的衰落。雖然這些新設備大多都是跑着
Linux 的內核，但是其上的生態環境不能說像 GNU/Linux 那樣自由。這一點上，自由軟件該如何發揮優勢
爭取用戶和生態可能是更關鍵的。&lt;/p&gt;
&lt;p&gt;當然這些都於我而言過於遙遠，一人之力難挽狂瀾……我只希望自己和朋友們所在的自由的土地能保持下去，
或許我也僅能做到這些。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="q6-arch-linux-trusted-users"&gt;
&lt;h2&gt;Q6：在 Arch Linux 做 Trusted Users 时有没有什么心得？&lt;/h2&gt;
&lt;p&gt;說來非常慚愧，做 TU 這麼4年了，實際做的事情着實有限，只能隔幾天打打包而已。要做的事情太多，
而自己上面也說了有幹活的人最重要，設身處地深刻體會到在開源社區的諸位志願者們大家都不容易。&lt;/p&gt;
&lt;p&gt;TU 應該做的事情，細數一下除了給 community 打包之外，還有處理包的 bug ，處理 AUR 的爭議，
測試新包給反饋，以及溝通和反饋上游。反觀自己做的事情，真的太少了。比起肥貓和其他 TU 們的辛勤，
總覺得自己不夠格。「精力有限，憑着志願者熱情」，什麼的說辭可以說很多，
但是良心上對着自己熱愛的事情卻不能百分百撲上去做，真的沒有顏面腆着臉說……&lt;/p&gt;
&lt;p&gt;打包和溝通上游之類的心得倒是有不少，也一直想寫點筆記記錄一下，挖坑卻沒時間填上。該說，
或許應該換個本職工作了，又想，孰重孰輕哪邊是本行需要自己掂量。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="q7"&gt;
&lt;h2&gt;Q7：有什么话要对咱说嘛？&lt;/h2&gt;
&lt;p&gt;不知何時起，不知萌狼經歷了什麼，有時候感覺萌狼傲嬌的性格讓人看不透，不過事後能看出萌狼都是本着好心。
或許，如果能更坦誠一些的話，也能更融入大家吧。雖然我也沒資格這麼說。&lt;/p&gt;
&lt;p&gt;像前面寫的，隱約能感覺到萌狼似乎爲了理想放棄了很多，孰重孰輕是每個人自己的權衡。&lt;/p&gt;
&lt;p&gt;以及還有感謝，感謝萌狼把我當作朋友，感謝萌狼的耐心。&lt;/p&gt;
&lt;p&gt;最後還有抱歉，這篇拖了太久，是該治治我的拖延症了。&lt;/p&gt;
&lt;/div&gt;
</content><category term="life"></category><category term="friend"></category><category term="horo"></category></entry><entry><title>東方歌詞翻譯遷移至 sak.uy</title><link href="//farseerfc.me/move-lyrics-to-sakuy.html" rel="alternate"></link><published>2019-02-24T08:37:00+09:00</published><updated>2019-02-24T08:37:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2019-02-24:/move-lyrics-to-sakuy.html</id><summary type="html">&lt;p&gt;最近幾個月在這個博客發了不少歌詞翻譯 &lt;del&gt;似乎有要轉型成音樂博主的趨勢&lt;/del&gt; ，前段時間買了個新域名
&lt;a class="reference external" href="https://sak.uy/"&gt;sak.uy&lt;/a&gt; ，準備專門用來放這些東方歌曲的歌詞翻譯，於是分設了單獨的博客「
&lt;a class="reference external" href="https://sak.uy/"&gt;Sakuya的音樂盒&lt;/a&gt; 」。主博客這邊右側邊欄會有到音樂盒的鏈接。&lt;/p&gt;
&lt;p&gt;曾經在這邊的那些歌儘量保持 URL 跳轉過去，新的歌詞翻譯會發到那邊去，還想繼續聽歌的話請繼續訂閱那邊的 RSS 呀。&lt;/p&gt;
&lt;p&gt;主博客這邊還是像往常一樣保持記錄生活點滴和技術經驗好了。說道介紹技術，
有人問過我那些日語歌詞上給漢字標註的假名都是我一個個手輸的麼？
一開始是手輸的，後來發現了不錯的自動化方案，於是這裏介紹一下。&lt;/p&gt;
&lt;div class="section" id="python-furigana"&gt;
&lt;h2&gt;首先是　python-furigana&lt;/h2&gt;
&lt;p&gt;這是個 python 寫的小程序（嚴格說是庫），可以把一段日文轉換成標準的 HTML 形式的
&lt;code class="code"&gt;
&amp;lt;ruby&amp;gt;&lt;/code&gt;
 標籤的振假名( &lt;ruby&gt;&lt;rb&gt;振&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;ふ&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; り &lt;ruby&gt;&lt;rb&gt;仮名&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;かな&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; )。
它本身只是個方便的格式化庫，實際工作是用 python-mecab 這個 binding 去查詢 mecab
這個著名的日語語料分析庫。要用它還得配合一些開源的 mecab 詞典，這些在 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;最近幾個月在這個博客發了不少歌詞翻譯 &lt;del&gt;似乎有要轉型成音樂博主的趨勢&lt;/del&gt; ，前段時間買了個新域名
&lt;a class="reference external" href="https://sak.uy/"&gt;sak.uy&lt;/a&gt; ，準備專門用來放這些東方歌曲的歌詞翻譯，於是分設了單獨的博客「
&lt;a class="reference external" href="https://sak.uy/"&gt;Sakuya的音樂盒&lt;/a&gt; 」。主博客這邊右側邊欄會有到音樂盒的鏈接。&lt;/p&gt;
&lt;p&gt;曾經在這邊的那些歌儘量保持 URL 跳轉過去，新的歌詞翻譯會發到那邊去，還想繼續聽歌的話請繼續訂閱那邊的 RSS 呀。&lt;/p&gt;
&lt;p&gt;主博客這邊還是像往常一樣保持記錄生活點滴和技術經驗好了。說道介紹技術，
有人問過我那些日語歌詞上給漢字標註的假名都是我一個個手輸的麼？
一開始是手輸的，後來發現了不錯的自動化方案，於是這裏介紹一下。&lt;/p&gt;
&lt;div class="section" id="python-furigana"&gt;
&lt;h2&gt;首先是　python-furigana&lt;/h2&gt;
&lt;p&gt;這是個 python 寫的小程序（嚴格說是庫），可以把一段日文轉換成標準的 HTML 形式的
&lt;code class="code"&gt;
&amp;lt;ruby&amp;gt;&lt;/code&gt;
 標籤的振假名( &lt;ruby&gt;&lt;rb&gt;振&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;ふ&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; り &lt;ruby&gt;&lt;rb&gt;仮名&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;かな&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; )。
它本身只是個方便的格式化庫，實際工作是用 python-mecab 這個 binding 去查詢 mecab
這個著名的日語語料分析庫。要用它還得配合一些開源的 mecab 詞典，這些在 &lt;code class="code"&gt;
[archlinuxcn]&lt;/code&gt;

都有打好的包了，直接安裝：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo pacman -Syu python-furigana mecab-git python-mecab mecab-ipadic&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;裝好之後用法也很直接，甚至沒有 binary 直接調用 python 的 module 就可以：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; python -m furigana.furigana &lt;span class="s2"&gt;"振り仮名の例"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;&amp;lt;ruby&amp;gt;&amp;lt;rb&amp;gt;振&amp;lt;/rb&amp;gt;&amp;lt;rt&amp;gt;ふ&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt;り&amp;lt;ruby&amp;gt;&amp;lt;rb&amp;gt;仮名&amp;lt;/rb&amp;gt;&amp;lt;rt&amp;gt;かめい&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt;の&amp;lt;ruby&amp;gt;&amp;lt;rb&amp;gt;例&amp;lt;/rb&amp;gt;&amp;lt;rt&amp;gt;れい&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是提供日語作爲輸入，然後輸出 HTML 形式的 &lt;code class="code"&gt;
&amp;lt;ruby&amp;gt;&lt;/code&gt;
 標籤而已。
像上面的例子中出現的錯誤（「振り仮名」完整的一個詞中「仮名」意思是「平仮名」應該發音「がな」而非意爲「假的人名」的「かめい」）
可以看出其實標註的準確率還是有些問題的。嘛日語作爲一個非常依賴上下文判斷的語言，
經常日本人都會搞錯某些漢字的發音，這些也不能強求機械化的算法能 100% 正確實現。
好在單純的詞典匹配也能滿足大部分標註的需要了，用這個標註總體來說 95%
以上的情況都是正確的（歌詞的話正確率低一些，畢竟歌詞中古語啦当て字啦訓読み這些情況很常見）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;把輸出插入我的博客&lt;/h2&gt;
&lt;p&gt;然後我的博客用 reStructuredText 語法寫，不能直接用 HTML 標籤（雖然我加了 &lt;code class="code"&gt;
:html:&lt;/code&gt;

這個 &lt;ruby&gt;&lt;rb&gt;行內角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;inline role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 但是大量用也不方便）。這個博客一開始用
&lt;a class="reference external" href="//farseerfc.me/redesign-pelican-theme.html#bootstrapify-twitter-bootstrap-rst-directives"&gt;Pelican 重寫主題的時候&lt;/a&gt;
我就實現了個自己的 &lt;code class="code"&gt;
:ruby:&lt;/code&gt;
&lt;ruby&gt;&lt;rb&gt;行內角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;inline role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 用來標發音，於是一段
sed 就能把 python-furigana 的輸出轉換成我用的 rst 語法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; which clipboard Co Ci Ct&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;clipboard: aliased to xclip -selection clipboard&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;Co: aliased to clipboard -o&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;Ci: aliased to clipboard -i&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;Ct () {&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;    t=$(mktemp /tmp/furigana-XXXX)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;    python -m furigana.furigana $(Co) | sed 's@&amp;lt;ruby&amp;gt;&amp;lt;rb&amp;gt;@ :ruby:`@g;s@&amp;lt;/rb&amp;gt;&amp;lt;rt&amp;gt;@|@g;s@&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt;@` @g' | sponge $t&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;    cat $t | tee /dev/tty | perl -pe 'chomp if eof' | Ci&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面這些 alias 在我的 &lt;a class="reference external" href="https://git.io/fczsh"&gt;.bashrc&lt;/a&gt; 中。有了這些之後，
我只要把需要標註的日語文本放入剪切版，執行 Ct ，再粘帖結果就好了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"振り仮名の例"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; Ci&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; Ct&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;:ruby:`振|ふ` り :ruby:`仮名|かめい` の :ruby:`例|れい`&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後所有那些歌詞上標註的假名都是這樣一句一句標註好之後，再手動校對修改的。&lt;/p&gt;
&lt;/div&gt;
</content><category term="life"></category><category term="life"></category></entry><entry><title>用 usbip 轉發 raspberry pi 的 USB 鍵盤鼠標給 Arch Linux 的 PC</title><link href="//farseerfc.me/usbip-forward-raspberrypi.html" rel="alternate"></link><published>2019-02-07T02:14:00+09:00</published><updated>2019-02-07T02:14:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2019-02-07:/usbip-forward-raspberrypi.html</id><summary type="html">&lt;p&gt;惠狐 &lt;a class="reference external" href="/links.html#megumifox"&gt;megumifox&lt;/a&gt; 寫了篇 &lt;a class="reference external" href="https://blog.megumifox.com/public/2019/02/06/%E7%94%A8pulseaudio%E5%B0%86%E7%94%B5%E8%84%91%E7%9A%84%E5%A3%B0%E9%9F%B3%E7%94%A8%E6%89%8B%E6%9C%BA%E6%94%BE%E5%87%BA%E6%9D%A5/"&gt;用PulseAudio將電腦的聲音用手機放出來&lt;/a&gt;
，文末提到想知道我怎麼用樹莓派轉發 USB 的，於是寫篇文章記錄一下。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;起因&lt;/h2&gt;
&lt;p&gt;家裏有個裝了 Arch Linux ARM 的樹莓派3B 閒置着，裝了 Arch Linux ARM 偶爾上電更新一下，
不過因爲性能實在不適合做別的事情於是一直在吃灰。某日 &lt;del&gt;給老婆安利幻想萬華鏡&lt;/del&gt;&lt;ins&gt;和老婆看片&lt;/ins&gt;
的時候， &lt;del&gt;老婆不吃安利於是遷怒鍵盤鼠標&lt;/del&gt;&lt;ins&gt;鍵盤鼠標被長長的 USB 線扯着感覺很難受&lt;/ins&gt;
，於是偶發奇想，能不能利用一下樹莓派的多達 4 個 USB 2.0 端口接鼠標鍵盤呢，
這樣鼠標鍵盤就可以跟着樹莓派來回走，不用拖着長長的 USB 線了。&lt;/p&gt;
&lt;p&gt;上網搜了一下， Linux 環境有個 usbip 工具正好能做到這個。原理也很直觀， usbip 能把 USB …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;惠狐 &lt;a class="reference external" href="/links.html#megumifox"&gt;megumifox&lt;/a&gt; 寫了篇 &lt;a class="reference external" href="https://blog.megumifox.com/public/2019/02/06/%E7%94%A8pulseaudio%E5%B0%86%E7%94%B5%E8%84%91%E7%9A%84%E5%A3%B0%E9%9F%B3%E7%94%A8%E6%89%8B%E6%9C%BA%E6%94%BE%E5%87%BA%E6%9D%A5/"&gt;用PulseAudio將電腦的聲音用手機放出來&lt;/a&gt;
，文末提到想知道我怎麼用樹莓派轉發 USB 的，於是寫篇文章記錄一下。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;起因&lt;/h2&gt;
&lt;p&gt;家裏有個裝了 Arch Linux ARM 的樹莓派3B 閒置着，裝了 Arch Linux ARM 偶爾上電更新一下，
不過因爲性能實在不適合做別的事情於是一直在吃灰。某日 &lt;del&gt;給老婆安利幻想萬華鏡&lt;/del&gt;&lt;ins&gt;和老婆看片&lt;/ins&gt;
的時候， &lt;del&gt;老婆不吃安利於是遷怒鍵盤鼠標&lt;/del&gt;&lt;ins&gt;鍵盤鼠標被長長的 USB 線扯着感覺很難受&lt;/ins&gt;
，於是偶發奇想，能不能利用一下樹莓派的多達 4 個 USB 2.0 端口接鼠標鍵盤呢，
這樣鼠標鍵盤就可以跟着樹莓派來回走，不用拖着長長的 USB 線了。&lt;/p&gt;
&lt;p&gt;上網搜了一下， Linux 環境有個 usbip 工具正好能做到這個。原理也很直觀， usbip 能把 USB
端口上的數據封裝成 IP 協議通過網絡轉發出去，從而兩個網絡間相互聯通的電腦就可以遠程轉發 USB 了。
設置好的話，就像是一臺 PC 多了幾個位於樹莓派上的 USB 端口，插上樹莓派的 USB 設備統統作爲 PC
的設備。&lt;/p&gt;
&lt;p&gt;這篇文章假設有一個裝了 Arch Linux 的 PC ，和一個裝了 Arch Linux ARM 的樹莓派，
並且兩者間能通過網絡互相訪問到。別的發行版上大概也可以這麼做，只是我沒有試過。 usbip
工具似乎普遍被發行版打包了，除此之外需要的也只是 Linux 內核提供好的功能而已。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="arch-linux-arm"&gt;
&lt;h2&gt;設置 Arch Linux ARM 的樹莓派端&lt;/h2&gt;
&lt;p&gt;假設樹莓派上面網絡已經設置妥當，開機插電就能自動聯網。接下來安裝 usbip 工具：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo pacman -Syu usbip&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後需要記錄一下樹莓派的 IP 地址：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ip addr&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;3: wlan0: ......&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;inet 192.168.0.117/24 brd 192.168.0.255 scope global noprefixroute wlan0&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;......&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下來給 udev 添加一個規則，當插入 usb 設備的時候，執行我的腳本 usbipall.sh
把 usb 設備通過 usbip 共享出去：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; cat /etc/udev/rules.d/usbipall.rules&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;ACTION=="add", SUBSYSTEM=="usb", RUN+="/usr/bin/bash /usr/local/bin/usbipall.sh"&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;這個 rules 文件 &lt;a class="reference external" href="https://github.com/farseerfc/dotfiles/blob/master/usbiprpi/usbipall.rules"&gt;可以在我的 dotfiles 裏面找到&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;然後規則調用的 usbipall.sh 我這麼寫的， &lt;a class="reference external" href="https://github.com/farseerfc/dotfiles/blob/master/usbiprpi/usbipall.sh"&gt;文件同樣在我的 dotfiles 裏面&lt;/a&gt; ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nv"&gt;allusb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;usbip list -p -l&lt;span class="k"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;for&lt;/span&gt; usb in &lt;span class="nv"&gt;$allusb&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="nv"&gt;busid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$usb&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sed &lt;span class="s2"&gt;"s|#.*||g;s|busid=||g"&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"1-1.1"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;then&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="c1"&gt;# ignoring usb ethernet&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;continue&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;fi&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;date -Iseconds&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;: Exporting &lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    usbip &lt;span class="nb"&gt;bind&lt;/span&gt; --busid&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;done&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;)&lt;/span&gt; &amp;gt;&amp;gt;/var/log/usbipall.log &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;這個腳本做了這樣幾件事。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;調用 &lt;code class="code"&gt;
usbip list --local&lt;/code&gt;
 列出本地所有 usb 設備。&lt;/li&gt;
&lt;li&gt;針對每個設備&lt;ol class="arabic"&gt;
&lt;li&gt;取出它的 busid&lt;/li&gt;
&lt;li&gt;判斷是不是樹莓派的 USB 以太網卡，不是的話繼續&lt;/li&gt;
&lt;li&gt;通過 &lt;code class="code"&gt;
usbip bind --busid=&lt;/code&gt;
 命令把這個 usb 設備導出到網上&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最後把所有輸出記錄到 /var/log/usbipall.log 日誌裏面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;樹莓派這邊設置就完成了。從此之後插入的 usb 設備就會統統導出出去。&lt;/p&gt;
&lt;p&gt;這裏需要注意一下，啓用了 udev 規則之後，就沒法插鍵盤鼠標到樹莓派上控制它了……我都是從另一端 ssh
上樹莓派操作的。如果有什麼地方設置錯誤，可能需要把樹莓派的 SD 卡拔下來插到電腦上，刪除掉 rules
文件……&lt;/p&gt;
&lt;p&gt;仔細檢查設置正確了之後，重新載入 udev 規則，或者重啓樹莓派：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;#&lt;/span&gt; systemctl restart systemd-udevd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;這樣樹莓派這邊就設置好了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="arch-linux-pc"&gt;
&lt;h2&gt;設置 Arch Linux 的 PC 端&lt;/h2&gt;
&lt;p&gt;同樣假設 PC 這邊也已經聯網。接下來同樣安裝 usbip 工具：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo pacman -Syu usbip&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後我寫了個小腳本去鏈接樹莓派端， &lt;a class="reference external" href="https://github.com/farseerfc/dotfiles/blob/master/usbiprpi/usbiprpi3.sh"&gt;這個文件 usbiprpi3.sh 也在我的 dotfiles&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nv"&gt;rpi3&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"192.168.0.117"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;modprobe vhci-hcd&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nv"&gt;allusb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;usbip list -p -r &lt;span class="nv"&gt;$rpi3&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; cut -d&lt;span class="s2"&gt;":"&lt;/span&gt; -f1 -s &lt;span class="p"&gt;|&lt;/span&gt; sed &lt;span class="s1"&gt;'s|^[ \t]*||;/^$/d'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;for&lt;/span&gt; busid in &lt;span class="nv"&gt;$allusb&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"1-1.1"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;then&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="c1"&gt;# ignoring usb ethernet&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;continue&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;fi&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Attaching &lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    usbip attach --remote&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$rpi3&lt;/span&gt; --busid&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$busid&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;done&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中腳本第一行填入上面記錄下來的樹莓派的 IP 地址，接下來腳本做了這麼幾件事：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;用 modprobe 確認加載 vhci-hcd 通用虛擬鍵鼠驅動&lt;/li&gt;
&lt;li&gt;用 &lt;code class="code"&gt;
usbip list --remote=&lt;/code&gt;
 列出遠程設備上已經導出了的 USB 設備，取出他們的 busid&lt;/li&gt;
&lt;li&gt;對每個設備用 &lt;code class="code"&gt;
usbip attach&lt;/code&gt;
 接上該設備&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然後就已經準備妥當，接下來是見證奇蹟的時刻：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sleep &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; sudo ./usbiprpi3.sh&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;Attaching 1-1.4.3&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;Attaching 1-1.4.1&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因爲只有一套鍵盤鼠標，所以先 sleep 個 10 秒，在此期間快速把鍵鼠拔下來插到樹莓派的 USB 口上去。
如果對自己手速沒自信也可以把時間設長一點。然後用 root 權限執行 usbiprpi3.sh 。&lt;/p&gt;
&lt;p&gt;一切正常的話，先能觀測插上樹莓派的鍵盤鼠標被樹莓派初始化了一下，比如鍵盤燈會亮，
然後這些設備會被導出出去，從而鍵盤燈滅掉，然後 10 秒等待結束後他們被遠程接到了 PC 端，
又會被初始化一下，同時 PC 端這邊會有上述 Attaching 的輸出。然後鍵盤鼠標就能像平常一樣用啦。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;使用體驗&lt;/h2&gt;
&lt;p&gt;因爲就是通過 IP 轉發 USB 嘛，所以就和普通地接 USB 的體驗差不多，當然前提是網絡環境足夠穩定。
在我家間隔 5 米到無線路由器的環境下，基本感覺不到網絡延遲的影響。
通過這種方式聊天上網應該和直接接 USB 設備完全一樣。本文就是在通過樹莓派轉發的前提下用鍵盤打字寫的。&lt;/p&gt;
&lt;p&gt;不過如果網絡負載本身就很大的話，可能會一些延遲，比如我開着 OBS 直播打東方的時候，原本就手殘
的我感覺更加手殘了……&lt;/p&gt;
&lt;p&gt;試過拿着樹莓派在房間到處走，走到無線信號覆蓋不到的地方， usbip 會斷掉，PC 上的現象就像是 USB
設備被拔下來了……所以如果無線網絡不穩的話，可能需要對上面腳本做個循環？不過那樣可能會用起來很彆扭吧。&lt;/p&gt;
&lt;p&gt;以及，上述操作 usbip 是走 TCP 3240 端口，數據包大概完全沒有加密，所以考慮安全性的話，
最好還是在內網環境使用。不過轉念一想，萬一有別人接上了我導出出去的 USB ，也就是截獲我的鍵盤，
PC 這邊沒法 attach 設備了，應該馬上會發現吧。我敲打 sudo 之類命令的時候 shell 裏面沒有回顯，
就不會再繼續敲密碼了。而且似乎對攻擊者也沒有什麼好處？要是他 usb attach 到了我的設備上，
我就能控制他的鍵盤了耶~&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="linux"></category><category term="archlinux"></category><category term="raspberrypi"></category><category term="usbip"></category><category term="usb"></category><category term="forward"></category></entry><entry><title>【聽譯】君さえいなけりゃよかった</title><link href="//farseerfc.me/kimisaeinakerya.html" rel="alternate"></link><published>2018-12-23T23:04:00+09:00</published><updated>2018-12-23T23:04:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2018-12-23:/kimisaeinakerya.html</id><summary type="html">&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/-KOeQapXsx8"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君さえいなけりゃよかった&lt;/td&gt;
&lt;td&gt;如果你從未出現過該多好&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;降り出した雨の中で　君に出会った時から&lt;/td&gt;
&lt;td&gt;下起雨的那一刻　從遇到你那時起&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君がいないということが　当たり前じゃなくなった&lt;/td&gt;
&lt;td&gt;身邊沒有你的情況　就已經不再是平常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ああ　こんなはずじゃない&lt;/td&gt;
&lt;td&gt;啊　不應該是這樣的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ずっと自分勝手にさ　過ごせたはずなのに&lt;/td&gt;
&lt;td&gt;明明一直是散漫地過着自己的日子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;まるで僕じゃないような僕が　さらけ出されてくよ&lt;/td&gt;
&lt;td&gt;就像是帶出了不是我的另一面的我&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr class="docutils"/&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君さえいなけりゃよかった　こんな気持ちは知らないから&lt;/td&gt;
&lt;td&gt;如果你從未出現過該多好　就不會知道這種心情&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;やらなくちゃいけないことが　手つかずのまま積もってく&lt;/td&gt;
&lt;td&gt;一堆不得不做的事情　堆在手頭越積越多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;僕じゃなくてもいいのなら　こっちを見て笑わないでよ&lt;/td&gt;
&lt;td&gt;如果不是我也可以的話　就別看着我這邊笑啊&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;大袈裟じゃなくてそれだけで　忘れられなくなるの&lt;/td&gt;
&lt;td&gt;甚至那些不重要的事情　都變得難以忘記了&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr class="docutils"/&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君の適当な話も　全部心に刺さります&lt;/td&gt;
&lt;td&gt;你無意間隨口說的話　全都刺在心頭&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;気にしなけりゃいいのにな　残らずかき集めちゃうの&lt;/td&gt;
&lt;td&gt;雖說只要不在意就可以了　卻一句不剩全收集了起來&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ああ　こんなはずじゃない　こんなはずじゃない&lt;/td&gt;
&lt;td&gt;啊　不應該是這樣的　不應該是這樣的 …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</summary><content type="html">&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt;&lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/-KOeQapXsx8"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君さえいなけりゃよかった&lt;/td&gt;
&lt;td&gt;如果你從未出現過該多好&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;降り出した雨の中で　君に出会った時から&lt;/td&gt;
&lt;td&gt;下起雨的那一刻　從遇到你那時起&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君がいないということが　当たり前じゃなくなった&lt;/td&gt;
&lt;td&gt;身邊沒有你的情況　就已經不再是平常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ああ　こんなはずじゃない&lt;/td&gt;
&lt;td&gt;啊　不應該是這樣的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ずっと自分勝手にさ　過ごせたはずなのに&lt;/td&gt;
&lt;td&gt;明明一直是散漫地過着自己的日子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;まるで僕じゃないような僕が　さらけ出されてくよ&lt;/td&gt;
&lt;td&gt;就像是帶出了不是我的另一面的我&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr class="docutils"/&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君さえいなけりゃよかった　こんな気持ちは知らないから&lt;/td&gt;
&lt;td&gt;如果你從未出現過該多好　就不會知道這種心情&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;やらなくちゃいけないことが　手つかずのまま積もってく&lt;/td&gt;
&lt;td&gt;一堆不得不做的事情　堆在手頭越積越多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;僕じゃなくてもいいのなら　こっちを見て笑わないでよ&lt;/td&gt;
&lt;td&gt;如果不是我也可以的話　就別看着我這邊笑啊&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;大袈裟じゃなくてそれだけで　忘れられなくなるの&lt;/td&gt;
&lt;td&gt;甚至那些不重要的事情　都變得難以忘記了&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr class="docutils"/&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君の適当な話も　全部心に刺さります&lt;/td&gt;
&lt;td&gt;你無意間隨口說的話　全都刺在心頭&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;気にしなけりゃいいのにな　残らずかき集めちゃうの&lt;/td&gt;
&lt;td&gt;雖說只要不在意就可以了　卻一句不剩全收集了起來&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ああ　こんなはずじゃない　こんなはずじゃない&lt;/td&gt;
&lt;td&gt;啊　不應該是這樣的　不應該是這樣的&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr class="docutils"/&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君に出会わなきゃよかった　こんなに寂しくなるのなら&lt;/td&gt;
&lt;td&gt;如果沒遇到過你該多好　就不會變得如此寂寞&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君じゃなくてもいいことが　もう見つからないの&lt;/td&gt;
&lt;td&gt;已經找不到　和你無關也可以的情況了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;忘れられないから　君じゃなかったら&lt;/td&gt;
&lt;td&gt;無法忘記了　要不是你的話&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr class="docutils"/&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;いっそ見損なってしまうような　そんなひとだったらなあ&lt;/td&gt;
&lt;td&gt;乾脆變成根本看不起的人　如果是那種人的話&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;でもそれでも　どうせ無理そう　嫌いになれないや&lt;/td&gt;
&lt;td&gt;但是即使如此　大概反正也不可能　無法變得討厭&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr class="docutils"/&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;僕がいなくてもいいなら　いっそ不幸になってしまえ&lt;/td&gt;
&lt;td&gt;如果不是我也可以的話　乾脆變得不幸吧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;最後にまた僕の元に　泣きついてくればいい&lt;/td&gt;
&lt;td&gt;最後還是會回到我身邊　哭着湊過來的話就可以&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君さえいなけりゃよかった　こんな気持ちは知らないから&lt;/td&gt;
&lt;td&gt;如果沒有你該多好　就不會知道這種心情&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;やらなくちゃいけないことが　手つかずのまま積もってく&lt;/td&gt;
&lt;td&gt;一堆不得不做的事情　堆在手頭越積越多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;僕じゃなくてもいいのなら　こっちを見て笑わないでよ&lt;/td&gt;
&lt;td&gt;如果不是我也可以的話　就別看着我這邊笑啊&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;大袈裟じゃなくてそれだけで&lt;/td&gt;
&lt;td&gt;甚至那些不重要的事情&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君のこと　間違いなく&lt;/td&gt;
&lt;td&gt;對你　毫無疑問&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;苦しいほど　好きになっちゃうよ&lt;/td&gt;
&lt;td&gt;刻骨銘心地　變得喜歡上了啊&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr class="docutils"/&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;忘れられないから　君じゃなかったら&lt;/td&gt;
&lt;td&gt;因爲無法忘記　如果不是你的話&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君に出会わなきゃ　僕じゃなかったら&lt;/td&gt;
&lt;td&gt;要是沒遇到過你　如果不是我的話&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;君さえいなけりゃよかった&lt;/td&gt;
&lt;td&gt;如果你從未出現過該多好&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content><category term="life"></category><category term="translate"></category><category term="chouyaku"></category><category term="kimi"></category><category term="sae"></category><category term="inakerya"></category><category term="聽譯"></category></entry><entry><title>【譯】使用 GNU stow 管理你的點文件</title><link href="//farseerfc.me/using-gnu-stow-to-manage-your-dotfiles.html" rel="alternate"></link><published>2018-12-08T03:35:00+09:00</published><updated>2018-12-08T03:35:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2018-12-08:/using-gnu-stow-to-manage-your-dotfiles.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;譯註&lt;/h2&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;這篇是翻譯自 &lt;a class="reference external" href="http://brandon.invergo.net/news/2012-05-26-using-gnu-stow-to-manage-your-dotfiles.html"&gt;Brandon Invergo 的博客的英文文章 Using GNU Stow to manage your dotfiles&lt;/a&gt; 。
Brandon Invergo 的博客採用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"&gt;CC-BY-SA 3.0&lt;/a&gt;
授權，因此本文也同樣採用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"&gt;CC-BY-SA 3.0&lt;/a&gt;
，不同於其它我寫的文章是 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;CC-BY-NC-SA 4.0&lt;/a&gt;
授權。&lt;/p&gt;
&lt;p&gt;我自己已經使用此文中介紹的方案管理 &lt;a class="reference external" href="https://git.io/fcdots"&gt;我自己的 dotfiles&lt;/a&gt;
快 3 年了。最早想採用這樣的管理方案是爲了方便在多臺 Arch Linux 系統之間同步配置，
後來逐漸主力系統也更新換代了一次，又同步到了自己的 vps 上去，目前管理多個 Arch Linux
上都多少都有這套配置。甚至裝好 Arch Linux 添加好用戶最初做的事情就是安裝 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;譯註&lt;/h2&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;這篇是翻譯自 &lt;a class="reference external" href="http://brandon.invergo.net/news/2012-05-26-using-gnu-stow-to-manage-your-dotfiles.html"&gt;Brandon Invergo 的博客的英文文章 Using GNU Stow to manage your dotfiles&lt;/a&gt; 。
Brandon Invergo 的博客採用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"&gt;CC-BY-SA 3.0&lt;/a&gt;
授權，因此本文也同樣採用 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"&gt;CC-BY-SA 3.0&lt;/a&gt;
，不同於其它我寫的文章是 &lt;a class="reference external" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;CC-BY-NC-SA 4.0&lt;/a&gt;
授權。&lt;/p&gt;
&lt;p&gt;我自己已經使用此文中介紹的方案管理 &lt;a class="reference external" href="https://git.io/fcdots"&gt;我自己的 dotfiles&lt;/a&gt;
快 3 年了。最早想採用這樣的管理方案是爲了方便在多臺 Arch Linux 系統之間同步配置，
後來逐漸主力系統也更新換代了一次，又同步到了自己的 vps 上去，目前管理多個 Arch Linux
上都多少都有這套配置。甚至裝好 Arch Linux 添加好用戶最初做的事情就是安裝 stow git
然後 clone 了我自己的 dotfiles repo 下來，然後按需取想要的配置，快捷方便有效。&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;p&gt;廢話不多說，下面是原文和翻譯。與之前的翻譯一樣，正文部分給出原文引用以便對照參考。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;使用 GNU stow 管理你的點文件&lt;/h2&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;我昨天偶然間發現一些我覺得值得分享的經驗，就是那種「爲毛我沒有早點知道這個？」那一類的。
我將在這篇文章中介紹如何使用 GNU Stow 管理你的 GNU/Linux 系統中位於用戶家目錄裏的各種配置文件
（通常又叫「點文件(dotfiles)」比如 .bashrc）。&lt;/td&gt;
&lt;td&gt;I accidentally stumbled upon something yesterday that I felt like sharing,
which fell squarely into the "why the hell didn't I know about this before?"
category. In this post, I'll describe how to manage the various
configuration files in your GNU/Linux home directory
(aka "dotfiles" like .bashrc) using GNU Stow.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;這件事的困難之處在於，如果能用版本管理系統(VCS, Version Control System)比如
Git, Mercurial(hg), Bazaar(bzr)
管理點文件的話會非常方便，但是這些點文件大部分都位於家目錄的頂級目錄下，
在這個位置不太適合初始化一個版本管理倉庫。這些年下來我試過很多程序，設計目的在於解決這個問題，
幫你把這些配置文件安置在某個下級目錄中，然後安裝或者鏈接這些文件到它們應該在的位置。
嘗試下來這些程序沒有一個真正能打動我。它們要麼有很多依賴（比如 Ruby 和一大坨庫），
要麼需要我記住如何用它，考慮到同步配置這種不算經常使用的場合，要記住用法真的挺難。&lt;/td&gt;
&lt;td&gt;The difficulty is that it would be helpful to manage one's configuration
files with a version control system like Git, Mercurial or Bazaar, but
many/most dotfiles reside at the top-level of your home directory,
where it wouldn't be a good idea to initialize a VCS repository.
Over time I've come across various programs which aim to manage this
for you by keeping all the files in a subdirectory and then installing or
linking them into their appropriate places. None of those programs ever
really appealed to me. They would require a ton of dependencies
(like Ruby and a ton of libraries for it) or they would require me to
remember how to use them, which is difficult when really for such a task
you rarely use the program.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;最近我在用 GNU Stow 來管理我從源代碼在本地編譯安裝到 &lt;code class="code"&gt;
/​usr/​local/​&lt;/code&gt;
 中的一些程序。
基本上說，在這種常見用法下，是你把這些本地編譯的包配置安裝到
&lt;code class="code"&gt;
/​usr/​local/​stow/​${PKGNAME}-{PKGVERSION}&lt;/code&gt;
 這樣的位置，然後在
&lt;code class="code"&gt;
/​usr/​local/​stow/​&lt;/code&gt;
 目錄中執行 &lt;code class="code"&gt;
# stow ${PKGNAME}-${PKGVERSION}&lt;/code&gt;

，然後它就會爲程序所有的文件創建符號鏈接放在 &lt;code class="code"&gt;
/​usr/​local&lt;/code&gt;

中合適的地方。然後當你想用 Stow 卸載這個程序的時候，就不必再考慮會留下什麼垃圾文件，
或者找不到安裝時用的 Makefile 了。這種安裝方式下也可以非常容易地切換一個程序的不同版本
（比如我想嘗試不同配置選項下的 &lt;a class="reference external" href="https://dwm.suckless.org/"&gt;dwm&lt;/a&gt; 或者
&lt;a class="reference external" href="https://st.suckless.org/"&gt;st&lt;/a&gt; 的時候）。&lt;/td&gt;
&lt;td&gt;Lately I've been using GNU Stow to manage programs I install from source to
/usr/local/. Basically, in this typical usage, you install locally built
packages to /usr/local/stow/${PKGNAME}-{PKGVERSION} and then
from /usr/local/stow/ you run # stow ${PKGNAME}-${PKGVERSION} and the
program generates symbolic links to all the programs' files into the
appropriate places under /usr/local/. Then, when you uninstall a program
via Stow, you don't have to worry about any stray files that you or a
provide Makefile may have missed. It also makes handling alternate versions
of a program quite easy (i.e. when I'm experimenting with different
configurations of dwm or st).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;前段時間在我掃郵件列表的時候，看到某個帖子中某人在說使用 Stow 管理安裝他的點文件。
當時我沒特別在意這個帖子，但是大概我大腦潛意識把它歸檔保存爲今後閱讀了。
昨天我想起來試試這種用法，試過後我不得不說，這比那些專門設計用來做這任務的點文件管理器要方便太多了，
雖然表面上看起來這種用法沒那麼顯而易見。&lt;/td&gt;
&lt;td&gt;Some time ago I happened across a mailing list posting where someone
described using Stow to manage the installation of their dotfiles.
I didn't pay much attention to it but my brain must have filed it away
for later. Yesterday I decided to give it a try and I have to say that
it is so much more convenient than those other dedicated dotfile-management
programs, even if it wasn't an immediately obvious option.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;方法很簡單。我建了個 &lt;code class="code"&gt;
${HOME}/​dotfiles&lt;/code&gt;
 文件夾，然後在裏面爲我想管理的每個程序配置都
創建一個子文件夾。然後我把這些程序的配置從原本的家目錄移動到這每一個對應的子文件夾中，
並保持它們在家目錄中的文件夾結構。比如，如果某個文件原本應該位於家目錄的頂層文件夾裏，
那它現在應該放在這個程序名子目錄的頂層文件夾。如果某個配置文件通常應該位於默認的
&lt;code class="code"&gt;
${XDG_CONFIG_HOME}/​${PKGNAME}&lt;/code&gt;
 位置 (&lt;code class="code"&gt;
${HOME}/​.config/​${PKGNAME}&lt;/code&gt;
)，
那麼現在它應該放在 &lt;code class="code"&gt;
${HOME}/​dotfiles/​${PKGNAME}/​.config/​${PKGNAME}&lt;/code&gt;

，如此類推。然後在那個 dotfiles 文件夾裏面，直接運行 &lt;code class="code"&gt;
$ stow $PKGNAME&lt;/code&gt;
 命令，
Stow 就會爲你自動創建這些配置文件的符號鏈接到合適的位置。接下來就很容易爲這個 dotfiles
目錄初始化版本管理倉庫，從而記錄你對這些配置文件做的修改（並且這也可以極度簡化在不同電腦之間
共享配置，這也是我想要這麼做的主要原因）。&lt;/td&gt;
&lt;td&gt;The procedure is simple. I created the ${HOME}/dotfiles directory and then
inside it I made subdirectories for all the programs whose cofigurations
I wanted to manage. Inside each of those directories, I moved in all the
appropriate files, maintaining the directory structure of my home directory.
So, if a file normally resides at the top level of your home directory,
it would go into the top level of the program's subdirectory.
If a file normally goes in the default ${XDG_CONFIG_HOME}/${PKGNAME}
location (${HOME}/.config/${PKGNAME}), then it would instead go in
${HOME}/dotfiles/${PKGNAME}/.config/${PKGNAME} and so on.
Finally, from the dotfiles directory, you just run $ stow $PKGNAME and
Stow will symlink all the package's configuration files to the appropriate
locations. It's then easy to make the dotfiles a VCS repository so you can
keep track of changes you make (plus it makes it so much easier to share
configurations between different computers, which was my main reason to
do it).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;舉個例子，比如說你想管理 Bash, VIM, Uzbl 這三個程序的配置文件。Bash 會在家目錄的頂層文件夾
放幾個文件； VIM 通常會有在頂層文件夾的 .vimrc 文件和 .vim 目錄；然後 Uzbl 的配置位於
&lt;code class="code"&gt;
${XDG_CONFIG_HOME}/​uzbl&lt;/code&gt;
 以及 &lt;code class="code"&gt;
${XDG_DATA_HOME}/​uzbl&lt;/code&gt;

。於是在遷移配置前，你的家目錄的文件夾結構應該看起來像這樣：&lt;/td&gt;
&lt;td&gt;For example, let's say you want to manage the configuration for Bash,
VIM and Uzbl. Bash has a couple files in the top-level directory;
VIM typically has your .vimrc file on the top-level and a .vim directory;
and Uzbl has files in ${XDG_CONFIG_HOME}/uzbl and ${XDG_DATA_HOME}/uzbl.
So, your home directory looks like this:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;home/&lt;/span&gt;
&lt;span class="code-line"&gt;    brandon/&lt;/span&gt;
&lt;span class="code-line"&gt;        .config/&lt;/span&gt;
&lt;span class="code-line"&gt;            uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;        .local/&lt;/span&gt;
&lt;span class="code-line"&gt;            share/&lt;/span&gt;
&lt;span class="code-line"&gt;                uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                    [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;        .vim/&lt;/span&gt;
&lt;span class="code-line"&gt;            [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;        .bashrc&lt;/span&gt;
&lt;span class="code-line"&gt;        .bash_profile&lt;/span&gt;
&lt;span class="code-line"&gt;        .bash_logout&lt;/span&gt;
&lt;span class="code-line"&gt;        .vimrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;然後遷移配置的方式是，應該建一個 dotfiles 子目錄，然後像這樣移動所有配置文件：&lt;/td&gt;
&lt;td&gt;You would then create a dotfiles subdirectory and move all the files there:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;home/&lt;/span&gt;
&lt;span class="code-line"&gt;    /brandon/&lt;/span&gt;
&lt;span class="code-line"&gt;        .config/&lt;/span&gt;
&lt;span class="code-line"&gt;        .local/&lt;/span&gt;
&lt;span class="code-line"&gt;            .share/&lt;/span&gt;
&lt;span class="code-line"&gt;        dotfiles/&lt;/span&gt;
&lt;span class="code-line"&gt;            bash/&lt;/span&gt;
&lt;span class="code-line"&gt;                .bashrc&lt;/span&gt;
&lt;span class="code-line"&gt;                .bash_profile&lt;/span&gt;
&lt;span class="code-line"&gt;                .bash_logout&lt;/span&gt;
&lt;span class="code-line"&gt;            uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                .config/&lt;/span&gt;
&lt;span class="code-line"&gt;                    uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                        [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;                .local/&lt;/span&gt;
&lt;span class="code-line"&gt;                    share/&lt;/span&gt;
&lt;span class="code-line"&gt;                        uzbl/&lt;/span&gt;
&lt;span class="code-line"&gt;                            [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;            vim/&lt;/span&gt;
&lt;span class="code-line"&gt;                .vim/&lt;/span&gt;
&lt;span class="code-line"&gt;                    [...some files]&lt;/span&gt;
&lt;span class="code-line"&gt;                .vimrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;然後執行以下命令：&lt;/td&gt;
&lt;td&gt;Then, perform the following commands:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; ~/dotfiles&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; stow bash&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; stow uzbl&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; stow vim&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;然後，瞬間，所有你的配置文件（的符號鏈接）就安安穩穩地放入了它們該在的地方，無論原本這些目錄結構
有多麼錯綜複雜，這樣安排之後的 dotfiles 文件夾內的目錄結構立刻整理得有條有理，
並且可以很容易地轉換成版本控制倉庫。非常有用的一點是，如果你有多臺電腦，可能這些電腦並沒有
安裝完全一樣的軟件集，那麼你可以手選一些你需要的軟件配置來安裝。在你的 dotfiles 文件夾中總是
可以找到所有的配置文件，但是如果你不需要某個程序的某份配置，那你就不對它執行 stow
命令，它就不會擾亂你的家目錄。&lt;/td&gt;
&lt;td&gt;And, voila, all your config files (well, symbolic links to them) are all
in the correct place, however disorganized that might be, while the actual
files are all neatly organized in your dotfiles directory, which is easily
turned into a VCS repo. One handy thing is that if you use multiple
computers, which may not have the same software installed on them,
you can pick and choose which configurations to install when you need them.
All of your dotfiles are always available in your dotfiles directory,
but if you don't need the configuration for one program, you simply don't
Stow it and thus it does not clutter your home directory.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;嗯，以上就是整個用法介紹。希望能有別人覺得這個用法有用！我知道對我來說這個非常有幫助。&lt;/td&gt;
&lt;td&gt;Well, that's all there is to it. Hopefully someone else out there finds
this useful! I know I've found it to be a huge help.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="linux"></category><category term="dotfiles"></category><category term="stow"></category></entry><entry><title>爲什麼 Linus Torvalds 不願意將 Linux 變成 GPLv3 授權？</title><link href="//farseerfc.me/why-linus-torvalds-undermine-gplv3.html" rel="alternate"></link><published>2016-08-08T16:15:00+09:00</published><updated>2016-08-08T16:15:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2016-08-08:/why-linus-torvalds-undermine-gplv3.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="https://www.zhihu.com/question/48884264/answer/113454129"&gt;知乎&lt;/a&gt; 轉載&lt;/p&gt;
&lt;p&gt;和上篇文章一樣，這篇也是來自一個知乎上我回答的問題。&lt;/p&gt;
&lt;p&gt;原問題：为什么 Linus Torvalds 不愿意将 Linux 变成 GPLv3 授权？&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
DebConf 14: Q&amp;amp;A with Linus Torvalds&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_1Mg5_gxNXTo"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/1Mg5_gxNXTo"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XMTY3NjIzNDU0NA"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XMTY3NjIzNDU0NA" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_1Mg5_gxNXTo"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XMTY3NjIzNDU0NA"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我的回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這裏有段 Linus Torvalds 在 DebConf 14 上的 Q&amp;amp;A:
&lt;a class="reference external" href="https://youtu.be/1Mg5_gxNXTo?t=47m20s"&gt;https://youtu.be/1Mg5_gxNXTo?t=47m20s&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中關於 GPLv3 和協議的那一段在47:20開始到57:00左右。
裏面 Linus 對自己的觀點澄清得很清楚了。
看u2b或者聽英語有困難的請留評論，我抽空可以試着翻譯一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;然後接下來就是我承諾的翻譯了 …&lt;/h2&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="https://www.zhihu.com/question/48884264/answer/113454129"&gt;知乎&lt;/a&gt; 轉載&lt;/p&gt;
&lt;p&gt;和上篇文章一樣，這篇也是來自一個知乎上我回答的問題。&lt;/p&gt;
&lt;p&gt;原問題：为什么 Linus Torvalds 不愿意将 Linux 变成 GPLv3 授权？&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
DebConf 14: Q&amp;amp;A with Linus Torvalds&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_1Mg5_gxNXTo"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/1Mg5_gxNXTo"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XMTY3NjIzNDU0NA"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XMTY3NjIzNDU0NA" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_1Mg5_gxNXTo"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XMTY3NjIzNDU0NA"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我的回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這裏有段 Linus Torvalds 在 DebConf 14 上的 Q&amp;amp;A:
&lt;a class="reference external" href="https://youtu.be/1Mg5_gxNXTo?t=47m20s"&gt;https://youtu.be/1Mg5_gxNXTo?t=47m20s&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中關於 GPLv3 和協議的那一段在47:20開始到57:00左右。
裏面 Linus 對自己的觀點澄清得很清楚了。
看u2b或者聽英語有困難的請留評論，我抽空可以試着翻譯一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;然後接下來就是我承諾的翻譯了&lt;/h2&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問：你是否同意說你貶低了 GPLv3 ? 以及……&lt;/td&gt;
&lt;td&gt;Q: Do you agree that you undermine GPLv3? and ...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 是的&lt;/td&gt;
&lt;td&gt;L: Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問：我們如何纔能讓你別這麼做？&lt;/td&gt;
&lt;td&gt;Q: How can we get you to stop?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 什麼？&lt;/td&gt;
&lt;td&gt;L: What?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問：我們如何纔能讓你別這麼做？&lt;/td&gt;
&lt;td&gt;Q: How can we get you to stop?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 哦我討厭 GPLv3 ，我是在故意貶低它。實際上我覺得 GPLv3 的擴展非常可怕。
我能理解爲什麼人們想要做這個，但是我覺得它本應是一個全新的協議。&lt;/td&gt;
&lt;td&gt;L: Oh I hate GPLv3. I undermined it on purpose.
I actually thought the GPLv3 extensions were horrible.
I understand why people would want to do them but I think it should have
been a completely new license.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;嗯我喜歡版本 2 的那些理由，並且我仍然覺得版本 2 是一個非常棒的協議，
理由是：「我給你源代碼，你給我你對它的修改，我們就扯平了」
對吧？這是我用 GPL 版本 2 的理由，就是這麼簡單。&lt;/td&gt;
&lt;td&gt;Emm my argument for liking version 2, and I still think version 2 is a
great license, was that, "I give you source code, you give me your
changes back, we are even." Right? That's my take on GPL version 2, right,
it's that simple.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;然後版本 3 的擴展在某些方面讓我個人覺得非常不舒服，也就是說「我給你源代碼，
這意味着你必須服從我的一些規則，否則你不能把它用在你的設備上。」
對我來說，這是違反了版本 2 協議所追求的所有目的。然而我理解爲什麼 FSF 要這麼做，
因爲我知道 FSF 想要達成什麼，但是對我來說這完全是不同的協議了。&lt;/td&gt;
&lt;td&gt;And version 3 extended that in ways that I personally am really
uncomfortable with, namely "I give you source code, that means that if
you use that source code, you can't use it on your device unless you
follow my rules." And to me that's, that's a violation of everything
version 2 stood for. And I understand why the FSF did it because I know
what the FSF wants.     But to me it's not the same license at all.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;所以我當時非常不安，並且表明了自己的觀點，並且這是在版本 3 發佈的數月之前。
在那很久之前曾經有過一場討論……在版本 3 之前有一個早期的版本，
事實上幾年之前，那時我就說過：「不，這不可能工作」。
並且在那個早期的討論階段我已經在內核裏寫好了「嘿，我可沒有寫過版本 2
或者更高版本」。所以之後也沒有過（爭議）……隨後版本 3 出來的時候我非常開心，
因爲我早在大概 5 年前做了預防，之後也就再也沒有過關於內核的協議究竟是哪個
版本的討論。&lt;/td&gt;
&lt;td&gt;So I was very upset and made it very clear, and this was months before
version 3 was actually published. There was a discussion about this
long before... There was an earlier version of version 3, years before
actually, where I said "No, this is not gonna fly."
And during that earlier discussion I had already added to the kernel that,
"Hey, I don't have the version 2 or later". And there was no...
And I was really happy then when version 3 came out, that I have done that
something like 5 years before, because there was ever never any question
about what the license for the kernel was.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;不過事實上我覺得版本 3 是……呃不……我事實上覺得版本 3 是個 &lt;strong&gt;不錯&lt;/strong&gt; 的協議，
對吧。我堅定地相信「如果是你寫的代碼，那麼你有權利決定它應該用什麼協議」。
並且版本 3 是個不錯的選擇。版本 3 不好的地方在……「我們給你了版本 2
，然後我們試圖偷偷混入這些新的規則，並且想逼着所有人都跟着升級」這是我不喜歡版本
3 的地方。並且 FSF 在其中做了很多見不得人的事情，我覺得做得很不道德。&lt;/td&gt;
&lt;td&gt;But I actually thought that version 3 is ... Uh, no ... I actually think
version 3 is a &lt;strong&gt;FINE&lt;/strong&gt; license, right. I'm a firm believer in,
"If you write your code, it is your choice to pick a license."
And version 3 is a fine license. Version 3 was not a good ...
"Here we give you version 2, and then we tried to sneak in these new rules,
and tried to force everybody to upgrade." That was the part I disliked.
And the FSF did some really sneaky stuff, downright immoral in my opinion.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問：所以你在說 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tivoization"&gt;Tivoization&lt;/a&gt; 的事情麼？&lt;/td&gt;
&lt;td&gt;Q: So you are talking about &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tivoization"&gt;Tivoization&lt;/a&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
譯註： 關於 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tivoization"&gt;Tivoization&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
Tivoization 是 FSF 發明的一個詞，表示 TiVo 的做法。 TiVo
是一個生產類似電視機頂盒之類的設備的廠商，他們在他們的設備中用到了 Linux
內核和很多別的開源組件，並且他們根據 GPLv2 協議開放了他們使用的組件的源代碼。
然而他們在他們出售的設備中增加了數字簽名，驗證正在執行的系統和軟件是他們自己
編制的軟件，從而限制了用戶修改運行軟件的自由。這種做法在 FSF 看來是鑽了 GPLv2
的法律上的空子，所以 FSF 提出了 GPLv3 封堵這種做法。&lt;/div&gt;
&lt;/div&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 沒錯，Tivoization 的事情一直是我反對版本 3 的主要根據。並且，FSF
在這件事上表現得極不誠實。「嘿，其實我們允許你無效化 Tivoization 條款」，這樣他們試圖，
應該說他們是在明白着欺騙別人，並且說「嘿，這意味着你可以使用除去 Tivoization 部分的 GPLv3」。
這很……在場的諸位中有誰從 FSF 那兒聽過這個說法？（請舉手）&lt;/td&gt;
&lt;td&gt;L: Ehmm, yeah the Tivoization is always my main, eh dislike of version 3.
And, the FSF was being very dishonest thing. "Hey, we actually allow you
to invalidate the Tivoization clause" and they tried to, they literally
lied to people, and say "Hey, so that means that you can use GPLv3 without
the Tivoization part", right. This is ... How many people heard this
particular statement from the FSF? (Please raise your hands)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;好吧，或許他們只試過對我用這套說辭，但是他們真的試過。我的反應是「我可不傻」，對吧。是的，
的確你可以…… GPLv3 允許你說「好， Tivoization 的事情對我們來說不是問題」，
但是它同時又允許別人接過這個項目，並且說「嘿，我覺得……去掉了 Tivoization 的 GPLv3
是兼容完整的 GPLv3 的，所以我可以 fork 這個項目，然後我將在自己的 fork 上用完整的
GPLv3 寫驅動。」然後我就囧了。我的困境在於說「嘿，我給了你我的源代碼，現在我卻不能拿回你對它
的修改了」。這是徹底違背了我用這個協議最初的目的了。&lt;/td&gt;
&lt;td&gt;Ok, maybe they only tried to convince me with that one.
But they did try. And it was like, "I'm not stupid", right. Yes, you can
... The GPLv3 allows you to say "Ok, Tivoization is not an issue for us".
But it allows somebody else to take the project, and say "Hey, I ... The
GPLv3 without Tivoization is compatible with the full GPLv3, so I will now
make my own fork of this, and I will start doing drivers that use the full
version of version 3" And where am I stuck then? I am stuck saying "Hey I
give you the source code, and now I can't take it back your changes".
That's completely against the whole point of the license in the first
place.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;所以 FSF 是，我是說那時他們暗地裏做的那些事情，讓我當下決定永遠不再和 FSF 有任何瓜葛。
所以如果你想捐錢給一個行善的組織，那就捐給 EFF 吧。FSF 充滿了瘋狂難處的人。這只是我的觀點。
呃其實我……嗯……我說得有點過分了。FSF 裏有很多不錯的人，不過其中有些人有點過激。&lt;/td&gt;
&lt;td&gt;So the FSF was, I mean the kind of stuff that was going on behind the
scenes, ah, made me once and for all to decide to never had any thing to
do with the FSF again. So if you wanted to give money to an organization
that does good? Give it to the EFF. The FSF is full of crazy bittered
people. That's just mine opinion. Uh, actually I have ... Ah ...
I overstated that a bit, right. The FSF has a lot of nice people in it,
but some of them are bit too extreme.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問: 嗯我也希望 EFF 能更多的關注於軟件的自由方面。但是你能……你覺得 Tivoization
這種行爲也能在某種方式上讓我作爲用戶獲益麼？&lt;/td&gt;
&lt;td&gt;Q: Well I wish the EFF care more about software freedom. But, uh,
can you ... Do you think that Tivoization benefits me as a user somehow?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 不，我不覺得。我的意思是……這從來都不是我的論據，這不是我選擇了 GPLv2 的理由。
並不是說我覺得 Tivoization 是某種值得你去爭取的權利，而是說在我的世界觀中，這是你的決定。
如果你生產硬件去鎖住了其中的軟件，這是你作爲一個硬件提供者的決定。
這完全不影響我作爲一個軟件提供者給你軟件的決定。你能看出我的立場在哪兒了麼？
我不喜歡上鎖的硬件，但是同時這也從來不是我想要給 Linux 加上的的社會契約。&lt;/td&gt;
&lt;td&gt;L: No, no I don't. I mean that ... But that was never my argument. That
was not why I selected the GPLv2. This is my whole point. It's not that
I think Tivoization is necessarily something that you should strive for.
But it is something that in my world view, it's your decision.
If you make hardware that locks down the software, that's your decision
as a hardware maker. That has no impact on my decision as a software maker
to give you the software. Do you see where I am coming from? I don't like
the locked down hardware, but at the same time that was never the social
contract I intended with Linux.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;對我來說，呃我想說，大家可能知道或者不知道， GPLv2 並不是 Linux 的最初的協議。
對我來說重要的部分一直是「我給你軟件，你可以用它做任何你想要做的事情。如果你做了任何改進，
你需要把它交還給我。」這是協議最初的樣子。最早的協議還有一條完全錯誤的條款，寫得完全不合理，
那時我很傻。嘿我也傻過。我最初的協議說你不能用它賺錢。這是失策，這明顯是不對的不好的，
因爲它和我真正想要做的事情沒有任何關係。但是那時我很傻很天真，
我沒意識到錢的事情在其中完全不重要。然後我發現了其中的問題，我看到了 GPLv2 然後說「嘿，
這是個完美的協議」。然後我看到了 GPLv3 我說「不，這做得過分了，這不是我想要的」
所以我讓 Linux 成爲了僅限 GPLv2 ，對吧。&lt;/td&gt;
&lt;td&gt;To me, umm, I mean, people may or may not
realize GPLv2 wasn't even the first license for Linux.
To me the important part was always "I give you software, you can do
whatever you want with it. If you making improvements, you have to give
them back." That was the first version of the license. It also had a
completely broken clause which was completely insane and I was stupid.
Hey it happened. My origin license says that you can't make money
change hands. And that was a mistake. That was clearly just wrong and bad
because it really didn't have anything to do with what I wanted. But I
was young, I was poor, I didn't realize that the whole money thing wasn't
the important part. And I have saw the errors in my ways, I saw the GPLv2
and said "Hey, that's the perfect license". And I saw the GPLv3 and I said
"No, that's overreaching a lot, that's not what I wanted". And so I made
Linux GPLv2 only, right.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問: 所以你是否認爲，即使你不能修改跑着這個軟件的設備，拿回對軟件的修改也還是同樣重要的？&lt;/td&gt;
&lt;td&gt;Q: So do you think getting the patches back is as useful even if you can't
modify the device that it is used on?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 是的，當然。我想說 TiVo 它自己實際上就是一個例子。他們的修改有點複雜，但是我想說他們基本
是，一開始基本是運行在一套相當標準的 MIPS 設備上。然後他們的修改是想繞開他們用到的芯片上的
一些問題，並且這些是合格的修改。之後的事情是他們覺得他們需要鎖住他們的硬件，我不喜歡這個。
但是就像我已經說的，我覺得這是他們的決定。&lt;/td&gt;
&lt;td&gt;L: Yeah, absolutely. And I mean TiVo itself is actually an example of this.
Their patches were kind of crafty but I mean they were basically running
on a, originally a fairly standard MIPS thing. And their patches were
working around bugs in the chipsets they used. And they were valid patches.
The fact that they then felt that their hardware had to be locked down
someway. I didn't like it. But as I have mentioned, I felt that that was
their decision.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;並且他們有真正的理由去這麼做。這是有時人們忽視的地方。有時是真的有理由去做 TiVo
他們做的事情。有時強加給你這種限制的是，無線運營商。有時強加給你的是迪士尼。
有時強加給你限制的甚至是法律。 GPLv3 在醫療設備之類的場合其實允許最後一種情況，我記得。
我的觀點是，整個 Tivoization 的事情有時是有理由去這麼做的。如果你生產……
我是說我不是硬件設計者，我覺得 FPGA 之類的東西很酷，但是我……我的意思是我真的不想把我對世界的
看法強加給別人。你不是非得要用 Linux ，如果你想要用 Linux
，那麼我唯一要求你做的事情是把源代碼（變更）還給我。然後在 GPLv2
中還有很多繁文縟節規定了詳細的細節，這些都不重要。這是我一直以來的觀點。&lt;/td&gt;
&lt;td&gt;And they had real reasons for that. That's something people sometimes
missed. There are sometimes reasons to do what TiVo did. Sometimes it's
imposed on you by, wireless carriers. Sometimes it's imposed on you by
Disney. Uh sometimes it's imposed on you by laws. The GPLv3 actually
accepts the last one when it comes to things like medical equipment
I think. But the point is that the whole Tivoization thing is, sometimes
it's, there is a reason for it. And if you make ... I mean I am not a
hardware designer. I think FPGA and stuff like that is really cool.
But I always ... I mean I really don't want to impose my world view on
anybody else. You don't have to use Linux. If you do use Linux, the only
thing I asked for is source code back. And there is all these other
verbiages in the GPLv2 about exact details, those aren't important.
And that was always my standpoint.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;問: 好吧那我就不浪費時間了。&lt;/td&gt;
&lt;td&gt;Q: Ok, well I will stop my non-point of making noise now.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
譯註： 關於 &lt;a class="reference external" href="https://zh.wikipedia.org/wiki/ISC%E8%A8%B1%E5%8F%AF%E8%AD%89"&gt;ISC 協議&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
ISC 協議是一個開源軟件協議，和兩句的 BSD 協議功能相同。OpenBSD 項目選擇儘量用 ISC
協議公開他們新寫的代碼。&lt;/div&gt;
&lt;/div&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="50%"/&gt;
&lt;col width="50%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: 我的意思是別誤解……我也喜歡別的協議。我用過……到底是哪個 BSD 協議是可以接受的？
有一個 BSD 協議實際上非常不錯。它實際上是……什麼？&lt;/td&gt;
&lt;td&gt;L: I mean don't get me ... I mean I like other licenses too. I have used
like the four, emmm... Which BSD license is the acceptable one?
One of the BSD license is actually really nice. And it's actually the...
What?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;觀衆： ISC&lt;/td&gt;
&lt;td&gt;A: ISC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L: ISC？並且事實上我在鼓勵那些不在意拿回修改但是在意「嘿，我做了一個很酷的東西，請用它」。
我鼓勵這些人去用 BSD 協議做這些事情。我想說 BSD 協議在這種場合是完美的。
只是碰巧我覺得對於我的項目，拿回修改也同樣重要，所以對我而言 BSD 不好。但是重點是
&lt;strong&gt;對我而言&lt;/strong&gt; 。 GPLv3 可能對你們想要做的事情而言是完美的協議，這很好，並且這時你就應該去用
GPLv3 。只是當代碼是別人寫的時候，你沒有這個選擇權。&lt;/td&gt;
&lt;td&gt;L: ISC? And I actually encourage people who don't care about the giving
code back but care about the "Hey, I did something cool, please use it".
I encourage people to use the BSD license for that. And I mean the BSD
license is wonderful for that. It so happens that I thought that for my
project the giving back is equally important so I, for me BSD is bad.
But the point is &lt;strong&gt;for me&lt;/strong&gt;. The GPLv3 maybe the perfect license for what
you guys want to do. And that's fine. And then it's the license you should
use. It's just that when somebody else wrote the code you don't get that
choice.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="Linux"></category><category term="zhihu"></category><category term="GPLv3"></category><category term="licenses"></category><category term="Linus Torvalds"></category><category term="GPL"></category><category term="FSF"></category><category term="EFF"></category></entry><entry><title>C语言中“.”与“-&gt;”有什么区别？</title><link href="//farseerfc.me/dot-and-arrow-in-c.html" rel="alternate"></link><published>2016-08-08T00:02:00+09:00</published><updated>2016-08-08T00:02:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2016-08-08:/dot-and-arrow-in-c.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="https://www.zhihu.com/question/49164544/answer/114584541"&gt;知乎&lt;/a&gt; 轉載&lt;/p&gt;
&lt;p&gt;轉載幾篇知乎上我自己的回答，因爲不喜歡知乎的排版，所以在博客裏重新排版一遍。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;原問題：C语言中“.”与“-&amp;gt;”有什么区别？&lt;/h2&gt;
&lt;p&gt;除了表达形式有些不同，功能可以说完全一样阿。那为何又要构造两个功能一样的运算符？ 效率有差异？可是现在编译器优化都那么强了，如果真是这样岂不是有些多此一举&lt;/p&gt;
&lt;hr class="docutils"/&gt;
&lt;p&gt;刚刚翻了下书，说早期的C实现无法用结构直接当作参数在函数间传递，只能用指向结构的指针在函数间进行传递！我想这应该也是最直观的原因吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;我的回答&lt;/h2&gt;
&lt;p&gt;首先 &lt;code class="code"&gt;
a-&amp;gt;b&lt;/code&gt;
 的含義是 &lt;code class="code"&gt;
(*a).b&lt;/code&gt;
 ，所以他們是不同的，不過的確 &lt;code class="code"&gt;
-&amp;gt;&lt;/code&gt;
 可以用 &lt;code class="code"&gt;
*&lt;/code&gt;
 和 &lt;code class="code"&gt;
.&lt;/code&gt;
 實現，不需要單獨一個運算符。
嗯，我這是說現代的標準化的 C 語義上來說， &lt;code class="code"&gt;
-&amp;gt;&lt;/code&gt;
 可以用 &lt;code class="code"&gt;
*&lt;/code&gt;
 和 &lt;code class="code"&gt;
.&lt;/code&gt;
 的組合實現。&lt;/p&gt;
&lt;p&gt;早期的 C 有一段時間的語義和現代的 C 的語義不太一樣。&lt;/p&gt;
&lt;p&gt;稍微有點彙編的基礎的同學可能知道，在機器碼和彙編的角度來看，不存在變量，不存在 struct …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="https://www.zhihu.com/question/49164544/answer/114584541"&gt;知乎&lt;/a&gt; 轉載&lt;/p&gt;
&lt;p&gt;轉載幾篇知乎上我自己的回答，因爲不喜歡知乎的排版，所以在博客裏重新排版一遍。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;原問題：C语言中“.”与“-&amp;gt;”有什么区别？&lt;/h2&gt;
&lt;p&gt;除了表达形式有些不同，功能可以说完全一样阿。那为何又要构造两个功能一样的运算符？ 效率有差异？可是现在编译器优化都那么强了，如果真是这样岂不是有些多此一举&lt;/p&gt;
&lt;hr class="docutils"/&gt;
&lt;p&gt;刚刚翻了下书，说早期的C实现无法用结构直接当作参数在函数间传递，只能用指向结构的指针在函数间进行传递！我想这应该也是最直观的原因吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;我的回答&lt;/h2&gt;
&lt;p&gt;首先 &lt;code class="code"&gt;
a-&amp;gt;b&lt;/code&gt;
 的含義是 &lt;code class="code"&gt;
(*a).b&lt;/code&gt;
 ，所以他們是不同的，不過的確 &lt;code class="code"&gt;
-&amp;gt;&lt;/code&gt;
 可以用 &lt;code class="code"&gt;
*&lt;/code&gt;
 和 &lt;code class="code"&gt;
.&lt;/code&gt;
 實現，不需要單獨一個運算符。
嗯，我這是說現代的標準化的 C 語義上來說， &lt;code class="code"&gt;
-&amp;gt;&lt;/code&gt;
 可以用 &lt;code class="code"&gt;
*&lt;/code&gt;
 和 &lt;code class="code"&gt;
.&lt;/code&gt;
 的組合實現。&lt;/p&gt;
&lt;p&gt;早期的 C 有一段時間的語義和現代的 C 的語義不太一樣。&lt;/p&gt;
&lt;p&gt;稍微有點彙編的基礎的同學可能知道，在機器碼和彙編的角度來看，不存在變量，不存在 struct 這種東西，只存在寄存器和一個叫做內存的大數組。&lt;/p&gt;
&lt;p&gt;所以變量，是 C 對內存地址的一個抽象，它代表了一個位置。舉個例子，C 裏面我們寫：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其實在彙編的角度來看更像是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 A 和 B 各是兩個內存地址，是指針。&lt;/p&gt;
&lt;p&gt;好，以上是基本背景。&lt;/p&gt;
&lt;p&gt;基於這個背景我們討論一下 struct 是什麼，以及 struct 的成員是什麼。
假設我們有&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;從現代語義上講 &lt;code class="code"&gt;
p&lt;/code&gt;
 就是一個結構體對象， &lt;code class="code"&gt;
x&lt;/code&gt;
 和 &lt;code class="code"&gt;
y&lt;/code&gt;
 各是其成員，嗯。&lt;/p&gt;
&lt;p&gt;從彙編的語義上講， &lt;code class="code"&gt;
p&lt;/code&gt;
 是一個不完整的地址，或者說，半個地址，再或者說，一個指向的東西是虛構出來的地址。而 &lt;code class="code"&gt;
x&lt;/code&gt;
 和 &lt;code class="code"&gt;
y&lt;/code&gt;
 各是在 Point 結構中的地址偏移量。也就是說，必須有 &lt;code class="code"&gt;
p&lt;/code&gt;
 和 &lt;code class="code"&gt;
x&lt;/code&gt;
 或者 &lt;code class="code"&gt;
p&lt;/code&gt;
 和 &lt;code class="code"&gt;
y&lt;/code&gt;
 同時出現，才形成一個完整的地址，單獨的一個 &lt;code class="code"&gt;
p&lt;/code&gt;
 沒有意義。&lt;/p&gt;
&lt;p&gt;早期的 C 就是在這樣的模型上建立的。所以對早期的 C 而言， &lt;code class="code"&gt;
*pp&lt;/code&gt;
 沒有意義，你取得了一個 struct ，而這個 struct 不能塞在任何一個寄存器裏，編譯器和 CPU 都無法表達這個東西。&lt;/p&gt;
&lt;p&gt;這時候只有 &lt;code class="code"&gt;
p.x&lt;/code&gt;
 和 &lt;code class="code"&gt;
p.y&lt;/code&gt;
 有意義，它們有真實的地址。&lt;/p&gt;
&lt;p&gt;早期的 C 就是這樣一個看起來怪異的語義，而它更貼近機器的表達。
所以對早期的 C 而言，以下的代碼是對的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而以下代碼是錯的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因爲作爲這個賦值的目標地址表達式的一部分， &lt;code class="code"&gt;
*pp&lt;/code&gt;
 ，這個中間結果沒法直譯到機器碼。&lt;/p&gt;
&lt;p&gt;所以對早期的 C 而言，對 pp 解引用的操作，必須和取成員的偏移的操作，這兩者緊密結合起來變成一個單獨的操作，其結果纔有意義。&lt;/p&gt;
&lt;p&gt;所以早期的 C 就發明了 -&amp;gt; ，表示這兩個操作緊密結合的操作。於是纔能寫：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;pp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嗯，這就是它存在的歷史原因。
而這個歷史原因現在已經不重要了，現代的符合標準的 C 編譯器都知道 &lt;code class="code"&gt;
(*pp).x&lt;/code&gt;
 和 &lt;code class="code"&gt;
pp-&amp;gt;x&lt;/code&gt;
 是等價的了。&lt;/p&gt;
&lt;p&gt;說句題外話， C++ 裏面還發明了 &lt;code class="code"&gt;
.*&lt;/code&gt;
 和 &lt;code class="code"&gt;
-&amp;gt;*&lt;/code&gt;
 這兩個運算符（注意 &lt;code class="code"&gt;
-&amp;gt;*&lt;/code&gt;
 不是單獨的 &lt;code class="code"&gt;
-&amp;gt;&lt;/code&gt;
 和 &lt;code class="code"&gt;
*&lt;/code&gt;
 並排放的意思），關於爲什麼要發明這兩個運算符，而不能直接說 &lt;code class="code"&gt;
a -&amp;gt;* b&lt;/code&gt;
 的意思就是 &lt;code class="code"&gt;
a -&amp;gt;(*b)&lt;/code&gt;
 ，這個就作爲課堂作業吧。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C"></category><category term="zhihu"></category></entry><entry><title>啓用 GitHub Issue 作爲博客留言系統</title><link href="//farseerfc.me/github-issues-as-comments.html" rel="alternate"></link><published>2016-08-07T16:28:00+09:00</published><updated>2016-08-07T16:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2016-08-07:/github-issues-as-comments.html</id><summary type="html">&lt;p&gt;從今天起本博客將啓用 GitHub Issue 作爲留言系統。
原本使用的 Disqus 將繼續保留一段時間，目前沒有關閉的計劃。&lt;/p&gt;
&lt;p&gt;換用 GitHub Issue 是計劃了好久的事情了，最初重做這個主題的時候就有考慮過。
這個想法的契機是看到了這篇
&lt;a class="reference external" href="http://ivanzuzak.info/2011/02/18/github-hosted-comments-for-github-hosted-blogs.html"&gt;GitHub hosted comments for GitHub hosted blogs&lt;/a&gt;
，然後立馬覺得這個想法很符合寄宿在 GitHub Pages 上的博客。
一個限制是要求評論者必須有 GitHub
賬戶，考慮到我的博客的受衆這個要求估計不算太過分。
使用 GitHub Issue 的好處麼，比如自帶的 GFMD
富文本格式，郵件通知，還有訂閱和取消訂閱通知，郵件回復，
這些方面都不比第三方留言系統遜色。&lt;/p&gt;
&lt;p&gt;換用 GitHub Issue 另一方面原因是最近聽說 Disqus
被部分牆了，想必以後牆也會越來越高。之前曾經試過在這個博客換上多說，
然而效果我並不喜歡，多說喜歡侵入頁面加很多奇怪的東西 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;從今天起本博客將啓用 GitHub Issue 作爲留言系統。
原本使用的 Disqus 將繼續保留一段時間，目前沒有關閉的計劃。&lt;/p&gt;
&lt;p&gt;換用 GitHub Issue 是計劃了好久的事情了，最初重做這個主題的時候就有考慮過。
這個想法的契機是看到了這篇
&lt;a class="reference external" href="http://ivanzuzak.info/2011/02/18/github-hosted-comments-for-github-hosted-blogs.html"&gt;GitHub hosted comments for GitHub hosted blogs&lt;/a&gt;
，然後立馬覺得這個想法很符合寄宿在 GitHub Pages 上的博客。
一個限制是要求評論者必須有 GitHub
賬戶，考慮到我的博客的受衆這個要求估計不算太過分。
使用 GitHub Issue 的好處麼，比如自帶的 GFMD
富文本格式，郵件通知，還有訂閱和取消訂閱通知，郵件回復，
這些方面都不比第三方留言系統遜色。&lt;/p&gt;
&lt;p&gt;換用 GitHub Issue 另一方面原因是最近聽說 Disqus
被部分牆了，想必以後牆也會越來越高。之前曾經試過在這個博客換上多說，
然而效果我並不喜歡，多說喜歡侵入頁面加很多奇怪的東西，比如用戶的頭像通常是
http 的……也試過結合新浪微博的評論，而新浪微博越來越封閉，API 也越來越不靠譜。&lt;/p&gt;
&lt;p&gt;使用 GitHub Issue 作爲評論的方式比較簡單，上面那篇博客裏面提到了，代碼量不比
加載 Disqus 多多少，而且沒有了 iframe 的困擾，唯一麻煩的地方就是要稍微設計一下佈局方式讓它融入
現有的頁面佈局。
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/blob/2ea6c9f3227275fe86ddaa75d8fc6496b3b03d8c/templates/includes/comments.html#L32"&gt;我參考上面的實現在這裏&lt;/a&gt; 。
這個加載代碼使用兩個變量加載 Issue Comments ，一個是在 pelicanconf.py 裏的
&lt;code class="code"&gt;
GITHUB_REPO&lt;/code&gt;
 ，可以指向任何 Repo ，我指向 farseerfc/farseerfc.github.io
的這個 GitHub Page repo ，另一個變量是每篇文章裏需要加上 &lt;code class="code"&gt;
issueid&lt;/code&gt;

的元數據，關連文章到每個 Issue 上。&lt;/p&gt;
&lt;p&gt;還有一個稍微麻煩的事情是現在每寫一篇文章之後都要新建一個 issue 了。
手動操作有點累人，於是我 &lt;a class="reference external" href="https://github.com/farseerfc/farseerfc/blob/master/createissue.py"&gt;寫了個腳本&lt;/a&gt;
自動搜索 pelican 的 content 文件夾裏面文章的 slug 並且對沒有 issueid 關連的
文章創建 issue 。&lt;/p&gt;
&lt;p&gt;好啦新的留言系統的外觀樣式還在測試中，希望大家多留言幫我測試一下！&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2016年8月7日19:30更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;新增了對 GitHub Issue comments 裏面
&lt;a class="reference external" href="https://developer.github.com/v3/issues/comments/#reactions-summary"&gt;reactions&lt;/a&gt;
的支持，套用 font-awesome 的圖標（似乎沒 GitHub 上的圖標好看）。這個還屬於 GitHub API
的實驗性功能，要加入 &lt;code class="code"&gt;
Accept: application/​vnd.github.squirrel-girl-preview&lt;/code&gt;

HTTP 頭纔能拿到。&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2016年8月7日23:16更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;感謝 @iovxw 的測試讓我發現 github 的高亮回復和郵件回復是需要特殊處理的。
高亮回復用上了 &lt;a class="reference external" href="https://github.com/sindresorhus/github-markdown-css"&gt;這裏的 CSS&lt;/a&gt;
郵件引言的展開事件直接用 jQuery 做了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;".email-hidden-toggle &amp;gt; a"&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"click"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;preventDefault&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;".email-hidden-reply"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;toggle&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;還得注意郵件的回復需要 CSS 裏面 &lt;code class="code"&gt;
white-space: pre-wrap&lt;/code&gt;
 。&lt;/p&gt;
</content><category term="tech"></category><category term="pelican"></category><category term="github"></category><category term="pages"></category><category term="issues"></category></entry><entry><title>PacVis: 可視化 pacman 本地數據庫</title><link href="//farseerfc.me/pacvis.html" rel="alternate"></link><published>2016-07-31T03:52:00+09:00</published><updated>2016-07-31T03:52:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2016-07-31:/pacvis.html</id><summary type="html">
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
PacVis&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Demo of PacVis" class="img-responsive" src="//farseerfc.me/images/pacvis-first.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pacvis"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;我爲什麼要做 PacVis&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我喜歡 Arch Linux ，大概是因爲唯有 Arch Linux 能給我對整個系統「瞭如指掌」的感覺。
在 Arch Linux 裏我能清楚地知道我安裝的每一個包，能知道系統裏任何一個文件是來自哪個包，
以及我爲什麼要裝它。或許對 Debian/Fedora/openSUSE 足夠熟悉了之後也能做到這兩點，
不過他們的細緻打包的結果通常是包的數量比 Arch 要多個 3 到 10 倍，並且打包的細節也比 Arch
Linux 簡單的 PKGBUILD 要複雜一個數量級。&lt;/p&gt;
&lt;p&gt;每一個裝過 Arch Linux 的人大概都知道，裝了 Arch Linux 之後得到的系統非常樸素，按照
ArchWiki 上的流程一路走下來的話，最關鍵的一條命令就是 &lt;code class="code"&gt;
pacstrap /​mnt …&lt;/code&gt;&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
PacVis&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Demo of PacVis" class="img-responsive" src="//farseerfc.me/images/pacvis-first.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pacvis"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;我爲什麼要做 PacVis&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我喜歡 Arch Linux ，大概是因爲唯有 Arch Linux 能給我對整個系統「瞭如指掌」的感覺。
在 Arch Linux 裏我能清楚地知道我安裝的每一個包，能知道系統裏任何一個文件是來自哪個包，
以及我爲什麼要裝它。或許對 Debian/Fedora/openSUSE 足夠熟悉了之後也能做到這兩點，
不過他們的細緻打包的結果通常是包的數量比 Arch 要多個 3 到 10 倍，並且打包的細節也比 Arch
Linux 簡單的 PKGBUILD 要複雜一個數量級。&lt;/p&gt;
&lt;p&gt;每一個裝過 Arch Linux 的人大概都知道，裝了 Arch Linux 之後得到的系統非常樸素，按照
ArchWiki 上的流程一路走下來的話，最關鍵的一條命令就是 &lt;code class="code"&gt;
pacstrap /​mnt base&lt;/code&gt;
 ，
它在 &lt;code class="code"&gt;
/​mnt&lt;/code&gt;
 裏作爲根調用 &lt;code class="code"&gt;
pacman -S base&lt;/code&gt;
 裝上了整個 base 組，
然後就沒有然後了。這個系統一開始空無一物，你需要的任何東西都是後來一點點用
&lt;code class="code"&gt;
pacman&lt;/code&gt;
 手動裝出來的，沒有累贅，按你所需。&lt;/p&gt;
&lt;p&gt;然而時間長了，系統中難免會有一些包，是你裝過用過然後忘記了，
然後這些包就堆在系統的角落裏，就像家裏陳年的老傢俱，佔着地，落着灰。雖然
&lt;code class="code"&gt;
pacman -Qtd&lt;/code&gt;
 能方便地幫你找出所有
&lt;strong&gt;曾經作爲依賴被裝進來，而現在不被任何包依賴&lt;/strong&gt; 的包，但是對於那些你手動指定的包，
它就無能爲力了。&lt;/p&gt;
&lt;p&gt;於是我就一直在找一個工具能幫我梳理系統中包的關係，方便我：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;找出那些曾經用過而現在不需要的包&lt;/li&gt;
&lt;li&gt;找出那些體積大而且佔地方的包&lt;/li&gt;
&lt;li&gt;釐清系統中安裝了的包之間的關係&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="figure"&gt;
&lt;img alt="Android System Architecture" class="img-responsive" src="//farseerfc.me/images/Android-System-Architecture.jpg"/&gt;
&lt;p class="caption"&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Android_(operating_system)"&gt;Android 系統架構&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;關於最後一點「釐清包的關係」，我曾經看到過
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Architecture_of_OS_X"&gt;macOS 系統架構圖&lt;/a&gt;
和 Android 的系統架構圖，對其中的層次化架構印象深刻，之後就一直在想，是否能畫出現代
Linux 桌面系統上類似的架構圖呢？又或者 Linux 桌面系統是否會展現完全不同的樣貌？
從維基百科或者別的渠道能找到 Linux 內核、或者 Linux 圖形棧，
或者某個桌面環境的架構，但是沒有找到覆蓋一整個發行版的樣貌的。
於是我便想，能不能從包的依賴關係中自動生成這樣一張圖呢。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;PacVis的老前輩們&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在開始寫 PacVis 之前，我試過一些類似的工具，他們都或多或少能解決一部分我的需要，
又在某些方面有所不足。這些工具成爲了 PacVis 的雛形，啓發了 PacVis
應該做成什麼樣子。&lt;/p&gt;
&lt;div class="section" id="pactree"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id13"&gt;pactree&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;pactree 曾經是一個
&lt;a class="reference external" href="https://bbs.archlinux.org/viewtopic.php?id=51795"&gt;獨立的項目&lt;/a&gt; ，現在則是
&lt;a class="reference external" href="https://www.archlinux.org/pacman/pactree.8.html"&gt;pacman 的一部分&lt;/a&gt; 了。
從手冊頁可以看出， pactree 的輸出是由某個包開始的依賴樹。
加上 &lt;code class="code"&gt;
--graph&lt;/code&gt;
 參數之後 pactree 還能輸出
&lt;a class="reference external" href="http://www.graphviz.org/"&gt;dot&lt;/a&gt; 格式的矢量圖描述，然後可以用 dot 畫出依賴圖：&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;code class="code"&gt;
pactree pacvis-git -d3 --graph | dot -Tpng &amp;gt;pacvis-pactree.png&lt;/code&gt;
&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="pactree --graph" class="img-responsive" src="//farseerfc.me/images/pacvis-pactree.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; pactree pacvis-git -d3&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;pacvis-git&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;├─python-tornado&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│ └─python&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─expat&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─bzip2&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─gdbm&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─openssl&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─libffi&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   └─zlib&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;├─pyalpm&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│ ├─python&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│ └─pacman&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─bash&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─glibc&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─libarchive&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─curl&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─gpgme&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   ├─pacman-mirrorlist&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;│   └─archlinux-keyring&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;└─python-setuptools&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;  └─python-packaging&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;    ├─python-pyparsing&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;    └─python-six&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt; $&lt;/span&gt; pactree pacvis-git -d3 --graph &lt;span class="p"&gt;|&lt;/span&gt; dot -Tpng &amp;gt;pacvis-pactree.png&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;從畫出的圖可以看出，因爲有共用的依賴，所以從一個包開始的依賴關係已經不再是一棵
&lt;a class="reference external" href="https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B"&gt;圖論意義上的樹(Tree)&lt;/a&gt;
了。最初嘗試做 PacVis 的早期實現的時候，就是試圖用 bash/python 腳本解析 pactree 和
pacman 的輸出，在 pactree 的基礎上把整個系統中所有安裝的包全都包含到一張圖裏。
當然後來畫出的結果並不那麼理想，首先由於圖非常巨大，導致 dot
的自動佈局要耗費數小時，最後畫出的圖也過於巨大基本上沒法看。&lt;/p&gt;
&lt;p&gt;然而不得不說沒有 pactree 就不會有 PacVis ，甚至 pacman 被分離出 alpm
庫也和 pactree 用 C 重寫的過程有很大關係，而 PacVis 用來查詢 pacman 數據庫的庫
pyalpm 正是 alpm 的 Python 綁定。因爲 pactree 的需要而增加出的 alpm 庫奠定了 PacVis
實現的基石。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pacgraph"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;pacgraph&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
pacgraph 的輸出&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="pacgraph" class="img-responsive" src="//farseerfc.me/images/pacvis-pacgraph.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="http://kmkeen.com/pacgraph/index.html"&gt;pacgraph&lt;/a&gt; 是一位 Arch Linux 的
Trusted User &lt;a class="reference external" href="http://kmkeen.com/"&gt;keenerd&lt;/a&gt; 寫的程序，和
PacVis 一樣也是用 Python 實現的。
比起 pactree ， pacgraph 明顯更接近我的需求，它默認繪製整個系統的所有安裝包，
並且用聰明的佈局算法解決了 dot 佈局的性能問題。&lt;/p&gt;
&lt;p&gt;pacgraph 的輸出是一個富有藝術感的依賴圖，圖中用不同的字體大小表示出了每個包佔用
的磁盤空間。通過觀察 pacgraph 的輸出，我們可以清楚地把握系統全局的樣貌，
比如一眼看出這是個桌面系統還是個服務器系統，並且可以很容易地發現那些佔用磁盤空間
巨大的包，考慮清理這些包以節約空間。&lt;/p&gt;
&lt;p&gt;更棒的是 pacgraph 還提供了一個交互性的 GUI 叫做 pacgraph-tk ，顯然通過 tk 實現。
用這個 GUI 可以縮放觀察整幅圖的細節，或者選中某個包觀察它和別的包的依賴關係。&lt;/p&gt;
&lt;p&gt;pacgraph 還支持通過參數指定只繪製個別包的依賴關係，就像 pactree 那樣。&lt;/p&gt;
&lt;p&gt;不過 pacgraph 也不是完全滿足我的需要。如我前面說過，我希望繪製出的圖能反應
&lt;strong&gt;這個發行版的架構面貌&lt;/strong&gt; ，而 pacgraph 似乎並不區別「該包依賴的包」和「依賴該包的包」
這兩種截然相反的依賴關係。換句話說 pacgraph 畫出的是一張無向圖，
而我更想要一張有向圖，或者說是 &lt;strong&gt;有層次結構的依賴關係圖&lt;/strong&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;於是就有了 PacVis&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
PacVis 剛打開的樣子&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="PacVis on startup" class="img-responsive" src="//farseerfc.me/images/pacvis-second.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;總結了老前輩們的優勢與不足，我便開始利用空餘時間做我心目中的 PacVis 。
前後斷斷續續寫了兩個月，又分爲兩個階段，第一階段做了基本的功能和雛形，
第二階段套用上 &lt;a class="reference external" href="https://getmdl.io/"&gt;https://getmdl.io/&lt;/a&gt; 的模板，總算有了能拿得出手給別人看的樣子。&lt;/p&gt;
&lt;p&gt;於是乎前兩天在 AUR 上給 pacvis 打了個
&lt;a class="reference external" href="https://aur.archlinux.org/packages/pacvis-git/"&gt;pacvis-git&lt;/a&gt;
包，現在想在本地跑 pacvis 應該很方便了，用任何你熟悉的 aurhelper
就可以安裝，也可以直接從 aur 下載 PKGBUILD 打包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;~$ git clone aur@aur.archlinux.org:pacvis-git.git&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;~$ cd pacvis-git&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;~/pacvis-git$ makepkg -si&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;~/pacvis-git$ pacvis&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;Start PacVis at http://localhost:8888/&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照提示說的，接下來打開瀏覽器訪問 &lt;a class="reference external" href="http://localhost:8888/"&gt;http://localhost:8888/&lt;/a&gt; 就能看到 PacVis
的樣子了。僅僅作爲嘗試也可以直接打開跑在我的服務器上的 demo:
&lt;a class="reference external" href="https://pacvis.farseerfc.me/"&gt;https://pacvis.farseerfc.me/&lt;/a&gt; ，這個作爲最小安裝的服務器載入速度大概比普通的桌面系統快一點。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
在 Windows msys2 跑 PacVis&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="PacVis on Windows msys2" class="img-responsive" src="//farseerfc.me/images/pacvis-msys2.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;另外補充一下，因爲 PacVis 只依賴 pyalpm 和 tornado ，所以在別的基於 pacman
的系統上跑它應該也沒有任何問題，包括
&lt;a class="reference external" href="https://msys2.github.io/"&gt;Windows 上的 msys2&lt;/a&gt; 裏（儘管在 msys2 上編譯
tornado 的包可能要花些功夫）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;PacVis 的圖例和用法&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;操作上 PacVis 仿照地圖程序比如 Google Maps 的用法，可以用滾輪或者觸摸屏的手勢
縮放、拖拽，右上角有個側邊欄，不需要的話可以點叉隱藏掉，右下角有縮放的按鈕和
回到全局視圖的按鈕，用起來應該還算直觀。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="PacVis showing pacvis-git" class="img-responsive" src="//farseerfc.me/images/pacvis-pacvis-git.png"/&gt;
&lt;p class="caption"&gt;pacvis-git 包的依賴&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;先解釋圖形本身，整張圖由很多小圓圈的節點，以及節點之間的箭頭組成。
一個圓圈就代表一個軟件包，而一條箭頭代表一個依賴關係。縮放到細節的話，
能看到每個小圓圈的下方標註了這個軟件包的名字，鼠標懸浮在圓圈上也會顯示響應信息。
還可以點開軟件包，在右側的邊欄裏會有更詳細的信息。&lt;/p&gt;
&lt;p&gt;比如圖例中顯示了 pacvis-git 自己的依賴，它依賴 pyalpm, python-tornado 和
python-setuptools ，其中 pyalpm 又依賴 pacman 。圖中用
&lt;span class="label label-primary"&gt;紫色&lt;/span&gt; 表示手動安裝的包，
&lt;span class="label label-warning"&gt;橙色&lt;/span&gt; 表示被作爲依賴安裝的包，
箭頭的顏色也隨着包的顏色改變。&lt;/p&gt;
&lt;p&gt;值得注意的是圖中大多數箭頭都是由下往上指的，這是因爲 PacVis 按照包的依賴關係做
了拓撲排序，並且給每個包賦予了一個拓撲層級。比如 pacvis-git 位於 39
層，那麼它依賴的 pyalpm 就位於 38 層，而 pyalpm 依賴的 pacman 就位於 37
層。根據層級關係排列包是 PacVis 於 pacgraph 之間最大的不同之處。&lt;/p&gt;
&lt;p&gt;除了手動縮放， PacVis 還提供了搜索框，根據包名快速定位你感興趣的包。
以及在右側邊欄中的 Dep 和 Req-By 等頁中，包的依賴關係也是做成了按鈕的形式，
可以由此探索包和包之間的關聯。&lt;/p&gt;
&lt;p&gt;最後稍微解釋一下兩個和實現相關的參數：&lt;/p&gt;
&lt;div class="label label-info"&gt;
Max Level&lt;/div&gt;
&lt;p&gt;這是限制 PacVis 載入的最大拓撲層。系統包非常多的時候 PacVis
的佈局算法會顯得很慢，限制層數有助於加快載入，特別是在調試 PacVis 的時候比較有用。&lt;/p&gt;
&lt;div class="label label-info"&gt;
Max Required-By&lt;/div&gt;
&lt;p&gt;這是限制 PacVis 繪製的最大被依賴關係。稍微把玩一下 PacVis 就會發現系統內絕大多數
的包都直接依賴了 glibc 或者 gcc-libs 等個別的幾個包，而要繪製這些依賴的話會導致
渲染出的圖中有大量長直的依賴線，不便觀察。於是可以通過限制這個值，使得 PacVis
不繪製被依賴太多的包的依賴關係，有助於讓渲染出的圖更易觀察。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;從 PacVis 能瞭解到的一些事實&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
一個 KDE 桌面的 PacVis 結果全圖， &lt;a class="reference external" href="//farseerfc.me/images/pacvis-16384.png"&gt;放大（17M）&lt;/a&gt;&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="A normal KDE desktop in PacVis" class="img-responsive" src="//farseerfc.me/images/pacvis-4096-anno.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;稍微玩一下 PacVis 就能發現不少有趣現象，上述「絕大多數包依賴 glibc 」就是一例。
除此之外還有不少值得玩味的地方。&lt;/p&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id18"&gt;依賴層次&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;系統中安裝的包被明顯地分成了這樣幾個層次：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;glibc 等 C 庫&lt;/li&gt;
&lt;li&gt;Bash/Perl/Python 等腳本語言&lt;/li&gt;
&lt;li&gt;coreutils/gcc/binutils 等核心工具&lt;/li&gt;
&lt;li&gt;pacman / systemd 等較大的系統工具&lt;/li&gt;
&lt;li&gt;gtk{2,3}/qt{4,5} 等 GUI toolkit&lt;/li&gt;
&lt;li&gt;chromium 等 GUI 應用&lt;/li&gt;
&lt;li&gt;Plasma/Gnome 等桌面環境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大體上符合直觀的感受，不過細節上有很多有意思的地方，比如 zsh 因爲 gdbm
間接依賴了 bash，這也說明我們不可能在系統中用 zsh 完全替代掉 bash。
再比如 python （在 Arch Linux 中是 python3）和 python2 和 pypy
幾乎在同一個拓撲層級。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="zsh depends on bash because of gdbm" class="img-responsive" src="//farseerfc.me/images/pacvis-zsh-bash.png" style="width: 45%;"/&gt;
&lt;p class="caption"&gt;zsh 因爲 gdbm 間接依賴了 bash&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;不過偶爾顯示的依賴層級不太符合直觀，比如 qt5-base &amp;lt; qt4 &amp;lt; gtk2 &amp;lt; gtk3 。
qt5 因爲被拆成了數個包所以比 qt4 更低級這可以理解，而 gtk 系比 qt
系更高級這一點是很多人（包括我）沒有預料到的吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;循環依賴&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有些包的依賴關係形成了循環依賴，一個例子是 freetype2 和 harfbuzz，freetype2
是繪製字體的庫，harfbuzz 是解析 OpenType 字形的庫，兩者對對方互相依賴。
另一個例子是 KDE 的 kio 和 kinit，前者提供類似 FUSE 的資源訪問抽象層，
後者初始化 KDE 桌面環境。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="freetype2 harfbuzz" class="img-responsive" src="//farseerfc.me/images/pacvis-freetype2-harfbuzz.png" style="width: 45%;"/&gt;
&lt;p class="caption"&gt;freetype2 和 harfbuzz 之間的循環依賴&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;因爲這些循環依賴的存在，使得 PacVis 在實現時不能直接拓撲排序，我採用環探測
算法找出有向圖中所有的環，並且打破這些環，然後再使用拓撲排序。
因此我在圖中用紅色的箭頭表示這些會導致環的依賴關係。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id20"&gt;有些包沒有依賴關係&lt;/a&gt;&lt;/h3&gt;
&lt;div class="figure"&gt;
&lt;img alt="PacVis Level 0" class="img-responsive" src="//farseerfc.me/images/pacvis-level0.png" style="width: 45%;"/&gt;
&lt;p class="caption"&gt;man-pages 和 licenses 沒有依賴關係&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;有些包既不被別的包依賴，也不依賴別的包，而是孤立在整張圖中，比如
man-pages 和 licenses 。這些包在圖中位於最頂端，拓撲層級是 0 ，我用
&lt;span class="label label-info"&gt;藍色&lt;/span&gt; 正方形特別繪製它們。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="linux"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id21"&gt;只看依賴關係的話 Linux 內核完全不重要&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;所有用戶空間的程序都依賴着 glibc ，而 glibc 則從定義良好的 syscall 調用內核。
因此理所當然地，如果只看用戶空間的話， glibc 和別的 GNU 組件是整個 GNU/Linux
發行版的中心，而 Linux 則是位於依賴層次中很深的位置，甚至在我的 demo 服務器上
Linux 位於整個圖中的最底端，因爲它的安裝腳本依賴 mkinitcpio
而後者依賴了系統中的衆多組件。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pacman-qtd"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id22"&gt;pacman -Qtd 不能找到帶有循環依賴的孤兒包&lt;/a&gt;&lt;/h3&gt;
&lt;div class="figure"&gt;
&lt;img alt="pacman -Qtd cannot find packages with circle dependency" class="img-responsive" src="//farseerfc.me/images/pacvis-circledeps-Qtd.png" style="width: 45%;"/&gt;
&lt;p class="caption"&gt;msys2 中帶有循環依賴的孤兒包&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;這是我在 msys2 上測試 PacVis 的時候發現的，我看到在渲染的圖中有一片羣島，
沒有連上任何手動安裝的包。這種情況很不正常，因爲我一直在我的所有系統中跑
&lt;code class="code"&gt;
pacman -Qtd&lt;/code&gt;
 找出孤兒包並刪掉他們。放大之後我發現這些包中有一條循環依賴，
這說明 &lt;code class="code"&gt;
pacman -Qtd&lt;/code&gt;
 不能像語言的垃圾回收機制那樣找出有循環依賴的孤兒包。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id23"&gt;PacVis 的未來&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;目前的 PacVis 基本上是我最初開始做的時候設想的樣子，隨着開發逐漸又增加了不少功能。
一些是迫於佈局算法的性能而增加的（比如限制層數）。&lt;/p&gt;
&lt;p&gt;今後準備再加入以下這些特性：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;更合理的 optdeps 處理。目前只是把 optdeps 關係在圖上畫出來了。&lt;/li&gt;
&lt;li&gt;更合理的 &lt;strong&gt;依賴關係抉擇&lt;/strong&gt; 。有時候包的依賴關係並不是直接根據包名，而是
&lt;code class="code"&gt;
provides&lt;/code&gt;
 由一個包提供另一個包的依賴。目前 PacVis 用 alpm
提供的方式抉擇這種依賴，於是這種關係並沒有記錄在圖上。&lt;/li&gt;
&lt;li&gt;目前的層級關係沒有考慮包所在的倉庫 (core/extra/community/...) 或者包所屬的組。
加入這些關係能更清晰地表達依賴層次。&lt;/li&gt;
&lt;li&gt;目前沒有辦法只顯示一部分包的關係。以後準備加入像 pactree/pacgraph 一樣顯示部分包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你希望 PacVis 出現某些有趣的用法和功能，也
&lt;a class="reference external" href="https://github.com/farseerfc/pacvis/issues"&gt;請給我提 issue&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="python"></category><category term="pacvis"></category><category term="pacman"></category><category term="arch"></category><category term="linux"></category><category term="pacgraph"></category></entry><entry><title>X 中的混成器與 Composite 擴展</title><link href="//farseerfc.me/compositor-in-X-and-compositext.html" rel="alternate"></link><published>2015-03-19T17:45:00+09:00</published><updated>2015-03-19T17:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-03-19:/compositor-in-X-and-compositext.html</id><summary type="html">
&lt;p&gt;在上篇文章 &lt;a class="reference external" href="//farseerfc.me/brief-history-of-compositors-in-desktop-os.html"&gt;「桌面系統的混成器簡史」&lt;/a&gt;
中我介紹了其它桌面系統中的混成器的發展史和工作原理，
話題回到我們的正題 Linux 系統上，來說說目前 X 中混成器是如何工作的。
這篇文章將比上一篇深入更多技術細節，不想看太多細節的可以直接跳過看 &lt;a class="reference external" href="#id6"&gt;結論&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="x"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;原始的 X 的繪圖模型&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先，沒有混成器的時候 X 是這樣畫圖的：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/e06d011e.png"/&gt;
&lt;p&gt;X 的應用程序沒有統一的繪圖 API 。GTK+ 在 3.0 之後統一用 &lt;a class="reference external" href="http://cairographics.org/"&gt;Cairo&lt;/a&gt; 繪圖，
而 Cairo 則是基於 PDF 1.4 的繪圖模型構建的，
GTK 的 2.0 和之前的版本中也有很大一部分的繪圖是用 Cairo 進行，
其餘則通過 xlib 或者 xcb 調用 X 核心協議提供的繪圖原語繪圖 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
&lt;p&gt;在上篇文章 &lt;a class="reference external" href="//farseerfc.me/brief-history-of-compositors-in-desktop-os.html"&gt;「桌面系統的混成器簡史」&lt;/a&gt;
中我介紹了其它桌面系統中的混成器的發展史和工作原理，
話題回到我們的正題 Linux 系統上，來說說目前 X 中混成器是如何工作的。
這篇文章將比上一篇深入更多技術細節，不想看太多細節的可以直接跳過看 &lt;a class="reference external" href="#id6"&gt;結論&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="x"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;原始的 X 的繪圖模型&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先，沒有混成器的時候 X 是這樣畫圖的：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/e06d011e.png"/&gt;
&lt;p&gt;X 的應用程序沒有統一的繪圖 API 。GTK+ 在 3.0 之後統一用 &lt;a class="reference external" href="http://cairographics.org/"&gt;Cairo&lt;/a&gt; 繪圖，
而 Cairo 則是基於 PDF 1.4 的繪圖模型構建的，
GTK 的 2.0 和之前的版本中也有很大一部分的繪圖是用 Cairo 進行，
其餘則通過 xlib 或者 xcb 調用 X 核心協議提供的繪圖原語繪圖。
QT 的情況也是類似，基本上用 QPaint 子系統繪製成位圖然後交給 X 的顯示服務器。
顯示服務器拿到這些繪製請求之後，再在屏幕上的相應位置繪製整個屏幕。
當然還有很多老舊的不用 GTK 或者 QT 的程序，他們則直接調用 X 核心協議提供的繪圖原語。&lt;/p&gt;
&lt;p&gt;值得注意一點是 X 上除了沒有統一的繪圖模型，也沒有統一的矢量圖格式。
X 核心協議的繪圖原語提供的是像素單位的繪圖操作，沒有類似 GDI+ 或者 Quartz
提供的 &lt;ruby&gt;&lt;rb&gt;設備無關&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Device Independence&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的「點」的抽象。所以只用 X
的繪圖原語的話，我們可以把 (1,1) 這個像素點塗黑，但是不能把 (0.5, 0.5)
這個點塗黑，這一設計缺陷在
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix Hater's Handbook&lt;/a&gt;
中已經被吐槽過了。因爲這個缺陷，所以直接用 X 繪圖原語繪製的圖像不能像
矢量圖那樣進行無損縮放。同樣的缺陷導致 X 繪圖原語繪製的字符不能做到
&lt;ruby&gt;&lt;rb&gt;子像素級&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;subpixel-level&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; &lt;ruby&gt;&lt;rb&gt;抗鋸齒&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;anti-aliasing&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
（這解釋了默認配置下的 xterm 和
&lt;a class="reference external" href="http://arch.acgtyrant.com/2015/01/05/I-do-not-recommend-urxvt-again-now/"&gt;urxvt 中的字體渲染爲什麼難看&lt;/a&gt;
）。相比之下 GDI 有對應的 WMF 矢量圖格式， Quartz 有對應的 PDF 矢量圖格式，
而 X 中沒有這樣的格式對應。因爲沒有統一的矢量圖格式，所以無論是 Cairo 、QPaint
還是沒有用這些繪圖庫但是同樣在意字體和曲線渲染效果的程序（比如 Firefox 和
Chromium）都需要首先渲染到內部的 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/X_PixMap"&gt;XPixMap&lt;/a&gt;
位圖格式，做好子像素渲染和矢量縮放，然後再把渲染好的位圖轉交給 X 圖形服務器。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="composite"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;通過 Composite 擴展重定向窗口輸出&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2004年發佈的 X11R6.8 版本的 Xorg 引入了
&lt;a class="reference external" href="http://freedesktop.org/wiki/Software/CompositeExt/"&gt;Composite 擴展&lt;/a&gt;
。這個擴展背後的動機以及前因後果在一篇文章
&lt;a class="reference external" href="http://keithp.com/~keithp/talks/xarch_ols2004/xarch-ols2004-html/"&gt;The (Re)Architecture of the X Window System&lt;/a&gt;
中有詳細的表述。Composite 擴展允許某個 X 程序做這幾件事情：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;通過 &lt;code class="code"&gt;
RedirectSubwindows&lt;/code&gt;
 調用將一個窗口樹中的所有窗口渲染重定向到
&lt;ruby&gt;&lt;rb&gt;內部存儲&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;off-screen storage&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。重定向的時候可以指定讓 X
自動更新窗口的內容到屏幕上或者由混成器手動更新。&lt;/li&gt;
&lt;li&gt;通過 &lt;code class="code"&gt;
NameWindowPixmap&lt;/code&gt;
 取得某個窗口的內部存儲。&lt;/li&gt;
&lt;li&gt;通過 &lt;code class="code"&gt;
GetOverlayWindow&lt;/code&gt;
 獲得一個特殊的用於繪圖的窗口，
在這個窗口上繪製的圖像將覆蓋在屏幕的最上面。&lt;/li&gt;
&lt;li&gt;通過 &lt;code class="code"&gt;
CreateRegionFromBorderClip&lt;/code&gt;
 取得某個窗口的邊界剪裁區域（不一定是矩形）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了 Composite 擴展，一個 X 程序就可以調用這些 API 實現混成器。
這裏有篇 &lt;a class="reference external" href="http://www.talisman.org/~erlkonig/misc/x11-composite-tutorial/"&gt;教學解釋如何使用 Composite 擴展&lt;/a&gt; 。開啓了混成的 X 是這樣繪圖的：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/18f7774d.png"/&gt;
&lt;p&gt;整個 X 的混成器模型與 Mac OS X 的混成器模型相比，有如下幾點顯著的區別：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;混成的部分是交由外部的程序完成的，對混成的繪製方式和繪製普通窗口一樣。
出於效率考慮，絕大多數 X 上的混成器額外使用了 XRender 擴展或者
OpenGL/EGL 來加速繪製貼圖。不過即使如此，還是不能避免同樣的位圖（內容不一定完全一致，
比如 X 可以在窗口交給它的位圖上加上邊框然後再返還給混成器） &lt;strong&gt;在不同的三個程序之間來回傳遞&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code class="code"&gt;
RedirectSubwindows&lt;/code&gt;
 調用針對的是一個窗口樹，換句話說是一個窗口
及其全部子窗口，不同於 Mac OS X 中混成器會拿到全部窗口的輸出。
這個特點其實並不算是限制，因爲 X 中每個虛擬桌面都有一個根窗口，只要指定這個根窗口
就可以拿到整個虛擬桌面上的全部可見窗口輸出了。
反而這個設計提供了一定的自由度，比如我們可以用這個調用實現一個截圖程序，
拿到某個特定窗口的輸出，而不用在意別的窗口。&lt;/li&gt;
&lt;li&gt;爲了讓窗口有輸出，窗口必須顯示在當前桌面上，不能處於最小化
狀態或者顯示在別的虛擬桌面，用 X 的術語說就是窗口必須處於 &lt;ruby&gt;&lt;rb&gt;被映射&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;mapped&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
的狀態。因此直接用上述方法 &lt;strong&gt;不能得到沒有顯示的窗口的輸出&lt;/strong&gt; ，比如不能對最小化的窗口
直接實現 Windows 7 中的 Aero Peak 之類的效果。這個限制可以想辦法繞開，
比如在需要窗口輸出的時候臨時把窗口映射到桌面上，拿到輸出之後再隱藏起來，
不過要實現這一點需要混成器和窗口管理器相互配合。&lt;/li&gt;
&lt;li&gt;不像 Mac OS X 的基於 OpenGL Surface 的繪圖模型是 &lt;ruby&gt;&lt;rb&gt;設備無關&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;device independent&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
的，這裏 X 的繪圖模型是 &lt;ruby&gt;&lt;rb&gt;設備相關&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;device dependent&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的。
這既是優點也是缺點。從缺點方面而言，顯示到 X 的位圖輸出因爲設備相關性，
所以嚴格對應顯示器的點陣，並不適合作爲文檔格式打印出來。當然無論是 Cairo
還是 QPaint 都提供了到 PostScript 或者 PDF 後端的輸出，所以實用層面這個並不構成問題。
設備相關這一點的優點在於，繪製到 XPM 位圖的時候，程序和繪圖庫是能拿到輸出設備（顯示器）
的特殊屬性的，從而繪圖庫能考慮不同的色彩、分辨率、 DPI 或者
&lt;ruby&gt;&lt;rb&gt;子像素佈局&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;subpixel layout&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 這些屬性以提供最好的渲染效果。
Mac OS X 10.4 在設計的時候也曾考慮過提供無極縮放的支持，而這種支持到了 Mac OS X
10.5 中就縮水變成了 Retina 的固定 2 倍縮放。這種局面在 X
上沒有發生正是因爲 X 的繪圖模型的這種設備相關性，而 Mac OS X 的混成器採用的
OpenGL Surface 則無視了這些設備相關的屬性。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;輸入事件的重定向，這可能做到麼？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通過上述 Composite 擴展提供的 API ，混成器可以把窗口的 &lt;strong&gt;輸出&lt;/strong&gt; 重定向到自己的窗口上。
但是僅僅重定向輸出，整個 X 還不處於可用狀態，因爲 &lt;strong&gt;沒有重定向輸入&lt;/strong&gt; 。
考慮一下用戶試圖用鼠標點擊某個按鈕或者文本框，這時鼠標處於的位置是在 OverlayWindow
上繪製的位置，這個鼠標事件會交給 OverlayWindow ，而用戶期待這個事件被發送給他看到的按鈕上。&lt;/p&gt;
&lt;p&gt;需要重定向的事件主要有鍵盤和鼠標事件兩大類（暫時先不考慮觸摸屏之類的額外輸入）。
由於 Composite 擴展並沒有直接提供這方面的重定向 API ，這使得輸入事件處理起來都比較麻煩，&lt;/p&gt;
&lt;p&gt;假設要重定向鍵盤事件，混成器需要效仿輸入法框架（fcitx, ibus, scim）
那樣處理一部分按鍵事件並把其餘事件轉給具有輸入焦點的程序。
看看現有的輸入法框架和諸多程序間的問題，我們就能知道這裏的坑有多深。
於是 &lt;strong&gt;大部分 X 的混成器都不處理鍵盤事件重定向&lt;/strong&gt;
。再來看重定向鼠標事件，這邊的坑比重定向鍵盤事件的坑更多，
因爲不像重定向窗口輸出那樣只需要考慮 &lt;ruby&gt;&lt;rb&gt;頂層&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;top-level&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 窗口，
重定向鼠標輸入的時候要考慮所有子窗口（它們有獨立的事件隊列），
以及要準確記錄輸入事件事件發生時的鍵盤組合鍵狀態，還要正確實現 ICCCM/EWMH
中描述的轉交窗口焦點的複雜規則，所有這些都已經在 X 中實現過的事情需要重新實現一遍。&lt;/p&gt;
&lt;p&gt;由於坑太多難以實現，所以所有 X 下的混成器的實現方式都是直接忽略這個繁重的任務，
&lt;strong&gt;不重定向輸入事件&lt;/strong&gt; 而把它交給 X 處理。具體的實現方式就是通過
&lt;a class="reference external" href="http://freedesktop.org/wiki/Software/FixesExt/"&gt;XFixes&lt;/a&gt;
擴展提供的 &lt;code class="code"&gt;
SetWindowShapeRegion&lt;/code&gt;
 API 將 OverlayWindow 的 &lt;strong&gt;輸入區域&lt;/strong&gt;
&lt;code class="code"&gt;
ShapeInput&lt;/code&gt;
 設爲空區域，從而忽略對這個 OverlayWindow 的一切鼠標鍵盤事件。
這樣一來對 OverlayWindow 的點擊會透過 OverlayWindow 直接作用到底下的窗口上。&lt;/p&gt;
&lt;p&gt;因爲選擇了不重定向輸入事件， X 下的混成器通常會處於以下兩種狀態：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;選擇狀態下可以縮放窗口的大小，扭曲窗口的形狀，並且可以把窗口繪製在任意想要繪製的位置上
（並不是移動窗口的位置）， &lt;strong&gt;但是不能讓用戶與窗口的內容交互&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;正常狀態下可以讓用戶與窗口的內容交互，但是
&lt;strong&gt;繪製的窗口位置、大小和形狀必須嚴格地和 X 記錄的窗口的位置、大小和形狀保持一致&lt;/strong&gt;
。持續時間短暫的動畫效果可以允許位置和形狀稍有偏差，但是在動畫的過程中如果用戶點擊了
變形縮放過的窗口，那麼鼠標事件將發往錯誤的（ X 記錄中的而非顯示出的）窗口元素上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以發現這兩種狀態就直接對應了 Gnome 3 的普通狀態和縮略圖狀態（點擊 &lt;ruby&gt;&lt;rb&gt;活動&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Activity&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
或者戳畫面左上角之後顯示的狀態），這也解釋了爲什麼儘管 Gnome 3
的窗口有碩大的關閉按鈕，但是在縮略圖狀態下 Gnome 3 仍然需要給窗口加上額外的關閉按鈕：
&lt;strong&gt;因爲處於縮略狀態下的窗口只是一張畫而不能點&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;Composite 擴展的這些限制使得 X 下的混成器目前只能實現 Mac OS X 那樣的 Exposé
效果，而不能實現 &lt;a class="reference external" href="//farseerfc.me/brief-history-of-compositors-in-desktop-os.html#project-looking-glass-3d"&gt;LG3D&lt;/a&gt; 那樣直接在 3D 空間中操縱窗口內容。&lt;/p&gt;
&lt;p&gt;解決重定向問題曾經的一縷曙光是 &lt;ruby&gt;&lt;rb&gt;昇陽公司&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Sun Microsystems&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 在開發 &lt;a class="reference external" href="//farseerfc.me/brief-history-of-compositors-in-desktop-os.html#project-looking-glass-3d"&gt;LG3D&lt;/a&gt; 的過程中同時提議過另一個 X
擴展叫做 Event Interception 或者簡稱 &lt;a class="reference external" href="http://freedesktop.org/wiki/Software/XEvIE/"&gt;XEvIE&lt;/a&gt; ，這個擴展的設計目的就是提供 API
讓某個程序接收並操縱全部的鍵盤和鼠標事件。可惜這個擴展隨着昇陽公司本身的隕落而
處於無人維護的狀態，這一點也在它的官方網頁上說明了：&lt;/p&gt;
&lt;blockquote&gt;
It has been suggested that this extension should not be used
because it is broken and maintainerless.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;Composite 擴展的不足&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通過上面的介紹，我們就已經可以看到 Composite 擴展的不足之處了。
總結起來說，主要有兩大不足：&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;繪圖效率低。因爲同樣的位圖從應用程序傳到 Xorg ，再從 Xorg 傳到混成器，
最後從混成器再繪製到屏幕上，繞了一個大彎。這就是爲什麼 Wayland 的開發者在他的slide
&lt;a class="reference external" href="http://people.freedesktop.org/~daniels/lca2013-wayland-x11.pdf"&gt;the real story behind Wayland and X&lt;/a&gt;
裏這麼說：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;and what's the X server? really bad IPC&lt;/p&gt;
&lt;p&gt;那麼 X 服務器到底做了什麼呢？ 非常糟糕的進程間通訊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;沒有重定向輸入事件。如果我們要在 X 的混成器裏做這個事情，
基本上我們要全部重寫一遍 X 已經寫好的窗口事件分發邏輯。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然同樣要重寫，爲什麼不直接重寫一遍 X 呢，扔掉那些歷史負擔，扔掉那些無用的 API
，重新設計可擴展的 API ，做好快速安全的 IPC —— 嗯，重寫 X 就是 Wayland 的目的。&lt;/p&gt;
&lt;p&gt;不過這麼重寫了的 Wayland 還是我們熟悉可愛的 X 麼？它有哪些地方變樣了？
這將是我下一篇文章的內容。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;附錄：擴展閱讀&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我自己沒有寫過窗口管理器，沒有寫過混成器，沒有寫過 Wayland
程序，以上說的都是我從互聯網上看到的整理出來的內容。寫下本文的過程中我參考了這些文章：&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://keithp.com/~keithp/talks/xarch_ols2004/xarch-ols2004-html/"&gt;The (Re)Architecture of the X Window System&lt;/a&gt; 這篇2004年寫的文章描述了 Composite
擴展出現的動機和歷史，介紹了繪圖庫的實現情況，涉及了上面所說的那些 X 擴展被用到的情況和可能。
同時這篇文章還展望了很多現在的 X 已然實現了的功能，比如 OpenGL 和 X 的結合方面我們有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/GLX"&gt;GLX&lt;/a&gt; 和 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/AIGLX"&gt;AIGLX&lt;/a&gt;
，比如內核的顯卡支持方面我們有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Direct_Rendering_Infrastructure"&gt;DRI&lt;/a&gt; 和 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Mode_setting"&gt;KMS&lt;/a&gt; 。總之這是一篇描述 Linux
桌面未來的發展軌跡的非常有閱讀價值的歷史文獻。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://wingolog.org/archives/2008/07/26/so-you-want-to-build-a-compositor"&gt;so you want to build a compositor&lt;/a&gt; 這是一篇 2008 年寫的博文，介紹如何用 Clutter
實現一個最簡單的混成器。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.talisman.org/~erlkonig/misc/x11-composite-tutorial/"&gt;Composite tutorial&lt;/a&gt; 這是另一篇介紹如何實現一個簡單的混成器的博文，用 Qt 實現，但是同樣很底層。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://projects.mini-dweeb.org/projects/unagi"&gt;unagi&lt;/a&gt; 這是一個可用的（但是已經長期沒有開發的）類似 xcompmgr 的混成器。這個項目貌似
是一位研究生的碩士畢業設計，同時他公開了碩士學位的畢業論文
&lt;a class="reference external" href="http://projects.mini-dweeb.org/attachments/download/3/report.pdf"&gt;Master thesis: Writing an X compositing manager&lt;/a&gt;
其中也對實現一個簡單的混成器做了詳盡描述，包括介紹了相關的 X 擴展和調用。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="linux"></category><category term="wayland"></category><category term="xorg"></category><category term="compositor"></category></entry><entry><title>桌面系統的混成器簡史</title><link href="//farseerfc.me/brief-history-of-compositors-in-desktop-os.html" rel="alternate"></link><published>2015-03-19T13:45:00+09:00</published><updated>2015-03-19T13:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-03-19:/brief-history-of-compositors-in-desktop-os.html</id><summary type="html">
&lt;p&gt;（原本是想寫篇關於 Wayland 的文章，後來越寫越長感覺能形成一個系列，
於是就先把這篇背景介紹性質的部分發出來了。）&lt;/p&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;Linux 系統上要迎來 Wayland 了，或許大家能從各種渠道打聽到 Wayland
是一個混成器，替代 X 作爲顯示服務器。
那麼 &lt;strong&gt;混成器&lt;/strong&gt; 是個什麼東西，桌面系統爲什麼需要它呢？
要理解爲什麼桌面系統需要 &lt;strong&gt;混成器&lt;/strong&gt; （或者它的另一個叫法，
&lt;ruby&gt;&lt;rb&gt;混成窗口管理器&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Compositing Window Manager&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
），在這篇文章中我想回顧一下歷史，
瞭解一下混成器出現的前因後果。&lt;/p&gt;
&lt;p&gt;首先介紹一下混成器出現前主要的一類窗口管理器，也就是
&lt;ruby&gt;&lt;rb&gt;棧式窗口管理器&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Stacking Window Manager&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的實現方式。&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="label label-warning"&gt;
本文中所有桌面截圖來自維基百科，不具有著作權保護。&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;早期的棧式窗口管理器&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
棧式窗口管理器的例子，Windows 3.11 的桌面&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="棧式窗口管理器的例子，Windows 3.11 的桌面" class="img-responsive" src="//farseerfc.me/images/Windows_3.11_workspace.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;我們知道最初圖形界面的應用程序是全屏的，獨佔整個顯示器（現在很多遊戲機和手持設備的實現仍舊如此）。
所有程序都全屏並且任何時刻只能看到一個程序的輸出，這個限制顯然不能滿足人們使用計算機的需求，
於是就有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/WIMP_(computing)"&gt;窗口 …&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
&lt;p&gt;（原本是想寫篇關於 Wayland 的文章，後來越寫越長感覺能形成一個系列，
於是就先把這篇背景介紹性質的部分發出來了。）&lt;/p&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;Linux 系統上要迎來 Wayland 了，或許大家能從各種渠道打聽到 Wayland
是一個混成器，替代 X 作爲顯示服務器。
那麼 &lt;strong&gt;混成器&lt;/strong&gt; 是個什麼東西，桌面系統爲什麼需要它呢？
要理解爲什麼桌面系統需要 &lt;strong&gt;混成器&lt;/strong&gt; （或者它的另一個叫法，
&lt;ruby&gt;&lt;rb&gt;混成窗口管理器&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Compositing Window Manager&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
），在這篇文章中我想回顧一下歷史，
瞭解一下混成器出現的前因後果。&lt;/p&gt;
&lt;p&gt;首先介紹一下混成器出現前主要的一類窗口管理器，也就是
&lt;ruby&gt;&lt;rb&gt;棧式窗口管理器&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Stacking Window Manager&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的實現方式。&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="label label-warning"&gt;
本文中所有桌面截圖來自維基百科，不具有著作權保護。&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;早期的棧式窗口管理器&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
棧式窗口管理器的例子，Windows 3.11 的桌面&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="棧式窗口管理器的例子，Windows 3.11 的桌面" class="img-responsive" src="//farseerfc.me/images/Windows_3.11_workspace.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;我們知道最初圖形界面的應用程序是全屏的，獨佔整個顯示器（現在很多遊戲機和手持設備的實現仍舊如此）。
所有程序都全屏並且任何時刻只能看到一個程序的輸出，這個限制顯然不能滿足人們使用計算機的需求，
於是就有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/WIMP_(computing)"&gt;窗口&lt;/a&gt;
的概念，有了 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Desktop_metaphor"&gt;桌面隱喻&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;在 &lt;ruby&gt;&lt;rb&gt;桌面隱喻&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Desktop Metaphor&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 中每個窗口只佔用顯示面積的一小部分，
有其顯示的位置和大小，可以互相遮蓋。於是棧式窗口管理器就是在圖形界面中實現桌面隱喻的核心功能，
其實現方式大體就是：給每個窗口一個相對的“高度”或者說“遠近”，比較高的窗口顯得距離用戶比較近，
會覆蓋其下比較低的窗口。繪圖的時候窗口管理器會從把窗口按高低排序，按照從低到高的順序使用
&lt;a class="reference external" href="http://zh.wikipedia.org/wiki/%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95"&gt;畫家算法&lt;/a&gt;
繪製整個屏幕。&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;p&gt;這裏還要補充一點說明，在當時圖形界面的概念剛剛普及的時候，繪圖操作是非常“昂貴”的。
可以想象一下 800x600 像素的顯示器輸出下，每幀
&lt;a class="reference external" href="http://zh.wikipedia.org/wiki/%E7%9C%9F%E5%BD%A9%E8%89%B2"&gt;真彩色&lt;/a&gt;
位圖就要佔掉 &lt;span class="math"&gt;\(800 \times 600 \times 3 \approx 1.4 \text{MiB}\)&lt;/span&gt; 的內存大小，30Hz
的刷新率（也就是30FPS）下每秒從 CPU 傳往繪圖設備的數據單單位圖就需要
&lt;span class="math"&gt;\(1.4 \times 30 = 41 \text{MiB}\)&lt;/span&gt; 的帶寬。對比一下當時的
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/VESA_Local_Bus"&gt;VESA 接口&lt;/a&gt; 總的數據傳輸能力也就是
&lt;span class="math"&gt;\(25 \text{MHz} \times 32 \text{bits} = 100 \text{MiB/s}\)&lt;/span&gt; 左右，
而 Windows 3.1 的最低內存需求是 1MB，對當時的硬件而言無論是顯示設備、內存或是CPU，
這無疑都是一個龐大的負擔。&lt;/p&gt;
&lt;p&gt;於是在當時的硬件條件下採用棧式窗口管理器有一個巨大 &lt;strong&gt;優勢&lt;/strong&gt; ：如果正確地採用畫家算法，
並且合理地控制重繪時 &lt;strong&gt;只繪製沒有被別的窗口覆蓋的部分&lt;/strong&gt; ，那麼無論有多少窗口互相
遮蓋，都可以保證每次繪製屏幕的最大面積不會超過整個顯示器的面積。
同樣因爲實現方式棧式窗口管理器也有一些難以迴避的 &lt;strong&gt;限制&lt;/strong&gt; ：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;窗口必須是矩形的，不能支持不規則形狀的窗口。&lt;/li&gt;
&lt;li&gt;不支持透明或者半透明的顏色。&lt;/li&gt;
&lt;li&gt;爲了優化效率，在縮放窗口和移動窗口的過程中，窗口的內容不會得到重繪請求，
必須等到縮放或者移動命令結束之後窗口纔會重繪。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上這些限制在早期的 X11 窗口管理器比如 twm 以及 XP 之前經典主題的 Windows
或者經典的 Mac OS 上都能看到。
在這些早期的窗口環境中，如果你拖動或者縮放一個窗口，那麼將顯示變化後的窗口邊界，
這些用來預覽的邊界用快速的位圖反轉方式繪製。當你放開鼠標的時候纔會觸發窗口的
重繪事件。
雖然有很多方法或者說技巧能繞過這些限制，比如 Windows XP 上就支持了實時的
重繪事件和不規則形狀的窗口剪裁，不過這些技巧都是一連串的 hack ，難以擴展。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nextstep-mac-os-x"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;NeXTSTEP 與 Mac OS X 中混成器的發展&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
NeXTSTEP 桌面&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="NeXTSTEP 桌面" class="img-responsive" src="//farseerfc.me/images/NeXTSTEP_desktop.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;轉眼進入了千禧年， Windows 稱霸了 PC 產業，蘋果爲重振 Macintosh 請回了 Jobs 基於 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/NeXTSTEP"&gt;NeXTSTEP&lt;/a&gt;
開發 Mac OSX 。&lt;/p&gt;
&lt;p&gt;NeXTSTEP 在當時提供的 GUI 界面技術相比較於同年代的 X 和 Windows 有一個很特別的地方：
拖動滾動條或者移動窗口的時候，窗口的內容是 &lt;strong&gt;實時更新&lt;/strong&gt; 的，這比只顯示一個縮放大小的框框來說被認爲更直觀。
而實現這個特性的基礎是在 NeXTSTEP 中運用了
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Display_PostScript"&gt;Display PostScript (DPS)&lt;/a&gt;
技術，簡單地說，就是每個窗口並非直接輸出到顯示設備，而是把內容輸出到 (Display) PostScript
格式交給窗口管理器，然後窗口管理器再在需要的時候把 PostScript 用軟件解釋器解釋成位圖顯示在屏幕上。&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/8d293c10.png"/&gt;
&lt;p&gt;比起讓窗口直接繪製，這種方案在滾動和移動窗口的時候不需要重新渲染保存好的 DPS ，
所以能實現實時渲染。到了實現 Mac OS X 的時候，爲了同時兼容老的 Mac 程序 API (carbon)
以及更快的渲染速度，以及考慮到 Adobe 對蘋果收取的高昂的 Display PostScript 授權費，
Mac OS X 的 Quartz 技術在矢量圖的 PDF 描述模型和最終渲染之間又插入了一層抽象：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/5807c26a.png"/&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Mission Control&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Mission Control" class="img-responsive" src="//farseerfc.me/images/Mac_OS_X_Lion_Preview_-_Mission_Control.jpg"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;也就是說在 Mac OS X 中無論窗口用何種方式繪圖，都會繪製輸出成一副內存中的位圖交給混成器，
而後者再在需要的時候將位圖混成在屏幕上。這種設計使得 2001年3月發佈的 Mac OS X v10.0
成爲了第一個廣泛使用的具有軟件混成器的操作系統。&lt;/p&gt;
&lt;p&gt;到了 Mac OS X v10.2 的時候，蘋果又引入了 Quartz Extreme 讓最後的混成渲染這一步發生在
顯卡上。然後在 2003年1月公開亮相的 Mac OS X v10.3 中，他們公佈了 Exposé (後來改名爲
Mission Control) 功能，把窗口的縮略圖（而不是事先繪製的圖標）並排顯示在桌面上，
方便用戶挑選打開的窗口。&lt;/p&gt;
&lt;p&gt;由於有了混成器的這種實現方式，使得可能把窗口渲染的圖像做進一步加工，添加陰影、三維和動畫效果。
這使得 Mac OS X 有了美輪美奐的動畫效果和 Exposé 這樣的方便易用的功能。
或許對於喬布斯而言，更重要的是因爲有了混成器，窗口的形狀終於能顯示爲他
&lt;a class="reference external" href="http://www.folklore.org/StoryView.py?story=Round_Rects_Are_Everywhere.txt"&gt;夢寐以求&lt;/a&gt;
的 &lt;a class="reference external" href="http://www.uiandus.com/blog/2009/7/26/realizations-of-rounded-rectangles.html"&gt;圓角矩形&lt;/a&gt;
了！&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="project-looking-glass-3d"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;插曲：曇花一現的 Project Looking Glass 3D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在蘋果那邊剛剛開始使用混成器渲染窗口的 2003 年，昔日的 &lt;ruby&gt;&lt;rb&gt;昇陽公司&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Sun Microsystems&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
則在 Linux 和 Solaris 上用 Java3D 作出了另一個炫酷到沒有朋友的東西，被他們命名爲
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Project_Looking_Glass"&gt;Project Looking Glass 3D&lt;/a&gt;
（縮寫LG3D，別和 Google 的 Project Glass 混淆呀）。這個項目的炫酷實在難以用言語描述，
好在還能找到兩段視頻展示它的效果。&lt;/p&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_JXv8VlpoK_g"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/JXv8VlpoK_g"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XOTEzMzM3MTY0"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XOTEzMzM3MTY0" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_JXv8VlpoK_g"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XOTEzMzM3MTY0"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_zcPIEMvyPy4"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/zcPIEMvyPy4"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XOTEzMzQwMjky"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XOTEzMzQwMjky" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_zcPIEMvyPy4"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XOTEzMzQwMjky"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
LG3D&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="LG3D" class="img-responsive" src="//farseerfc.me/images/LG3D.jpg"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如視頻中展示的那樣， LG3D 完全突破了傳統的棧式窗口管理方式，
在三維空間中操縱二維的窗口平面，不僅像傳統的窗口管理器那樣可以縮放和移動窗口，
還能夠旋轉角度甚至翻轉到背面去。從視頻中難以體會到的一點是， LG3D 在實現方式上與
Mac OS X 中的混成器有一個本質上的不同，那就是處於（靜止或動畫中）縮放或旋轉狀態
下的窗口是 &lt;strong&gt;可以接受輸入事件&lt;/strong&gt; 的。這一重要區別在後面 Wayland 的說明中還會提到。
LG3D 項目展示了窗口管理器將如何突破傳統的棧式管理的框架，可以說代表了窗口管理器的未來發展趨勢。&lt;/p&gt;
&lt;p&gt;LG3D 雖然以 GPL 放出了實現的源代碼，不過整個項目已經停滯開發許久了。
官方曾經放出過一個
&lt;a class="reference external" href="http://sourceforge.net/projects/lg3d-livecd/"&gt;預覽版的 LiveCD&lt;/a&gt;
。可惜時隔久遠（12年前了）在我的 VirtualBox 上已經不能跑起來這個 LiveCD 了……&lt;/p&gt;
&lt;p&gt;更爲可惜的是，就在這個項目剛剛公開展示出來的時候，喬布斯就致電昇陽，
說如果繼續商業化這個產品，昇陽公司將涉嫌侵犯蘋果的知識產權
（時間順序上來看，蘋果最初展示 Exposé 是在 2003年6月23日的
Apple Worldwide Developers Conference ，而昇陽最初展示
LG3D 是在 2003年8月5日的 LinuxWorld Expo）。
雖然和喬布斯的指控無關，昇陽公司本身的業務也着重於服務器端的業務，
後來隨着昇陽的財政困難，這個項目也就停止開發並不了了之了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="windows"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;Windows 中的混成器&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Longhorn 中的 Wobbly 效果&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_X0idaN0MY1U"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/X0idaN0MY1U"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XOTEzMzY5NjQ0"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XOTEzMzY5NjQ0" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_X0idaN0MY1U"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XOTEzMzY5NjQ0"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面說到， Windows 系列中到 XP 爲止都還沒有使用混成器繪製窗口。
看着 Mac OS X 上有了美輪美奐的動畫效果， Windows 這邊自然不甘示弱。
於是同樣在 2003 年展示的 Project Longhorn 中就演示了 wobbly 效果的窗口，
並且跳票推遲多年之後的 Windows Vista 中實現了完整的混成器
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Desktop_Window_Manager"&gt;Desktop Window Manager (DWM)&lt;/a&gt;
。整個 DWM 的架構和 Mac OS X 上看到的很像：&lt;/p&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/1763baf6.png"/&gt;
&lt;p&gt;和 Mac OS X 的情況類似， Windows Vista 之後的應用程序有兩套主要的繪圖庫，一套是從早期
Win32API 就沿用至今的 GDI（以及GDI+），另一套是隨着 Longhorn 計劃開發出的 WPF 。
WPF 的所有用戶界面控件都繪製在 DirectX 貼圖上，所以使用了 WPF 的程序也可以看作是
DirectX 程序。而對老舊的 GDI 程序而言，它們並不是直接繪製到 DirectX 貼圖的。首先每一個
GDI 的繪圖操作都對應一條
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Windows_Metafile"&gt;Windows Metafile (WMF)&lt;/a&gt;
記錄，所以 WMF 就可以看作是 Mac OS X 的 Quartz 內部用的 PDF 或者 NeXTSTEP 內部用的
DPS，它們都是矢量圖描述。隨後，這些 WMF 繪圖操作被通過一個
Canonical Display Driver (cdd.dll) 的內部組建轉換到 DirectX 平面，並且保存起來交給
DWM。最後， DWM 拿到來自 CDD 或者 DirectX 的平面，把它們混合起來繪製在屏幕上。&lt;/p&gt;
&lt;p&gt;值得注意的細節是，WPF 底層的繪圖庫幾乎肯定有 C/C++ 綁定對應， Windows 自帶的不少應用程序
和 Office 2007 用了 Ribbon 之後的版本都採用這套繪圖引擎，不過微軟沒有公開這套繪圖庫的
C/C++ 實現的底層細節，而只能通過 .Net 框架的 WPF 訪問它。這一點和 OS X 上只能通過
Objective-C 下的 Cocoa API 調用 Quartz 的情況類似。&lt;/p&gt;
&lt;p&gt;另外需要注意的細節是 DirectX 的單窗口限制在 Windows Vista 之後被放開了，或者嚴格的說是
基於 WDDM 規範下的顯卡驅動支持了多個 DirectX 繪圖平面。
在早期的 Windows 包括 XP 上，整個桌面上同一時刻只能有一個程序的窗口處於 DirectX 的
&lt;strong&gt;直接繪製&lt;/strong&gt; 模式，而別的窗口如果想用 DirectX 的話，要麼必須改用軟件渲染要麼就不能工作。
這種現象可以通過打開多個播放器或者窗口化的遊戲界面觀察到。
而在 WDDM 規範的 Vista 中，所有窗口最終都繪製到 DirectX 平面上，換句話說每個窗口都是
DirectX 窗口。又或者我們可以認爲，整個界面上只有一個真正的窗口也就是 DWM 繪製的全屏窗口，
只有 DWM 處於 DirectX 的直接渲染模式下，而別的窗口都輸出到 DirectX 平面裏（可能通過了硬件加速）。&lt;/p&gt;
&lt;p&gt;由 DWM 的這種實現方式，可以解釋爲什麼
&lt;a class="reference external" href="http://gaming.stackexchange.com/questions/13066/why-is-windowed-mode-always-slower-in-games"&gt;窗口模式下的遊戲總是顯得比較慢&lt;/a&gt;
，原因是整個桌面有很多不同的窗口都需要 DWM 最後混成，而如果在全屏模式下，只有遊戲
處於 DirectX 的直接渲染方式，從而不會浪費對遊戲而言寶貴的 GPU 資源。&lt;/p&gt;
&lt;p&gt;由於 DWM 實現了混成器，使得 Vista 和隨後的 Windows 7 有了
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Windows_Aero"&gt;Aero Glass&lt;/a&gt; 的界面風格，
有了 Flip 3D 、Aero Peek 等等的這些輔助功能和動畫效果。
這套渲染方式延續到 Windows 8 之後，雖然 Windows 8 還提出了 Modern UI
不過傳統桌面上的渲染仍舊是依靠混成器來做的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="linux"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;這就結束了？ Linux 桌面呢？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;別急，我寫這些文章的目的是想聊聊 Linux 中的混成器，尤其是 X 下現有的混成器和 Wayland
，這篇文章只是個背景介紹。關於 X 中混成器的實現方式和限制，且聽我下回分解。&lt;/p&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="tech"></category><category term="desktop"></category><category term="compositor"></category><category term="macosx"></category><category term="windows"></category><category term="window"></category><category term="manager"></category></entry><entry><title>避免在博文中寫「簡單地」</title><link href="//farseerfc.me/stop-write-simply.html" rel="alternate"></link><published>2015-03-11T22:00:00+09:00</published><updated>2015-03-11T22:00:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-03-11:/stop-write-simply.html</id><summary type="html">&lt;p&gt;我的 RSS 訂閱着一個博客叫 &lt;a class="reference external" href="http://blogs.msdn.com/b/oldnewthing/"&gt;The Old New Thing&lt;/a&gt;
，作者是Windows開發者之一的 Raymond Chen ，記錄 Windows 中的很多有趣的技術細節。
這個博客中的一些精彩內容還被他寫成了一本書，中文名叫《Windows編程啓示錄》
(ISBN: &lt;a class="reference external" href="http://www.amazon.cn/dp/B0011C1ZEG/"&gt;978-7-111-21919-4&lt;/a&gt;) 而英文書名就叫
&lt;em&gt;The Old New Thing — Practical Development Throughout the Evolution of Windows&lt;/em&gt;
(ISBN: &lt;a class="reference external" href="http://www.amazon.com/gp/product/0321440307"&gt;978-0-321-44030-3&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;今天看到這個博客的一篇文章說
&lt;a class="reference external" href="http://blogs.msdn.com/b/oldnewthing/archive/2015/03/10/10598846.aspx"&gt;你用「簡單地」次數越多我越懷疑你不懂這個詞的意思&lt;/a&gt; ， 描述他看到某個博客上指導讀者打開命令行、執行某條魔法命令、從命令輸出抽取參數、
改寫配置文件、用魔法命令重啓服務，並把這些工作描述爲「簡單地」。&lt;/p&gt;
&lt;p&gt;的確正如 Raymond 指出，一個人覺得簡單的事情對別人並不一定是簡單的。
搜了一下我自己寫的東西，的確很多地方寫了「簡單 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;我的 RSS 訂閱着一個博客叫 &lt;a class="reference external" href="http://blogs.msdn.com/b/oldnewthing/"&gt;The Old New Thing&lt;/a&gt;
，作者是Windows開發者之一的 Raymond Chen ，記錄 Windows 中的很多有趣的技術細節。
這個博客中的一些精彩內容還被他寫成了一本書，中文名叫《Windows編程啓示錄》
(ISBN: &lt;a class="reference external" href="http://www.amazon.cn/dp/B0011C1ZEG/"&gt;978-7-111-21919-4&lt;/a&gt;) 而英文書名就叫
&lt;em&gt;The Old New Thing — Practical Development Throughout the Evolution of Windows&lt;/em&gt;
(ISBN: &lt;a class="reference external" href="http://www.amazon.com/gp/product/0321440307"&gt;978-0-321-44030-3&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;今天看到這個博客的一篇文章說
&lt;a class="reference external" href="http://blogs.msdn.com/b/oldnewthing/archive/2015/03/10/10598846.aspx"&gt;你用「簡單地」次數越多我越懷疑你不懂這個詞的意思&lt;/a&gt; ， 描述他看到某個博客上指導讀者打開命令行、執行某條魔法命令、從命令輸出抽取參數、
改寫配置文件、用魔法命令重啓服務，並把這些工作描述爲「簡單地」。&lt;/p&gt;
&lt;p&gt;的確正如 Raymond 指出，一個人覺得簡單的事情對別人並不一定是簡單的。
搜了一下我自己寫的東西，的確很多地方寫了「簡單」二字，這的確對讀者不友好。&lt;/p&gt;
&lt;p&gt;從今往後避免用「簡單」來描述。&lt;/p&gt;
</content><category term="life"></category><category term="blog"></category><category term="writing"></category></entry><entry><title>用 Travis-CI 生成 Github Pages 博客</title><link href="//farseerfc.me/travis-push-to-github-pages-blog.html" rel="alternate"></link><published>2015-02-20T11:10:00+09:00</published><updated>2015-02-20T11:10:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-02-20:/travis-push-to-github-pages-blog.html</id><summary type="html">
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月21日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;上次介紹過 &lt;a class="reference external" href="//farseerfc.me/redesign-pelican-theme.html"&gt;這個博客改換了主題&lt;/a&gt; ，
本以爲這個話題可以告一段落了，沒想到還能繼續寫呢。&lt;/p&gt;
&lt;p&gt;寄宿在 Github Pages 上的靜態博客通常有兩種方案，其一是使用 &lt;a class="reference external" href="http://jekyllrb.com/"&gt;Jekyll&lt;/a&gt; 方式撰寫，這可以利用
Github Pages 原本就有的
&lt;a class="reference external" href="https://help.github.com/articles/using-jekyll-with-pages/"&gt;Jekyll支持&lt;/a&gt;
生成靜態網站。另一種是在 &lt;strong&gt;本地&lt;/strong&gt; 也就是自己的電腦上生成好，然後把生成的 HTML 網站 push
到 Github Pages ，這種情況下 Github Pages 就完全只是一個靜態頁面宿主環境。&lt;/p&gt;
&lt;p&gt;我用 &lt;a class="reference external" href="http://getpelican.com/"&gt;Pelican&lt;/a&gt; 生成博客，當然就只能選擇後一種方式了。這帶來一些不便，比如本地配置 pelican
還是有一點點複雜的，所以不能隨便找臺電腦就開始寫博客。有的時候只是想修正一兩個錯別字，
這時候必須打開某臺特定的電腦纔能編輯博客就顯得不太方便了。再比如 pelican 本身雖然是 python
寫的所以跨平臺，但是具體到博客的配置方面， Windows …&lt;/p&gt;</summary><content type="html">
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月21日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;上次介紹過 &lt;a class="reference external" href="//farseerfc.me/redesign-pelican-theme.html"&gt;這個博客改換了主題&lt;/a&gt; ，
本以爲這個話題可以告一段落了，沒想到還能繼續寫呢。&lt;/p&gt;
&lt;p&gt;寄宿在 Github Pages 上的靜態博客通常有兩種方案，其一是使用 &lt;a class="reference external" href="http://jekyllrb.com/"&gt;Jekyll&lt;/a&gt; 方式撰寫，這可以利用
Github Pages 原本就有的
&lt;a class="reference external" href="https://help.github.com/articles/using-jekyll-with-pages/"&gt;Jekyll支持&lt;/a&gt;
生成靜態網站。另一種是在 &lt;strong&gt;本地&lt;/strong&gt; 也就是自己的電腦上生成好，然後把生成的 HTML 網站 push
到 Github Pages ，這種情況下 Github Pages 就完全只是一個靜態頁面宿主環境。&lt;/p&gt;
&lt;p&gt;我用 &lt;a class="reference external" href="http://getpelican.com/"&gt;Pelican&lt;/a&gt; 生成博客，當然就只能選擇後一種方式了。這帶來一些不便，比如本地配置 pelican
還是有一點點複雜的，所以不能隨便找臺電腦就開始寫博客。有的時候只是想修正一兩個錯別字，
這時候必須打開某臺特定的電腦纔能編輯博客就顯得不太方便了。再比如 pelican 本身雖然是 python
寫的所以跨平臺，但是具體到博客的配置方面， Windows 環境和 Linux/OSX/Unix-like
環境下還是有
&lt;a class="reference external" href="http://pelican.readthedocs.org/en/latest/settings.html#date-format-and-locale"&gt;些許出入&lt;/a&gt;
的。還有就是沒有像 wordpress 那樣的基於 web
的編輯環境，在手機上就不能隨便寫一篇博客發表出來（不知道有沒有勇士嘗試過在
Android 的 &lt;a class="reference external" href="https://code.google.com/p/android-scripting/"&gt;SL4A&lt;/a&gt; 環境下的 python 中跑 pelican ，還要配合一個
&lt;a class="reference external" href="https://play.google.com/store/apps/details?id=com.romanenco.gitt"&gt;Android 上的 git 客戶端&lt;/a&gt; ）。&lt;/p&gt;
&lt;p&gt;當然並不是因此就束手無策了，感謝 &lt;a class="reference external" href="https://travis-ci.org/"&gt;Travis-CI&lt;/a&gt; 提供了免費的
&lt;ruby&gt;&lt;rb&gt;持续整合&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Continuous integration&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 虛擬機環境，
通過它全自動生成靜態博客成爲了可能。&lt;/p&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;關於 Travis-CI&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88"&gt;持续整合&lt;/a&gt;
原本是 &lt;ruby&gt;&lt;rb&gt;敏捷開發&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Agile Development&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
或者 &lt;ruby&gt;&lt;rb&gt;極限編程&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Extreme Programming&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 中提到的概念，大意就是說在開發的過程中，
一旦有微小的變更，就全自動地 &lt;strong&gt;持續&lt;/strong&gt; 合併到主線中， &lt;strong&gt;整合&lt;/strong&gt; 變更的內容到發佈版本裏。
這裏的 &lt;strong&gt;整合&lt;/strong&gt; 實際上可以理解爲 &lt;strong&gt;全自動測試&lt;/strong&gt; 加上 &lt;strong&gt;生成最終產品&lt;/strong&gt; 。
可以看到 &lt;strong&gt;持續整合&lt;/strong&gt; 實際強調 &lt;strong&gt;全自動&lt;/strong&gt; ，於是需要有一個服務器不斷地監聽主線開發的變更內容，
一旦有任何變更（可以理解爲 git commit ）就自動調用測試和部署腳本。&lt;/p&gt;
&lt;p&gt;於是要用持續整合就需要一個整合服務器，幸而 Travis-CI 對 github 上的公開 repo
提供了免費的整合服務器虛擬機服務，和 github 的整合非常自然。所以我們就可以用它提供的虛擬機
爲博客生成靜態網站。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;啓用 Travis-CI 自動編譯&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;這一步很簡單，訪問 &lt;a class="reference external" href="https://travis-ci.org/"&gt;https://travis-ci.org/&lt;/a&gt; 並用你的 Github 賬戶登錄，
授權它訪問你的賬戶信息就可以了。然後在 &lt;a class="reference external" href="https://travis-ci.org/repositories"&gt;https://travis-ci.org/repositories&lt;/a&gt; 裏開啓
需要編譯的 repo ，這樣 Travis-CI 就會監視對這個 repo 的所有 push 操作，並且對
每個 push 調用測試了。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="在 Travis-CI 中開啓對 Github Repo 的持續整合" class="img-responsive" src="//farseerfc.me/images/travis-repo-enable.png"/&gt;
&lt;p class="caption"&gt;在 Travis-CI 中開啓對 Github Repo 的持續整合&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;然後在 repo 的根目錄放一個 &lt;code class="code"&gt;
.travis.yml&lt;/code&gt;
 文件描述編譯的步驟。
&lt;strong&gt;暫時&lt;/strong&gt; 測試的目的下我寫的 &lt;code class="code"&gt;
.travis.yml&lt;/code&gt;
 大概是下面這樣。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;language&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;python&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nt"&gt;python&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;"2.7"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nt"&gt;before_install&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo apt-add-repository ppa:chris-lea/node.js -y&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo apt-get update&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo apt-get install nodejs ditaa doxygen parallel&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nt"&gt;install&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo pip install pelican&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo pip install jinja2&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo pip install babel&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo pip install beautifulsoup4&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo pip install markdown&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo npm install -g less&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;wget "http://downloads.sourceforge.net/project/plantuml/plantuml.jar?r=&amp;amp;ts=1424308684&amp;amp;use_mirror=jaist" -O plantuml.jar&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo mkdir -p /opt/plantuml&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo cp plantuml.jar /opt/plantuml&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;echo "#! /bin/sh" &amp;gt; plantuml&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;echo 'exec java -jar /opt/plantuml/plantuml.jar "$@"' &amp;gt;&amp;gt; plantuml&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo install -m 755 -D plantuml /usr/bin/plantuml&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;wget https://bintray.com/artifact/download/byvoid/opencc/opencc-1.0.2.tar.gz&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;tar xf opencc-1.0.2.tar.gz&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;cd opencc-1.0.2 &amp;amp;&amp;amp; make &amp;amp;&amp;amp; sudo make install &amp;amp;&amp;amp; cd ..&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo locale-gen zh_CN.UTF-8&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo locale-gen zh_HK.UTF-8&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo locale-gen en_US.UTF-8&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo locale-gen ja_JP.UTF-8&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone --depth 1 https://github.com/farseerfc/pelican-plugins plugins&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone --depth 1 https://github.com/farseerfc/pelican-bootstrap3 theme&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;mkdir output&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;env SITEURL="farseerfc.me" make publish&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Travis-CI 提供的虛擬機是比較標準的 Ubuntu 12.04 LTS ，打上了最新的補丁，並且根據你指定的
語言選項會把相應的解釋器和編譯器升級到最新版（或者指定的版本）。這裏用 python 語言的配置，
所以 python 是 2.7 的最新版並且有 pip 可以直接用。
配置中的 before_install 和 install 的區別其實不大，其中任何一個失敗的話算作
build errored 而不是 build fail ，而如果在 script 裏失敗的話算作 build fail 。&lt;/p&gt;
&lt;p&gt;爲了編譯我的模板，還需要比較新的 less.js ，所以添加了 ppa 裝了個最新的 nodejs
並用它裝上了 less 。
還從源碼編譯安裝上了最新版的 opencc 1.0.2 ，因爲 Ubuntu 源裏的 opencc 的版本比較老(0.4)，
然後 doxygen 作爲 opencc 的編譯依賴也裝上了。
其它安裝的東西麼，除了 pelican 之外都是插件們需要的。以及我還需要生成 4 個語言的 locale
所以調用了 4 次 locale-gen 。由於是比較標準的 Ubuntu 環境，所以基本上編譯的步驟和在本地
Linux 環境中是一樣的，同樣的這套配置應該可以直接用於本地 Ubuntu 下編譯我的博客。&lt;/p&gt;
&lt;p&gt;寫好 &lt;code class="code"&gt;
.travis.yml&lt;/code&gt;
 之後把它 push 到 github ，然後 travis 這邊就會自動 clone
下來開始編譯。 travis 上能看到編譯的完整過程和輸出，一切正常的話編譯結束之後
build 的狀態就會變成 passing ，比如
&lt;a class="reference external" href="https://travis-ci.org/farseerfc/farseerfc/builds/51344614"&gt;我的這次的build&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="travis-ci-github"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;從 Travis-CI 推往 Github&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上面的測試編譯通過了之後，下一步就是讓 travis-ci 編譯的結果自動推到 Github Pages
並發佈出來。要推往 Github 自然需要設置 Github 用戶的身份，在本地設置的時候是把
ssh key 添加到 github 賬戶就可以了，在編譯細節都通過 github repo 公開了的 travis 上
當然不能放推送用的私有 key ，所以我們需要另外一種方案傳遞密碼。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Github 上創建 Personal Access Token&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Github 上創建 Personal Access Token" class="img-responsive" src="//farseerfc.me/images/travis-blog-push.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;好在 Github 支持通過 &lt;a class="reference external" href="https://github.com/settings/applications"&gt;Personal Access Token&lt;/a&gt;
的方式驗證，這個和 App Token 一樣可以隨時吊銷，同時完全是個人創建的。另一方面 Travis-CI
支持加密一些私密數據，通過環境變量的方式傳遞給編譯腳本，避免公開密碼這樣的關鍵數據。&lt;/p&gt;
&lt;p&gt;首先創建一個 &lt;a class="reference external" href="https://github.com/settings/applications"&gt;Personal Access Token&lt;/a&gt;
，這裏需要勾選一些給這個 Token 的權限，我只給予了最小的 public_repo 權限，如側邊裏的圖。
生成之後會得到一長串 Token 的散列碼。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
如果你不能使用 travis 命令&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月21日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;使用 &lt;code class="code"&gt;
travis encrypt&lt;/code&gt;
 命令來加密重要數據最方便，不過如果有任何原因，
比如 ruby 版本太低或者安裝不方便之類的，那麼不用擔心，我們直接通過
&lt;a class="reference external" href="http://docs.travis-ci.com/api/#repository-keys"&gt;travis api&lt;/a&gt;
也能加密數據。&lt;/p&gt;
&lt;p&gt;第一步用這個命令得到你的repo的 pubkey ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;curl -H "Accept: application/vnd.travis-ci.2+json" https://api.travis-ci.org/repos/&amp;lt;github-id/repo&amp;gt;/key | python2 -m json.tool | grep key | sed 's/.*"key": "\(.*\)"/\1/' | xargs -0 echo -en | sed 's/ RSA//' &amp;gt; travis.pem&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的 &amp;lt;github-id/repo&amp;gt; 替換成 github 上的 用戶名/repo名， 比如我的是
farseerfc/farseer 。travis api 獲得的結果是一個 json ，所以還用 python 的
json 模塊處理了一下，然後把其中包含 key 的行用 &lt;code class="code"&gt;
grep&lt;/code&gt;
 提取出來，用
&lt;code class="code"&gt;
sed&lt;/code&gt;
 匹配出 key 的字符串本身，然後 &lt;code class="code"&gt;
xargs -0 echo -en&lt;/code&gt;

解釋掉轉義字符，然後刪掉其中的 "&amp;lt;空格&amp;gt;RSA" 幾個字（否則 openssl 不能讀），
最後保存在名爲 travis.pem 的文件裏。&lt;/p&gt;
&lt;p&gt;有了 pubkey 之後用 openssl 加密我們需要加密的東西並用 base64 編碼：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;echo -n 'GIT_NAME="Jiachen Yang" GIT_EMAIL=farseerfc@gmail.com GH_TOKEN=&amp;lt;Personal Access Token&amp;gt;' | openssl rsautl -encrypt -pubin -inkey travis.pem | base64 -w0&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;替換了相應的身份信息和token之後，這行得到的結果就是 secure 裏要寫的加密過的內容。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然後我們需要 &lt;code class="code"&gt;
travis&lt;/code&gt;
 命令來加密這個 token ， archlinux 用戶可以安裝
&lt;code class="code"&gt;
aur/​ruby-travis&lt;/code&gt;
 ，其它用戶可以用 gems 安裝：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; gem install travis&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;裝好之後，在設定了 Travis-CI 的 repo 的目錄中執行一下 &lt;code class="code"&gt;
travis status&lt;/code&gt;
 ，
命令會指導你登錄 Travis-CI 並驗證 repo 。正常的話會顯示最新的 build 狀態。
然後同樣在這個 repo 目錄下執行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; travis encrypt &lt;span class="s1"&gt;'GIT_NAME="Jiachen Yang" GIT_EMAIL=farseerfc@gmail.com GH_TOKEN=&amp;lt;Personal Access Token&amp;gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;當然上面一行裏的相應信息替換爲個人的信息，作爲這個命令的執行結果會得到另一長串散列碼，
把這串散列寫入剛纔的 &lt;code class="code"&gt;
.travis.yml&lt;/code&gt;
 文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;env&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;secure&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"long&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;secure&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;base64&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;string"&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了這段聲明之後， Travis-CI 就會在每次編譯之前，設置上面加密的環境變量。
然後在編譯腳本中利用這些環境變量來生成博客：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git config --global user.email "$GIT_EMAIL"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git config --global user.name "$GIT_NAME"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git config --global push.default simple&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone --depth 1 https://github.com/farseerfc/pelican-plugins plugins&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone --depth 1 https://github.com/farseerfc/pelican-bootstrap3 theme&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone --depth 1 https://$GH_TOKEN@github.com/farseerfc/farseerfc.github.io output&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;env SITEURL="farseerfc.me" make publish&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nt"&gt;after_success&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;cd output&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git add -A .&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git commit -m "update from travis"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git push --quiet&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="alert alert-warning compound"&gt;
&lt;p&gt;這裏要注意最後 &lt;code class="code"&gt;
git push&lt;/code&gt;
 的時候一定要加上 &lt;code class="code"&gt;
--quiet&lt;/code&gt;
，因爲默認不加的時候會把
代入了 &lt;code class="code"&gt;
$GH_TOKEN&lt;/code&gt;
 的 URL 顯示出來，從而上面的加密工作就前功盡棄了……&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;根據 &lt;a class="reference external" href="http://docs.travis-ci.com/user/build-lifecycle/"&gt;travis 的文檔&lt;/a&gt;
， after_success 裏寫的步驟只有在 script 裏的全都完全無錯執行完之後纔會執行，這正是我們
push 的條件。目前 after_success 的成功與否不會影響到 build 的狀態。
具體我用的配置見
&lt;a class="reference external" href="https://github.com/farseerfc/farseerfc/blob/master/.travis.yml"&gt;這裏的最新版&lt;/a&gt; 。
在我的 &lt;code class="code"&gt;
make github&lt;/code&gt;
 中
&lt;a class="reference external" href="https://github.com/farseerfc/farseerfc/blob/master/Makefile#L102"&gt;調用了&lt;/a&gt;
&lt;code class="code"&gt;
git push&lt;/code&gt;
 命令，從而執行了 &lt;code class="code"&gt;
make github&lt;/code&gt;
 之後就會自動部署到 github 上。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="web"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;用 Web 編輯並發佈靜態博客&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;經過以上設置之後，一切正常的話，每次對主 repo 推送更新的同時， Travis-CI 就會自動
拉來更新然後編譯並發佈了。可以放置這樣的圖標 &lt;img alt="travisIcon" class="img-responsive no-responsive" src="https://travis-ci.org/farseerfc/farseerfc.svg?branch=master"/&gt; 在項目的 &lt;code class="code"&gt;
Readme.md&lt;/code&gt;

中顯示編譯狀態。&lt;/p&gt;
&lt;p&gt;這樣設置之後的另一個好處就在於可以利用 Github 的 Web 界面編輯文章內容。在 Github 裏
編輯和保存之後會自動作爲一個 commit 提交，所以也會觸發 Travis-CI 的自動編譯。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="在 Github 的 Web 界面中直接編輯文章內容" class="img-responsive" src="//farseerfc.me/images/travis-edit-github-web.png"/&gt;
&lt;p class="caption"&gt;在 Github 的 Web 界面中直接編輯文章內容&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;以及雖然目前還沒有好用的 Github 的手機客戶端，不過直接用 Android/iPhone 的瀏覽器登錄
github 並編輯文章的可用性也還不錯，所以同樣的方式也可以直接在手機上發佈博文了。&lt;/p&gt;
&lt;p&gt;That is all, happy blogging ~&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="pelican"></category><category term="github"></category><category term="pages"></category><category term="travis"></category><category term="travis-ci"></category><category term="ubuntu"></category></entry><entry><title>從天氣預報談談日本的學術氛圍</title><link href="//farseerfc.me/weather-forcast-academic-in-japan.html" rel="alternate"></link><published>2015-02-18T21:00:00+09:00</published><updated>2015-02-18T21:00:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-02-18:/weather-forcast-academic-in-japan.html</id><summary type="html">&lt;p&gt;最近 &lt;a class="reference external" href="/links.html#mazk"&gt;mazk&lt;/a&gt; 說我 &lt;a class="reference external" href="//farseerfc.me/pages/about.html#comment-1856339316"&gt;life 分類裏的文章太少&lt;/a&gt;
，所以想了想寫了這篇。&lt;/p&gt;
&lt;p&gt;很多人問過我爲什麼要來日本留學，嘛原因之一是我英語太差了，相對而言日語比較好。
另一方面，我比較喜歡日本的學術氛圍。這個當然是主觀體會，而不是客觀的評價，只是我
覺得相對於 &lt;strong&gt;歐美喜歡研究基礎架構技術&lt;/strong&gt; ， &lt;strong&gt;日本則偏向實用層面&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;說個具體一點例子，最近看到這篇新聞說
&lt;a class="reference external" href="http://www.solidot.org/story?sid=43079"&gt;卢布贬值影响中央气象台预报准确率？&lt;/a&gt;
，其中提到：&lt;/p&gt;
&lt;blockquote&gt;
因为卢布贬值，天气预报的准确率会有所降低&lt;/blockquote&gt;
&lt;p&gt;也說道：&lt;/p&gt;
&lt;blockquote&gt;
不过经我多年的观察，中国中央气象台的预报准确率实在是不怎么样，具体到我生活的地区，
实际天气状况和中国中央气象台预报的出入较大……&lt;/blockquote&gt;
&lt;p&gt;相信不少人也有類似的體會。&lt;/p&gt;
&lt;p&gt;天氣預報是事關人們生活的重要信息，其準確度對生產生活當然有很大影響。
說到增加天氣預報的準確度，人們自然會想到高性能的超級計算機比如
&lt;a class="reference external" href="https://zh.wikipedia.org/wiki/%E5%A4%A9%E6%B2%B3%E4%BA%8C%E5%8F%B7"&gt;天河二號&lt;/a&gt;
，想到環繞在地球高空的 &lt;a class="reference external" href="https://zh.wikipedia.org/wiki/%E6%B0%A3%E8%B1%A1%E8%A1%9B%E6%98%9F"&gt;氣象衛星&lt;/a&gt;
，想到遍佈世界各地的氣象站觀測臺。想想這麼多耗資不菲的高尖端項目被國家投入，
用來改善天氣預報的準確程度，看起來這的確是一個困難的科研課題。&lt;/p&gt;
&lt;p&gt;話說回來，準確預測氣溫、氣壓、溼度、降水概率等等這些事情對於生產生活固然重要，
不過對一般民衆而言，天氣預報最重要的作用就只是回答 &lt;strong&gt;明天我該穿多厚的衣服，出門是否需要打傘&lt;/strong&gt;
這種問題 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近 &lt;a class="reference external" href="/links.html#mazk"&gt;mazk&lt;/a&gt; 說我 &lt;a class="reference external" href="//farseerfc.me/pages/about.html#comment-1856339316"&gt;life 分類裏的文章太少&lt;/a&gt;
，所以想了想寫了這篇。&lt;/p&gt;
&lt;p&gt;很多人問過我爲什麼要來日本留學，嘛原因之一是我英語太差了，相對而言日語比較好。
另一方面，我比較喜歡日本的學術氛圍。這個當然是主觀體會，而不是客觀的評價，只是我
覺得相對於 &lt;strong&gt;歐美喜歡研究基礎架構技術&lt;/strong&gt; ， &lt;strong&gt;日本則偏向實用層面&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;說個具體一點例子，最近看到這篇新聞說
&lt;a class="reference external" href="http://www.solidot.org/story?sid=43079"&gt;卢布贬值影响中央气象台预报准确率？&lt;/a&gt;
，其中提到：&lt;/p&gt;
&lt;blockquote&gt;
因为卢布贬值，天气预报的准确率会有所降低&lt;/blockquote&gt;
&lt;p&gt;也說道：&lt;/p&gt;
&lt;blockquote&gt;
不过经我多年的观察，中国中央气象台的预报准确率实在是不怎么样，具体到我生活的地区，
实际天气状况和中国中央气象台预报的出入较大……&lt;/blockquote&gt;
&lt;p&gt;相信不少人也有類似的體會。&lt;/p&gt;
&lt;p&gt;天氣預報是事關人們生活的重要信息，其準確度對生產生活當然有很大影響。
說到增加天氣預報的準確度，人們自然會想到高性能的超級計算機比如
&lt;a class="reference external" href="https://zh.wikipedia.org/wiki/%E5%A4%A9%E6%B2%B3%E4%BA%8C%E5%8F%B7"&gt;天河二號&lt;/a&gt;
，想到環繞在地球高空的 &lt;a class="reference external" href="https://zh.wikipedia.org/wiki/%E6%B0%A3%E8%B1%A1%E8%A1%9B%E6%98%9F"&gt;氣象衛星&lt;/a&gt;
，想到遍佈世界各地的氣象站觀測臺。想想這麼多耗資不菲的高尖端項目被國家投入，
用來改善天氣預報的準確程度，看起來這的確是一個困難的科研課題。&lt;/p&gt;
&lt;p&gt;話說回來，準確預測氣溫、氣壓、溼度、降水概率等等這些事情對於生產生活固然重要，
不過對一般民衆而言，天氣預報最重要的作用就只是回答 &lt;strong&gt;明天我該穿多厚的衣服，出門是否需要打傘&lt;/strong&gt;
這種問題。一年四季換衣服的時機其實並不那麼頻繁，氣溫提升五度或者降低兩度這種程度下人們估計也
不能感覺得到，大體上只要根據「昨天穿什麼衣服，昨天覺得冷不冷」就能作出判斷。另一方面，
&lt;strong&gt;出門是否需要打傘&lt;/strong&gt; 這樣的問題的確只能依靠天氣預報來回答。&lt;/p&gt;
&lt;p&gt;那麼解決 &lt;strong&gt;出門是否需要打傘&lt;/strong&gt; 這個問題需要那麼高尖端的技術麼？&lt;/p&gt;
&lt;p&gt;我所在的大阪大學情報科學研究科有個已經畢業的學長 &lt;ruby&gt;&lt;rb&gt;今城 健太郎&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;いまじょう けんたろう&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
就對此作出了解答。他的專業不是氣象預測，而是圖像分析處理，純粹的計算機科學學科。
而他的本科畢業設計就着眼於「僅僅分析氣象雲圖，能否高精度預測降水概率」，
其研究成果，就是一個叫 &lt;a class="reference external" href="http://blog.imoz.jp/post/7316967132/ninetan-forecast"&gt;ないんたん 的降水概率預測系統&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;這個系統有數個會賣萌的Twitter機器人 &lt;a class="reference external" href="//twitter.com/ninetan"&gt;@ninetan&lt;/a&gt; ，每時每刻對
其預測地區的降水情況做播報，同時也有詳細的降水概率曲線圖對
&lt;a class="reference external" href="http://sx9.jp/weather/osaka.html"&gt;大阪&lt;/a&gt; ( &lt;a class="reference external" href="//twitter.com/ninetan_osaka"&gt;@ninetan_osaka&lt;/a&gt; )，
&lt;a class="reference external" href="http://sx9.jp/weather/kyoto.html"&gt;京都&lt;/a&gt; ( &lt;a class="reference external" href="//twitter.com/ninetan_kyoto"&gt;@ninetan_kyoto&lt;/a&gt; )，
&lt;a class="reference external" href="http://sx9.jp/weather/tokyo.html"&gt;東京&lt;/a&gt; ( &lt;a class="reference external" href="//twitter.com/ninetan_tokyo"&gt;@ninetan_tokyo&lt;/a&gt; )，
&lt;a class="reference external" href="http://sx9.jp/weather/hyogo.html"&gt;兵庫&lt;/a&gt; ( &lt;a class="reference external" href="//twitter.com/ninetan_hyogo"&gt;@ninetan_hyogo&lt;/a&gt; )，
&lt;a class="reference external" href="http://sx9.jp/weather/wakayama.html"&gt;和歌山&lt;/a&gt; ( &lt;a class="reference external" href="//twitter.com/ninetan_wakayam"&gt;@ninetan_wakayam&lt;/a&gt; ) 的各個大學所在校區
兩個半小時內做精確的降水概率預測。比如今天晚上大阪大學三個校區的降水概率圖如下：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="今天晚上大阪大學三個校區的降水概率圖" class="img-responsive" src="//farseerfc.me/images/forcast-osaka.png"/&gt;
&lt;p class="caption"&gt;今天晚上大阪大學三個校區的降水概率圖&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;從上面的圖可以看出這個系統的預測精度是以 &lt;strong&gt;分爲單位&lt;/strong&gt; 的，可以看到
兩個半小時內各地的降水量的大小。比如我可以根據這張圖看出，我所在的吹田校區
將在 &lt;strong&gt;21時35分&lt;/strong&gt; 開始有微弱的概率下起 0.1mm/h~1mm/h 的毛毛雨，到 &lt;strong&gt;22時05分&lt;/strong&gt; 左右這個降水概率
爬升到最高大約45%，從而作出判斷：
我最好在晚上九點左右離開學校回家，避免淋雨。&lt;/p&gt;
&lt;p&gt;自從研究室的前輩給我介紹這個天氣預報系統開始，我用了它兩三年了，直觀感覺是
這個系統的預測精度驚人得準確，基本上能接近
&lt;a class="reference external" href="http://zh.wikipedia.org/wiki/%E9%AD%94%E6%B3%95%E7%A6%81%E6%9B%B8%E7%9B%AE%E9%8C%84%E7%94%A8%E8%AA%9E%E5%88%97%E8%A1%A8#.E8.A3.9D.E7.BD.AE.E3.80.81.E5.85.B5.E5.99.A8.E3.80.81.E6.8A.80.E8.A1.93"&gt;《魔法的禁書目錄》中的「樹形圖設計者」&lt;/a&gt;
能做的天氣預報的程度，
它說何時會下雨就一定下雨，它說何時雨停就一定雨停。同學們出門和回家的時候一般都會
看一眼這個天氣預報然後決定是否出門。「啊今天晚上9點開始下雨所以早點回家」
或者「啊還有30分鐘雨就停了，再在研究室裏留一會兒」。&lt;/p&gt;
&lt;p&gt;這只是一個本科生的畢業設計，所以覆蓋面小（只有5所大學的十幾個校區，只能預測
未來兩個多小時的降水概率），不過僅此而已能做到如此的精度以至於實用，實在讓我
驚訝。系統的測試之初就有人說：&lt;/p&gt;
&lt;blockquote class="twitter-tweet" lang="zh-tw"&gt;&lt;p&gt;最近ないんたん予報あたりすぎてないんたんが雨降らせてるんじゃないかという疑惑&lt;/p&gt;— すみのネコ歩き (@sumi_eee) &lt;a href="https://twitter.com/sumi_eee/status/88530793407852544"&gt;2011 7月 6日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" charset="utf-8" src="//platform.twitter.com/widgets.js"&gt;&lt;/script&gt;&lt;!-- --&gt;
&lt;blockquote&gt;
最近ないんたん預告實在太準了，甚至讓人懷疑是不是ないんたん把雨招來的。&lt;/blockquote&gt;
&lt;p&gt;不過最近身邊的日本人似乎已經把這個系統的準確當作習以爲常了，就像日本的電車
掐着秒錶準點到站一樣，理所當然。
把天氣預報這種高尖端的技術做到如此實用的地步，這基本上可以代表我對
日本學術界研究方式和研究目的的總體印象了。&lt;/p&gt;
&lt;p&gt;嗯今天就寫這麼多，9點到了，我要按照天氣預報的預測，準時回家了。&lt;/p&gt;
&lt;p&gt;——寫於2015羊年除夕夜，9點。&lt;/p&gt;
</content><category term="life"></category><category term="japan"></category><category term="academic"></category></entry><entry><title>archlinux 上用 chrome 實現 透明計算 遠程登錄</title><link href="//farseerfc.me/arch-chrome-remote-desktop.html" rel="alternate"></link><published>2015-02-13T20:39:00+09:00</published><updated>2015-02-13T20:39:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-02-13:/arch-chrome-remote-desktop.html</id><summary type="html">
&lt;p&gt;&lt;a class="reference external" href="http://news.sciencenet.cn/htmlnews/2015/1/311393.shtm"&gt;透明計算&lt;/a&gt;
具體是什麼，因爲他們沒有公開技術細節所以我並不知道，只是看
&lt;a class="reference external" href="http://v.qq.com/page/h/v/q/h0145ebh1vq.html"&gt;公開出來的演示視頻&lt;/a&gt;
，感覺似乎只要能從手機上遠程登錄系統桌面，就能算是透明計算了。
如果透明計算真是這個意思，那麼我似乎已經用着這個技術很多年了嘛。&lt;/p&gt;
&lt;p&gt;Xorg 上常用的遠程桌面工具有很多，基於 VNC 協議的、基於NX的和基於 RDP 協議的都能找到，
直接 ssh X forwarding 效果也不錯。只是這些方案的一個 &lt;strong&gt;不太易用&lt;/strong&gt; 的地方在於，需要
通過 ip 訪問到遠程的電腦，所以在跨越 NAT 之類的情況下不太容易使用。&lt;/p&gt;
&lt;p&gt;於是今天介紹一個使用方便設置也簡單的方法： 通過 chrome-remote-desktop 在 archlinux
上使用遠程桌面。這個方案的優勢在於，藉助 Google 的雲端服務器（內部貌似是XMPP協議下的握手）
方便地實現了 NAT 穿透，無論什麼網絡環境基本都能使用。當然，要支持遠程登錄，
位於遠端的登錄的計算機必須一直開着 …&lt;/p&gt;</summary><content type="html">
&lt;p&gt;&lt;a class="reference external" href="http://news.sciencenet.cn/htmlnews/2015/1/311393.shtm"&gt;透明計算&lt;/a&gt;
具體是什麼，因爲他們沒有公開技術細節所以我並不知道，只是看
&lt;a class="reference external" href="http://v.qq.com/page/h/v/q/h0145ebh1vq.html"&gt;公開出來的演示視頻&lt;/a&gt;
，感覺似乎只要能從手機上遠程登錄系統桌面，就能算是透明計算了。
如果透明計算真是這個意思，那麼我似乎已經用着這個技術很多年了嘛。&lt;/p&gt;
&lt;p&gt;Xorg 上常用的遠程桌面工具有很多，基於 VNC 協議的、基於NX的和基於 RDP 協議的都能找到，
直接 ssh X forwarding 效果也不錯。只是這些方案的一個 &lt;strong&gt;不太易用&lt;/strong&gt; 的地方在於，需要
通過 ip 訪問到遠程的電腦，所以在跨越 NAT 之類的情況下不太容易使用。&lt;/p&gt;
&lt;p&gt;於是今天介紹一個使用方便設置也簡單的方法： 通過 chrome-remote-desktop 在 archlinux
上使用遠程桌面。這個方案的優勢在於，藉助 Google 的雲端服務器（內部貌似是XMPP協議下的握手）
方便地實現了 NAT 穿透，無論什麼網絡環境基本都能使用。當然，要支持遠程登錄，
位於遠端的登錄的計算機必須一直開着 Chrome Remote Desktop 的後臺服務。&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Chrome Remote Desktop 插件&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Chrome Remote Desktop 插件" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-plugin.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="chrome-remote-desktop"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;Chrome Remote Desktop 的客戶端&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;雖然可能有很多人不知道，不過 Chrome 內包括遠程桌面的功能很久了。只是這個功能的界面默認
沒有提供界面，要使用它需要安裝 Google 官方出品的
&lt;a class="reference external" href="https://chrome.google.com/webstore/detail/chrome-remote-desktop/gbchcmhmhahfdphkhkmpfmihenigjmpp"&gt;remote-desktop 插件&lt;/a&gt; 。
裝好之後遠程桌面的客戶端就準備好，可以用來遠程訪問別的計算機桌面了（無論是 Windows/OS X
還是 Linux 都支持）。並且不光可以自己遠程訪問自己賬戶的桌面，還可以遠程協助朋友的桌面。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="archlinux"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;Archlinux 上設置遠程登錄的服務器&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;有了客戶端之後還要設置一下纔能讓桌面作爲遠程登錄的服務器。Windows 和 OS X 上 Chrome
會自動下載需要的安裝包，無腦下一步就能裝好了。Linux上由於發行版衆多，桌面配置各異，
所以需要一點手動配置。官方的設置步驟記載在 &lt;a class="reference external" href="https://support.google.com/chrome/answer/1649523"&gt;這裏&lt;/a&gt;
其中給出了 debian 用的二進制包和 Ubuntu 12.10 上的設置方式，以下設置是參考官方步驟。&lt;/p&gt;
&lt;p&gt;首先要安裝 chrome-remote-desktop 這個包，這個包實際上對應了 Windows/OS X 上用安裝程序
安裝的 Remote Desktop Host Controller。 archlinux 上開啓了
&lt;a class="reference external" href="https://github.com/archlinuxcn/repo"&gt;[archlinuxcn]&lt;/a&gt;
倉庫的話，可以直接安裝打好的包。或者可以從
&lt;a class="reference external" href="https://aur.archlinux.org/packages/chrome-remote-desktop/"&gt;AUR&lt;/a&gt; 裝。&lt;/p&gt;
&lt;pre&gt;&lt;span class="code-line"&gt;$ pacman -Ss chrome-remote-desktop&lt;br/&gt;&lt;span style="color:purple;font-weight:bold;"&gt;archlinuxcn/&lt;/span&gt;&lt;span style="font-weight:bold;"&gt;chrome-remote-desktop &lt;/span&gt;&lt;span style="color:green;font-weight:bold;"&gt;40.0.2214.44-1&lt;/span&gt;&lt;br/&gt;Allows you to securely access your computer over the Internet through Chrome.&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;裝好之後從會說這麼一段話：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;groupadd：无效的组 ID “chrome-remote-desktop”&lt;/p&gt;
&lt;p&gt;Please create ~/.config/chrome-remote-desktop folder manually, if it doesn't exist, or else you can't use CRD.
The needed files are created by the Chrome app, inside the chrome-remote-desktop folder, after Enabling Remote Connections.
To {enable,start} the service use systemctl --user {enable,start} chrome-remote-desktop&lt;/p&gt;
&lt;p&gt;You may need to create a ~/.chrome-remote-desktop-session file with commands to start your session&lt;/p&gt;
&lt;p&gt;Go to &lt;a class="reference external" href="https://support.google.com/chrome/answer/1649523"&gt;https://support.google.com/chrome/answer/1649523&lt;/a&gt; for more information.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那句報錯是 AUR 裏打的包還沒跟上上游 Google 的更改導致的錯誤，
首先我們需要把遠程登錄的用戶添加入 chrome-remote-desktop 這個用戶組裏。
新版本的 chrome remote desktop 提供了一個命令做這個事情，所以執行以下命令就可以了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; /opt/google/chrome-remote-desktop/chrome-remote-desktop --add-user&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後我們需要手動創建 &lt;code class="code"&gt;
~/​.config/​chrome-remote-desktop&lt;/code&gt;
 這個文件夾，內容是空的
就好了，隨後 chrome 會往這裏面放 &lt;code class="code"&gt;
host#.json&lt;/code&gt;
 文件用於身份驗證。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; mkdir ~/.config/chrome-remote-desktop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後我們要創建一個 shell 腳本 &lt;code class="code"&gt;
~/​.chrome-remote-desktop-session&lt;/code&gt;
 ，這是遠程
登錄時的 .xinitrc ，內容麼就是啓動你想在遠程登錄時用的桌面環境。
這裏可以指定一個和你正在登錄的 WM/DE 不同的桌面，比如我啓動 xfce4：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; cat ~/.chrome-remote-desktop-session&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;#&lt;/span&gt;!/bin/bash&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;startxfce4&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; chmod &lt;span class="m"&gt;755&lt;/span&gt; .chrome-remote-desktop-session&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下來需要從 Chrome 的插件裏啓用遠程桌面。打開 Chrome 的 Remote Desktop 插件，這時
應該可以看到一個「啓用遠程鏈接」的按鈕。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="Chrome Remote Desktop 插件中「啓用遠程鏈接」的按鈕" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-enable-button.png"/&gt;
&lt;p class="caption"&gt;Chrome Remote Desktop 插件中「啓用遠程鏈接」的按鈕&lt;/p&gt;
&lt;/div&gt;
&lt;div class="alert alert-warning compound"&gt;
&lt;p&gt;在撰寫本文的時候， Archlinux 官方源裏的 chromium 的版本和 aur/google-chrome
的版本尚且還是 40.0.2214.111 ，而 Chrome Web Store 中提供的 Chrome Remote
Desktop 的插件的版本是 41.0.2272.41 。雖然通常並不要求兩者版本一致，不過貌似最近
Chrome 內部的 Remoting 功能更改了 API 導致可能出問題。如果你找不到
「啓用遠程鏈接」的按鈕，請嘗試一下新版本的 Chrome 比如 google-chrome-dev 。
在這一步啓用之後，老版本的 chrome 應該也就能使用遠程桌面了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="alert alert-warning compound"&gt;
&lt;p&gt;在32位的 Linux 版本上，最近更新的 Chrome Remote Desktop 插件可能無法正確識別 Host
的版本，具體 &lt;a class="alert-link reference external" href="https://code.google.com/p/chromium/issues/detail?id=332930"&gt;參考這個 bug&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;點擊「啓用遠程鏈接」，設定一個 PIN 密碼（不需要很複雜，這裏首先有 Google 帳號驗證保證只有
你纔能訪問），然後就能看到這套電腦的 hostname 出現在「我的電腦」列表裏。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="啓用遠程鏈接之後的樣子" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-after-enabled.png"/&gt;
&lt;p class="caption"&gt;啓用遠程鏈接之後的樣子&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;同時，啓用了遠程鏈接之後，可以在剛剛創建的 ~/.config/chrome-remote-desktop
文件夾中找到記錄了驗證信息的文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ls .config/chrome-remote-desktop&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="go"&gt;chrome-profile  host#8cfe7ecfd6bb17955c1ea22f77d0d800.json  pulseaudio#8cfe7ecfd6&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後就可以啓動對應的 systemd 用戶服務了，如果想自動啓動服務要記得 &lt;code class="code"&gt;
systemctl --user enable&lt;/code&gt;
 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; systemctl --user start chrome-remote-desktop.service&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果上面的設置一切正常，就可以看到 chrome-remote-desktop 啓動了另外一個 Xorg 執行你
剛剛指定的桌面環境：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="htop 中看到的 chrome-remote-desktop 啓動的另外一個 Xorg" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-htop.png"/&gt;
&lt;p class="caption"&gt;htop 中看到的 chrome-remote-desktop 啓動的另外一個 Xorg&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;然後就可以試着通過 Remote Desktop 插件登錄到這個新開的 Xorg 了：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="「遠程」登錄到新的 XFCE4" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-xfce4.png"/&gt;
&lt;p class="caption"&gt;「遠程」登錄到新的 XFCE4&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="linux-chrome-windows-os-x"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;Linux 版本的 Chrome遠程桌面 和 Windows/ OS X 上的區別&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通過上面的設置步驟也可以看出，Linux版本的遠程桌面會在後臺開一個獨立的 X 會話，而不能
復用現在已有的 X 會話。對遠程登錄的用法而言這還能接受，對遠程協助的功能而言有點問題，
因爲正在使用的人不能觀察協助者做了什麼，協助者也不能繼續請求協助的人的操作。&lt;/p&gt;
&lt;p&gt;當然目前 Chrome 遠程桌面的 Linux Host Controller 還只是 beta 版本，官方只測試支持
Ubuntu 12.04 和 12.10 （14.04之後似乎有
&lt;a class="reference external" href="https://code.google.com/p/chromium/issues/detail?id=366432"&gt;Bug&lt;/a&gt;
），所以不能要求太多。希望以後能改善吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bonus"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;Bonus： 手機遠程登錄&lt;/a&gt;&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
手機上的 Chrome 遠程桌面 App&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="手機上的 Chrome 遠程桌面 App" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-android.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通過上面的設置就可以從任何一個 Chrome 遠程桌面客戶端登錄剛剛設置的這臺電腦了。
因爲 Chrome 在三大桌面系統 Windows / OS X / Linux 上都有，所以應該能覆蓋大多數桌面
系統了。&lt;/p&gt;
&lt;p&gt;除了桌面的 Chrome 之外還有一個客戶端是 Android 上的
&lt;a class="reference external" href="https://play.google.com/store/apps/details?id=com.google.chromeremotedesktop"&gt;Chrome 遠程桌面 App&lt;/a&gt; 經過上面的設置之後，從這個 App 也能看到並登錄：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="手機遠程登錄" class="img-responsive" src="//farseerfc.me/images/chrome-remote-desktop-android-logined.png"/&gt;
&lt;p class="caption"&gt;手機遠程登錄&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;好啦，開始享受國家自然科學一等獎的透明計算技術吧！&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="linux"></category><category term="archlinux"></category><category term="arch"></category><category term="chrome"></category><category term="remote"></category><category term="desktop"></category></entry><entry><title>換到 farseerfc.me 域名</title><link href="//farseerfc.me/switch-to-farseerfc-dot-me-domain.html" rel="alternate"></link><published>2015-01-26T23:32:00+09:00</published><updated>2015-01-26T23:32:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-01-26:/switch-to-farseerfc-dot-me-domain.html</id><summary type="html">&lt;p&gt;上個月就在 &lt;ruby&gt;&lt;rb&gt;狗爹&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;godaddy&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 上買了個自己的域名 &lt;code class="code"&gt;
farseerfc.me&lt;/code&gt;
 準備用在這個
博客上，當時試着轉到過這個域名，發現 &lt;ruby&gt;&lt;rb&gt;自定義域名&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;custom domain&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
只支持 http 不支持 https ，想着還要買自己的證書，於是就扔在了一旁。不用自定義域名的話，
放在 github.io 上是可以用 HTTPS 的。
今天在 &lt;a class="reference external" href="//webchat.freenode.net/?channels=archlinux-cn"&gt;#archlinux-cn&lt;/a&gt; 上受大牛 &lt;a class="reference external" href="/links.html#quininer"&gt;quininer&lt;/a&gt; 和 &lt;a class="reference external" href="/links.html#lilydjwg"&gt;lilydjwg&lt;/a&gt; 點播，
發現 cloudflare 有提供
&lt;a class="reference external" href="https://blog.cloudflare.com/introducing-universal-ssl/"&gt;免費的支持 SSL 的 CDN 服務&lt;/a&gt;
趕快去申請了一個，感覺非常讚，於是就換過來了。&lt;/p&gt;
&lt;p&gt;設置的方法按照 &lt;a class="reference external" href="https://me.net.nz/blog/github-pages-secure-with-cloudflare/"&gt;這篇博文&lt;/a&gt;
說的一步步做下來，如它所述，用 CloudFlare …&lt;/p&gt;</summary><content type="html">&lt;p&gt;上個月就在 &lt;ruby&gt;&lt;rb&gt;狗爹&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;godaddy&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 上買了個自己的域名 &lt;code class="code"&gt;
farseerfc.me&lt;/code&gt;
 準備用在這個
博客上，當時試着轉到過這個域名，發現 &lt;ruby&gt;&lt;rb&gt;自定義域名&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;custom domain&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
只支持 http 不支持 https ，想着還要買自己的證書，於是就扔在了一旁。不用自定義域名的話，
放在 github.io 上是可以用 HTTPS 的。
今天在 &lt;a class="reference external" href="//webchat.freenode.net/?channels=archlinux-cn"&gt;#archlinux-cn&lt;/a&gt; 上受大牛 &lt;a class="reference external" href="/links.html#quininer"&gt;quininer&lt;/a&gt; 和 &lt;a class="reference external" href="/links.html#lilydjwg"&gt;lilydjwg&lt;/a&gt; 點播，
發現 cloudflare 有提供
&lt;a class="reference external" href="https://blog.cloudflare.com/introducing-universal-ssl/"&gt;免費的支持 SSL 的 CDN 服務&lt;/a&gt;
趕快去申請了一個，感覺非常讚，於是就換過來了。&lt;/p&gt;
&lt;p&gt;設置的方法按照 &lt;a class="reference external" href="https://me.net.nz/blog/github-pages-secure-with-cloudflare/"&gt;這篇博文&lt;/a&gt;
說的一步步做下來，如它所述，用 CloudFlare 的優點如下：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;CDN 加速&lt;/li&gt;
&lt;li&gt;SSL (HTTPS) 加密&lt;/li&gt;
&lt;li&gt;支持 SPDY 協議&lt;/li&gt;
&lt;li&gt;支持 IPv6&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年12月29日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;現在不光支持 SPDY 而且支持 HTTP/2 了。&lt;/p&gt;
&lt;p&gt;然後 &lt;strong&gt;免費賬戶&lt;/strong&gt; 的一些缺點有：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;CloudFlare 和 github.io 之間的數據不是加密的，因爲 github
&lt;ruby&gt;&lt;rb&gt;自定義域名&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;custom domain&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 還不支持使用自己的證書。這也是一開始我沒用
自定義域名的原因嘛，這沒有辦法……&lt;/li&gt;
&lt;li&gt;CloudFlare 給免費賬戶簽名的 SSL 證書比較新，不支持一些老的設備和瀏覽器，比如不支持
老的 XP 系統的 IE 或者 2.x 的 Android。這種情況下沒辦法只能用沒有加密的 HTTP 了。&lt;/li&gt;
&lt;li&gt;不支持 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security"&gt;HSTS 頭&lt;/a&gt;
，所以不能從服務器這邊強制瀏覽器用 HTTPS。當然可以放個 javascript 跳轉，
也可以用 &lt;a class="reference external" href="https://www.eff.org/https-everywhere"&gt;HTTPSEverywhere&lt;/a&gt; 這種方案。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年12月29日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;如評論中 &lt;a class="reference external" href="http://farseerfc.me/switch-to-farseerfc-dot-me-domain.html#comment-2015037231"&gt;提到的&lt;/a&gt;
現在支持 HSTS 了。&lt;/p&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;設置步驟&lt;/h2&gt;
&lt;p&gt;基本按照默認的選項下一步就可以了。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;和那個博主一樣我把 &lt;ruby&gt;&lt;rb&gt;安全級別&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Security profile&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 降到了 Low ，即使是可疑流量也
不會要求輸入 CAPTCHA 。&lt;/li&gt;
&lt;li&gt;把 SSL 方式開在 Flexible SSL，訪客到 CloudFlare 是加密的，而 CloudFlare 到
github.io 是不加密的。&lt;/li&gt;
&lt;li&gt;把 CDN 開到了 CDT+Full Optimization ，可以對訪問加速。由於是完全靜態的博客，沒有
動態變化的內容，所以應該比較安全。&lt;/li&gt;
&lt;li&gt;服務器設置的一步需要將 &lt;ruby&gt;&lt;rb&gt;域名解析服務器&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;DNS nameservers&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 從狗爹的服務器改到
CloudFlare 的，如下圖：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="figure"&gt;
&lt;img alt="更改狗爹的域名服務器" class="img-responsive" src="//farseerfc.me/images/godaddy.png"/&gt;
&lt;p class="caption"&gt;更改狗爹的域名服務器&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;申請好之後就由 CloudFlare 接管域名解析了，接下來在 CloudFlare 的 DNS 設置添加一條
&lt;a class="reference external" href="https://help.github.com/articles/tips-for-configuring-an-a-record-with-your-dns-provider/"&gt;A 類規則指向 github pages 的 IP&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="更改CloudFlare的DNS規則" class="img-responsive" src="//farseerfc.me/images/cloudflaredns.png"/&gt;
&lt;p class="caption"&gt;更改CloudFlare的DNS規則&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;等一切都反映到 DNS 服務器上就設置完成了，接下來給
&lt;a class="reference external" href="https://help.github.com/articles/adding-a-cname-file-to-your-repository/"&gt;farseerfc.github.io push 一個 CNAME 文件&lt;/a&gt;
寫上我的域名就可以了。我用 Makefile 配合我的 pelican 配置做這個：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;publish&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;rmdrafts&lt;/span&gt; &lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="n"&gt;clean&lt;/span&gt; &lt;span class="n"&gt;theme&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;[&lt;/span&gt; ! -d &lt;span class="k"&gt;$(&lt;/span&gt;OUTPUTDIR&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; find &lt;span class="k"&gt;$(&lt;/span&gt;OUTPUTDIR&lt;span class="k"&gt;)&lt;/span&gt; -mindepth &lt;span class="m"&gt;1&lt;/span&gt; -not -wholename &lt;span class="s2"&gt;"*/.git*"&lt;/span&gt; -delete&lt;/span&gt;
&lt;span class="code-line"&gt;  rm -rf cache&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;SITEURL&lt;span class="k"&gt;)&lt;/span&gt; &amp;gt; content/static/CNAME&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;$(&lt;/span&gt;PELICAN&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;INPUTDIR&lt;span class="k"&gt;)&lt;/span&gt; -o &lt;span class="k"&gt;$(&lt;/span&gt;OUTPUTDIR&lt;span class="k"&gt;)&lt;/span&gt; -s &lt;span class="k"&gt;$(&lt;/span&gt;PUBLISHCONF&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;PELICANOPTS&lt;span class="k"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;$(&lt;/span&gt;MAKE&lt;span class="k"&gt;)&lt;/span&gt; rsthtml&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nf"&gt;github&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;OUTPUTDIR&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; git checkout master&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  env &lt;span class="nv"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"farseerfc.me"&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MAKE&lt;span class="k"&gt;)&lt;/span&gt; publish&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;OUTPUTDIR&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; git add . &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; git commit -m &lt;span class="s2"&gt;"update"&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; git push&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'//'&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;getenv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"SITEURL"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'localhost:8000'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;STATIC_PATHS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'static'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'images'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'uml'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'images/favicon.ico'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'static/CNAME'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;EXTRA_PATH_METADATA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="s1"&gt;'images/favicon.ico'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;'path'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'favicon.ico'&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="s1"&gt;'static/CNAME'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;'path'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'CNAME'&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後把生成的靜態網站 push 到 github 之後可以從項目設置裏看到域名的變化：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="Github 配置好自定義域名之後的變化" class="img-responsive" src="//farseerfc.me/images/githubdomain.png"/&gt;
&lt;p class="caption"&gt;Github 配置好自定義域名之後的變化&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;最後把Disqus的評論也遷移到新的域名，disqus有方便的遷移嚮導，一直下一步就可以了。&lt;/p&gt;
&lt;p&gt;這樣就一切都設置妥當了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;致謝&lt;/h2&gt;
&lt;p&gt;最後要感謝提供消息的 &lt;a class="reference external" href="/links.html#quininer"&gt;quininer&lt;/a&gt; 和 &lt;a class="reference external" href="/links.html#lilydjwg"&gt;lilydjwg&lt;/a&gt; ，感謝撰寫設置步驟的
&lt;em&gt;Jonathan J Hunt&lt;/em&gt; ， 感謝 CloudFlare 提供免費 SSL CDN 服務，感謝 Github 提供
方便免費的 Pages 託管。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="pelican"></category><category term="domain"></category><category term="cloudflare"></category><category term="github"></category></entry><entry><title>重新設計了 Pelican 的主題與插件</title><link href="//farseerfc.me/redesign-pelican-theme.html" rel="alternate"></link><published>2015-01-25T22:45:00+09:00</published><updated>2015-01-25T22:45:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-01-25:/redesign-pelican-theme.html</id><summary type="html">
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月14日更新&lt;/strong&gt;&lt;/div&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id38"&gt;前言: 新天新地，將一切都更新了 &lt;a class="footnote-reference" href="#id37" id="id1"&gt;[1]&lt;/a&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;不知不覺間放任這邊長草很久了，從上次
&lt;a class="reference external" href="//farseerfc.me/try-pelican.html"&gt;折騰主題&lt;/a&gt; 到現在都快三年了，
而從上次 &lt;a class="reference external" href="//farseerfc.me/marry-me.html"&gt;寫了篇告白信&lt;/a&gt; 到現在也有快兩年了。
這期間曾經把主題配色從 &lt;a class="reference external" href="http://getbootstrap.com/2.3.2/"&gt;Bootstrap 2&lt;/a&gt; 默認的
白底黑字改成了讓眼睛更舒適的黑底白字，也不過是用 drop-in 的配色方案而已，沒有本質上的改進。&lt;/p&gt;
&lt;p&gt;洞中一日世上千載，兩年裏 Bootstrap 已經升上 &lt;a class="reference external" href="http://getbootstrap.com/"&gt;v3.3&lt;/a&gt; ,
而 Pelican 則已經升到 &lt;a class="reference external" href="https://github.com/getpelican/pelican/releases/tag/3.5.0"&gt;3.5&lt;/a&gt; 了。
早就眼饞 Bootstrap 和 Pelican 中的諸多新功能新設計，不過無奈於時間有限只能飽飽眼福。&lt;/p&gt;
&lt;p&gt;近日想寫的東西越積越多，終於下定決心花了前前後後 &lt;strong&gt;兩個月&lt;/strong&gt; 的時間重新設計了一遍
Pelican 的主題，配合一些我覺得有用的插件。於是本博客就變成你們現在看到的樣子了。
（以及本篇博文也用了兩個月的時間寫完，其間還發了幾篇別的短文，算是恢復寫博客的嘗試吧 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月14日更新&lt;/strong&gt;&lt;/div&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id38"&gt;前言: 新天新地，將一切都更新了 &lt;a class="footnote-reference" href="#id37" id="id1"&gt;[1]&lt;/a&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;不知不覺間放任這邊長草很久了，從上次
&lt;a class="reference external" href="//farseerfc.me/try-pelican.html"&gt;折騰主題&lt;/a&gt; 到現在都快三年了，
而從上次 &lt;a class="reference external" href="//farseerfc.me/marry-me.html"&gt;寫了篇告白信&lt;/a&gt; 到現在也有快兩年了。
這期間曾經把主題配色從 &lt;a class="reference external" href="http://getbootstrap.com/2.3.2/"&gt;Bootstrap 2&lt;/a&gt; 默認的
白底黑字改成了讓眼睛更舒適的黑底白字，也不過是用 drop-in 的配色方案而已，沒有本質上的改進。&lt;/p&gt;
&lt;p&gt;洞中一日世上千載，兩年裏 Bootstrap 已經升上 &lt;a class="reference external" href="http://getbootstrap.com/"&gt;v3.3&lt;/a&gt; ,
而 Pelican 則已經升到 &lt;a class="reference external" href="https://github.com/getpelican/pelican/releases/tag/3.5.0"&gt;3.5&lt;/a&gt; 了。
早就眼饞 Bootstrap 和 Pelican 中的諸多新功能新設計，不過無奈於時間有限只能飽飽眼福。&lt;/p&gt;
&lt;p&gt;近日想寫的東西越積越多，終於下定決心花了前前後後 &lt;strong&gt;兩個月&lt;/strong&gt; 的時間重新設計了一遍
Pelican 的主題，配合一些我覺得有用的插件。於是本博客就變成你們現在看到的樣子了。
（以及本篇博文也用了兩個月的時間寫完，其間還發了幾篇別的短文，算是恢復寫博客的嘗試吧。）&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
在邁阿密參加 &lt;a class="reference external" href="http://icsr2015.ipd.kit.edu/"&gt;ICSR 2015&lt;/a&gt; 的時候
拍到的街邊一家叫 Pelican 的旅館&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Pelican Hotel" class="img-responsive" src="//farseerfc.me/images/pelican.jpg"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="bootstrap-3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id39"&gt;Bootstrap 3 的新設計&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;全新的 &lt;ruby&gt;&lt;rb&gt;優先移動設備&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;mobile-first&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; &lt;ruby&gt;&lt;rb&gt;響應式&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;responsive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 設計。
原本Bootstrap 2雖然有響應式設計，
不過諸多細節不能符合我的需求，最終還是得手工 hack &lt;code class="code"&gt;
@media&lt;/code&gt;
 查詢去微調。
現在的 &lt;ruby&gt;&lt;rb&gt;優先移動設備&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;mobile-first&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; &lt;ruby&gt;&lt;rb&gt;響應式&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;responsive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
&lt;ruby&gt;&lt;rb&gt;柵格系統&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;grid system&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 則相對顯得科學很多了，也終於能在手持
設備上看起來舒服一些。諸位可以嘗試改變窗口寬度，或者在不同的手持設備上打開這個
blog ，體驗一下這個頁面在不同顯示器大小中的效果。如果仍有問題歡迎
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/issues"&gt;發 Issue 給我&lt;/a&gt;  。&lt;/li&gt;
&lt;li&gt;科學的 &lt;ruby&gt;&lt;rb&gt;導航欄&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Navbar&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。
比 Bootstrap 2 那個科學很多了。無論是 &lt;ruby&gt;&lt;rb&gt;保持&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;sticky&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 在上端還是跟着浮動，
或者像這邊這樣 &lt;a class="reference external" href="http://www.virtuosoft.eu/code/bootstrap-autohidingnavbar/"&gt;自動隱藏&lt;/a&gt; 都很簡單。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多細節參考 &lt;a class="reference external" href="http://getbootstrap.com/"&gt;Bootstrap 3 主頁&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pelican-3-5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id40"&gt;Pelican 3.5 的新功能&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Python 2 和 Python 3 統一代碼：
再沒有惱人的 unicode 相關的問題了。這對 blog 系統來說相當重要啊。
而且還能方便切換 pypy 等不同的解釋器。&lt;/li&gt;
&lt;li&gt;全新的插件系統：非常多功能強大的 &lt;a class="reference external" href="https://github.com/getpelican/pelican-plugins"&gt;插件&lt;/a&gt; 等着你。&lt;/li&gt;
&lt;li&gt;增強了導入系統：嗯總算可以導入我的中文的 wordpress 博客了。（雖然那邊長草更久了……）&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://pelican.readthedocs.org/en/latest/content.html#linking-to-internal-content"&gt;站內鏈接&lt;/a&gt;
：不用 &lt;ruby&gt;&lt;rb&gt;硬編碼&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;hard code&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 目標頁面的鏈接了，可以直接寫源文件的位置然後讓 pelican
處理，這樣能簡化各種 &lt;ruby&gt;&lt;rb&gt;插件&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;plugin&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 和 &lt;ruby&gt;&lt;rb&gt;主題&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;theme&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的實現。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多細節參考 &lt;a class="reference external" href="http://pelican.readthedocs.org/en/latest/"&gt;Pelican 文檔&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id41"&gt;新的文件夾佈局&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Pelican 的新文件夾佈局&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;pre&gt;&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span style="color:blue;font-weight:bold;"&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:blue;font-weight:bold;"&gt;cache&lt;/span&gt;             生成頁面的 pickle 緩存&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:blue;font-weight:bold;"&gt;content&lt;/span&gt;           讀取的全部內容&lt;/span&gt;
&lt;span class="code-line"&gt;│   ├── &lt;span style="color:blue;font-weight:bold;"&gt;&amp;lt;categories&amp;gt;&lt;/span&gt;      按分類存放的文章&lt;/span&gt;
&lt;span class="code-line"&gt;│   ├── &lt;span style="color:blue;font-weight:bold;"&gt;pages&lt;/span&gt;             像 About 這樣的固定頁面&lt;/span&gt;
&lt;span class="code-line"&gt;│   └── &lt;span style="color:blue;font-weight:bold;"&gt;static&lt;/span&gt;            文章內用到的靜態內容&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:blue;font-weight:bold;"&gt;drafts&lt;/span&gt;            文章的草稿箱&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:green;font-weight:bold;"&gt;Makefile&lt;/span&gt;          生成用的 makefile&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:green;font-weight:bold;"&gt;pelicanconf.py&lt;/span&gt;    測試時用的快速 Pelican 配置&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:green;font-weight:bold;"&gt;publishconf.py&lt;/span&gt;    部署時用的耗時 Pelican 配置&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:teal;font-weight:bold;"&gt;output&lt;/span&gt;          -&amp;gt; &lt;span style="color:blue;font-weight:bold;"&gt;../farseerfc.github.io&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;├── &lt;span style="color:teal;font-weight:bold;"&gt;plugins&lt;/span&gt;         -&amp;gt; &lt;span style="color:blue;font-weight:bold;"&gt;../pelican-plugins&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;└── &lt;span style="color:teal;font-weight:bold;"&gt;theme&lt;/span&gt;           -&amp;gt; &lt;span style="color:blue;font-weight:bold;"&gt;../pelican-bootstrap3&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/farseerfc/farseerfc.github.com"&gt;之前的博客&lt;/a&gt; 仍然留在
github 上，其中的內容完全搬過來了。開始寫老博客的時候 Pelican 版本較早，沒有形成好的
文件夾佈局，導致生成的文章、使用的模板和撰寫的內容全都混在一起，非常難以管理，
於是趁改版之際用了新的文件夾佈局方式，並分爲 4 個 git repo 分別管理歷史。&lt;/p&gt;
&lt;p&gt;首先是存放 &lt;a class="reference external" href="https://github.com/farseerfc/farseerfc"&gt;總的博客內容的 repo&lt;/a&gt; ，
其佈局是如圖那樣的。這樣將生成的靜態網站和生成網站用的配置啦內容啦分開之後，頓時清晰了很多。&lt;/p&gt;
&lt;p&gt;然後這個內容 repo 中的三個符號鏈接分別指向三個子 repo（沒用 &lt;code class="code"&gt;
git submodule&lt;/code&gt;

管理純粹是因爲偷懶）。 theme 指向
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3"&gt;pelican-bootstrap3&lt;/a&gt;
，是我修改過的 pelican 主題。
plugins 指向 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-plugins"&gt;pelican-plugins&lt;/a&gt;
，由於 plugins 的質量有些參差不齊，其中不少 plugin
都按我的需要做了些許修改，一些是功能改進，另一些則是修bug（比如不少plugin只支持 python 2）。
最後 output 指向
&lt;a class="reference external" href="https://github.com/farseerfc/farseerfc.github.io"&gt;farseerfc.github.io&lt;/a&gt;
也就是發佈的靜態網站啦。&lt;/p&gt;
&lt;p&gt;接下來從 &lt;strong&gt;主題&lt;/strong&gt; 和 &lt;strong&gt;插件&lt;/strong&gt; 兩個方面介紹一下改版的細節。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="material-design-bootstrap-3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id42"&gt;主題： Material Design 風格的 Bootstrap 3&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上篇 &lt;a class="reference external" href="//farseerfc.me/summarize-material-design-css-framework.html"&gt;博文&lt;/a&gt;
就總結了我爲了這個博客尋找了一堆 CSS 框架，並且最終決定用
&lt;a class="reference external" href="http://fezvrasta.github.io/bootstrap-material-design/"&gt;bootstrap-material-design&lt;/a&gt;
, &lt;a class="reference external" href="https://github.com/DandyDev/pelican-bootstrap3"&gt;DandyDev/pelican-bootstrap3&lt;/a&gt;
和 &lt;a class="reference external" href="http://getbootstrap.com/"&gt;Bootstrap 3&lt;/a&gt; 這三個項目結合的方式實現這個模板的主題。
這三個項目都或多或少經過了我的修改，修改後的項目以 pelican-bootstrap3 爲基礎放在
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3"&gt;這裏&lt;/a&gt; ，包括 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/tree/master/static/bootstrap"&gt;Bootstrap3 樣式&lt;/a&gt;
和 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/tree/master/static/material"&gt;Material 樣式&lt;/a&gt;。&lt;/p&gt;
&lt;div class="section" id="id16"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id43"&gt;對 Bootstrap 3 的定製&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;由於架構完善，修改 Bootstrap 3 感覺非常簡單。另一方面我在 Web 前端技術上的技能點也不多，
所以修改的地方非常有限，只能按我自己的需求定製而已。&lt;/p&gt;
&lt;div class="section" id="id17"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id44"&gt;響應式設備的大小&lt;/a&gt;&lt;/h4&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
修改了 Bootstrap 3 響應式設備的大小&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;screen-xs&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="nt"&gt;320px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;screen-sm&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="nt"&gt;598px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;/*  768px; */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;screen-md&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="nt"&gt;952px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;/*  992px; */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;screen-lg&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="nt"&gt;1350px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;/* 1200px; */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;screen-xl&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="nt"&gt;2030px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;container-sm&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="nt"&gt;582px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;/*  750px; */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;container-md&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="nt"&gt;930px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;/*  970px; */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;container-lg&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;1320px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;/* 1170px; */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;container-xl&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;1990px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;首先把 Bootstrap 3 默認適配的幾個 &lt;a class="reference external" href="http://getbootstrap.com/css/#grid"&gt;響應式設備的大小&lt;/a&gt;
改成了我需要的大小。 &lt;code class="code"&gt;
xs&lt;/code&gt;
 和 &lt;code class="code"&gt;
sm&lt;/code&gt;
 的大小分別按照我的手機屏幕 &lt;strong&gt;豎屏&lt;/strong&gt; 和
&lt;strong&gt;橫屏&lt;/strong&gt; 時候的瀏覽器頁面寬度來算， &lt;code class="code"&gt;
md&lt;/code&gt;
 是想兼容 Nexus 7 橫屏 960 的寬度以及
一個常見上網本 1024 的寬度。 &lt;code class="code"&gt;
lg&lt;/code&gt;
 的大小則按照常見的筆記本 1366 寬的屏幕來適配。&lt;/p&gt;
&lt;p&gt;這裏 Bootstrap 3 支持的設備大小的一個問題是，它最多考慮到 1200 像素寬的顯示器，而更寬的
比如 1600、 2048 甚至 2560 像素寬的顯示器現在也並不少見，其結果就是頁面中左右兩側
有很大的空間被浪費掉了。作爲深受這一問題困擾的用戶之一，我用
&lt;a class="reference external" href="http://stackoverflow.com/a/25644266"&gt;這裏介紹的方法&lt;/a&gt;
給 bootstrap 增加了一類「 &lt;ruby&gt;&lt;rb&gt;比大更大&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;bigger than bigger&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 」的
&lt;code class="code"&gt;
xl&lt;/code&gt;
 響應式設備尺寸，寬度設爲支持 2048 像素寬的顯示器，具體的修改反映在
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/blob/master/static/bootstrap/variables.less"&gt;variables.less&lt;/a&gt;
文件裏。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id20"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id45"&gt;根據寬度自動分欄和瀑布式佈局&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;接下來目標是讓主頁的文章列表像 Google+ 主頁那樣根據顯示器寬度自動調整分欄，使得寬度不同的
顯示器上每個分欄的寬度接近。想要達到的效果是，根據上面定義的屏幕寬度尺寸：&lt;/p&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="26%"/&gt;
&lt;col width="17%"/&gt;
&lt;col width="18%"/&gt;
&lt;col width="39%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;code class="code"&gt;
xs&lt;/code&gt;
 用單欄 &lt;ruby&gt;&lt;rb&gt;流動&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;fluid&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 佈局&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;code class="code"&gt;
sm&lt;/code&gt;
 用上方單欄文章列表、下方雙欄 &lt;ruby&gt;&lt;rb&gt;側邊欄&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;sidebar&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 固定佈局&lt;/td&gt;
&lt;td&gt;&lt;code class="code"&gt;
md&lt;/code&gt;
 用單欄文章列表、單欄 側邊欄 固定佈局&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;table border="0" class="docutils first borderless table last"&gt;
&lt;colgroup&gt;
&lt;col width="100%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;ruby&gt;&lt;rb&gt;導航欄&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Navbar&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;側邊欄&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;底欄&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;table border="0" class="docutils first borderless table last"&gt;
&lt;colgroup&gt;
&lt;col width="53%"/&gt;
&lt;col width="47%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;導航欄&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;文章&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;側邊欄 1&lt;/td&gt;
&lt;td&gt;側邊欄 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;&lt;ruby&gt;&lt;rb&gt;底欄&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;footer&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;td&gt;&lt;table border="0" class="docutils first borderless table last"&gt;
&lt;colgroup&gt;
&lt;col width="53%"/&gt;
&lt;col width="47%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;導航欄&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章 1&lt;/td&gt;
&lt;td&gt;側邊欄 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章 2&lt;/td&gt;
&lt;td&gt;側邊欄 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;&lt;ruby&gt;&lt;rb&gt;底欄&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;footer&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;&lt;code class="code"&gt;
lg&lt;/code&gt;
 用雙欄文章列表、單欄 側邊欄 固定佈局&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;code class="code"&gt;
xl&lt;/code&gt;
 用三欄文章列表、雙欄 側邊欄 固定佈局&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;&lt;table border="0" class="docutils first borderless table last"&gt;
&lt;colgroup&gt;
&lt;col width="35%"/&gt;
&lt;col width="35%"/&gt;
&lt;col width="31%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td colspan="3"&gt;導航欄&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章 1&lt;/td&gt;
&lt;td&gt;文章 3&lt;/td&gt;
&lt;td&gt;側邊欄 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章 2&lt;/td&gt;
&lt;td&gt;文章 4&lt;/td&gt;
&lt;td&gt;側邊欄 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="3"&gt;&lt;ruby&gt;&lt;rb&gt;底欄&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;footer&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;table border="0" class="docutils first borderless table last"&gt;
&lt;colgroup&gt;
&lt;col width="26%"/&gt;
&lt;col width="26%"/&gt;
&lt;col width="26%"/&gt;
&lt;col width="23%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td colspan="4"&gt;導航欄&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章 1&lt;/td&gt;
&lt;td&gt;文章 3&lt;/td&gt;
&lt;td&gt;文章 5&lt;/td&gt;
&lt;td&gt;側邊欄 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;文章 2&lt;/td&gt;
&lt;td&gt;文章 4&lt;/td&gt;
&lt;td&gt;文章 6&lt;/td&gt;
&lt;td&gt;側邊欄 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan="4"&gt;&lt;ruby&gt;&lt;rb&gt;底欄&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;footer&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一開始純粹用 Bootstrap3 的響應式柵格實現這個分欄佈局，結果發現效果不太理想，
因爲文章列表和側邊欄的高度是變化的，會導致柵格間留下大片空白。後來改用
&lt;a class="reference external" href="http://cssdeck.com/labs/pinterest-like-waterfall-design-purely-css"&gt;這裏示範的純CSS瀑布式佈局&lt;/a&gt;
實現文章和側邊欄的佈局，具體的實現代碼在
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/blob/master/static/bootstrap/waterfall.less"&gt;waterfall.less&lt;/a&gt;
，總算達到了想要的佈局了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id21"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id46"&gt;正文的樣式&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;最最重要的是文章正文的樣式。這裏我想要達到的效果是，在大屏幕上用更大的字號，讓讀者
看起來更舒適，同時在小屏幕上用比較小的字號，最終保證基本上「一行」的文字數接近。這個修改
主要針對 &lt;code class="code"&gt;
.jumbotron&lt;/code&gt;
，
用了 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/blob/master/static/bootstrap/jumbotron.less"&gt;不太科學的方式&lt;/a&gt;
代碼太長就不貼全了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id23"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id47"&gt;一些細微的定製&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;把主題配色改成了現在這樣的淡紫色
&lt;code class="code"&gt;
@brand-primary: darken(#6B5594, 6.5%);&lt;/code&gt;

，配合我的頭像風格， 這個修改只需要一行。
接着刪掉了 &lt;code class="code"&gt;
.btn&lt;/code&gt;
 的 &lt;code class="code"&gt;
white-space: nowrap;&lt;/code&gt;
 讓按鈕的文字可以換行，
這也只是一行修改。&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年1月29日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;另外我也不太喜歡 Bootstrap 3 默認在手機上的 &lt;ruby&gt;&lt;rb&gt;摺疊導航欄&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;collapsed navbar&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; ，
摺疊之後的操作不夠直觀方便而且依賴 javascript 所以有 bug …… 於是我把它關掉了，
具體方式是在 variables.less 把 &lt;code class="code"&gt;
@grid-float-breakpoint&lt;/code&gt;
 和
&lt;code class="code"&gt;
@grid-float-breakpoint-max&lt;/code&gt;
 都設爲0就可以了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id24"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id48"&gt;對 bootstrap-material-design 的定製&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;這裏定製的地方不多。原樣式中一個不太科學的做法是所有 &lt;code class="code"&gt;
.btn&lt;/code&gt;
 都強制加上了陰影
效果，這在已經有陰影的環境裏用的話非常礙眼，像是 Win9x 風格的厚重睫毛膏。既然可以單獨
給每個樣式加陰影，於是就把 &lt;code class="code"&gt;
.btn&lt;/code&gt;
 強制的陰影去掉了，只保留鼠標懸停之後強調的陰影。&lt;/p&gt;
&lt;p&gt;其它定製的細節麼就是統一配色風格，修補漏洞錯誤，微調響應式效果而已，這裏不細說。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id25"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id49"&gt;將以上兩者整合在 pelican-bootstrap3 裏&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Pelican 實現顯示源代碼按鈕&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;p&gt;顯示源代碼按鈕借用了 Pelican 配置中自帶的 &lt;code class="code"&gt;
OUTPUT_SOURCES&lt;/code&gt;
 選項將源文件複製到輸出文件夾：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;OUTPUT_SOURCES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;OUTPUT_SOURCES_EXTENSION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'.rst'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後在 Makefile 裏用 pygmentize 把所有源代碼文件着色：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;find -iname &lt;span class="s2"&gt;"*.rst"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; parallel -I@  pygmentize -f html -o @.html @&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最後在按鈕按下的時候用 jQuery 載入源代碼：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;onclick&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"$.get('{{SITEURL}}/{{article.slug}}.rst.html', function(data){$('#source-code').html(data)});$('#article-content').toggle();$('#source-content').toggle();"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;雖然難看的 hack 比較多，但是能用！&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;雖說 pelican-bootstrap3 是我 fork 出來的，不過由於我修改的地方實在太多，代碼看來基本上
接近重寫了一份。好在之前有給 pelican 寫 bootstrap 2 主題的經驗，這次修改算得上駕輕就熟。
可以對比一下 &lt;a class="reference external" href="http://dandydev.net/"&gt;上游作者的博客&lt;/a&gt; 和這裏的樣子體會一下感覺。
具體修改過的地方包括：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;套用 bootstrap-material-design 的各個元素樣式。&lt;/li&gt;
&lt;li&gt;在文章列表模板應用上面提到的 Bootstrap 3 的柵格佈局和瀑布式佈局。&lt;/li&gt;
&lt;li&gt;翻譯到多個語言，這裏在後面的 i18n-subsite 插件裏詳述。&lt;/li&gt;
&lt;li&gt;套用後面會介紹到的各種插件。&lt;/li&gt;
&lt;li&gt;統一側邊欄的樣式到一個模板裏。&lt;/li&gt;
&lt;li&gt;添加 Atom 訂閱按鈕和 breadcrumb 條。&lt;/li&gt;
&lt;li&gt;對正文中出現的插圖，添加點擊放大的功能，通過 Bootstrap 的 &lt;code class="code"&gt;
modal&lt;/code&gt;
 實現。&lt;/li&gt;
&lt;li&gt;上面提到的用 &lt;a class="reference external" href="http://www.virtuosoft.eu/code/bootstrap-autohidingnavbar/"&gt;這個bootstrap插件&lt;/a&gt;
讓導航欄自動隱藏。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;顯示源代碼按鈕&lt;/strong&gt; ，也就是每篇文章信息欄中的
&lt;button class="btn btn-primary"&gt;&lt;i class="fa fa-code"&gt;&lt;/i&gt;&lt;/button&gt; 按鈕。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pelican-restructuredtext"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id50"&gt;插件: 發揮 Pelican 和 reStructuredText 的優勢&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;先列舉一下我目前用到的所有插件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;PLUGINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"i18n_subsites"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s2"&gt;"plantuml"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s2"&gt;"youku"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s2"&gt;"youtube"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'tipue_search'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'neighbors'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'series'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'bootstrapify'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'twitter_bootstrap_rst_directives'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s2"&gt;"render_math"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'extract_toc'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;           &lt;span class="s1"&gt;'summary'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嗯其實不算多。接下來逐一介紹一下這些各具特色的插件。&lt;/p&gt;
&lt;div class="section" id="i18n-subsites"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id51"&gt;i18n-subsites&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;這個插件的目的是創建 &lt;ruby&gt;&lt;rb&gt;國際化&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;internationalization&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
&lt;ruby&gt;&lt;rb&gt;子站&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;subsite&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。&lt;/p&gt;
&lt;p&gt;之前介紹 Pelican 配置的時候就提到過，
原本的 Pelican 就支持一篇文章用多種語言書寫，有 &lt;code class="code"&gt;
lang&lt;/code&gt;
 屬性註明這篇文章使用的
語言，以及 &lt;code class="code"&gt;
slug&lt;/code&gt;
 屬性註明多語言的翻譯之間的關聯，換句話說同一篇文章的多個語言
版本應該有相同的 &lt;code class="code"&gt;
slug&lt;/code&gt;
 和不同的 &lt;code class="code"&gt;
lang&lt;/code&gt;
。然後原本 Pelican 裏對多語言的
實現方式是，首先有一個 &lt;strong&gt;主語言&lt;/strong&gt; 是模板和大部分文章採用的語言，文章列表中會優先列出
用 &lt;strong&gt;主語言&lt;/strong&gt; 撰寫的文章，然後從 &lt;strong&gt;主語言&lt;/strong&gt; 的文章鏈接到別的翻譯版本。
很多博客系統和CMS對多語言的支持都是這樣的，這種處理方式的缺點也顯而易見：作爲 &lt;strong&gt;主語言&lt;/strong&gt;
的語言必須足夠通用，纔能讓進來的人找到合適的翻譯版本，所以通常 &lt;strong&gt;主語言&lt;/strong&gt; 都是英語。&lt;/p&gt;
&lt;p&gt;而這個插件做的事情描述起來很簡單：將文章按語言屬性分到多個子站，每個子站獨立放在各自的文件夾。
比如主站是 &lt;a class="reference external" href="https://farseerfc.github.io/"&gt;https://farseerfc.github.io/&lt;/a&gt; 的話，那麼英語的子站就可以是
&lt;a class="reference external" href="https://farseerfc.github.io/en/"&gt;https://farseerfc.github.io/en/&lt;/a&gt; 。
然後分別對多個子站生成靜態頁面。具體的實現方式是對 pelican 的頁面生成步驟做了拆分：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;pelican 按正常情況讀入文章，生成元信息。&lt;/li&gt;
&lt;li&gt;i18n-subsites 針對每個語言，覆蓋掉 pelican 的一些選項設置比如路徑和 URL ，
分別調用 pelican 的頁面生成器按模板生成文章。&lt;/li&gt;
&lt;li&gt;對共用的靜態內容比如模板的 js 和 css 文件，只在主站中生成，子站中的相應鏈接全部鏈回主站。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;雖然描述起來簡單，但是這個插件可以說最大化利用了 Pelican 的插件系統，實現細節相對比較
複雜，大概是我用的這些插件裏面最複雜的了。不誇張的說 Pelican 3.4 支持的新插件 API 和
站內鏈接功能基本上就是爲了配合這個插件的。至於具體它會覆蓋哪些 Pelican 的配置，請參閱它的
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-plugins/blob/master/i18n_subsites/README.rst"&gt;README.md文件&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;按內容拆分多語言子站的做法只解決了問題的一半，還留下另一半的問題，也即對模板的翻譯。
對這個問題， i18n-subsites 提供了兩套方案供選擇：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;用覆蓋配置路徑的方式讓每個子站套用不同的模板。這配置起來簡單，但是對模板維護起來有點困難。&lt;/li&gt;
&lt;li&gt;用 jinja2 的 i18n 插件，配合 Python 的 gettext 庫實現內容翻譯。這個方案
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-plugins/blob/master/i18n_subsites/localizing_using_jinja2.rst"&gt;配置起來比較複雜&lt;/a&gt; ，但是配置好之後用起來就很方便了。
只是要記得每次修改了模板都要更新翻譯，處理 *.po 和 *.mo 文件等等瑣碎事宜。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這裏我用 jinja2 的 i18n 插件的方式實現了模板的翻譯，
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/tree/master/translations"&gt;各個語言的翻譯在這裏&lt;/a&gt; ，
然後用 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/blob/master/SConstruct"&gt;這裏的 SCons 腳本&lt;/a&gt;
根據內容是否變化自動更新 po 和 mo 文件。&lt;/p&gt;
&lt;p&gt;配置好這一套方案之後，還要注意在模板和文章中處理好鏈接。用 Pelican 3.4 之後推薦的
新的文章間鏈接的寫法以及將 &lt;code class="code"&gt;
SITEURL&lt;/code&gt;
 設置爲實際 URL 並且關閉 &lt;code class="code"&gt;
RELATIVE_URLS&lt;/code&gt;

之後，應該就不會出沒什麼問題了（可能還要考慮使用的模板和插件的兼容性，大部分都是寫死了 URL 的問題）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="plantuml"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id52"&gt;plantuml&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
嵌入 PlantUML 的示例&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="uml diagram" class="img-responsive uml" src="//farseerfc.me/uml/8e4b1ee3.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="http://plantuml.sourceforge.net/"&gt;PlantUML&lt;/a&gt; 是一個Java實現的，
用接近文字描述的語言繪製 UML 圖或者 GUI 界面圖的工具，非常適合嵌入在
Markdown、 reStructuredText、 AsciiDoc 等這種輕量級標記語言裏。
然後麼這個 plantuml 插件就是定義了一個新的 reStructuredText
&lt;ruby&gt;&lt;rb&gt;指示符&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;directive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; &lt;code class="code"&gt;
.. uml::&lt;/code&gt;
，把嵌入的內容提取出來調用 plantuml 命令處理
成圖像然後再插入到文章中。&lt;/p&gt;
&lt;p&gt;比如示例裏的這個 UML 圖就是用這樣一段簡單的文字描述生成的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt; &lt;span class="ow"&gt;uml&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    Object &amp;lt;|-- ArrayList&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    Object : equals()&lt;/span&gt;
&lt;span class="code-line"&gt;    ArrayList : Object[] elementData&lt;/span&gt;
&lt;span class="code-line"&gt;    ArrayList : size()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;實際用起來這個插件實現上稍微有點小問題：首先它只支持 python2，所以我把它改寫成了 python
2 和 3 都通用的語法；其次它原本輸出的文件夾似乎會被 pelican 刪掉，所以把它改了個位置；
然後它輸出的 URL 也和 i18n-subsites 插件間有不兼容的問題，也順帶修掉了。
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-plugins/tree/master/plantuml"&gt;修改之後的代碼在這裏&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年1月30日更新&lt;/strong&gt;&lt;/div&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
嵌入 Ditaa 的示例&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="ditaa diagram" class="img-responsive ditaa" src="//farseerfc.me/uml/973a8424.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;plantuml 是繪製UML的，除此之外還有一個類似的工具是繪製一般的 &lt;ruby&gt;&lt;rb&gt;流程圖&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;diagram&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;
的，叫 &lt;a class="reference external" href="http://ditaa.sourceforge.net/"&gt;ditaa&lt;/a&gt; ，和 plantuml 非常像，也比較像
reStructuredText 的表格。
於是我也照貓畫虎實現了一個 ditaa 的 &lt;ruby&gt;&lt;rb&gt;指示符&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;directive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; ，用起來類似這樣：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt; &lt;span class="ow"&gt;ditaa&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;                       +-------------+&lt;/span&gt;
&lt;span class="code-line"&gt;                       &lt;span class="o"&gt;|&lt;/span&gt;   ditaa     |-------+&lt;/span&gt;
&lt;span class="code-line"&gt;                       &lt;span class="o"&gt;|&lt;/span&gt;  Diagram    |       |&lt;/span&gt;
&lt;span class="code-line"&gt;                       +-------------+       | PNG out&lt;/span&gt;
&lt;span class="code-line"&gt;                           ^                 |&lt;/span&gt;
&lt;span class="code-line"&gt;                           &lt;span class="o"&gt;|&lt;/span&gt; ditaa in        |&lt;/span&gt;
&lt;span class="code-line"&gt;                           &lt;span class="o"&gt;|&lt;/span&gt;                 v&lt;/span&gt;
&lt;span class="code-line"&gt;     +--------+   +--------+----+    /----------------\&lt;/span&gt;
&lt;span class="code-line"&gt;     &lt;span class="o"&gt;|&lt;/span&gt;        | --+   Pelican   +--&amp;gt; |                |&lt;/span&gt;
&lt;span class="code-line"&gt;     &lt;span class="o"&gt;|&lt;/span&gt;  Text  |   +-------------+    | Beautiful Blog |&lt;/span&gt;
&lt;span class="code-line"&gt;     |Document|   |   !magic!   |    |                |&lt;/span&gt;
&lt;span class="code-line"&gt;     &lt;span class="o"&gt;|&lt;/span&gt;     {d}|   |             |    |                |&lt;/span&gt;
&lt;span class="code-line"&gt;     +---+----+   +-------------+    \----------------/&lt;/span&gt;
&lt;span class="code-line"&gt;         :                                   ^&lt;/span&gt;
&lt;span class="code-line"&gt;         &lt;span class="o"&gt;|&lt;/span&gt;          Lots of work             |&lt;/span&gt;
&lt;span class="code-line"&gt;         +-----------------------------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="render-math"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id53"&gt;render-math&lt;/a&gt;&lt;/h3&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
嵌入公式的示例&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;p&gt;示範行內公式 &lt;span class="math"&gt;\(A_\text{c} = (\pi/4) d^2\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;整行公式&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\alpha{}_t(i) = P(O_1, O_2, \ldots  O_t, q_t = S_i \lambda{})
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;這個插件提供在 reStructuredText 中用 LaTeX 語法插入數學公式的能力，定義了
&lt;code class="code"&gt;
:math:&lt;/code&gt;
&lt;ruby&gt;&lt;rb&gt;行內角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 和 &lt;code class="code"&gt;
.. math::&lt;/code&gt;
&lt;ruby&gt;&lt;rb&gt;指示符&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;directive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。
實際工作的渲染庫當然是大名鼎鼎的 &lt;a class="reference external" href="http://www.mathjax.org/"&gt;MathJax&lt;/a&gt; ，這個插件
會用 MathJax 的 CDN 載入，所以也沒有額外的依賴文件。（只是不知道是否會被國內牆掉，
如果公式顯示不正常請 &lt;strong&gt;務必&lt;/strong&gt; 告訴我。）&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="youtube-youku"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id54"&gt;youtube 和 youku&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;顧名思義，這兩個插件分別實現嵌入 youtube 和 youku 視頻。其中 youtube 是原本就有的插件，
youku 是我照貓畫虎抄的。
之前寫了一篇
&lt;a class="reference external" href="//farseerfc.me/jumping-kde5-plasma-activities-button.html"&gt;KDE5 Plasma 之跳動賣萌的活動按鈕&lt;/a&gt;
用到了這兩個插件。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tipue-search"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id55"&gt;tipue_search&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.tipue.com/search/"&gt;Tipue search&lt;/a&gt; 是一個非常有意思也很強大的搜索工具，
通過 jQuery 實現靜態博客的站內搜索功能。實現方式是，它需要你寫一個 json 文件，包含
整個網站的 &lt;strong&gt;全部&lt;/strong&gt; 文章的標題和文字內容，然後在搜索的時候讀入這個 json 做搜索（是不是有點耍賴）。
雖然聽起來會有性能問題，但是應用在小型的靜態博客上效果意外很不錯，比如本站的所有文章內容
放在一起的 json 也只有 300KiB 左右。&lt;/p&gt;
&lt;p&gt;這個插件就是自動在 pelican 輸出完全部靜態網頁之後，調用 beautifulsoup4 從所有網頁中抽取出
純文本，產生這個 json 給 Tipue 用。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="neighbors-series"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id56"&gt;neighbors 和 series&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;這兩個插件比較類似也都比較簡單， neighbors 提供一篇文章的前後文章信息，
在主題模板裏可以用來製作 &lt;strong&gt;上一篇&lt;/strong&gt; 和 &lt;strong&gt;下一篇&lt;/strong&gt; 按鈕。
series 提供將多篇文章歸類爲一個 &lt;strong&gt;系列&lt;/strong&gt; 的支持，當然也需要在
主題模板中定義顯示「文章系列」的列表。這兩個插件的效果都能在本文末尾，評論區上方的部分看到。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bootstrapify-twitter-bootstrap-rst-directives"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id57"&gt;bootstrapify 和 twitter_bootstrap_rst_directives&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;這兩個插件讓文章的 &lt;strong&gt;正文&lt;/strong&gt; 套用上 Bootstrap 的樣式。&lt;/p&gt;
&lt;p&gt;bootstrapify 這個插件實現得比較簡單，用 beautifulsoup4 在靜態網頁的結果裏面過濾元素，
對 &lt;code class="code"&gt;
table&lt;/code&gt;
 , &lt;code class="code"&gt;
img&lt;/code&gt;
 , &lt;code class="code"&gt;
embed&lt;/code&gt;
 , &lt;code class="code"&gt;
iframe&lt;/code&gt;
 ,
&lt;code class="code"&gt;
video&lt;/code&gt;
 , &lt;code class="code"&gt;
object&lt;/code&gt;
 這幾個標籤套用上
&lt;a class="reference external" href="http://getbootstrap.com/components/#responsive-embed"&gt;響應式嵌入對象的類&lt;/a&gt;
讓他們更美觀。&lt;/p&gt;
&lt;p&gt;twitter_bootstrap_rst_directives 這個插件則是增加了幾個 reStructuredText 的
&lt;ruby&gt;&lt;rb&gt;行內角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 和 &lt;ruby&gt;&lt;rb&gt;指示符&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;directive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。
它實現的 &lt;ruby&gt;&lt;rb&gt;行內角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 包括：
用 &lt;code class="code"&gt;
:kbd:&lt;/code&gt;
 實現如 &lt;kbd class="kbd"&gt;
Ctrl+C&lt;/kbd&gt;
 這樣的鍵盤快捷鍵，
用 &lt;code class="code"&gt;
:code:&lt;/code&gt;
 嵌入代碼片段，用 &lt;code class="code"&gt;
:glyph:&lt;/code&gt;
 嵌入字符圖標。
它實現的 &lt;ruby&gt;&lt;rb&gt;指示符&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;directive&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 包括：
&lt;a class="reference external" href="http://getbootstrap.com/components/#labels"&gt;labels 行內標籤&lt;/a&gt; ，
&lt;a class="reference external" href="http://getbootstrap.com/components/#alerts"&gt;alerts 提示段落&lt;/a&gt; ，
&lt;a class="reference external" href="http://getbootstrap.com/components/#panels"&gt;panels 嵌入面板&lt;/a&gt; ，
以及還有一個 &lt;a class="reference external" href="http://getbootstrap.com/components/#media"&gt;media 混排圖標&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;對其中的 &lt;code class="code"&gt;
panel&lt;/code&gt;
 我改寫了它在文章正文中的樣式，在 &lt;code class="code"&gt;
lg&lt;/code&gt;
 或者 &lt;code class="code"&gt;
xl&lt;/code&gt;

的屏幕寬度下，分別用 &lt;span class="math"&gt;\(\frac{1}{2}\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(\frac{1}{3}\)&lt;/span&gt; 大小的嵌入面板，
簡單實現和正文文字的圖文混排。&lt;/p&gt;
&lt;p&gt;除此以外我還在 twitter_bootstrap_rst_directives 這個插件裏套用它的框架實現了兩個額外
的 &lt;ruby&gt;&lt;rb&gt;行內角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; ， 分別是 &lt;code class="code"&gt;
:ruby:&lt;/code&gt;
 ：通過 html5 的 &lt;code class="code"&gt;
&amp;lt;ruby&amp;gt;&lt;/code&gt;

標籤實現文字上方的注音（firefox下
&lt;a class="reference external" href="https://bugzilla.mozilla.org/show_bug.cgi?id=33339"&gt;不支持&lt;/a&gt;
，會使用文字後的括號顯示）， 以及 &lt;code class="code"&gt;
:html:&lt;/code&gt;
 ：在
行內插入 &lt;ruby&gt;&lt;rb&gt;裸&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;raw&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; html 標籤（這屬於 Markdown 的基本功能，在 reStructuredText
這邊由於要考慮多種輸出格式於是就比較麻煩了）。這兩個 &lt;ruby&gt;&lt;rb&gt;行內角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-plugins/blob/master/twitter_bootstrap_rst_directives/bootstrap_rst_directives.py#L140"&gt;實現代碼在這裏&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月3日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;今天又在 twitter_bootstrap_rst_directives 裏增加了兩個 &lt;ruby&gt;&lt;rb&gt;行內角色&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;role&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 。
一個是 &lt;code class="code"&gt;
:twi:&lt;/code&gt;
 用來寫 twitter 用戶的鏈接，比如 &lt;a class="reference external" href="//twitter.com/farseerfc"&gt;@farseerfc&lt;/a&gt; ，另一個是
&lt;code class="code"&gt;
:irc:&lt;/code&gt;
 用來指向 freenode 的 channel ，比如 &lt;a class="reference external" href="//webchat.freenode.net/?channels=yssyd3"&gt;#yssyd3&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年2月14日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;今天增加了 &lt;code class="code"&gt;
.. friend::&lt;/code&gt;
 用來寫好友鏈接，以及 &lt;code class="code"&gt;
fref&lt;/code&gt;
 用來引用好友，
比如 &lt;a class="reference external" href="/links.html#lqymgt"&gt;LQYMGT&lt;/a&gt; 這樣。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="extract-toc-summary"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id58"&gt;extract_toc 和 summary&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;最後是這兩個有點「名不副實」的插件。&lt;/p&gt;
&lt;p&gt;reStructuredText 原本就有自動生成
&lt;ruby&gt;&lt;rb&gt;目錄&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;toc&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 的功能，用起來也非常簡單，只需要在想要插入目錄的地方寫一行
&lt;code class="code"&gt;
.. contents::&lt;/code&gt;
 ，剩下的都由 docutils 自動生成了。
只是當然這樣生成的目錄肯定會插入在文章的正文裏，而 extract_toc 這個插件的作用就是簡單地
把這個目錄抽取出來，讓模板能在別的地方放置這個目錄。比如我這裏就把目錄放在了一個
&lt;code class="code"&gt;
panel&lt;/code&gt;
 裏。&lt;/p&gt;
&lt;p&gt;然後 Pelican 也原本就有從文章中抽取 &lt;ruby&gt;&lt;rb&gt;總結&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;summary&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; 顯示在文章列表的功能。
Pelican 原始的實現似乎是按照文字數抽取前半段，不總是適合作爲總結。 於是這個 summary
插件的作用其實是允許在正文中以特殊的註釋的方式標註哪些部分應該被抽出來作爲總結。
summary 這個插件原本的實現只允許抽取一段文字，我又對它的實現做了少許擴充，允許標註多段
文字合併起來作爲總結。&lt;/p&gt;
&lt;div class="label label-warning"&gt;
&lt;strong&gt;2015年1月29日更新&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;今天在 extract_toc 插件的幫助下，在側邊欄裏放了一個 Bootstrap affix 的目錄，
它保持在頁面的右側位置不變，方便導航到文章的各個地方。具體實現方法除了 Bootstrap 3 的
&lt;a class="reference external" href="http://getbootstrap.com/javascript/#affix"&gt;Affix 文檔&lt;/a&gt; ，還參考了
&lt;a class="reference external" href="http://tutsme-webdesign.info/bootstrap-3-affix/"&gt;這篇更詳細的說明&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id36"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id59"&gt;結語&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;這個博客的配置都可以在
&lt;a class="reference external" href="https://github.com/farseerfc/farseerfc/blob/master/pelicanconf.py"&gt;github 上找到&lt;/a&gt;
，包括用來
&lt;a class="reference external" href="https://github.com/farseerfc/farseerfc/blob/master/Makefile"&gt;自動生成整個博客的 Makefile&lt;/a&gt;
，由於比較長，這裏就不再貼了。&lt;/p&gt;
&lt;p&gt;折騰這個主題前後歷時兩個月，期間學會了不少東西，也算是不錯的收穫吧。
現在既然基礎打好了，接下來就要開始多寫博客了。（希望拖延症不會再犯……）&lt;/p&gt;
&lt;p&gt;最近發現除了我的博客之外還有一個網站
&lt;a class="reference external" href="http://www.kansaslinuxfest.us/"&gt;Kansas Linux Fest&lt;/a&gt; fork
了我的主題，不過他們用了我修改的早期版本，還是原本的 Bootstrap 3 和
bootstrap-material-design 樣式。自己草草修改的東西被別人用到果然還是有點小激動呢，
以及接下來不能馬馬虎虎地寫 commit 消息了。&lt;/p&gt;
&lt;table border="0" class="docutils footnote table" frame="void" id="id37" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;賽65:17「看哪！我造新天新地」啟21:5「我將一切都更新了。」&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="tech"></category><category term="python"></category><category term="pelican"></category><category term="bootstrap"></category><category term="material"></category><category term="subsite"></category></entry><entry><title>總結一下 Material Design 的 CSS 框架</title><link href="//farseerfc.me/summarize-material-design-css-framework.html" rel="alternate"></link><published>2015-01-16T03:27:00+09:00</published><updated>2015-01-16T03:27:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2015-01-16:/summarize-material-design-css-framework.html</id><summary type="html">&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;現在這裏的界面風格要從 Google 在 &lt;a class="reference external" href="https://www.google.com/events/io"&gt;I/O 2014 大會&lt;/a&gt;
上公佈Android L 也即 後來的 Lollipop 說起。 他們在談論界面設計的時候公佈了他們的
設計準則： &lt;a class="reference external" href="http://www.google.com/design/spec/material-design/introduction.html"&gt;Material Design&lt;/a&gt; (&lt;a class="reference external" href="http://wcc723.gitbooks.io/google_design_translate/"&gt;中文非官方翻譯&lt;/a&gt; )。
當然這只是一些準則，總結並描述了之前在 Web 設計和移動端 App 界面設計方面的一些規範，
並且用材料的類比來形象化的比喻這個準則。關於 Material Design 的更多中文資料可
&lt;a class="reference external" href="http://www.ui.cn/Material/"&gt;參考這裏&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;看到 Material Design 之後就覺得這個設計風格非常符合直覺，於是想在這邊也用上
Material Design。 但是我在 Web 前端科技樹上沒點多少技能點，所以想找找別人實現好的模板
或者框架直接套用上。在網絡上搜索數日找到了這幾個：&lt;/p&gt;
&lt;div class="section" id="polymer-paper-elements"&gt;
&lt;h2&gt;Polymer Paper Elements&lt;/h2&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Polymer&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;object class="embed-responsive-item" data="https://www.polymer-project.org/images/logos/p-logo.svg" type="image/svg+xml"&gt;
Polymer logo&lt;/object&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;Google …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;現在這裏的界面風格要從 Google 在 &lt;a class="reference external" href="https://www.google.com/events/io"&gt;I/O 2014 大會&lt;/a&gt;
上公佈Android L 也即 後來的 Lollipop 說起。 他們在談論界面設計的時候公佈了他們的
設計準則： &lt;a class="reference external" href="http://www.google.com/design/spec/material-design/introduction.html"&gt;Material Design&lt;/a&gt; (&lt;a class="reference external" href="http://wcc723.gitbooks.io/google_design_translate/"&gt;中文非官方翻譯&lt;/a&gt; )。
當然這只是一些準則，總結並描述了之前在 Web 設計和移動端 App 界面設計方面的一些規範，
並且用材料的類比來形象化的比喻這個準則。關於 Material Design 的更多中文資料可
&lt;a class="reference external" href="http://www.ui.cn/Material/"&gt;參考這裏&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;看到 Material Design 之後就覺得這個設計風格非常符合直覺，於是想在這邊也用上
Material Design。 但是我在 Web 前端科技樹上沒點多少技能點，所以想找找別人實現好的模板
或者框架直接套用上。在網絡上搜索數日找到了這幾個：&lt;/p&gt;
&lt;div class="section" id="polymer-paper-elements"&gt;
&lt;h2&gt;Polymer Paper Elements&lt;/h2&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Polymer&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;object class="embed-responsive-item" data="https://www.polymer-project.org/images/logos/p-logo.svg" type="image/svg+xml"&gt;
Polymer logo&lt;/object&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;Google 官方提供的參考實現應該是 &lt;a class="reference external" href="https://www.polymer-project.org/"&gt;Polymer&lt;/a&gt; 中的
&lt;a class="reference external" href="https://www.polymer-project.org/docs/elements/paper-elements.html"&gt;Paper Elements&lt;/a&gt; 。&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;p&gt;由於是 &lt;strong&gt;官方參考實現&lt;/strong&gt; ，這個框架的確非常忠實地實現了 Material Design 的設計，但是同時
由於它基於 &lt;a class="reference external" href="http://webcomponents.org/"&gt;HTML5 Web Components&lt;/a&gt; 構建，相關技術我還
不太懂，瀏覽器兼容性和其餘 HTML 技術的兼容性也還不太完善的樣子……&lt;/p&gt;
&lt;p&gt;並且對於我這個 Web 開發的半吊子來說，Polymer 只是提供了一組設計組建，沒有完善的
&lt;strong&gt;響應式&lt;/strong&gt; (responsive) 佈局支持，也沒有 Navbar 這種常見的框架組建，真的要用起來的話還
需要手工實現不少東西。於是口水了半天之後只好放棄……以後可能真的會換用這個，只是目前需要學
的東西太多了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="angular-material-design"&gt;
&lt;h2&gt;Angular Material Design&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
AngularJS&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="AngularJS logo" class="img-responsive" src="https://angularjs.org/img/AngularJS-large.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="https://angularjs.org/"&gt;AngularJS&lt;/a&gt; 是 Google 對 Web Components 技術的另一個
嘗試。而這額 &lt;a class="reference external" href="https://material.angularjs.org/"&gt;Angular Material Design&lt;/a&gt; 項目
就是基於 AngularJS 構建的Material Design 庫啦，同樣是 Google 出品所以應該算得上半個
官方實現吧。 相比於 Polymer, AngularJS 算是實用了很多，提供了基於
&lt;a class="reference external" href="http://www.w3.org/TR/css3-flexbox/"&gt;CSS Flexbox&lt;/a&gt; 的佈局。有人對這兩者的評價是，
如果說 Polymer 代表了 &lt;strong&gt;未來趨勢&lt;/strong&gt; ，那麼 AngularJS 就是 &lt;strong&gt;眼下可用&lt;/strong&gt; 的 Web
Components 實現了。&lt;/p&gt;
&lt;p&gt;只不過同樣是因爲它是 Components 的框架，對 WebApp 的支持很豐富，大量採用 Ajax 等
JavaScript 技術， 對於我這個靜態博客來說仍然稍顯高級了……非常擔心還不支持 HTML5 的瀏覽器
比如 w3m 甚至 cURL 對它的支持程度。 於是最終也沒有使用它。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="materialize"&gt;
&lt;h2&gt;Materialize&lt;/h2&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
Materialize&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;img alt="Materialize logo" class="img-responsive" src="https://raw.githubusercontent.com/Dogfalo/materialize/master/images/materialize.gif"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="http://materializecss.com/"&gt;Materialize&lt;/a&gt; 這是一批(自稱?)熟悉 Android 上
Material Design 的設計師們新近出爐的框架，試圖提供一個接近 Bootstrap 的方案。
最早是在 &lt;a class="reference external" href="http://www.reddit.com/r/web_design/comments/2lt4qy/what_do_you_think_of_materialize_a_responsive/"&gt;Reddit&lt;/a&gt; 上看到對它的討論的，立刻覺得這個想法不錯。&lt;/p&gt;
&lt;p&gt;體驗一下官網的設計就可以看出，他們的動畫效果非常接近 Polymer 的感覺，響應式設計的佈局
也還不錯。 只是同樣體驗一下他們現在的官網就可以看出，他們目前的
&lt;a class="reference external" href="https://github.com/Dogfalo/materialize/issues"&gt;bug 還比較多&lt;/a&gt; ，甚至一些 bug
在他們自己的主頁上也有顯現。 雖然不想給這個新出爐的項目潑涼水，不過看來要達到他們聲稱的接近
Bootstrap 的易用度還任重而道遠……&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bootstrap-material-design-bootstrap3"&gt;
&lt;h2&gt;bootstrap-material-design + bootstrap3&lt;/h2&gt;
&lt;p&gt;這是我最終選擇的方案。這個方案將三個項目組合在了一起，分別是
&lt;a class="reference external" href="http://fezvrasta.github.io/bootstrap-material-design/"&gt;bootstrap-material-design&lt;/a&gt;
, &lt;a class="reference external" href="https://github.com/DandyDev/pelican-bootstrap3"&gt;pelican-bootstrap3&lt;/a&gt;
和 &lt;a class="reference external" href="http://getbootstrap.com/"&gt;Bootstrap 3&lt;/a&gt; 。
Bootstrap 3 想必不用再介紹了，很多網站都在使用這套框架，定製性很高。
bootstrap-material-design 是在 Bootstrap 3 的基礎上套用 Material Design 風格
製作的一套 CSS 庫，當然也不是很完善並且在不斷改進中，一些細節其實並不是很符合我的要求。
最後 pelican-bootstrap3 是用 Bootstrap 3 做的 pelican 模板。
這三個項目或多或少都有點不合我的口味，於是嘛就把 pelican-bootstrap3 fork了一套放在
&lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3"&gt;這裏&lt;/a&gt; ，其中還包括我自己改
過的 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/tree/master/static/bootstrap"&gt;Bootstrap3 樣式&lt;/a&gt;
和 &lt;a class="reference external" href="https://github.com/farseerfc/pelican-bootstrap3/tree/master/static/material"&gt;Material 樣式&lt;/a&gt;
，需要的可以自取。&lt;/p&gt;
&lt;p&gt;至於細節上我定製了哪些地方，敬請聽下回分解……&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="css"></category><category term="material"></category><category term="paper"></category></entry><entry><title>從非緩衝輸入流到 Linux 控制檯的歷史</title><link href="//farseerfc.me/from-unbuffered-stdin-to-history-of-linux-tty.html" rel="alternate"></link><published>2014-12-12T17:06:00+09:00</published><updated>2014-12-12T17:06:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2014-12-12:/from-unbuffered-stdin-to-history-of-linux-tty.html</id><summary type="html">
&lt;p&gt;這篇也是源自於水源C板上板友的一個問題，涉及Linux上的控制檯的實現方式和歷史原因。因爲內容比較長，所以在這裏再排版一下發出來。
&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1418138991,file,M.1418138991.A.html"&gt;原帖在這裏&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;可以設置不帶緩衝的標準輸入流嗎？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;WaterElement(UnChanged) 於 2014年12月09日23:29:51 星期二 問到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;請問對於標準輸入流可以設置不帶緩衝嗎？比如以下程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer …&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary><content type="html">
&lt;p&gt;這篇也是源自於水源C板上板友的一個問題，涉及Linux上的控制檯的實現方式和歷史原因。因爲內容比較長，所以在這裏再排版一下發出來。
&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1418138991,file,M.1418138991.A.html"&gt;原帖在這裏&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;可以設置不帶緩衝的標準輸入流嗎？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;WaterElement(UnChanged) 於 2014年12月09日23:29:51 星期二 問到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;請問對於標準輸入流可以設置不帶緩衝嗎？比如以下程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;似乎還是需要在命令行輸入後按回車纔會讓 &lt;code class="code"&gt;
fgets&lt;/code&gt;
 返回，不帶緩衝究竟體現在哪裏？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;這和緩存無關，是控制檯的實現方式的問題。&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;再講細節一點，這裏有很多個程序和設備。以下按 linux 的情況講：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;終端模擬器窗口（比如xterm）收到鍵盤事件&lt;/li&gt;
&lt;li&gt;終端模擬器(xterm)把鍵盤事件發給虛擬終端 pty1&lt;/li&gt;
&lt;li&gt;pty1 檢查目前的輸入狀態，把鍵盤事件轉換成 stdin 的輸入，發給你的程序&lt;/li&gt;
&lt;li&gt;你的程序的 c 庫從 stdin 讀入一個輸入，處理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;標準庫說的輸入緩存是在 4 的這一步進行的。而行輸入是在 3 的這一步被緩存起來的。&lt;/p&gt;
&lt;p&gt;終端pty有多種狀態，一般控制檯程序所在的狀態叫「回顯行緩存」狀態，這個狀態的意思是:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;所有普通字符的按鍵，會回顯到屏幕上，同時記錄在行緩存區裏。&lt;/li&gt;
&lt;li&gt;處理退格( &lt;kbd class="kbd"&gt;
BackSpace&lt;/kbd&gt;
 )，刪除( &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;
 )按鍵爲刪掉字符，左右按鍵移動光標。&lt;/li&gt;
&lt;li&gt;收到回車的時候把整個一行的內容發給stdin。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;參考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Cooked_mode"&gt;http://en.wikipedia.org/wiki/Cooked_mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同時在Linux/Unix下可以發特殊控制符號給pty讓它進入「raw」狀態，這種狀態下按鍵
不會被回顯，顯示什麼內容都靠你程序自己控制。
如果你想得到每一個按鍵事件需要用raw狀態，這需要自己控制回顯自己處理緩衝，
簡單點的方法是用 readline 這樣的庫（基本就是「回顯行緩存」的高級擴展，支持了
Home/End，支持歷史）或者 ncurses 這樣的庫（在raw狀態下實現了一個簡單的窗口/
事件處理框架）。&lt;/p&gt;
&lt;p&gt;參考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/POSIX_terminal_interface#History"&gt;http://en.wikipedia.org/wiki/POSIX_terminal_interface#History&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除此之外， &lt;kbd class="kbd"&gt;
Ctrl-C&lt;/kbd&gt;
 轉換到 SIGINT ， &lt;kbd class="kbd"&gt;
Ctrl-D&lt;/kbd&gt;
 轉換到 EOF 這種也是在 3 這一步做的。&lt;/p&gt;
&lt;p&gt;以及，有些終端模擬器提供的 &lt;kbd class="kbd"&gt;
Ctrl-Shift-C&lt;/kbd&gt;
 表示複製這種是在 2 這一步做的。&lt;/p&gt;
&lt;p&gt;以上是 Linux/unix 的方式。 Windows的情況大體類似，只是細節上有很多地方不一樣：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;窗口事件的接收者是創建 cmd 窗口的 Win32 子系統。&lt;/li&gt;
&lt;li&gt;Win32子系統接收到事件之後，傳遞給位於 命令行子系統 的 cmd 程序&lt;/li&gt;
&lt;li&gt;cmd 程序再傳遞給你的程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Windows上同樣有類似行緩存模式和raw模式的區別，只不過實現細節不太一樣。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="strace"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;strace查看了下&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WaterElement(UnChanged) 於 2014年12月10日21:53:54 星期三 回復：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;感謝FC的詳盡解答。&lt;/p&gt;
&lt;p&gt;用strace查看了下，設置標準輸入沒有緩存的話讀每個字符都會調用一次 &lt;code class="code"&gt;
read&lt;/code&gt;
 系統調用，
比如輸入abc：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;read(0, abc&lt;/span&gt;
&lt;span class="code-line"&gt;"a", 1)                         = 1&lt;/span&gt;
&lt;span class="code-line"&gt;read(0, "b", 1)                         = 1&lt;/span&gt;
&lt;span class="code-line"&gt;read(0, "c", 1)                         = 1&lt;/span&gt;
&lt;span class="code-line"&gt;read(0, "\n", 1)                        = 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有緩存的話就只調用一次了 &lt;code class="code"&gt;
read&lt;/code&gt;
 系統調用了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;read(0, abc&lt;/span&gt;
&lt;span class="code-line"&gt;"abc\n", 1024)                  = 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="raw-mode"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;如果想感受一下 raw mode&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;沒錯，這個是你的進程內C庫做的緩存，tty屬於字符設備所以是一個一個字符塞給你的
程序的。&lt;/p&gt;
&lt;p&gt;如果想感受一下 raw mode 可以試試下面這段程序（沒有檢測錯誤返回值）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;termios.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ttyfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;/* reset tty - useful also for restoring the terminal when this process&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;   wishes to temporarily relinquish the tty&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* flush and reset */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;/* put terminal in raw mode - see termio(7I) for modes */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* copy original and then modify below */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* input modes - clear indicated ones giving: no break, no CR to NL,&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;       no parity check, no strip char, no start/stop output (sic) control */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_iflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BRKINT&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICRNL&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;INPCK&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISTRIP&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IXON&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* output modes - clear giving: no post processing such as NL to CR+NL */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_oflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OPOST&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* control modes - set 8 bit chars */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cflag&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CS8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* local modes - clear giving: echoing off, canonical off (no erase with&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;       backspace, ^U,...),  no extended functions, no signal chars (^Z,^C) */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_lflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ECHO&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICANON&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IEXTEN&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISIG&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* control chars - set return condition: min number of bytes and timer */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after 5 bytes or .8 seconds&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="cm"&gt;                                                after first byte seen      */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* immediate - anything       */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after two bytes, no timer  */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after a byte or .8 seconds */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="cm"&gt;/* put terminal in raw mode after flushing */&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;atexit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;終端上的字符編程&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;vander(大青蛙) 於 2014年12月12日08:52:20 星期五 問到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;學習了！&lt;/p&gt;
&lt;p&gt;進一步想請教一下fc大神。如果我在Linux上做終端上的字符編程，是否除了用ncurses庫
之外，也可以不用該庫而直接與終端打交道，就是你所說的直接在raw模式？
另外，終端類型vt100和linux的差別在哪裏？爲什麼Kevin Boone的KBox配置手冊裏面說必
須把終端類型設成linux，而且要加上terminfo文件，才能讓終端上的vim正常工作？term
info文件又是幹什麼的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;Linux控制檯的歷史&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;嗯理論上可以不用 ncurses 庫直接在 raw 模式操縱終端。&lt;/p&gt;
&lt;p&gt;這裏稍微聊一下terminfo/termcap的歷史，詳細的歷史和吐槽參考
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater's Handbook&lt;/a&gt;
第6章 Terminal Insanity。&lt;/p&gt;
&lt;p&gt;首先一個真正意義上的終端就是一個輸入設備（通常是鍵盤）加上一個輸出設備（打印
機或者顯示器）。很顯然不同的終端的能力不同，比如如果輸出設備是打印機的話，顯
示出來的字符就不能刪掉了（但是能覆蓋），而且輸出了一行之後就不能回到那一行了
。再比如顯示器終端有的支持粗體和下劃線，有的支持顏色，而有的什麼都不支持。
早期Unix工作在電傳打字機（TeleTYpe）終端上，後來Unix被port到越來越多的機器上
，然後越來越多類型的終端會被連到Unix上，很可能同一臺Unix主機連了多個不同類型
的終端。由於是不同廠商提供的不同的終端，能力各有不同，自然控制他們工作的方式
也是不一樣的。所有終端都支持回顯行編輯模式，所以一般的面向行的程序還比較好寫
，但是那時候要撰寫支持所有終端的「全屏」程序就非常痛苦，這種情況就像現在瀏覽
器沒有統一標準下寫HTML要測試各種瀏覽器兼容性一樣。
通常的做法是&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;使用最小功能子集&lt;/li&gt;
&lt;li&gt;假設終端是某個特殊設備，不管別的設備。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;水源的代碼源頭 Firebird2000 就是那樣的一個程序，只支持固定大小的vt102終端。&lt;/p&gt;
&lt;p&gt;這時有一個劃時代意義的程序出現了，就是 vi，試圖要做到「全屏可視化編輯」。這在
現在看起來很簡單，但是在當時基本是天方夜譚。
vi 的做法是提出一層抽象，記錄它所需要的所有終端操作，然後有一個終端類型數據庫
，把那些操作映射到終端類型的具體指令上。當然並不是所有操作在所有終端類型上都
支持，所以會有一堆 fallback，比如要「強調」某段文字，在彩色終端上可能
fallback 到紅色，在黑白終端上可能 fallback 到粗體。&lt;/p&gt;
&lt;p&gt;vi 一出現大家都覺得好頂讚，然後想要寫更多類似 vi 這樣的全屏程序。然後 vi 的作
者就把終端抽象的這部分數據庫放出來形成一個單獨的項目，叫 termcap （Terminal
Capibility），對應的描述終端的數據庫就是 termcap 格式。然後 termcap 只是一個
數據庫（所以無狀態）還不夠方便易用，所以後來又有人用 termcap 實現了 curses 。&lt;/p&gt;
&lt;p&gt;再後來大家用 curses/termcap 的時候漸漸發現這個數據庫有一點不足：它是爲 vi 設
計的，所以只實現了 vi 需要的那部分終端能力。然後對它改進的努力就形成了新的
terminfo 數據庫和 pcurses 和後來的 ncurses 。 然後 VIM 出現了自然也用
terminfo 實現這部分終端操作。&lt;/p&gt;
&lt;p&gt;然後麼就是 X 出現了， xterm 出現了，大家都用顯示器了，然後 xterm 爲了兼容各種
老程序加入了各種老終端的模擬模式。不過因爲最普及的終端是 vt100 所以 xterm 默
認是工作在兼容 vt100 的模式下。然後接下來各種新程序（偷懶不用*curses的那些）
都以 xterm/vt100 的方式寫。&lt;/p&gt;
&lt;p&gt;嗯到此爲止是 Unix 世界的黑歷史。&lt;/p&gt;
&lt;p&gt;知道這段歷史的話就可以明白爲什麼需要 TERM 變量配合 terminfo 數據庫纔能用一些
Unix 下的全屏程序了。類比一下的話這就是現代瀏覽器的 user-agent。&lt;/p&gt;
&lt;p&gt;然後話題回到 Linux 。 大家知道 Linux 早期代碼不是一個 OS， 而是 Linus 大神想
在他的嶄新蹭亮的 386-PC 上遠程登錄他學校的 Unix 主機，接收郵件和逛水源（咳咳
）。於是 Linux 最早的那部分代碼並不是一個通用 OS 而只是一個 bootloader 加一個
終端模擬器。所以現在 Linux 內核裏還留有他當年實現的終端模擬器的部分代碼，而這
個終端模擬器的終端類型就是 linux 啦。然後他當時是爲了逛水源嘛所以 linux 終端
基本上是 vt102 的一個接近完整子集。&lt;/p&gt;
&lt;p&gt;說到這裏脈絡大概應該清晰了， xterm終端類型基本模擬 vt100，linux終端類型基本模
擬 vt102。這兩個的區別其實很細微，都是同一個廠商的兩代產品嘛。有差別的地方差
不多就是 &lt;kbd class="kbd"&gt;
Home&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
End&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageUp&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageDown&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;

這些不在 ASCII 控制字符表裏的按鍵的映射關係不同。&lt;/p&gt;
&lt;p&gt;嗯這也就解釋了爲什麼在linux環境的圖形界面的終端裏 telnet 上水源的話，上面這些
按鍵會錯亂…… 如果設置終端類型是 linux/vt102 的話就不會亂了。在 linux 的
TTY 裏 telnet 也不會亂的樣子。&lt;/p&gt;
&lt;p&gt;寫到這裏纔發現貌似有點長…… 總之可以參考
&lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater's Handbook&lt;/a&gt;
裏的相關歷史評論和吐槽，那一段非常有意思。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="c"></category><category term="linux"></category><category term="stdio"></category><category term="tty"></category><category term="unix"></category><category term="ugh"></category><category term="ncurses"></category><category term="termcap"></category><category term="terminfo"></category></entry><entry><title>KDE5 Plasma 之跳動賣萌的活動按鈕</title><link href="//farseerfc.me/jumping-kde5-plasma-activities-button.html" rel="alternate"></link><published>2014-12-09T01:54:00+09:00</published><updated>2014-12-09T01:54:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2014-12-09:/jumping-kde5-plasma-activities-button.html</id><content type="html">&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;今天嘗試 KDE5 Plasma 的活動的時候無意間發現這個現象。
只要把活動按鈕拖出桌面，它就會在桌面邊緣來回跳動。
視頻如下：&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_SSbf97jGSpI"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/SSbf97jGSpI"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XODQ0NjM2MzQ4"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XODQ0NjM2MzQ4" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_SSbf97jGSpI"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XODQ0NjM2MzQ4"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;當然你可以把它再拖回來，所以這個問題還無傷大雅，只是賣萌。&lt;/p&gt;
&lt;p&gt;比比之前 Gnome3 那個跳動的界面真是好太多了：&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;div class="well" style="padding: 0"&gt;
&lt;div class="tab-content" id="youtubeku"&gt;
&lt;div class="tab-pane fade active in" id="youtube_TRQJdRHYwrw"&gt;
&lt;div align="left" class="youtube embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" src="https://www.youtube.com/embed/TRQJdRHYwrw"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;div class="tab-pane fade" id="youku_XNjc4MjQ5NjE2"&gt;
&lt;div align="left" class="youku embed-responsive embed-responsive-16by9"&gt; &lt;iframe allow="fullscreen" class="embed-responsive-item" frameborder="0" height="498" src="https://player.youku.com/embed/XNjc4MjQ5NjE2" width="510"&gt;&lt;/iframe&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="nav nav-tabs"&gt;
&lt;li class="active"&gt;&lt;a data-toggle="tab" href="#youtube_TRQJdRHYwrw"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a data-toggle="tab" href="#youku_XNjc4MjQ5NjE2"&gt;Youku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;p&gt;順便，今天還看到一個賣萌的 KDE5 Plasma 靜音圖標的翻譯：&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;blockquote class="twitter-tweet" lang="zh-tw"&gt;&lt;p&gt;KDE5のミュート画面の中国語翻訳、「静音」のはずだが「镜音」になっている。Vocaloidファンのネタだか、単なる入力ミスだか分からない。 &lt;a href="http://t.co/ipyHjXMscR"&gt;pic.twitter.com/ipyHjXMscR&lt;/a&gt;&lt;/p&gt;— Jiachen YANG (@farseerfc) &lt;a href="https://twitter.com/farseerfc/status/541944351270518784"&gt;2014 12月 8日&lt;/a&gt;&lt;/blockquote&gt;</content><category term="tech"></category><category term="kde5"></category><category term="plasma"></category><category term="linux"></category><category term="gnome3"></category></entry><entry><title>嫁給我好麼</title><link href="//farseerfc.me/marry-me.html" rel="alternate"></link><published>2013-02-20T20:42:00+09:00</published><updated>2013-02-20T20:42:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2013-02-20:/marry-me.html</id><content type="html">&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
渲染的樣子&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;blockquote&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;img alt="嫁給我好麼" class="img-responsive" src="/images/marry-me.png"/&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以玩的是下面這個：&lt;/p&gt;
&lt;script src="/static/three.min.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/FirstPersonControls.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/helvetiker_regular.typeface.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/214game.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;div id="game_area" style="width: 600px; height: 450px; margin-left: 10px;clear:both"&gt;
&lt;/div&gt;
&lt;p style="margin-left: 100px; margin-top: 10px; "&gt;* 用 WASD←→ 移動，需要 WebGL 支持&lt;/p&gt;</content><category term="life"></category><category term="will"></category><category term="you"></category><category term="marry"></category><category term="me"></category></entry><entry><title>ICSE 2012</title><link href="//farseerfc.me/icse2012.html" rel="alternate"></link><published>2012-06-06T10:42:00+09:00</published><updated>2012-06-06T10:42:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2012-06-06:/icse2012.html</id><summary type="html">
&lt;div class="section" id="june-6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;June 6&lt;/a&gt;&lt;/h2&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;div class="section" id="keynote-1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id2"&gt;Keynote 1&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;沒怎麼聽懂，只記得講到了finance is not money但是沒聽懂這個和軟件有什麼關係。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cost-estimation-for-distributed-software-project"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id3"&gt;Cost Estimation for Distributed Software Project&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;講到他們試圖改善現有的模型去更精確地評估軟件開發的開銷。&lt;/p&gt;
&lt;p&gt;他們會給PM建議之前的項目的歷史數據，然後對於新項目，他們建議歷史上已有
的項目的數據，從而幫助PM得到更精確的評估。他們試圖儘量減少項目評估對PM
的經驗的需求，從而幫助即使經驗很少的PM也能準確評估項目的開銷。&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;p&gt;他們的觀點：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Context-specfic solutions needed!&lt;/p&gt;
&lt;p&gt;我們需要更上下文相關的解決方案！&lt;/p&gt;
&lt;p&gt;Early user paticipation is key!&lt;/p&gt;
&lt;p&gt;早期用戶的參與是關鍵&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="characterizing-logging-practices-in-open-source-software"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id4"&gt;Characterizing Logging Practices in Open-Source Software&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Common mistakes in logging messages&lt;/p&gt;
&lt;p&gt;在日誌記錄中容易犯的錯誤&lt;/p&gt;
&lt;p&gt;他們學習了歷史上的log記錄，然後試圖找到重複修改的輸出log的語句，確定log …&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">
&lt;div class="section" id="june-6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;June 6&lt;/a&gt;&lt;/h2&gt;
&lt;!-- PELICAN_BEGIN_SUMMARY --&gt;
&lt;div class="section" id="keynote-1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id2"&gt;Keynote 1&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;沒怎麼聽懂，只記得講到了finance is not money但是沒聽懂這個和軟件有什麼關係。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cost-estimation-for-distributed-software-project"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id3"&gt;Cost Estimation for Distributed Software Project&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;講到他們試圖改善現有的模型去更精確地評估軟件開發的開銷。&lt;/p&gt;
&lt;p&gt;他們會給PM建議之前的項目的歷史數據，然後對於新項目，他們建議歷史上已有
的項目的數據，從而幫助PM得到更精確的評估。他們試圖儘量減少項目評估對PM
的經驗的需求，從而幫助即使經驗很少的PM也能準確評估項目的開銷。&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;p&gt;他們的觀點：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Context-specfic solutions needed!&lt;/p&gt;
&lt;p&gt;我們需要更上下文相關的解決方案！&lt;/p&gt;
&lt;p&gt;Early user paticipation is key!&lt;/p&gt;
&lt;p&gt;早期用戶的參與是關鍵&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="characterizing-logging-practices-in-open-source-software"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id4"&gt;Characterizing Logging Practices in Open-Source Software&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Common mistakes in logging messages&lt;/p&gt;
&lt;p&gt;在日誌記錄中容易犯的錯誤&lt;/p&gt;
&lt;p&gt;他們學習了歷史上的log記錄，然後試圖找到重複修改的輸出log的語句，確定log
中存在的問題。他們首先確定修改是事後修改。&lt;/p&gt;
&lt;p&gt;通常的修改的比例（9027個修改）&lt;/p&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="10%"/&gt;
&lt;col width="90%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;45%&lt;/td&gt;
&lt;td&gt;靜態文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;27%&lt;/td&gt;
&lt;td&gt;打印出的變量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;26%&lt;/td&gt;
&lt;td&gt;調試等級verbosity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2%&lt;/td&gt;
&lt;td&gt;日誌輸出的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;他們發現有調試等級的變化，是因爲安全漏洞之類的原因，或者在開銷和數據
之間的權衡。&lt;/p&gt;
&lt;p&gt;大多數對log的變量的修改都是爲了增加一個參數。他們之前的LogEnhancer是爲了
解決這個問題而提出的，通過靜態檢查，提醒程序員是否忘記了某個參數&lt;/p&gt;
&lt;p&gt;對text的修改是因爲要改掉過時的代碼信息，避免誤導用戶。&lt;/p&gt;
&lt;p&gt;他們的實驗是採用了基於code clone 的技術，找到所有log語句，然後找不一致
的clone，然後自動提出建議。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="combine-functional-and-imperative-pgrm-for-multicore-sw-scala-java"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id5"&gt;Combine Functional and Imperative Pgrm for Multicore Sw: Scala &amp;amp; Java&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;趨勢：到處都是多核，但是併發程序呢？&lt;/p&gt;
&lt;p&gt;他們研究的對象是Scala和Java，因爲可以編譯後確認JVM字節碼的語義。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Java:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;共享內存&lt;/li&gt;
&lt;li&gt;顯示創建的線程&lt;/li&gt;
&lt;li&gt;手動同步&lt;/li&gt;
&lt;li&gt;Wait/Notify機制&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Scala:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;高階函數&lt;/li&gt;
&lt;li&gt;Actors, 消息傳遞&lt;/li&gt;
&lt;li&gt;lists, filters, iterators&lt;/li&gt;
&lt;li&gt;while&lt;/li&gt;
&lt;li&gt;共享狀態, OO&lt;/li&gt;
&lt;li&gt;import java.* 能從java導入任何庫&lt;/li&gt;
&lt;li&gt;auto type inferance 自動類型推導&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;實驗的參與者都經過4周的訓練，實驗項目是工業等級的開發項目&lt;/p&gt;
&lt;p&gt;結果：&lt;/p&gt;
&lt;p&gt;scala 的項目平均比java多花38%的時間，主要都是花在Test和debug上的時間。&lt;/p&gt;
&lt;p&gt;程序員的經驗和總體時間相關，但是對test和debug沒有顯著影響。&lt;/p&gt;
&lt;p&gt;scala的爲了讓編程更有效率的設計，導致debug更困難。比如類型推導，debug
的時候需要手動推導，來理解正在發生什麼。&lt;/p&gt;
&lt;p&gt;scala的程序比java小，中位數2.6%，平均15.2%&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;性能比較：&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;單核：scala的線性程序的性能比java好&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;4核：&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;scala 7s @ 4 threads&lt;/li&gt;
&lt;li&gt;java 4si @ 8 threads&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;median&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;83s scala&lt;/li&gt;
&lt;li&gt;98s java&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;32core: best scala 34s @ 64 threads&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;結論&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;java有更好的scalability&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;scala類型推導&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;45%說對攜帶碼有幫助&lt;/li&gt;
&lt;li&gt;85%說導致程序錯誤&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;調試&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;23%認爲scala簡單&lt;/li&gt;
&lt;li&gt;77%認爲java簡單&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;multi-paradigram are better&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sound-empirical-evidence-in-software-testing"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id6"&gt;Sound Empirical Evidence in Software Testing&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Test data generation 測試數據自動生成&lt;/p&gt;
&lt;p&gt;Large Empirical Studies - not always possible&lt;/p&gt;
&lt;p&gt;For open source software - big enough&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="identifing-linux-bug-fixing-patch"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;Identifing Linux Bug Fixing Patch&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;current practice:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;manual&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Current research:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;keywords in commits&lt;/li&gt;
&lt;li&gt;link bug reports in bugzilla&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Try to solve classification problem&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;issue&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;pre-identified&lt;/li&gt;
&lt;li&gt;post-identified&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;data&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;from commit log&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;feature extraction&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;text pre-process stemmed non-stop words&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;model learning&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;research questions&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="active-refinement-of-clone-anomaly-reports"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;Active Refinement of Clone Anomaly Reports&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;motivating&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;code clones, clone groups&lt;/li&gt;
&lt;li&gt;clone used to detect bugs&lt;/li&gt;
&lt;li&gt;anomaly : inconsistent clone group
many anomaly clone are note bug, high false positive&lt;/li&gt;
&lt;/ul&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;approach&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;reorder by sorted bug reports&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr class="docutils"/&gt;
&lt;div class="section" id="june7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;June7&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="keynotes-2-sustainability-with-software-an-industrial-perspective"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;Keynotes 2: Sustainability with Software - An Industrial Perspective&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Sustainability&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Classic View: Idenpendent view with overlap&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;Social&lt;/li&gt;
&lt;li&gt;Environment&lt;/li&gt;
&lt;li&gt;Economic&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Nested viw&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Environment&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Social&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;Economic&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;Triple bottom line&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;economic&lt;/dt&gt;
&lt;dd&gt;-global business, networks , global econ&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;env&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;natural res, climate change, population grow&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;social&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;awareness, connectivity, accountability&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;div class="section" id="green-it"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id11"&gt;Green IT&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;reduce IT energy&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;more than 50% cooling - doing nothing&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;mini e-waste: not properly recycled&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;80% in EU&lt;/li&gt;
&lt;li&gt;75% in US&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;foster dematerialization&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In-Memory Technology: Expected Sustainable Benefits&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-can-we-do"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id12"&gt;What can we do?&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;consider all software lifecycle phases in your design&lt;/li&gt;
&lt;li&gt;avoid energy expensive behavior in your codes&lt;/li&gt;
&lt;li&gt;design lean architectures&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="green-by-it"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id13"&gt;Green by IT&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2% green IT&lt;/li&gt;
&lt;li&gt;98% green IT&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="on-how-often-code-is-cloned-across-repositories"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;On How Often code is cloned across repositories&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Line based hashing code clone detection&lt;/p&gt;
&lt;p&gt;never do anything harder than sorting&lt;/p&gt;
&lt;p&gt;hashing a window of 5 lines of normalized (tokenized) code, dropping
3/4 of the hashing&lt;/p&gt;
&lt;p&gt;把ccfinder一個月的工作縮短到了3, 4天。沒有比較presion和recall。&lt;/p&gt;
&lt;table border="0" class="docutils borderless table"&gt;
&lt;colgroup&gt;
&lt;col width="11%"/&gt;
&lt;col width="89%"/&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;14%&lt;/td&gt;
&lt;td&gt;type1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16%&lt;/td&gt;
&lt;td&gt;type2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;17%&lt;/td&gt;
&lt;td&gt;type3 (not really type2)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="graph-based-analysis-and-prediction-for-sw-evolution"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;Graph-based analysis and prediction for sw evolution&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="graph-are-everywhere"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id16"&gt;graph are everywhere&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;internet topology&lt;/li&gt;
&lt;li&gt;social net&lt;/li&gt;
&lt;li&gt;chemistry&lt;/li&gt;
&lt;li&gt;biology&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;in sw
- func call graph
- module dependency graph&lt;/p&gt;
&lt;p&gt;developer interaction graph
- commit logs
- bug reports&lt;/p&gt;
&lt;p&gt;experiment 11 oss, 27~171 release, &amp;gt; 9 years&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="predictors"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id17"&gt;predictors&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;NodeRank&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;similar to pagerank of google&lt;/li&gt;
&lt;li&gt;measure relative importance of each node&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;func call graph with noderank&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;compare rank with severity scale on bugzilla&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;correlation between noderank and BugSeverity&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;func level 0.48 ~ 0.86 varies among projects.&lt;/li&gt;
&lt;li&gt;model level &amp;gt; func level&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;ModularityRatio&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;cohesion/coupling ratio:  IntraDep(M)/InterDep(M)&lt;/li&gt;
&lt;li&gt;forecast mantencance effort&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;use for&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;identify modules that need redesign or refactoring&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;EditDistance&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;bug-based developer collaboration graphs&lt;/li&gt;
&lt;li&gt;ED(G1,G2)=|V1|+|V2|-2|V1交V2|+|E1|+|E2|-2|E1交E2|&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;use for&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;release planning&lt;/li&gt;
&lt;li&gt;resource allocation&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;graph metrics&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;graph diameter&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;average node degree indicates reuse&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;clustering coefficient&lt;/li&gt;
&lt;li&gt;assortativity&lt;/li&gt;
&lt;li&gt;num of cycles&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id18"&gt;Conclusion&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;"Actionable intelligence" from graph evolution&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;studie 11 large long-live projs&lt;/li&gt;
&lt;li&gt;predictors&lt;/li&gt;
&lt;li&gt;identify pivotal moments in evolution&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-make-long-term-contributors-willingness-and-opportunity-in-oss"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;What make long term contributors: willingness and opportunity in OSS&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;OSS don't work without contributors form community&lt;/p&gt;
&lt;p&gt;mozilla (2000-2008)&lt;/p&gt;
&lt;p&gt;10^2.2 LTC &amp;lt;- 2 order -&amp;gt; 10^4.2 new contributors &amp;lt;- 3.5 order -&amp;gt; 10^7.7 users&lt;/p&gt;
&lt;p&gt;gnome (1999-2007)&lt;/p&gt;
&lt;p&gt;10^2.5 LTC &amp;lt;- 1.5 order -&amp;gt; 10^4.0 new contributors &amp;lt;- 3.5 order -&amp;gt; 10^6.5 users&lt;/p&gt;
&lt;div class="section" id="approach"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id20"&gt;approach&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;read issues of 20 LTC and 20 non-LTC&lt;/li&gt;
&lt;li&gt;suvery 56 (36 non-LTC and 20 LTC)&lt;/li&gt;
&lt;li&gt;extract practices published on project web sites&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="summeray"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id21"&gt;summeray&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Ability/Willingness distinguishes LTCs&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Environment&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;macro-climate&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;popularity&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;micro-climate&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;attention&lt;/li&gt;
&lt;li&gt;bumber of peers&lt;/li&gt;
&lt;li&gt;performance of peers&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;regression model&lt;/p&gt;
&lt;p&gt;newcomers to LTC conversion drops&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;actions in first month predicts LTCs&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;24% recall&lt;/li&gt;
&lt;li&gt;37% precision&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="develop-of-auxiliary-functions-should-you-be-agile"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id22"&gt;develop of auxiliary functions: should you be agile?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;a empirial assessment of pair programming and test-first programming&lt;/p&gt;
&lt;p&gt;can agile help auxiliary functions?&lt;/p&gt;
&lt;div class="section" id="experiment"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id23"&gt;experiment&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;pair vs solo&lt;/li&gt;
&lt;li&gt;test-first vs test-last&lt;/li&gt;
&lt;li&gt;students vs professors&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="research-questions"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id24"&gt;research questions&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;r1: can pair help obtain more correct impl&lt;/li&gt;
&lt;li&gt;r2: can test-first&lt;/li&gt;
&lt;li&gt;r3: dst test1 encourage the impl or more test cases?&lt;/li&gt;
&lt;li&gt;r4: does test1 course more coverage&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="result"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id25"&gt;result&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;test-first&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;higher coverage&lt;/li&gt;
&lt;li&gt;non change with correctness&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;pair&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;improve on correctness&lt;/li&gt;
&lt;li&gt;longer total programming time&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="static-detection-of-resource-contention-problems-in-server-side-script"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id26"&gt;Static Detection of Resource Contention Problems in Server-side script&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Addressed the race condition of accessing database or filesystem of PHP&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="amplifying-tests-to-validate-exception-handling-code"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id27"&gt;Amplifying Tests to Validate Exception Handling Code&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;異常處理的代碼不但難寫，而且難以驗證。各種組合情況難以估計，尤其是手機
系統上。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-tactic-centric-approach-automating-traceability-of-quality-concerns"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id28"&gt;A tactic-centric approach automating traceability of quality concerns&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;tactic traceability information models&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="life"></category><category term="icse"></category><category term="software"></category></entry><entry><title>MSR 2012 @ ICSE</title><link href="//farseerfc.me/msr2012.html" rel="alternate"></link><published>2012-06-02T10:42:00+09:00</published><updated>2012-06-02T10:42:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2012-06-02:/msr2012.html</id><summary type="html">
&lt;div class="section" id="mining-software-repository-2012-icse"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;Mining Software Repository 2012 @ ICSE&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;參加了今年的MSR，會場在University of Zurich。一大早來到大學，註冊有點
小插曲，顯然瑞士人搞不清楚中國人的名字，3個楊（Yang）姓的中國人的名牌
被搞錯了。然後堀田學長的所屬被寫作了“Japan, Japan”，成爲了全日本的代表。&lt;/p&gt;
&lt;div class="section" id="msr-microsoft-research-talk-msr-mining-software-repositories"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id4"&gt;MSR(MicroSoft Research) talk @ MSR(Mining Software Repositories)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;首先是來自微軟亞洲研究院（MicroSoft Research @ Asia, MSR Asia）的Keynots，
於是就變成了MSR在MSR的演講。MSR的張冬梅（Dongmei Zhang）女士的演講
分爲關於Software Analysis和XIAO的兩部分。XIAO是MSRA開發的Code Clone
Detector，似乎我要給井上研做的就是這個。想更多瞭解Xiao的細節，不過張女士
演講結束的時候的鼓掌導致了話筒的小故障 …&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">
&lt;div class="section" id="mining-software-repository-2012-icse"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;Mining Software Repository 2012 @ ICSE&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;參加了今年的MSR，會場在University of Zurich。一大早來到大學，註冊有點
小插曲，顯然瑞士人搞不清楚中國人的名字，3個楊（Yang）姓的中國人的名牌
被搞錯了。然後堀田學長的所屬被寫作了“Japan, Japan”，成爲了全日本的代表。&lt;/p&gt;
&lt;div class="section" id="msr-microsoft-research-talk-msr-mining-software-repositories"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id4"&gt;MSR(MicroSoft Research) talk @ MSR(Mining Software Repositories)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;首先是來自微軟亞洲研究院（MicroSoft Research @ Asia, MSR Asia）的Keynots，
於是就變成了MSR在MSR的演講。MSR的張冬梅（Dongmei Zhang）女士的演講
分爲關於Software Analysis和XIAO的兩部分。XIAO是MSRA開發的Code Clone
Detector，似乎我要給井上研做的就是這個。想更多瞭解Xiao的細節，不過張女士
演講結束的時候的鼓掌導致了話筒的小故障。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="towards-improving-bts-with-game-mechanisms"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id5"&gt;Towards Improving BTS with Game Mechanisms&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;感覺這篇的內容基本上就是關於&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.joelonsoftware.com/items/2008/09/15.html"&gt;http://www.joelonsoftware.com/items/2008/09/15.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這裏寫到的東西，然後說同樣的理論是否可以用於Issue Tracking之類的事情上。
個人感覺這個意義不大，stackoverflow之所以成功是因爲它把開源社區本身就
具有的名譽體系具現化了，本着大家都喜歡被別人奉爲大牛的心態，就如同
wikipedia一樣。同樣的理論如果用於公司內部的Issue Tracking系統上，會得到
完全不同的東西吧。就像MSDN的組織方式雖然和wikipedia是一樣的，但是在MSDN
裏找信息的感覺和在wikipedia完全不一樣。個人不太看好這個方向。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ghtorrent"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id6"&gt;GHTorrent&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;這篇的slide在這裏可以看到：&lt;a class="reference external" href="http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524"&gt;http://www.slideshare.net/gousiosg/ghtorrent-githubs-data-from-a-firehose-13184524&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Data exporter for github. Github的主要數據，代碼，已經可以通過git接口
獲得了，wiki是git的形式保存的。所以這個項目的目的就是暴露別的數據，主要
是issue tracking，code comments，這種。代碼訪問github api，然後用分佈式
實現以克服api的限制，然後提供torrents形式的history下載。github api獲得
的json數據以bson的形式保存在MongoDB裏，解析過的有了Schema之後的數據保存
在MySQL裏並可以導出SQL。&lt;/p&gt;
&lt;p&gt;個人的想法，覺得數據如果能夠更統一，全部存在Git裏或許更好，像Wiki一樣。
同樣是要暴露全部歷史記錄的目的，用Torrent自己實現的歷史遠不如用Git的
接口實現的歷史記錄方便吧，git blame之類的也更方便追蹤code comment之類的
作者信息。當然對git的raw date直接讀寫，需要對git的內部原理有足夠的理解，
或許只有github的人有這種能力了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="topic-mining"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;Topic Mining&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;用得兩個參數， DE 和 AIC，完全不能理解，過後研究。實驗針對了Firefox,
Mylyn, Eclipse三個軟件。試圖從Repo中分析源代碼的identifier和comments，
找到topic和bug之間的關係，比如怎樣的topic更容易導致bug。得出的結論似乎
也很曖昧，只是說核心功能被報告的bug更多，但是不知道原因。這只能表示核心
功能受到更多關注和更多測試吧，並不能說明核心功能就容易產生bug。&lt;/p&gt;
&lt;p&gt;不過這個的Slide做得很漂亮，很容易理解。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="secold"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;SeCold&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A linked data platform for mining software repositories&lt;/p&gt;
&lt;p&gt;沒聽懂這個項目的目的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-evolution-of-software"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;The evolution of software&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;第二天的Keynotes，關於將Social Media和Software Development相結合的想法。
或許就是Github賴以成功的基礎。講到代碼中的comment, Tags, uBlog, blog之類
的social的特性和IDE的融合的趨勢。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="do-faster-releases-imporve-software-quality"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;Do Faster Releases Imporve Software Quality?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;使用Firefox作爲例子。&lt;/p&gt;
&lt;p&gt;結論是快速發佈導致bug更多，更容易crash，但是bug更快得到修復，並且用戶
更快轉向新的發佈。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="security-vs-performance-bugs-in-firefox"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;Security vs Performance Bugs in Firefox&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Performance bugs are regression, blocks release.&lt;/p&gt;
&lt;/div&gt;
&lt;hr class="docutils"/&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;一些感想&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="commit"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id13"&gt;基於自然語義分析的commit分割&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;經常工具（比如git）的使用者並沒有按照工具設計者的意圖使用工具，這給MSR
帶來很多困難。舉個例子，git有非常完美的branch系統，通常期望git的使用者
能夠在一次commit裏commit一個功能，比如一個bug的修復，或者一個feature的
添加，但是事實上經常有很多邏輯上的commit被合併在一個裏面了。&lt;/p&gt;
&lt;p&gt;或許這不是使用者的錯，而是工具仍然不夠人性的表現。或許我們可以自動把
一次的commit按照語義分割成多個。&lt;/p&gt;
&lt;p&gt;分割之後，可以更容易地把issue和commit關聯，也更容易組織更多的研究。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="slides"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id14"&gt;關於這次發表中大家用的slides系統&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;題目爲``Incorporating Version Histories in Information Retrieval Based
Bug Localization''的人用的slide是beamer的。公式很多，overlay很多，列表
很多，圖片很少，典型的beamer做出的slide。思維導圖用得很不錯。今天一天
有至少3個slide是用beamer做的。&lt;/p&gt;
&lt;p&gt;題目爲``Towards Improving Bug Tracking Systems with Game Mechanisms''
的人用了prezi，圖片很多，過度很多。但是比如沒有頁號沒有頁眉頁腳，正式
會議的場合不太方便。&lt;/p&gt;
&lt;p&gt;至少有六個以上用了Apple Keynotes，Keynotes做出來的東西真的和Powerpoint
做出來的很難區別，其中兩個人用了初始的主題所以才看出來。&lt;/p&gt;
&lt;p&gt;剩下的自然是PPT。MSRA的張女士做的雖然是PPT，倒是有很多beamer的感覺，
比如頁眉頁腳和overlay的用法。這些如果都是PPT做出來的，會多很多額外的
人力吧。&lt;/p&gt;
&lt;p&gt;值得一提的是有一個題目爲``Green Mining: A Methodology of Relating
Software Change to Power Consumption''的人的slide全是``劣質''的手繪漫畫，
效果意外地好，很低碳很環保很綠色很可愛。具體效果可以參考下面的動畫，雖然
現場看到的不是一個版本：&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv"&gt;http://softwareprocess.es/a/greenmining-presentatation-at-queens-20120522.ogv&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id15"&gt;微軟是個腹黑娘！&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;嘛雖然這也不是什麼新聞了。MSR2012的Mining Challenge的贊助商是微軟，管理
組織者來自微軟研究院，獎品是Xbox和Kinect。然後今年的題目是：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Mining Android Bug
&lt;/pre&gt;
&lt;p&gt;我看到了微軟滿滿的怨氣……&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="life"></category><category term="msr"></category><category term="icse"></category><category term="mining"></category><category term="software"></category><category term="repository"></category></entry><entry><title>Pyssy 項目</title><link href="//farseerfc.me/pyssy.html" rel="alternate"></link><published>2012-04-02T12:42:00+09:00</published><updated>2012-04-02T12:42:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2012-04-02:/pyssy.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;簡介&lt;/h2&gt;
&lt;p&gt;Pyssy 是用於 &lt;a class="reference external" href="https://bbs.sjtu.edu.cn"&gt;上海交通大學 飲水思源站&lt;/a&gt; 的一系列 Python 腳本和工具。&lt;/p&gt;
&lt;p&gt;Pyssy 被有意設計爲既可以託管寄宿在 SAE &lt;a class="footnote-reference" href="#sae" id="id3"&gt;[1]&lt;/a&gt; 上，也可以在單機上獨立使用。&lt;/p&gt;
&lt;p&gt;項目地址： &lt;a class="reference external" href="http://pyssy.sinaapp.com/"&gt;http://pyssy.sinaapp.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github上的源代碼地址： &lt;a class="reference external" href="https://github.com/yssy-d3/pyssy"&gt;https://github.com/yssy-d3/pyssy&lt;/a&gt;&lt;/p&gt;
&lt;table border="0" class="docutils footnote table" frame="void" id="sae" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://sae.sina.com.cn/"&gt;Sina App Engine&lt;/a&gt; ，新浪雲平臺，類似 &lt;a class="reference external" href="https://appengine.google.com/"&gt;Google App Engine&lt;/a&gt; 的東西。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;依賴關係&lt;/h2&gt;
&lt;p&gt;Pyssy 使用 &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; 作爲網頁服務器，
並且使用 Memcached 或者 Redis 作爲抓取 &lt;em&gt;水源Web&lt;/em&gt; 的緩存。&lt;/p&gt;
&lt;p&gt;SAE Python 環境下請開啓 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;簡介&lt;/h2&gt;
&lt;p&gt;Pyssy 是用於 &lt;a class="reference external" href="https://bbs.sjtu.edu.cn"&gt;上海交通大學 飲水思源站&lt;/a&gt; 的一系列 Python 腳本和工具。&lt;/p&gt;
&lt;p&gt;Pyssy 被有意設計爲既可以託管寄宿在 SAE &lt;a class="footnote-reference" href="#sae" id="id3"&gt;[1]&lt;/a&gt; 上，也可以在單機上獨立使用。&lt;/p&gt;
&lt;p&gt;項目地址： &lt;a class="reference external" href="http://pyssy.sinaapp.com/"&gt;http://pyssy.sinaapp.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github上的源代碼地址： &lt;a class="reference external" href="https://github.com/yssy-d3/pyssy"&gt;https://github.com/yssy-d3/pyssy&lt;/a&gt;&lt;/p&gt;
&lt;table border="0" class="docutils footnote table" frame="void" id="sae" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://sae.sina.com.cn/"&gt;Sina App Engine&lt;/a&gt; ，新浪雲平臺，類似 &lt;a class="reference external" href="https://appengine.google.com/"&gt;Google App Engine&lt;/a&gt; 的東西。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;依賴關係&lt;/h2&gt;
&lt;p&gt;Pyssy 使用 &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; 作爲網頁服務器，
並且使用 Memcached 或者 Redis 作爲抓取 &lt;em&gt;水源Web&lt;/em&gt; 的緩存。&lt;/p&gt;
&lt;p&gt;SAE Python 環境下請開啓 Memcached 支持。&lt;/p&gt;
&lt;p&gt;本地環境下請安裝 Redis-py 並運行 redis-server 服務器程序。&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="python"></category><category term="sjtu"></category><category term="yssy"></category></entry><entry><title>PyRuby</title><link href="//farseerfc.me/mix-ruby.html" rel="alternate"></link><published>2012-03-02T23:09:00+09:00</published><updated>2012-03-02T23:09:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2012-03-02:/mix-ruby.html</id><summary type="html">&lt;p&gt;今天在GitHub上閒逛的時候看到一個叫做 &lt;a class="reference external" href="https://github.com/danielfm/pyruby"&gt;PyRuby&lt;/a&gt; 的項目。項目的Readme說得很好：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PyRuby - Some Ruby for your Python!
PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful.

Usage
All you have to do is import the ruby module:

import ruby
From now on you should be able …&lt;/pre&gt;</summary><content type="html">&lt;p&gt;今天在GitHub上閒逛的時候看到一個叫做 &lt;a class="reference external" href="https://github.com/danielfm/pyruby"&gt;PyRuby&lt;/a&gt; 的項目。項目的Readme說得很好：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PyRuby - Some Ruby for your Python!
PyRuby is a simple way to leverage the power of Ruby to make your Python code more readable and beautiful.

Usage
All you have to do is import the ruby module:

import ruby
From now on you should be able to write Ruby code within a regular Python module. An example:

1.upto(10) { |n| puts n }
&lt;/pre&gt;
&lt;p&gt;甚至 &lt;a class="reference external" href="http://pypi.python.org/pypi/pyruby/1.0.0"&gt;PyPI&lt;/a&gt; 上還有這個項目的包。&lt;/p&gt;
&lt;p&gt;一開始我還以爲這又是一個野心勃勃的基於PyPy的Ruby實現，或者某種trick在Python裏面直接調用Ruby解釋器。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;然後我想看看這個的源代碼&lt;/h2&gt;
&lt;p&gt;只有一個ruby.py文件，內容是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"""&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;                              `.-:/+ossyhhddmmmmNNNNNNNmmmmmdddddhhhyyyyhhhyo:`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;                       .:+sydNNNmmdhhysso++/+++++++////::::::-.```......--/oymms.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;                  `:ohmdys+//::/::--::::////:-.```......`````.://:-`         `/dNs.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;               .+hNds:`-:-:///::------::///++///:--....--::///::-`.///.        `oMm/&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;             /hNmo.`   ``    `....```````````      ...------:::-:/+/-.:/:`       /NMs&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;            oMd/`      `::::--.---://+`           //`     `````-:::::+/-`::.`     :NM+&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;            yN`       -+.`         `/`           o.               ``::.-:. ``      :NN:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;           :Nm        -             ./           :    `.-://///:-.   `-` ``         :NN-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;          /NM/           .-:::-.`   `/            `:sdmdhyMMMMMMNNmy/`               :mNo`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        :hMd:          /dmddddNNmdy+-.          `smmy/-```hMMMMMMMhydm/ `-.``     `...:mMm+.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;      -hNd/-/o/-..-::`.ydmmmmNMMMMMMNh:/+-      dMN-`-+hmmmmdhhhhdddmMN-`-/o:    .-::::/oydms-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;     oNMo:+/::.         ``...--:/+ohNMNhs-      :hNmmdyo:..``yo-```.--. `-`-+shdddhs+-` `.//yms.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;    .MMo:/`o:.:+sso+:-`             sM+           ./-`       /mNh+-....-/ymNNdo::--/shd+`  -`:mm:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;    /MM-o ./ ohhsooohNmy::sh.      `yM/                       `:oyyyyyyhys+:.` hy    `/Nh`  : -NN.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;    -MM// -: ``   y: odddhh+     -omNh-          `--.` ``          ````    .:ohMMs.    +Ms  /  yMo&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;     hMoo .+.    :Mh  ````    `/hNd/.`           ohdddy::...`..`      `-/sdmdyo+NMNh+- :Mh  /  sMs&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;     .mmh:..:.  :NMm       `-/dMNM+         ./+++/:`.hM:`.````.` `-/shmNmh+-`  /Mmooso.hM/ .: `mM/&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;      .mNs://: .NMNMs-   -:-.`/+-sms.   `  `shyyyhy`sNd`   `.:+sdmmmdMM-.    .oNM+    :m/ `s``yMh&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;       -mMo  . sMNdMNNh+-.        .ydyoyy`        ``+o::+shdddhs+:-.:MM.`.-+hNMMh-    `.`-/::dNs`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        -NM-   mMMMh:MMdNmhs+:-..```-ohs-`...-:/+syhddmMMs:-.`    `/mMMdmmddNMm+`      ..-/hNh-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         sMy   NMMM`:Mh`-/mMmmmdddddddddhhhdNNdhyo+:--.yMs  `..:+ymMMMMd+--yNh.        `+hNh:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         -Mm   NMMM/yMh  -NM-`..--:NMo:--.`+My         :MNoydmNMMNmhdMh` -dNs`        `yMd:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         `MN   mMMMMMMMyshMN+:---.-MN-.....+My...-:/oyhdMMMMNmdy+-` +Mh:sNm/          yMy`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;          MN   yMMMMMMMMMMMMMMMMMNMMMMNNNNNMMMNNNMMMMMNmhMM/-.      `yMMNs.          /My&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         `MN   :MMmMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmdy+:-``NM-      ./hNNy-           /Nd`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         -Mh    dMydMmsNMNdNNMMmmmNMMMdddhys+yMo``       /Nm:  `:yNNdo.           .sNd.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         +Ms    .mMsMN::NN:.:MN: `.+NM.      +Mo          +Mm+ymNdo-            .omm+`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         yM:     .hNMd+:sMN. oMm.   oMo      +Mh   ```.:+shMNmy+-``.-:-..-//-`:yNmo`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         mM.       :ohmNNMMdhyMMdo//+Mm//////sMNhyhhdmNNmhs/-``./+/:--+so/-:smNy/`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        .Mm        ``  .-:/+osyyhhddddddddddhhyysoo+/:-.  `./+//--+oo/--+ymmy/.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        :Mh   .:   `+:`        `.------------`      ```-////:/++/:../ydNdo:`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        +Ms   `/`    :+o+:-```              ``..-::///++///:-.`-+ydNdo:`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        oMs     :/:.``  `..---.``` ````````..-:/:::---.`  `-ohmmh+:`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;        /Mh       .://///:::-----.-----.......`       `-+hmmy+-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;         sMy`                                ``````-+ydmy+-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;          /mNs-`                        `./ohmNMNNNmy+-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;            /yNmho/:.``````````.-:/+syhdNmdyso+/-.`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;              `:+ydmNMNNNNNNNNNmdhys+/:.`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;                     ``.....`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;    LOL U MAD?&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="s2"&gt;"""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是的……的確……這種嘗試把Python和Ruby放在一起的想法絕對是瘋了……&lt;/p&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="python"></category><category term="ruby"></category></entry><entry><title>關於C++模板的類型轉換的討論</title><link href="//farseerfc.me/discuss-cpp-template-downcast.html" rel="alternate"></link><published>2012-02-26T05:54:57+09:00</published><updated>2012-02-26T05:54:57+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2012-02-26:/discuss-cpp-template-downcast.html</id><summary type="html">
&lt;p&gt;這兩天在飲水思源的C板，關於C++模板的類型轉換的一個討論，後面是我的解答。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;討論地址&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html"&gt;http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;原問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;今天在書上看到模板演繹的時候可以允許cast-down，於是我寫了個東西：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;_Test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct …&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">
&lt;p&gt;這兩天在飲水思源的C板，關於C++模板的類型轉換的一個討論，後面是我的解答。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;討論地址&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html"&gt;http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;原問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;今天在書上看到模板演繹的時候可以允許cast-down，於是我寫了個東西：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;_Test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BB&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DD&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="c1"&gt;//f(b);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;奇怪的是重載決議的時候， &lt;code class="code"&gt;
f&lt;/code&gt;
 的情況下它就不讓我特化的 &lt;code class="code"&gt;
f&amp;lt;A&amp;gt;&lt;/code&gt;
 進來。&lt;/p&gt;
&lt;p&gt;但是在 &lt;code class="code"&gt;
ff&lt;/code&gt;
 的情況下， &lt;code class="code"&gt;
ff&amp;lt;BB&amp;lt;long&amp;gt;&amp;gt;&lt;/code&gt;
 卻進來了。&lt;/p&gt;
&lt;p&gt;在VC10和GCC3.4下測試&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;我的解答&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我們來設身處地地作爲編譯器，看一遍到底發生了什麼。&lt;/p&gt;
&lt;p&gt;約定符號 &lt;code class="code"&gt;
#&lt;/code&gt;
 : &lt;code class="code"&gt;
A#B&lt;/code&gt;
 是把 &lt;code class="code"&gt;
B&lt;/code&gt;
 帶入 &lt;code class="code"&gt;
A&amp;lt;T&amp;gt;&lt;/code&gt;
 的參數 &lt;code class="code"&gt;
T&lt;/code&gt;
 之後實例化得到的結果。&lt;/p&gt;
&lt;div class="section" id="ff"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;首先看ff的情況。&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;處理到這句的時候，編譯器看到了 &lt;code class="code"&gt;
DD&amp;lt;long&amp;gt;&lt;/code&gt;
 的實例化，於是去實例化 &lt;code class="code"&gt;
DD#long&lt;/code&gt;
 ，繼而實例
化了 &lt;code class="code"&gt;
BB#long&lt;/code&gt;
 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;這句，首先計算重載函數集合。&lt;/p&gt;
&lt;p&gt;第一步，需要從參數 &lt;code class="code"&gt;
DD#long -&amp;gt; BB&amp;lt;T&amp;gt;&lt;/code&gt;
 推斷 &lt;code class="code"&gt;
ff&amp;lt;T&amp;gt;&lt;/code&gt;
 的 &lt;code class="code"&gt;
T&lt;/code&gt;
 。根據函數模板參數推斷規則：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:code:`class_template_name&amp;lt;T&amp;gt;` 類型的參數，可以用於推斷 :code:`T` 。
&lt;/pre&gt;
&lt;p&gt;於是編譯器推斷 &lt;code class="code"&gt;
T&lt;/code&gt;
 爲 &lt;code class="code"&gt;
long&lt;/code&gt;
 。這裏就算不是 &lt;code class="code"&gt;
BB&lt;/code&gt;
 而是完全無關的 &lt;code class="code"&gt;
CC&lt;/code&gt;
 都可以推斷成功，只要 &lt;code class="code"&gt;
CC&lt;/code&gt;
 也
是一個 &lt;code class="code"&gt;
CC&amp;lt;T&amp;gt;&lt;/code&gt;
 形式的模板。&lt;/p&gt;
&lt;p&gt;第二步，模板特化匹配。因爲只有一個模板，所以匹配了最泛化的 &lt;code class="code"&gt;
ff&amp;lt;T&amp;gt;&lt;/code&gt;
 。&lt;/p&gt;
&lt;p&gt;第三步，模板實例化。&lt;/p&gt;
&lt;p&gt;推斷了 &lt;code class="code"&gt;
long -&amp;gt; T&lt;/code&gt;
 之後，編譯器實例化 &lt;code class="code"&gt;
ff#long&lt;/code&gt;
 。&lt;/p&gt;
&lt;p&gt;重載函數集合： &lt;code class="code"&gt;
{ff#long}&lt;/code&gt;
&lt;/p&gt;
&lt;p&gt;然後重載抉擇找到唯一的可匹配的實例 &lt;code class="code"&gt;
ff#long&lt;/code&gt;
 ，檢查實際參數 &lt;code class="code"&gt;
DD#long&lt;/code&gt;
 可以隱式轉換到
形式參數 &lt;code class="code"&gt;
BB#long&lt;/code&gt;
 ，從而生成了這次函數調用。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="f"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;再來看f的情況。&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;計算候選重載函數集合。&lt;/p&gt;
&lt;p&gt;第一步，對所有 &lt;code class="code"&gt;
f&lt;/code&gt;
 模板推斷實參。根據函數模板參數推斷規則：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
帶有 :code:`T` 類型的參數，可以用於推斷 :code:`T` 。
&lt;/pre&gt;
&lt;p&gt;於是 &lt;code class="code"&gt;
B -&amp;gt; T&lt;/code&gt;
 被推斷出來了。&lt;/p&gt;
&lt;p&gt;第二步，模板特化匹配。&lt;/p&gt;
&lt;p&gt;這裏 &lt;code class="code"&gt;
B&lt;/code&gt;
 不是 &lt;code class="code"&gt;
A&lt;/code&gt;
 ，所以不能用 &lt;code class="code"&gt;
f&amp;lt;A&amp;gt;&lt;/code&gt;
 特化，只能用 &lt;code class="code"&gt;
f&amp;lt;T&amp;gt;&lt;/code&gt;
 模板。&lt;/p&gt;
&lt;p&gt;第三步，模板實例化。&lt;/p&gt;
&lt;p&gt;&lt;code class="code"&gt;
B&lt;/code&gt;
 帶入 &lt;code class="code"&gt;
f&amp;lt;T&amp;gt;&lt;/code&gt;
 實例化成 &lt;code class="code"&gt;
f#B&lt;/code&gt;
 的過程中，實例化 &lt;code class="code"&gt;
traits#B&lt;/code&gt;
 。&lt;/p&gt;
&lt;p&gt;由於沒有針對 &lt;code class="code"&gt;
B&lt;/code&gt;
 的特化，所以用 &lt;code class="code"&gt;
traits&amp;lt;T&amp;gt;&lt;/code&gt;
 模板， &lt;code class="code"&gt;
traits#B::value=false&lt;/code&gt;
 ，進而 &lt;code class="code"&gt;
enable_if#false&lt;/code&gt;
 沒有 &lt;code class="code"&gt;
type&lt;/code&gt;
 ，出錯。&lt;/p&gt;
&lt;p&gt;唯一的模板匹配出錯，重載函數集合爲空，SFINAE原則不能找到合適的匹配，於是報錯。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="template"></category><category term="C"></category></entry><entry><title>嘗試一下 Pelican</title><link href="//farseerfc.me/try-pelican.html" rel="alternate"></link><published>2012-02-24T17:33:00+09:00</published><updated>2012-02-24T17:33:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2012-02-24:/try-pelican.html</id><summary type="html">&lt;p&gt;似乎一夜之間所有的
&lt;a class="reference external" href="http://blog.yxwang.me/2011/11/migrated-to-octopress/"&gt;極客們&lt;/a&gt;
&lt;a class="reference external" href="http://xoyo.name/2012/02/migrate-to-octopress/"&gt;都&lt;/a&gt;
&lt;a class="reference external" href="http://blog.xdite.net/posts/2011/10/07/what-is-octopress/"&gt;有了&lt;/a&gt;
&lt;a class="reference external" href="http://www.yangzhiping.com/tech/octopress.html"&gt;自己&lt;/a&gt;
的 &lt;a class="reference external" href="http://pages.github.com/#user__organization_pages"&gt;Github主頁&lt;/a&gt;
和 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 博客。就像所有人在他們的博客中指出的，靜態博客的確比傳統的WordPress方式具有更多優勢。 自從看到這些
我就一直在想着自己搭一個 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;但是似乎 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 不適合我&lt;/h2&gt;
&lt;p&gt;一上手就被 &lt;a class="reference external" href="http://octopress.org/docs/setup/"&gt;Octopress的搭建步驟&lt;/a&gt; 煩到了。 &lt;a class="reference external" href="http://beginrescueend.com/"&gt;RVM&lt;/a&gt; 是什麼？ &lt;a class="reference external" href="https://github.com/sstephenson/rbenv"&gt;rbenv&lt;/a&gt; 又是什麼？
看來 Ruby 社區的快節奏發展已經超過了我的想象，他們似乎需要一套發行版管理器來調和不同版本之間的 Ruby 的兼容性問題。
雖然同樣的兼容性問題在 Python 社區也有 &lt;a class="footnote-reference" href="#id10" id="id8"&gt;[1]&lt;/a&gt; ，不過總覺得 Python 至少還沒到需要一個發行版管理器的程度 &lt;a class="footnote-reference" href="#id11" id="id9"&gt;[2]&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;真正的問題是我手上還沒有一個可以讓我隨便玩的 Linux 環境（真的想要……）。 而無論是 &lt;a class="reference external" href="http://beginrescueend.com/"&gt;RVM&lt;/a&gt; 還是 &lt;a class="reference external" href="https://github.com/sstephenson/rbenv"&gt;rbenv&lt;/a&gt; 似乎都只支持 Unix/Linux …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;似乎一夜之間所有的
&lt;a class="reference external" href="http://blog.yxwang.me/2011/11/migrated-to-octopress/"&gt;極客們&lt;/a&gt;
&lt;a class="reference external" href="http://xoyo.name/2012/02/migrate-to-octopress/"&gt;都&lt;/a&gt;
&lt;a class="reference external" href="http://blog.xdite.net/posts/2011/10/07/what-is-octopress/"&gt;有了&lt;/a&gt;
&lt;a class="reference external" href="http://www.yangzhiping.com/tech/octopress.html"&gt;自己&lt;/a&gt;
的 &lt;a class="reference external" href="http://pages.github.com/#user__organization_pages"&gt;Github主頁&lt;/a&gt;
和 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 博客。就像所有人在他們的博客中指出的，靜態博客的確比傳統的WordPress方式具有更多優勢。 自從看到這些
我就一直在想着自己搭一個 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;但是似乎 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 不適合我&lt;/h2&gt;
&lt;p&gt;一上手就被 &lt;a class="reference external" href="http://octopress.org/docs/setup/"&gt;Octopress的搭建步驟&lt;/a&gt; 煩到了。 &lt;a class="reference external" href="http://beginrescueend.com/"&gt;RVM&lt;/a&gt; 是什麼？ &lt;a class="reference external" href="https://github.com/sstephenson/rbenv"&gt;rbenv&lt;/a&gt; 又是什麼？
看來 Ruby 社區的快節奏發展已經超過了我的想象，他們似乎需要一套發行版管理器來調和不同版本之間的 Ruby 的兼容性問題。
雖然同樣的兼容性問題在 Python 社區也有 &lt;a class="footnote-reference" href="#id10" id="id8"&gt;[1]&lt;/a&gt; ，不過總覺得 Python 至少還沒到需要一個發行版管理器的程度 &lt;a class="footnote-reference" href="#id11" id="id9"&gt;[2]&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;真正的問題是我手上還沒有一個可以讓我隨便玩的 Linux 環境（真的想要……）。 而無論是 &lt;a class="reference external" href="http://beginrescueend.com/"&gt;RVM&lt;/a&gt; 還是 &lt;a class="reference external" href="https://github.com/sstephenson/rbenv"&gt;rbenv&lt;/a&gt; 似乎都只支持 Unix/Linux/MacOSX 。 身爲極客就註定不能用 Windows 麼？（或許是的……）。&lt;/p&gt;
&lt;p&gt;剩下的問題就是 Ruby 和 Python 兩大陣營的對立問題了。我不熟悉 &lt;a class="reference external" href="http://daringfireball.net/projects/markdown/"&gt;Markdown&lt;/a&gt; ， 相對來說比較喜歡 &lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;ReST&lt;/a&gt; 。 似乎無論哪邊都要
依賴 &lt;a class="reference external" href="http://pygments.org/"&gt;Pygments&lt;/a&gt; 作爲代碼着色器，那麼其實 Rubyist 也至少需要安裝 Python 。 我傾向於不依賴任何 Ruby 組件，最好沒有 C 擴展
的純 Python 實現。&lt;/p&gt;
&lt;p&gt;於是我開始在 Github 上找 Python 的靜態博客引擎。 &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; 的作者 &lt;a class="reference external" href="https://github.com/mitsuhiko"&gt;mitsuhiko&lt;/a&gt; 寫的 &lt;a class="reference external" href="https://github.com/mitsuhiko/rstblog"&gt;rstblog&lt;/a&gt; 看起來不錯，不過似乎沒有多少人在用。 &lt;a class="reference external" href="http://ringce.com/hyde"&gt;Hyde&lt;/a&gt; 似乎很完善，不過默認的標記語言是 MarkDown ， 又依賴於幾個 Ruby 組建，而且官方網站的設計實在太前衛。 最終我看到了 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt; 。&lt;/p&gt;
&lt;table border="0" class="docutils footnote table" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id8"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;比如 Python 2.x 與 3.x 之間看似難以跨越的鴻溝，以及 &lt;a class="reference external" href="http://pypy.org/"&gt;PyPy&lt;/a&gt; 、 &lt;a class="reference external" href="http://python.org/"&gt;CPython&lt;/a&gt; 、 &lt;a class="reference external" href="http://www.stackless.com/"&gt;Stackless&lt;/a&gt; 、 &lt;a class="reference external" href="http://cython.org/"&gt;Cython&lt;/a&gt; 等各個實現之間的微妙差別。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table border="0" class="docutils footnote table" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id9"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;是的，我們有 &lt;a class="reference external" href="http://packages.python.org/distribute/easy_install.html"&gt;easy_install&lt;/a&gt; ，我們有 &lt;a class="reference external" href="http://www.pip-installer.org/en/latest/index.html"&gt;pip&lt;/a&gt; ， 不過這些都是包管理器，都是裝好特定的Python實現之後的事情。 Python實現本身還不需要包管理器來管理。 Python 的版本問題基本上也只需要 &lt;a class="reference external" href="http://docs.python.org/release/3.0.1/library/2to3.html"&gt;2to3.py&lt;/a&gt; 和 &lt;a class="reference external" href="http://www.startcodon.com/wordpress/?cat=8"&gt;3to2.py&lt;/a&gt; 這樣的輕量級轉換器就可以了，你不需要爲了安裝多個軟件而在硬盤裏留下多個不同版本的 Python 。 如果爲了引用的穩定性，你可以用 &lt;a class="reference external" href="http://pypi.python.org/pypi/virtualenv"&gt;virtualenv&lt;/a&gt; ，不過這又是另一回事情了。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h2&gt;那麼就 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt; 吧&lt;/h2&gt;
&lt;p&gt;對我而言， &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt; 相比於 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 有幾個好處：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;純 Python 實現。 這意味着我可以換用任何 Python 解釋器而不必擔心兼容性問題。比如我就換成了 &lt;a class="reference external" href="http://pypy.org/"&gt;PyPy&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;多語言支持。因爲 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt; 的作者似乎是個法國人。不過這個似乎大部分人不需要…… 我是想儘量把一篇博客寫成三種語言作爲鍛鍊吧。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;ReST&lt;/a&gt; 。這樣我就可以用 &lt;a class="reference external" href="http://webpages.charter.net/edreamleo/front.html"&gt;Leo&lt;/a&gt; 的 @auto-rst 直接寫 ReST了。簡單方便快捷有效。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;不過似乎 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt; 的關注度不如 &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 那麼高，現在一些部分還有細微的問題：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;pelican-import 從 WordPress 導入的時候對中文、日文的支持似乎很成問題。&lt;/li&gt;
&lt;li&gt;日期格式、時區、字符集、和多語言功能的結合度還不夠。  &lt;strong&gt;我在嘗試改善它。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;模板還不夠豐富。&lt;/li&gt;
&lt;li&gt;插件也不夠多……&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;希望這麼優秀的工具能夠受到更多關注，以上這些問題都是增加關注度之後很快就能解決的問題。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="settings-py"&gt;
&lt;h2&gt;我的設置 settings.py&lt;/h2&gt;
&lt;p&gt;安裝 &lt;a class="reference external" href="http://pelican.notmyidea.org/en/latest/"&gt;Pelican&lt;/a&gt; 很容易，一句話就夠了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; pip install pelican&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然後把文章寫成ReST的格式，放在`pages`文件夾裏面。(重新)生成只要：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; pelican -s settings.py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上傳到 Github:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; git commit -am &lt;span class="s2"&gt;"Commit message"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="gp"&gt;$&lt;/span&gt; git push&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就這麼簡單。附上我的配置文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;TIMEZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Asia/Tokyo'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;DATE_FORMATS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="s1"&gt;'en'&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="s1"&gt;'usa'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="si"&gt;%a&lt;/span&gt;&lt;span class="s1"&gt;, &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s1"&gt; %b %Y'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="s1"&gt;'zh'&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="s1"&gt;'chs'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'%Y-%m-&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s1"&gt;, &lt;/span&gt;&lt;span class="si"&gt;%a&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="s1"&gt;'jp'&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="s1"&gt;'jpn'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'%Y/%m/&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s1"&gt; (&lt;/span&gt;&lt;span class="si"&gt;%a&lt;/span&gt;&lt;span class="s1"&gt;)'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="c1"&gt;# windows locale: http://msdn.microsoft.com/en-us/library/cdax410z%28VS.71%29.aspx&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;LOCALE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'usa'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'chs'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'jpn'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;        &lt;span class="c1"&gt;# windows&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;          &lt;span class="s1"&gt;'en_US'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'zh_CN'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'ja_JP'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;# Unix/Linux&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;DEFAULT_LANG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'zh'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Farseerfc Blog'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;AUTHOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Jiachen Yang'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'farseerfcgithub'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;GITHUB_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'https://github.com/farseerfc'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'http://farseerfc.github.com'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;TAG_FEED&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'feeds/&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;.atom.xml'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s1"&gt;'twitter'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'http://twitter.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'github'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'https://github.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'facebook'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'http://www.facebook.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'weibo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'http://weibo.com/farseerfc'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'renren'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'http://www.renren.com/farseer'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;          &lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;TWITTER_USERNAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'farseerfc'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;THEME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'notmyidea'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;CSS_FILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"wide.css"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;DEFAULT_CATEGORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'Others'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;OUTPUT_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'.'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'posts'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</content><category term="tech"></category><category term="python"></category><category term="pelican"></category></entry><entry><title>關於我的Blogs</title><link href="//farseerfc.me/about-my-blogs.html" rel="alternate"></link><published>2011-09-27T02:35:00+09:00</published><updated>2011-09-27T02:35:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2011-09-27:/about-my-blogs.html</id><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;很久沒有寫過blog或者之類的東西了。這邊一直荒廢着。&lt;/p&gt;
&lt;p&gt;由於國內被牆的原因，另一個wordpress： &lt;a class="reference external" href="http://fchome.sinaapp.com/"&gt;http://fchome.sinaapp.com/&lt;/a&gt;
應該會同步更新這裏的內容。&lt;/p&gt;
&lt;p&gt;抽空寫點什麼吧。&lt;/p&gt;
</content><category term="import"></category></entry><entry><title>“…if we do this work … ” --Bill Gates</title><link href="//farseerfc.me/if-we-do-this-work.html" rel="alternate"></link><published>2011-03-14T20:34:00+09:00</published><updated>2011-03-14T20:34:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2011-03-14:/if-we-do-this-work.html</id><summary type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/716517729"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From: Bill Gates&lt;/p&gt;
&lt;p&gt;’-- Sent: Sunday, January 24, 1999 8:41 AM&lt;/p&gt;
&lt;p&gt;Jeff Westorinon; Ben Fathi ;&lt;/p&gt;
&lt;p&gt;TO: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder&lt;/p&gt;
&lt;p&gt;Subject: ACPI extensions&lt;/p&gt;
&lt;p&gt;One thing I find myself wondering about is whether we shouldn’t try and
make the "ACPI" extensions somehow Windows specific.&lt;/p&gt;
&lt;p&gt;It …&lt;/p&gt;</summary><content type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/716517729"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From: Bill Gates&lt;/p&gt;
&lt;p&gt;’-- Sent: Sunday, January 24, 1999 8:41 AM&lt;/p&gt;
&lt;p&gt;Jeff Westorinon; Ben Fathi ;&lt;/p&gt;
&lt;p&gt;TO: Carl Stork (Exchange); Nathan Myhrvofd; Eric Rudder&lt;/p&gt;
&lt;p&gt;Subject: ACPI extensions&lt;/p&gt;
&lt;p&gt;One thing I find myself wondering about is whether we shouldn’t try and
make the "ACPI" extensions somehow Windows specific.&lt;/p&gt;
&lt;p&gt;It seems unfortunate if we do this work and get our partners to do the
work and the result is that &lt;strong&gt;Linux works great without having to do the work&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maybe there is no way to avoid this problem but it does bother me.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Maybe we could define the APIs so that they work well with NT and not
the others even if they are open.&lt;/p&gt;
&lt;p&gt;Or maybe we could patent something relaled to this.&lt;/p&gt;
&lt;p&gt;From:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf"&gt;http://antitrust.slated.org/www.iowaconsumercase.org/011607/3000/PX03020.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果這就是我至今在Xen4.0上得不到ACPI 3.0的完善支持的原因，那麼我詛咒Bill Gates！&lt;/p&gt;
</content><category term="import"></category><category term="microsoft"></category><category term="linux"></category><category term="acpi"></category></entry><entry><title>[zz]“西廂計劃”原理小解</title><link href="//farseerfc.me/zz-introducing-scholarzhang.html" rel="alternate"></link><published>2010-03-17T09:40:00+09:00</published><updated>2010-03-17T09:40:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2010-03-17:/zz-introducing-scholarzhang.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;好神奇的想法，先存着，以後慢慢研究&lt;/p&gt;
&lt;p&gt;原文： &lt;a class="reference external" href="http://blog.youxu.info/2010/03/14/west-chamber/"&gt;http://blog.youxu.info/2010/03/14/west-
chamber/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;待月西廂下，迎風戶半開。隔牆花影動，疑是玉人來。&lt;/p&gt;
&lt;p&gt;最近推上最流行的一個關鍵詞是”西廂計劃”,
這個計劃名字取得很浪漫，客戶端叫做張生，對，就是西廂記裏面那個翻牆去見崔鶯鶯小姐的張生；顯然，服務器端必然叫做崔鶯鶯。客戶端的張生是最重要的部件，可以不依賴於服務端工作。因爲西廂計劃的作者只是簡要的介紹了一下原理，其他報道又語焉不詳，我當時就覺得很好奇，花了昨天一個晚上詳細讀了一下源代碼，終於知道怎麼回事了，覺得原理非常漂亮，所以寫篇文章介紹總結一下。&lt;/p&gt;
&lt;p&gt;先說大方向。大家都知道，連接被重置的本質，是因爲收到了破壞連接的一個 TCP
Reset 包。以前劍橋大學有人實驗過，客戶端和服務器都忽略 Reset,
則通信可以不受影響 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;好神奇的想法，先存着，以後慢慢研究&lt;/p&gt;
&lt;p&gt;原文： &lt;a class="reference external" href="http://blog.youxu.info/2010/03/14/west-chamber/"&gt;http://blog.youxu.info/2010/03/14/west-
chamber/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;待月西廂下，迎風戶半開。隔牆花影動，疑是玉人來。&lt;/p&gt;
&lt;p&gt;最近推上最流行的一個關鍵詞是”西廂計劃”,
這個計劃名字取得很浪漫，客戶端叫做張生，對，就是西廂記裏面那個翻牆去見崔鶯鶯小姐的張生；顯然，服務器端必然叫做崔鶯鶯。客戶端的張生是最重要的部件，可以不依賴於服務端工作。因爲西廂計劃的作者只是簡要的介紹了一下原理，其他報道又語焉不詳，我當時就覺得很好奇，花了昨天一個晚上詳細讀了一下源代碼，終於知道怎麼回事了，覺得原理非常漂亮，所以寫篇文章介紹總結一下。&lt;/p&gt;
&lt;p&gt;先說大方向。大家都知道，連接被重置的本質，是因爲收到了破壞連接的一個 TCP
Reset 包。以前劍橋大學有人實驗過，客戶端和服務器都忽略 Reset,
則通信可以不受影響。但是這個方法其實只有理論價值，因爲絕大多數服務器都不可能忽略
Reset 的 (比如 Linux, 需要 root 權限配置iptables, 而且這本身也把正常的
Reset 給忽略了)。只要服務器不忽略 Reset,
客戶端再怎麼弄都沒用，因爲服務器會停止發送數據，Reset
這條連接。所以，很多報道說西廂計劃是忽略 Reset,
我從源代碼來看應該不是這樣。在我看來，西廂計劃是利用了牆的一個可能的弱點–牆只在連接發起的時候把一個
TCP
連接加入監聽序列，如果牆認爲這個連接終止了，就會從監聽序列中去掉這條記錄，這樣，這條連接上後續的包就不會被監聽。西廂計劃就是讓牆“認爲”這個連接終止的一個絕妙的方法。只要牆認爲這個連接兩端都是死老虎，牆就不會觸發關鍵詞檢測，其後所有的數據，都不存在連接被重置的問題了。&lt;/p&gt;
&lt;p&gt;如何讓一個連接置之死地而後生，就是西廂計劃那幫黑客神奇的地方了。這也不是一日之功。
首先，這幫牛人發現，牆的是一個入侵檢測系統，把含有關鍵字的包當成一種“入侵”來對待。採取這種設計有很多好處，但缺點是入侵檢測系統可能具有的問題，牆都可能有。西廂計劃主頁上那篇著名的論文就是講這些七七八八的漏洞的。可以說處理這些七七八八的漏洞是非常困難的，迫使牆的設計者“拆東牆，補西牆”。這樣補來補去，外表看起來好像很牛逼的牆，其實有很多本質上無法簡單修補的漏洞，其中有一個致命的，就是
TCP 連接狀態的判定問題。
出於入侵檢測系統這種設計的侷限，牆沒有，也沒辦法準確判定一條 TCP
連接的狀態，而只是根據兩邊收到的數據來“推測”連接的狀態。而所有的關鍵詞檢測功能，都是基於“連接還活着”的這個推測的結果的。因爲牆的規則是在連接發起的時候開始對這條連接的檢測，在連接終止的時候停止對這條連接的檢測，所以，一旦對連接的狀態推測錯誤，把還活着的連接當成已經關閉的連接，牆就會放棄對這條連接上隨後所有的包的檢測，他們都會都透明的穿過牆的入侵檢測。&lt;/p&gt;
&lt;p&gt;上面只是想法，具體到 TCP
協議實現這一層，就要只迷惑牆，還不能觸及我要通信的服務器。最理想的情況下，在任何有效通信之前，就能讓牆出現錯誤判斷，這些，就需要對
TCP 協議有深刻理解了。西廂計劃的那幫黑客，居然真的去讀 TCP 幾百頁的
RFC，還居然就發現了方法（這裏我假設讀者都知道 TCP
的三次握手過程和序列號每次加一的規則）。
我們都知道，三次握手的時候，在收到服務器的 SYN/ACK
的時候，客戶端如果發送 ACK 並且序列號+1
就算建立連接了，但是客戶端如果發送一個序列號沒 +1 的 FIN
（表示連接終止，但是服務器知道，這時候連接還沒建立呢， FIN
這個包狀態是錯的，加上序列號也是錯的，服務器自己一判斷，就知道這個包是壞包，按照標準協議，服務器隨手丟棄了這個包）,
但這個包，過牆的時候，在牆看來，是表示連接終止的(牆是 ma de in china,
是比較山寨的，不維護連接狀態，並且，牆並沒有記下剛纔服務器出去的 SYN/ACK
的序列號，所以牆不知道序列號錯了）。所以，牆很高興的理解爲連接終止，舒了一口氣去重置其他連接了，
而這個連接，就成了殭屍，牆不管你客戶端了，而這時候，好戲纔剛剛開始。&lt;/p&gt;
&lt;p&gt;事實上，牆是雙向檢測的（或者說對每個包都檢測的），因此，對服務器和客戶端實現相同的對待方法，所以，牆不管客戶端還不行，假如服務端有關鍵詞傳給客戶端，牆還是有可能要發飆的（這裏說有可能，因爲我也不知道）。所以，最好的辦法就是，讓服務端也給牆一個終止連接的標誌就好了。可是這個說起來簡單，做起來難，怎麼能讓不受自己控制的服務器發一個自己想要的包呢？
西廂計劃的那幫黑客，再次去讀幾百頁的 RFC, 令人驚訝的發現，他們居然在 RFC
上發現了一個可以用的特性。我們上面說了，三次握手的時候，在收到 SYN/ACK
後，客戶端要給服務器發送一個序列號+1 的ACK，可是，假如我不+1呢，直接發
ACK 包給服務器。
牆已經認爲你客戶端是死老虎了，不理你了，不知道你搞什麼飛機，讓這個 ACK
過了。可是服務器一看，不對啊，你給我的不是我期待的那個序列號， RFC
上說了，TCP 包如果序列號錯了的話，就回復一個 Reset.
所以，服務器就回復了一個 Reset。這個 Reset
過牆的時候，牆一看樂了，服務器也終止連接了，好吧，兩邊都是死老虎了，我就不監聽這條連接了。而至於客戶端，這個服務器過來的
Reset 非常好識別，忽略就是。隨後，客戶端開始正確的發送 ACK,
至此，三次握手成功，真正的好戲開始，而牆則認爲客戶端和服務器都是死老虎，直接放過。所以，張生就這樣透明的過了牆。
至於過牆以後所有的事情，《西廂記》裏面都有記載，各位讀者自行買書學習。&lt;/p&gt;
&lt;p&gt;現在的西廂計劃客戶端，即“張生”模塊的防連接重置的原理就是這樣，服務器端，即鶯鶯模塊的實現也是類似的。防DNS那個，不懂
DNS
協議，所以看不懂。我猜想，因爲開發人員都是黑客，所以自然喜歡用最經得起折騰和高度定製的
Linux 開發。 現在看西廂計劃的實現，因爲依賴於 Linux 內核模塊 netfilter,
在 Linux 上如魚得水，但往其他平臺的移植可能是個亟待解決的問題。
我覺得，在其他平臺上，可以通過 libpcap 和 libnet
，在用戶態實現相同的功能，就是有點麻煩而已，有興趣的懂網絡的可以照西廂計劃原理，在家自行做出此功能；當然，全中國人民都用
Linux 最好 :)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;PS 1: 據說是西廂計劃一個作者畫的原理圖：&lt;a class="reference external" href="http://img.ly/DIi"&gt;http://img.ly/DIi&lt;/a&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;PS 2: 我對 TCP 的理解僅限於課本，如果上面的對技術的理解有錯，請大家指出。&lt;/div&gt;
&lt;div class="line"&gt;PS 3: 有些漏洞，可能是設計上本質缺陷，不是那麼容易修復的。&lt;/div&gt;
&lt;div class="line"&gt;PS 4: 除了最後一個圖，本文沒有其他相關鏈接，如需相關資料，自行Google。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="zz"></category></entry><entry><title>寫程序讓CPU佔用率保持正弦函數</title><link href="//farseerfc.me/sine-cpu.html" rel="alternate"></link><published>2008-06-02T23:27:00+09:00</published><updated>2008-06-02T23:27:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2008-06-02:/sine-cpu.html</id><summary type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/298871889"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;據說是一道微軟的面試題。如題，寫程序，讓Windows的任務管理器中的性能監視器呈現正弦曲線。&lt;/p&gt;
&lt;img alt="正弦曲線" class="img-responsive align-center" src="http://fm531.img.xiaonei.com/pic001/20080602/23/14/large_10019p67.jpg"/&gt;
&lt;img alt="正弦曲線" class="img-responsive align-center" src="http://fm541.img.xiaonei.com/pic001/20080602/23/14/large_9935o67.jpg"/&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;p&gt;潛心鑽研良久，得代碼：（java）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;sincpu&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;calcNextSleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int …&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/298871889"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;據說是一道微軟的面試題。如題，寫程序，讓Windows的任務管理器中的性能監視器呈現正弦曲線。&lt;/p&gt;
&lt;img alt="正弦曲線" class="img-responsive align-center" src="http://fm531.img.xiaonei.com/pic001/20080602/23/14/large_10019p67.jpg"/&gt;
&lt;img alt="正弦曲線" class="img-responsive align-center" src="http://fm541.img.xiaonei.com/pic001/20080602/23/14/large_9935o67.jpg"/&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;
&lt;p&gt;潛心鑽研良久，得代碼：（java）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;sincpu&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;calcNextSleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;calcNextSleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sleep&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;sleepTime&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleepTime&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;yield&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;else&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleepTime&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;period&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(;;){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;period&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;                &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多核CPU上測試時要注意關掉一個CPU：&lt;/p&gt;
&lt;img alt="多核CPU上測試" class="img-responsive align-center" src="http://fm411.img.xiaonei.com/pic001/20080602/23/14/large_9946k67.jpg"/&gt;
</content><category term="import"></category><category term="java"></category><category term="microsoft"></category></entry><entry><title>關於神創論的一些見解</title><link href="//farseerfc.me/some-thought-on-creationism.html" rel="alternate"></link><published>2008-05-12T11:16:00+09:00</published><updated>2008-05-12T11:16:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2008-05-12:/some-thought-on-creationism.html</id><summary type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/292274803"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到陳驫同學很有感想的一篇神創論與命運日誌，覺得近日很久沒有看到這樣的評論了。想說幾句自己的觀點。&lt;/p&gt;
&lt;p&gt;首先我認爲，神創論與宿命論沒有多少關聯，甚至進化論者相較於神創論者更容易接受宿命論的觀點。因爲神創論主張意志的存在，人所具有的個體意志與神的意志，因此在神創論者的眼中事件的結果是可以通過意志來改變的，亦即如果我從物理樓11樓跳下，那麼我就可以改變自己死亡時間的宿命。上帝的意志同樣可以左右事件的結果，也就是所謂的宿命不復存在。而進化論者不承認意志獨立於物質世界的存在，你我的思考、行爲，都受到物理學法則諸如量子力學的約束，這就引出了北大物理系教授的那句“宇宙中的一切都是可以計算的”，亦即宿命論。如我我選擇現在從物理樓上跳下，我這一行爲並不是處於個人的獨立意志，乃是想證明這一點，亦即我跳樓這一舉動是有其背後的動機與原因的，就如同計算機的輸入必然導致了輸出，宿命的必然終結於此。&lt;/p&gt;
&lt;p&gt;其次，關於事件的複雜度所導致的隨機化，在大量混沌隨機中也存在着如統計學和隨機分形學這樣的規律，並不是否認宿命的充分理由。&lt;/p&gt;
&lt;p&gt;關於神創論的合理性問題。我認爲是否相信神的存在只是一個boolean二值問題，它爲true爲false本身並不重要，重要的是確定它的取值之後得到的推論與結果。如果否認神的存在，如現代數學這樣的完美又何以存在，進化論者的解釋是事物最終會向着更好更高級的方向發展，產生現代數學乃至現代科學是發展的必然。而這種論調顯然有悖於物理中以熱力學第二定律爲首的，預言事物會隨時間推演愈發混亂的論斷。更進一步，甚至整個人類、整個生物系統的存在都是有悖於熱力學推論的現象，是某種理論只能以“小概率事件”解釋的現象。&lt;/p&gt;
&lt;p&gt;神創論的核心觀點之一，是神的唯一存在性 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;導入自
&lt;a class="reference external" href="http://blog.renren.com/blog/230263946/292274803"&gt;renren&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到陳驫同學很有感想的一篇神創論與命運日誌，覺得近日很久沒有看到這樣的評論了。想說幾句自己的觀點。&lt;/p&gt;
&lt;p&gt;首先我認爲，神創論與宿命論沒有多少關聯，甚至進化論者相較於神創論者更容易接受宿命論的觀點。因爲神創論主張意志的存在，人所具有的個體意志與神的意志，因此在神創論者的眼中事件的結果是可以通過意志來改變的，亦即如果我從物理樓11樓跳下，那麼我就可以改變自己死亡時間的宿命。上帝的意志同樣可以左右事件的結果，也就是所謂的宿命不復存在。而進化論者不承認意志獨立於物質世界的存在，你我的思考、行爲，都受到物理學法則諸如量子力學的約束，這就引出了北大物理系教授的那句“宇宙中的一切都是可以計算的”，亦即宿命論。如我我選擇現在從物理樓上跳下，我這一行爲並不是處於個人的獨立意志，乃是想證明這一點，亦即我跳樓這一舉動是有其背後的動機與原因的，就如同計算機的輸入必然導致了輸出，宿命的必然終結於此。&lt;/p&gt;
&lt;p&gt;其次，關於事件的複雜度所導致的隨機化，在大量混沌隨機中也存在着如統計學和隨機分形學這樣的規律，並不是否認宿命的充分理由。&lt;/p&gt;
&lt;p&gt;關於神創論的合理性問題。我認爲是否相信神的存在只是一個boolean二值問題，它爲true爲false本身並不重要，重要的是確定它的取值之後得到的推論與結果。如果否認神的存在，如現代數學這樣的完美又何以存在，進化論者的解釋是事物最終會向着更好更高級的方向發展，產生現代數學乃至現代科學是發展的必然。而這種論調顯然有悖於物理中以熱力學第二定律爲首的，預言事物會隨時間推演愈發混亂的論斷。更進一步，甚至整個人類、整個生物系統的存在都是有悖於熱力學推論的現象，是某種理論只能以“小概率事件”解釋的現象。&lt;/p&gt;
&lt;p&gt;神創論的核心觀點之一，是神的唯一存在性，按照鄒恆明的比喻，這就如同數學中集閤中元素的的唯一性一般至關重要。數學乃至近代科學的發展，其起源在於這種對神性的探求，而不僅僅是好奇心就可以解釋的。反觀東方文化中數學的發展，開始時領先於西方科學千餘每年，但是始終作爲一種craft-oriented的實用主義學科。可以說沒有了神的唯一性支持，人們就不能確信自己能找到這樣一種完美高效的學科，只能在實用的基礎上發展其基礎算數。可以想象，沒有神的完美與唯一性，數學必將發展成現代化學或者微軟軟件這樣，龐大而充滿特例，到處都是修補與查表，怎麼會像現在的完美、簡潔與和諧。&lt;/p&gt;
&lt;p&gt;神創論者並不是將難題推與“神”然後放任不管，他們相信神是最爲理智的存在，創人時人同樣得到了神的智慧和理智，也就是神可以用人的理智來理解。&lt;/p&gt;
&lt;p&gt;引用牛頓《自然哲學的數學原理》中終章的話“太陽、恆星、行星的這個極精緻的結構不可能存在，除非通過一個有理智的和有權能的存在的設計和主宰……他不是作爲宇宙的靈魂，而是作爲一切的主宰而統治所有……”&lt;/p&gt;
&lt;p&gt;以上……&lt;/p&gt;
&lt;p&gt;(發現最近的哲理思維果然慢了不少，寫作思緒也一片混亂^_^)&lt;/p&gt;
</content><category term="import"></category><category term="creationism"></category></entry><entry><title>由記憶棒誤差故障引發的關於面向對象設計的九點思考</title><link href="//farseerfc.me/9-thoughts-about-oop-from-wrongly-insert-memory-stick.html" rel="alternate"></link><published>2007-09-20T14:38:00+09:00</published><updated>2007-09-20T14:38:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-09-20:/9-thoughts-about-oop-from-wrongly-insert-memory-stick.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;故障描述:
MMC Memory Stick Duo記憶棒未經Adapter適配器，直接插入SD Reader，致使MMC卡入SD Reader中。&lt;/p&gt;
&lt;p&gt;棧展開：
某日下午，無課。
忙於數分作業，想查詢用手機拍攝的板書照片。
取出手機中的MMC。
未經裝配Adapter，直接插入SD Reader。
(A runtime exception was thrown.)
嘗試翻轉筆記本機身，倒出MMC，未果。(rethrow)
嘗試用手指甲取出，未果。(rethrow)
考慮到有“推入反彈”機制，嘗試將MMC推入更深，反彈機制由於類型不匹配而失效，未果。(rethrow)
(The exception spread across the border of the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;故障描述:
MMC Memory Stick Duo記憶棒未經Adapter適配器，直接插入SD Reader，致使MMC卡入SD Reader中。&lt;/p&gt;
&lt;p&gt;棧展開：
某日下午，無課。
忙於數分作業，想查詢用手機拍攝的板書照片。
取出手機中的MMC。
未經裝配Adapter，直接插入SD Reader。
(A runtime exception was thrown.)
嘗試翻轉筆記本機身，倒出MMC，未果。(rethrow)
嘗試用手指甲取出，未果。(rethrow)
考慮到有“推入反彈”機制，嘗試將MMC推入更深，反彈機制由於類型不匹配而失效，未果。(rethrow)
(The exception spread across the border of the model.)
電腦維修技師接手(catch)
技師未能發現問題所在，由我解說原委。
(Because the exception lose the information, RTTI was asked to recall the information)
技師發現問題，嘗試用鑷子鑷出MMC，未果。
技師開解機箱(expose the data structure)
技師製作鉤子，勾出MMC(hooker link to the structure)
取出MMC，故障解除&lt;/p&gt;
&lt;p&gt;故障總結
1.接收到沒有完全瞭解、或沒有適當工具解決的exception時，不要嘗試用不成熟的技術解決，應儘快尋求能解決它的代碼。否則，被反覆rethrow的exception，尤其是通過模塊邊界的exception，有可能由subclass退化爲superclass，並因此而喪失一些信息。儘量不要讓exception丟失信息，必要時，通過RTTI機制尋回信息。&lt;/p&gt;
&lt;p&gt;2.超負荷運轉，多線程執行，這種種複雜性都有可能導致錯誤，應避免。無論你有多麼信任你的代碼或能力。&lt;/p&gt;
&lt;p&gt;3.在設計class的interface時，相匹配的interface應該滿足is-a的關係。因此，任何能插入SD Reader的object，即任何實現了SD interface的object，都應該is-a SD card。這次故障中，interface接受了MMC，但MMC不是SD。即使這種情況下throw an exception，都不能使事態緩和。能提供compile-time error時，儘量讓錯誤以compile-time error的形式展現，並在事先解決。類型匹配問題是應該能在事先解決的問題。&lt;/p&gt;
&lt;p&gt;4.Design patterns中的Adapter pattern應該只是迫不得已情況之下的解決方案。只有當你無權改變現狀時，才能使用Adapter。如果能改變現狀，應該改變設計以符合interface。&lt;/p&gt;
&lt;p&gt;5.因爲上條，所有相似功能的對象應具有相同的interface，不同的interface是本次故障的根源所在。&lt;/p&gt;
&lt;p&gt;6.特殊情況下，破壞封裝機制並expose the data structure是必要的，應該有方法支持這種做法。C的指針和C#的Reflection技術都以不同的方式支持這種做法。其他的一些語言機制，比如serializing(序列化)或streaming(流化)，也可以以某種方式間接支持這一做法。當然，機制還應避免這種做法被濫用。&lt;/p&gt;
&lt;p&gt;7.相反功能具有相同操作的設計，容易造成使用的混亂，應適當避免。比如SD Reader的推入反彈設計，即插入和彈出使用同一個向裏推的操作的設計。同樣的設計還包括，C++中的setNewHandle使用同一個函數，同時設置和返回handle。以及有些書中提倡的，使用同名函數重載的方式，實現setter/getter的設計。&lt;/p&gt;
&lt;p&gt;8.特殊工具(hooker)對於解決特定問題，通常比手工解決有效。不要嫌麻煩而不願意構造特殊工具。&lt;/p&gt;
&lt;p&gt;9.棧語義，即FILO順序，總在不知不覺中影響我們。違反了FILO順序的操作極易造成混亂。本故障發生時正確的處理順序爲：
裝配Adapter
    插入SD Reader
        讀取數據
        停用設備
    拔出SD Reader
拆解Adapter
本次故障的原因就是違反了FILO順序，違反了棧語義。&lt;/p&gt;
</content><category term="import"></category><category term="oop"></category></entry><entry><title>Program Development in Java Preface</title><link href="//farseerfc.me/program-development-in-java-preface.html" rel="alternate"></link><published>2007-09-16T13:26:00+09:00</published><updated>2007-09-16T13:26:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-09-16:/program-development-in-java-preface.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;程序開發原理&lt;/h2&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;——抽象、規格與面向對象設計&lt;/h3&gt;
&lt;p&gt;Barbara Liskov 、John Guttag 著&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;楊嘉晨 等譯&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;關於翻譯風格：&lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;多年來閱讀計算機類的著作及譯作，感覺總體的困難在於一大堆沒有標準譯名的技術術語。由於通行於工業界和學術界的還是英文原名和術語，我決定保留大量的英文術語。這樣的翻譯風格借鑑於臺灣著名的譯者和作者侯捷先生。對於譯與不譯的權衡，主要考慮閱讀的流暢，以及讀者的理解能力，或許難免帶有一些主觀色彩。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="preface"&gt;
&lt;h2&gt;前言 Preface&lt;/h2&gt;
&lt;p&gt;構建產品級質量的程序——可以在很長一段時間內使用的程序——衆所周知是極其困難的。本書的目標就是改善程序員解決這項任務的效率。我希望讀者在閱讀本書之後成爲一名好程序員。我相信本書的成功在於改善編程技巧，因爲我的學生告訴我這已經發生在他們身上。&lt;/p&gt;
&lt;p&gt;怎麼纔算是一名好程序員？是產生整個程序產品的效率。關鍵是要在每一階段減少浪費掉的努力。解決的方法包括：在開始編寫代碼之前就仔細考慮你的實現方案，通過未雨綢繆的方法來編寫代碼，使用嚴格的測試在早期發現錯誤，以及仔細注意模塊化編程，這樣當錯誤出現時，只需要改動極少數代碼就可以修正整個程序。本書涉及所有這些領域的技術。&lt;/p&gt;
&lt;p&gt;模塊化編程(Modularity)是編寫好程序的關鍵。把程序分解成許多小模塊，每一個模塊通過良好定義的狹窄接口和別的模塊交互作用 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;程序開發原理&lt;/h2&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;——抽象、規格與面向對象設計&lt;/h3&gt;
&lt;p&gt;Barbara Liskov 、John Guttag 著&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;楊嘉晨 等譯&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;關於翻譯風格：&lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;多年來閱讀計算機類的著作及譯作，感覺總體的困難在於一大堆沒有標準譯名的技術術語。由於通行於工業界和學術界的還是英文原名和術語，我決定保留大量的英文術語。這樣的翻譯風格借鑑於臺灣著名的譯者和作者侯捷先生。對於譯與不譯的權衡，主要考慮閱讀的流暢，以及讀者的理解能力，或許難免帶有一些主觀色彩。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="preface"&gt;
&lt;h2&gt;前言 Preface&lt;/h2&gt;
&lt;p&gt;構建產品級質量的程序——可以在很長一段時間內使用的程序——衆所周知是極其困難的。本書的目標就是改善程序員解決這項任務的效率。我希望讀者在閱讀本書之後成爲一名好程序員。我相信本書的成功在於改善編程技巧，因爲我的學生告訴我這已經發生在他們身上。&lt;/p&gt;
&lt;p&gt;怎麼纔算是一名好程序員？是產生整個程序產品的效率。關鍵是要在每一階段減少浪費掉的努力。解決的方法包括：在開始編寫代碼之前就仔細考慮你的實現方案，通過未雨綢繆的方法來編寫代碼，使用嚴格的測試在早期發現錯誤，以及仔細注意模塊化編程，這樣當錯誤出現時，只需要改動極少數代碼就可以修正整個程序。本書涉及所有這些領域的技術。&lt;/p&gt;
&lt;p&gt;模塊化編程(Modularity)是編寫好程序的關鍵。把程序分解成許多小模塊，每一個模塊通過良好定義的狹窄接口和別的模塊交互作用(interact)。有了模塊化，可以修正一部分程序中的錯誤而不考慮程序的其他部分，而且可以僅僅理解一部分程序而不必理解整個程序。沒有模塊化，程序是一大堆有着錯綜複雜的相互關係的部分的拼湊。很難去領悟和修改這樣一個程序，同樣也很難讓它正常工作。&lt;/p&gt;
&lt;p&gt;因此本書的重點在於創建模塊化的程序：怎樣把程序組織成一系列精心挑選的模塊。本書認爲模塊化就是抽象(abstraction)。每一個模塊意味着一個抽象，比如說指引一系列文檔中的關鍵字的目錄，或者在文檔中使用目錄來查找匹配某個問題的文檔的過程。着重強調面向對象編程思想——在程序中使用數據抽象和對象的思想。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;這本書使用Java作爲它的編程示例的語言。我們沒有假定讀者已經熟悉Java。儘管可能沒什麼價值，但是本書中的思想是語言無關的，並且可以在任何語言的編程中使用。&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="how-can-the-book-be-used"&gt;
&lt;h3&gt;怎樣使用這本書？ How Can the Book Be Used&lt;/h3&gt;
&lt;p&gt;本書《程序開發原理》有兩種使用方法。其一是作爲課本教材，講述如何用面向對象的方法來設計和實現複雜系統；其二是編程專家使用，幫助他們改善編程技能，增進他們的關於模塊化和Object-Oriented(面向對象)設計的知識。&lt;/p&gt;
&lt;p&gt;作爲教材使用時，本書一般作爲第二或第三門程序設計課程。我們已經在MIT使用本書很多年，給大一大二的本科生教授第二門編程課。在這一階段，學生們已經知道怎樣編寫小程序。課程在兩方面利用這一點：讓學生更仔細地思考小程序，以及教他們如何利用小程序作爲組件構建大型程序。這本書也可以在專業（如軟件工程）後期教學中使用。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;建立在本書基礎上的課程適合於所有計算機科學專業。儘管許多學生可能永遠不會成爲真正的大型程序的設計師，他們可以在開發部門工作，在那兒他們負責設計和實現能與整個結構耦合的子系統。模塊化設計的子系統是這種任務中心，這對那些從事大型程序設計任務的人來說也同樣重要。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-is-this-book-about"&gt;
&lt;h3&gt;這本書講什麼？What Is This Book About&lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;通觀全篇三分之二的書致力於討論在構建獨立的程序模塊時產生的問題，剩下的部分討論怎樣運用這些模塊構建大型程序。&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="program-modules"&gt;
&lt;h4&gt;程序模塊Program Modules&lt;/h4&gt;
&lt;p&gt;這一部分的書集中討論抽象機制(abstraction
mechanism)。它討論procedure(子程序)和exception(異常)，數據抽象，遍歷(iteration)抽象，數據抽象系列(family)以及多態(polymorphic)抽象。&lt;/p&gt;
&lt;p&gt;在對抽象的討論中，三個步驟是重要的。首先是決定被抽象的東西到底是什麼：它提供給它的用戶哪些行爲。創造抽象是設計的關鍵，因此本書討論如何在衆多選擇中挑選，以及怎樣才能創造出好的抽象。&lt;/p&gt;
&lt;p&gt;第二步是通過爲一個抽象制定一個規格(specification)來獲取它的意義。如果沒有一些描述，一個抽象就會含糊不清，而變得沒有使用價值。specification則提供了需要的描述。本書定義了一種specification的格式，討論了一份好的specification應有的屬性，並且提供了許多示例。&lt;/p&gt;
&lt;p&gt;第三步是實現抽象。本書討論怎樣設計一份實現，以及在簡潔性和執行性能之間怎樣權衡利弊。書中強調封裝(encapsulation)的重要性以及在一份實現中履行規格中定義的行爲的重要性。書中同樣提供一些技術——尤其是不變式斷言(representation
invariant)和抽象函數(abstraction
function)——來幫助讀者理解代碼和它的原因。不變式斷言和抽象函數都實現到儘可能的程度，這對於除錯和調試很有用。&lt;/p&gt;
&lt;p&gt;關於類型層次(type
hierarchy)的材料注重討論使用它作爲抽象的技術——一種把相關聯的一組數據抽象歸入同一系列的技術。這裏很重要的一點是，是否應當將一個類型作爲另一個類型的子類。本書定義了替換原則——通過比較子類和父類的specification，來決定是否建立子類關係的方法&lt;a class="reference external" href="#_ftn1"&gt;[1]&lt;/a&gt;。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;本書同樣涉及除錯和調試。書中討論怎樣得到足夠數量的測試情況，來準備通過黑箱和白箱測試，它同樣強調了複查(regression)測試的重要性。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="programming-in-the-large"&gt;
&lt;h4&gt;編寫大型程序 Programming in the Large&lt;/h4&gt;
&lt;p&gt;本書的其後部分講解怎樣用模塊化的方法設計和實現大型程序。它建立在前文有關abstraction和specification的材料的基礎之上。&lt;/p&gt;
&lt;p&gt;編寫大型程序涵蓋四個主要議題。首先講解需求分析——怎樣才能領悟程序中需要什麼。本書討論怎樣實施需求分析，也討論書寫產生的需求規格的方式，通過使用一種描述程序的抽象階段的數據模型。使用這種模型將產生一份更爲正式的specification，同時它也使需求檢查更加嚴格，這樣可以更好的領悟需求。&lt;/p&gt;
&lt;p&gt;編寫大型程序的第二項議題是程序設計，這通常是一個循序漸進的過程。設計過程圍繞構建有用的抽象來組織，這些抽象作爲整個程序之中理想的構建組建。這些抽象在設計時被仔細的編寫規格，這樣當程序實現時，那些實現抽象的模塊可以獨立地開發。這種設計使用設計筆記編寫文檔，包括描述整個程序結構的模塊間依賴性的圖示。&lt;/p&gt;
&lt;p&gt;第三項議題是實現和測試。本書討論了前置設計分析對於實現的必要性，以及怎樣進行設計複審。它同樣討論了設計和實現的順序。這一部分比較了自頂而下與自底而上的組織方式，討論如何使用驅動程序和佔位程序&lt;a class="reference external" href="#_ftn2"&gt;[2]&lt;/a&gt;(stub)，並且強調了制定一個事先的順序策略的必要性，以滿足開發組織和客戶的需求。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;本書以一章設計模式(design pattern)結束。一些模式在前面的章節介紹過，比如遍歷抽象是算法的主要組建。最後的章節討論前文中沒有涉及到的模式。希望它作爲這一教材的介紹。有興趣的讀者可以繼續閱讀其它書中更完善的討論&lt;a class="reference external" href="#_ftn3"&gt;[3]&lt;/a&gt;。&lt;/div&gt;
&lt;/div&gt;
&lt;hr class="docutils"/&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref1"&gt;[1]&lt;/a&gt;
譯註：如果子類的specification包括了所有父類的specification，就是說父類的要求也是子類的要求，或者子類的要求更爲嚴格，那麼可以建立父子關係。而替換原則的說法是，對於具有父子關係的類，任何需要一個父類對象的地方，都可以替換爲一個子類對象。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref2"&gt;[2]&lt;/a&gt;
譯註：在測試某一組建時，由於其餘組建還未實現，這一組建與其餘組建的接口銜接部分無法工作。此時可以針對這一組建編寫其餘組建的佔位程序(stub)，預留出接口的銜接代碼。佔位代碼通常不做任何有價值的事情，只報告組建的銜接部位工作正常。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="#_ftnref3"&gt;[3]&lt;/a&gt; 譯註：作者指的是設計模式的開山之作——《Design
Patterns—Elements of Reusable Object-Oriented
Software》,作者爲設計模式界著名的“四人幫”GoF(Gang of
Four)。此書詳盡討論了三大類共23個廣泛使用的設計模式的適用範圍、依存關係、實現細節以及已有的應用領域等問題。書中以C++和Smalltalk爲示例語言，不過書中所涉及的模式適用於所有面向對象的語言。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="Java"></category></entry><entry><title>C++ Tricks 3.2 標號、goto，以及switch的實現</title><link href="//farseerfc.me/c-tricks-3-2-label-goto-and-implementation-of-switch.html" rel="alternate"></link><published>2007-09-16T13:08:00+09:00</published><updated>2007-09-16T13:08:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-09-16:/c-tricks-3-2-label-goto-and-implementation-of-switch.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h2&gt;3.2 標號、goto，以及switch的實現&lt;/h2&gt;
&lt;p&gt;goto語句及標號(label)是最古老的C語言特性，也是最早被人們拋棄的語言特性之一。像彙編語言中的jmp指令一樣，goto語句可以跳轉到同一函數體中任何標號位置：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{int i=0;&lt;/p&gt;
&lt;p&gt;Loop: //A label&lt;/p&gt;
&lt;p&gt;++i;&lt;/p&gt;
&lt;p&gt;if(i&amp;lt;10)goto Loop; //Jump to the label&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;在原始而和諧的早期Fortran和Basic時代，我們沒有if then
else，沒有for和while，甚至沒有函數的概念，一切控制結構都靠goto(帶條件的或無條件的)構件。軟件工程師將這樣的代碼稱作“意大利麪條”代碼。實踐證明這樣的代碼極容易造成混亂。&lt;/p&gt;
&lt;p&gt;自從證明了結構化的程序可以做意大利麪條做到的任何事情，人們就開始不遺餘力地推廣結構化設計思想，將goto像猛獸一般囚禁在牢籠 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h2&gt;3.2 標號、goto，以及switch的實現&lt;/h2&gt;
&lt;p&gt;goto語句及標號(label)是最古老的C語言特性，也是最早被人們拋棄的語言特性之一。像彙編語言中的jmp指令一樣，goto語句可以跳轉到同一函數體中任何標號位置：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{int i=0;&lt;/p&gt;
&lt;p&gt;Loop: //A label&lt;/p&gt;
&lt;p&gt;++i;&lt;/p&gt;
&lt;p&gt;if(i&amp;lt;10)goto Loop; //Jump to the label&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;在原始而和諧的早期Fortran和Basic時代，我們沒有if then
else，沒有for和while，甚至沒有函數的概念，一切控制結構都靠goto(帶條件的或無條件的)構件。軟件工程師將這樣的代碼稱作“意大利麪條”代碼。實踐證明這樣的代碼極容易造成混亂。&lt;/p&gt;
&lt;p&gt;自從證明了結構化的程序可以做意大利麪條做到的任何事情，人們就開始不遺餘力地推廣結構化設計思想，將goto像猛獸一般囚禁在牢籠，標號也因此消失。&lt;/p&gt;
&lt;p&gt;標號唯一散發餘熱的地方，是在switch中控制分支流程。&lt;/p&gt;
&lt;p&gt;很多人不甚瞭解switch存在的意義，認爲它只是大型嵌套if then
else結構的縮略形式，並且比if語句多了很多“不合理”的限制。如果你瞭解到switch在編譯器內部的實現機制，就不難理解強加在switch之上的諸多限制，比如case後只能跟一個編譯期整型常量，比如用break結束每一個case。首先看一個switch實例：&lt;/p&gt;
&lt;p&gt;switch (shape.getAngle())&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;case 3: cout&amp;lt;&amp;lt;”Triangle”;break;&lt;/p&gt;
&lt;p&gt;case 4: cout&amp;lt;&amp;lt;”Square”;break;&lt;/p&gt;
&lt;p&gt;case 0:case1: cout&amp;lt;&amp;lt;”Not a sharp!”;break;&lt;/p&gt;
&lt;p&gt;default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;任何程序員都可以寫出與之對應的if結構：&lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i==3) cout&amp;lt;&amp;lt;”Triangle”;&lt;/p&gt;
&lt;p&gt;else if(i==4) cout&amp;lt;&amp;lt;”Square”;&lt;/p&gt;
&lt;p&gt;else if(i==0||i==1) cout&amp;lt;&amp;lt;”Not a sharp!”;&lt;/p&gt;
&lt;p&gt;else cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;看起來這兩段代碼在語義上是完全一樣的，不是麼？&lt;/p&gt;
&lt;p&gt;不！或許代碼的執行結果完全一樣，但是就執行效率而言，switch版本的更快！&lt;/p&gt;
&lt;p&gt;要了解爲什麼switch的更快，我們需要知道編譯器是怎樣生成switch的實現代碼的：&lt;/p&gt;
&lt;p&gt;首先，保留switch之後由{}括起來的語具體，僅將其中case、default和break替換爲真正的標號：&lt;/p&gt;
&lt;p&gt;switch (getAngle(shape))&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;隨後，對於所有出現在case之後的常量，列出一張只有goto的跳轉表，其順序按case後的常量排列：&lt;/p&gt;
&lt;p&gt;goto _case_0;&lt;/p&gt;
&lt;p&gt;goto _case_1;&lt;/p&gt;
&lt;p&gt;goto _case_3;&lt;/p&gt;
&lt;p&gt;goto _case_4;&lt;/p&gt;
&lt;p&gt;然後，計算case之後的常量與跳轉表地址之間的關係，如有需要，在跳轉表中插入空缺的項目：&lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default; //因爲沒有case 2，所以插入此項以條轉到default&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt;假設一個goto語句佔用5個字節，那麼在本例中，goto的地址=case後的常量*5+100105&lt;/p&gt;
&lt;p&gt;之後，生成跳轉代碼，在其餘條件下跳轉至default，在已知範圍內按照公式跳轉，全部的實現如下：&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i&amp;lt;0||i&amp;gt;=5)goto _default;&lt;/p&gt;
&lt;p&gt;i=i*5+100105; //按照得出的公式算出跳轉地址&lt;/p&gt;
&lt;p&gt;goto i; //僞代碼，C中不允許跳轉到整數，但是彙編允許&lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default;&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;經過這樣處理整個switch結構，使得無論switch後的變量爲何值，都可以通過最多兩次跳轉到達目標代碼。相比之下if版本的代碼則採用線性的比較和跳轉，在case語句很多的情況下效率極低。&lt;/p&gt;
&lt;p&gt;由此,我們也可以知道,爲什麼case後跟的一定是編譯期整型常數，因爲編譯器需要根據這個值製作跳轉表。我們可以明白爲什麼case與case之間應該用break分隔，因爲編譯器不改變switch語句體的結構，case其本身只是一個具有語義的標號而已，要想跳出switch，就必須用break語句。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 3.1 左值右值與常量性(lvalue，rvalue &amp; constant)</title><link href="//farseerfc.me/c-tricks-3-1-lvalue-rvalue-constant.html" rel="alternate"></link><published>2007-09-16T13:07:00+09:00</published><updated>2007-09-16T13:07:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-09-16:/c-tricks-3-1-lvalue-rvalue-constant.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h2&gt;3.1 左值右值與常量性(lvalue，rvalue &amp;amp; constant)&lt;/h2&gt;
&lt;p&gt;首先要搞清楚的是，什麼是左值，什麼是右值。這裏給出左值右值的定義：&lt;/p&gt;
&lt;p&gt;1、左值是可以出現在等號(=)左邊的值，右值是隻能出現在等號右邊的值。&lt;/p&gt;
&lt;p&gt;2、左值是可讀可寫的值，右值是隻讀的值。&lt;/p&gt;
&lt;p&gt;3、左值有地址，右值沒有地址。&lt;/p&gt;
&lt;p&gt;根據左值右值的第二定義，值的左右性就是值的常量性——常量是右值，非常量是左值。比如：&lt;/p&gt;
&lt;p&gt;1=1;//Error&lt;/p&gt;
&lt;p&gt;這個複製操作在C++中是語法錯誤，MSVC給出的錯誤提示爲“error C2106: '=' :
left operand must be
l-value”，就是說’=’的左操作數必須是一個左值，而字面常數1是一個右值。可見，嚴格的區分左值右值可以從語法分析的角度找出程序的邏輯錯誤。&lt;/p&gt;
&lt;p&gt;根據第二定義，一個左值也是一個右值 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h2&gt;3.1 左值右值與常量性(lvalue，rvalue &amp;amp; constant)&lt;/h2&gt;
&lt;p&gt;首先要搞清楚的是，什麼是左值，什麼是右值。這裏給出左值右值的定義：&lt;/p&gt;
&lt;p&gt;1、左值是可以出現在等號(=)左邊的值，右值是隻能出現在等號右邊的值。&lt;/p&gt;
&lt;p&gt;2、左值是可讀可寫的值，右值是隻讀的值。&lt;/p&gt;
&lt;p&gt;3、左值有地址，右值沒有地址。&lt;/p&gt;
&lt;p&gt;根據左值右值的第二定義，值的左右性就是值的常量性——常量是右值，非常量是左值。比如：&lt;/p&gt;
&lt;p&gt;1=1;//Error&lt;/p&gt;
&lt;p&gt;這個複製操作在C++中是語法錯誤，MSVC給出的錯誤提示爲“error C2106: '=' :
left operand must be
l-value”，就是說’=’的左操作數必須是一個左值，而字面常數1是一個右值。可見，嚴格的區分左值右值可以從語法分析的角度找出程序的邏輯錯誤。&lt;/p&gt;
&lt;p&gt;根據第二定義，一個左值也是一個右值，因爲左值也可讀，而一個右值不是一個左值，因爲右值不可寫。&lt;/p&gt;
&lt;p&gt;通常情況下，聲明的變量是一個左值，除非你指定const將它變成一個右值：&lt;/p&gt;
&lt;p&gt;int lv=1;&lt;/p&gt;
&lt;p&gt;const int rv=lv;&lt;/p&gt;
&lt;p&gt;由於右值的值在程序執行期間不能改變，所以必須用另一個右值初始化它。&lt;/p&gt;
&lt;p&gt;一個普通變量只能用右值初始化，如果你想傳遞左值，必須聲明一個引用或一個指針：&lt;/p&gt;
&lt;p&gt;int &amp;amp; ref=lv;//用引用傳遞左值&lt;/p&gt;
&lt;p&gt;int * plv=&amp;amp;lv;//傳遞指針以間接傳遞左值&lt;/p&gt;
&lt;p&gt;必須用左值初始化引用，然而，可以用右值初始化常量引用：&lt;/p&gt;
&lt;p&gt;int &amp;amp; r1=1; //Error!&lt;/p&gt;
&lt;p&gt;const int &amp;amp; r2=1; //OK&lt;/p&gt;
&lt;p&gt;這實際上相當於：&lt;/p&gt;
&lt;p&gt;int _r2=1;&lt;/p&gt;
&lt;p&gt;const int &amp;amp; r2=_r2;&lt;/p&gt;
&lt;p&gt;這樣的寫法在函數體內沒什麼作用，但是在傳遞函數參數時，它可以避免潛在的(傳遞左值時的)複製操作，同時又可以接受右值。&lt;/p&gt;
&lt;p&gt;通常情況下，函數的參數和返回值都只傳回右值，除非你明確的通過引用傳遞左值。&lt;/p&gt;
&lt;p&gt;明確了左值與右值的區別，有助於我們寫函數時確定什麼時候應該有const，什麼時候不該有。比如，我們寫了一個代表數學中複數的類Complex：&lt;/p&gt;
&lt;p&gt;class Complex;&lt;/p&gt;
&lt;p&gt;然後，我們寫針對Complex的運算符重載：operator+和operator=。問題在於，參數和返回值應該是什麼類型，可選類型有四種：
Complex、const Complex、Complex&amp;amp;、const Complex&amp;amp;。&lt;/p&gt;
&lt;p&gt;對於operator+，我們不會改變參數的值，所以可以通過const
Complex&amp;amp;傳遞參數。至於返回值類型，由於int類型的加法返回右值，所以根據Do
as the ints do的原則，返回值類型爲const Complex：&lt;/p&gt;
&lt;p&gt;const Complex operator+(const Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt;對於operator=，同樣要思考這些問題。我們寫入第一個參數，所以第一個參數爲Complex&amp;amp;，我們只讀取第二個參數，所以第二個參數爲const
Complex&amp;amp;。至於返回值，還是Do as the ints
do。int的賦值返回左值，不信你可以試一試：&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;(i=1)=2;&lt;/p&gt;
&lt;p&gt;雖然比較傻，先將i賦爲1，再將其改爲2，但是這是被C++語法支持的做法，我們就理應遵守。所以返回第一個參數的左值：&lt;/p&gt;
&lt;p&gt;Complex&amp;amp; operator=(Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt;const是C++引入的語言特性，也被ANSI
C99借鑑，在經典版本的C語言中是沒有的。關於const的歷史，有幾點值得玩味。最初Bjarne
Stroustrup引入const時，可寫性是和可讀性分開的。那時使用關鍵字readonly和writeonly。這個特點被首先提交到C的ANSI標準化委員會(當時還沒有C++標準化的計劃)，但是ANSI
C標準只接受了readonly的概念，並將其命名爲const。隨後，有人發現在多線程同步的環境下，有些變量的值會在編譯器的預料之外改變，爲了防止過度優化破壞這些變量，C++又引入關鍵字violate。從語義特點來看，violate是const的反義詞，因爲const表示不會變的量，而violate表示會不按照預期自行變化的量。從語法特點而言，violate與const是極爲相似的，適用於const的一切語法規則同樣適用於violate。&lt;/p&gt;
&lt;p&gt;值的常量性可以被劃分爲兩種：編譯期常量和運行期常量。C++語法並沒有嚴格區分這兩種常量，導致了少許混亂：&lt;/p&gt;
&lt;p&gt;const int i=5;const int * pi=&amp;amp;i;&lt;/p&gt;
&lt;p&gt;const_cast&amp;lt;int&amp;amp;&amp;gt;i=1;//對於運行期常量，在需要時可以去除它的常量性&lt;/p&gt;
&lt;p&gt;int a[i];//對於編譯期常量，可以用它來指定數組大小&lt;/p&gt;
&lt;p&gt;cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;sizeof(a)/sizeof(a[0])&amp;lt;&amp;lt;*pi;&lt;/p&gt;
&lt;p&gt;這種將編譯期與運行期常量的特性混用的方法，勢必導致語義的混亂。數組a的大小最終是5，因爲採用了i的編譯期值，而不管i在運行期是否被改變了值。最後一句代碼將（有可能）輸出551，第一個i的值作爲一種優化在編譯期綁定，第二個值標明瞭a的大小，第三個值通過指針顯示地輸出i的運行期真實值。&lt;/p&gt;
&lt;p&gt;在C++的近親C#的語法中，這兩種常量被嚴格地區分開：編譯期常量由const指定，只能是內建類型變量；運行期常量由readonly指定，可以是任何類型。永遠不會改變的常量，如圓周率pi的值，應該用const聲明；而其它有可能改變的常量，皆由readonly聲明。&lt;/p&gt;
&lt;p&gt;C++中的const的特點更傾向於C#中的readonly，雖然語法上允許使用const的編譯期常量性，但正如上文所展示的，這容易造成混亂。爲了得到C#中const的語義，在C++中，我們不必迴歸惡魔#define的懷抱，可以使用所謂“匿名enum技巧”。當匿名聲明一個enum類型時，其中的枚舉值就是一個int類型的編譯期常量，比如：&lt;/p&gt;
&lt;p&gt;enum{Size=5;};&lt;/p&gt;
&lt;p&gt;int a[Size];&lt;/p&gt;
&lt;p&gt;這種使用匿名enum來聲明編譯期常量的做法，被廣泛應用於STL、boost等模板庫的實現代碼中。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.2 I386平臺的內存佈局</title><link href="//farseerfc.me/c-tricks-2-2-i386-memory-layout.html" rel="alternate"></link><published>2007-08-28T14:30:00+09:00</published><updated>2007-08-28T14:30:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks-2-2-i386-memory-layout.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.2 I386平臺的內存佈局&lt;/h2&gt;
&lt;p&gt;衆所周知，I386是32位體系結構。因此對於絕大多數I386平臺的C++編譯器而言，sizeof(int)=sizeof(long)=sizeof(void*)=4。當然C++標準對此沒有任何保證，我們也不應該試圖編寫依賴於此的代碼。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;32位指針的可尋址空間爲4GB。爲充分利用這麼大的尋址空間，也是爲了支持其它更先進的技術比如多任務技術或者動態鏈接庫技術，WinNT使用虛擬內存技術，給與每個應用程序全部4GB的內存空間。4GB的地址被一分爲二，前2GB供應用程序自己使用，後2GB由系統內核分配和管理。這2GB的內存地址，通常被劃分成3種內存區使用：&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;1 代碼及靜態數據區&lt;/h3&gt;
&lt;p&gt;由代碼加載器從動態鏈接庫鏡像(通常是exe或dll文件)加載，通常定位到鏡像文件中指定的基址開始的內存區。如果基址所在內存已被佔用，動態連接器會將代碼或數據重定向到其它可用地址。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;在C++中，靜態數據包括：名字空間(namespace)和全局(global)對象、函數的static對象、類的static數據成員 …&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.2 I386平臺的內存佈局&lt;/h2&gt;
&lt;p&gt;衆所周知，I386是32位體系結構。因此對於絕大多數I386平臺的C++編譯器而言，sizeof(int)=sizeof(long)=sizeof(void*)=4。當然C++標準對此沒有任何保證，我們也不應該試圖編寫依賴於此的代碼。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;32位指針的可尋址空間爲4GB。爲充分利用這麼大的尋址空間，也是爲了支持其它更先進的技術比如多任務技術或者動態鏈接庫技術，WinNT使用虛擬內存技術，給與每個應用程序全部4GB的內存空間。4GB的地址被一分爲二，前2GB供應用程序自己使用，後2GB由系統內核分配和管理。這2GB的內存地址，通常被劃分成3種內存區使用：&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;1 代碼及靜態數據區&lt;/h3&gt;
&lt;p&gt;由代碼加載器從動態鏈接庫鏡像(通常是exe或dll文件)加載，通常定位到鏡像文件中指定的基址開始的內存區。如果基址所在內存已被佔用，動態連接器會將代碼或數據重定向到其它可用地址。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;在C++中，靜態數據包括：名字空間(namespace)和全局(global)對象、函數的static對象、類的static數據成員。這些靜態數據由編譯器分配地址(但可能被重定向)，由靜態連接器寫入代碼文件(通常是exe或dll)的靜態數據區段。所以標準說，這些靜態數據在編譯期就已經具有地址。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stack"&gt;
&lt;h3&gt;2 棧(Stack)&lt;/h3&gt;
&lt;p&gt;棧是最常用的動態數據存儲區，所有函數的non-static對象和函數參數都在程序運行期在棧上分配內存。在數據結構中，術語“棧(Stack)”意指先進後出(FILO，First
In Last
Out)，與“隊列(Queue)”所指的FIFO相對。相對於基於堆的對象分配技術，默認使用棧的對象分配有兩點優勢：&lt;/p&gt;
&lt;p&gt;一、棧的FILO與人的思維方式相同&lt;/p&gt;
&lt;p&gt;現實生活中有許多事例都使用FILO的方式，比如人們必須先提起話筒再撥打號碼，而後掛斷電話之後再放下話筒。使用FILO的棧，可以保證事物的銷燬順序以其誕生順序相反的順序進行，不會產生在掛斷電話之前就放下話筒的尷尬。&lt;/p&gt;
&lt;p&gt;二、棧的分配管理僅需要兩個額外指針：棧頂(esp)和棧底(ebp)指針&lt;/p&gt;
&lt;p&gt;從實現的技術層面而言，棧的管理比其它動態分配技術要簡單很多。I386平臺上的動態棧管理，僅需要棧頂和棧底兩個指針。這兩個指針的存儲顯然不能放置於棧中，置於靜態數據區又有損效率。I386平臺爲管理動態棧專門預留了兩個通用寄存器變量esp與ebp，分別代表棧頂(esp,Extended
Stack Pointer)與棧底(Extended Bottom
Pointer)指針。其中的extended代表它們是32位指針，以區分16位的sp和bp寄存器。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;棧是動態存儲區的特點，表明它的內存佔用將隨着程序的運行而變化。I386平臺上WinNT將應用程序的棧置於程序空間，向下增長。程序初始化時，由操作系統將esp指向系統分配的棧空間的頂部。當程序需要在棧上分配變量時，就將esp減去變量所需字節數，這被稱作“壓棧(Push)”；隨後又要銷燬變量時，就將esp加上變量所需字節數，這被稱作“彈出(Pop)”。esp與ebp兩者之間所夾的空間，就是當前函數正在使用的棧空間。由於棧向下增長，esp(棧頂)的值總是小於ebp(棧底)的值，新分配的變量地址總是小於舊變量的地址。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="heap"&gt;
&lt;h3&gt;3 堆(Heap)和自由存儲區&lt;/h3&gt;
&lt;p&gt;棧中的變量對於分配與釋放的順序有特定要求，這在一定程度上限制了棧的適用範圍。面向對象(OO，Object
Oriented)的程序設計思想也要求能自由地控制變量的分配與銷燬。由此，現代操作系統都提供了被稱作“堆(Heap)”的自由存儲區，以允許由程序員控制的對象創建和銷燬過程。C標準庫函數malloc和free則是對操作系統提供的堆操作的封裝。C++提供的自由存儲區運算符new和delete則通常是malloc和free的又一層封裝。&lt;/p&gt;
&lt;p&gt;操作系統經由malloc和free控制對堆的訪問。堆的存儲管理技術各不相同，簡單的使用雙鏈表管理，複雜的可以比擬一個完整的文件系統。&lt;/p&gt;
&lt;p&gt;由於額外的管理需求，使用系統提供的通用分配器在堆上分配和銷燬變量的代價，無論從空間角度還是效率角度而言，都比在棧上分配對象要高昂很多。對於sizeof上百的大型對象，這樣的高昂代價還是可以接受的，但是對於sizeof只有個位數的小對象，這樣的代價通常是一個數量級的差距。正因爲這個原因，STL不使用new和delete，轉而使用分配子(alllocor)分配對象。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks</title><link href="//farseerfc.me/c-tricks.html" rel="alternate"></link><published>2007-08-28T14:28:00+09:00</published><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ Tricks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;By  FarseerFc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;從今天起，我再將在&lt;a class="reference external" href="http://firechildren.spaces.live.com/"&gt;Live
Space&lt;/a&gt;和&lt;a class="reference external" href="http://76635424.qzone.qq.com/"&gt;QQZone&lt;/a&gt;同時發表一系列文章，暫定名爲“C++Tricks”。&lt;/p&gt;
&lt;p&gt;本文旨在記錄和闡述一些本人學習C++時所得的心得、技巧。總體來看，本文涉及的內容是每一個C++程序員都應該知道的，但是很少見諸C++教材。希望對各位同仁學習C++有所幫助。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;也可以通過QQ或MSN向我索要此文的DOC版或PDF版，會比網頁上的更新的快一點。&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lexical-problems"&gt;
&lt;h2&gt;1      詞法問題(Lexical Problems)&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!139.entry"&gt;1.1 條件運算符(?:)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!140.entry"&gt;1.2 逗號運算符(,)、邏輯運算符(&amp;amp;&amp;amp;,||)與運算符重載的陷阱&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="x86"&gt;
&lt;h3&gt;2      X86體系結構&lt;/h3&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!146.entry"&gt;2.1 X86概述&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!147.entry"&gt;2.2 …&lt;/a&gt;&lt;/h4&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ Tricks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;By  FarseerFc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;從今天起，我再將在&lt;a class="reference external" href="http://firechildren.spaces.live.com/"&gt;Live
Space&lt;/a&gt;和&lt;a class="reference external" href="http://76635424.qzone.qq.com/"&gt;QQZone&lt;/a&gt;同時發表一系列文章，暫定名爲“C++Tricks”。&lt;/p&gt;
&lt;p&gt;本文旨在記錄和闡述一些本人學習C++時所得的心得、技巧。總體來看，本文涉及的內容是每一個C++程序員都應該知道的，但是很少見諸C++教材。希望對各位同仁學習C++有所幫助。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;也可以通過QQ或MSN向我索要此文的DOC版或PDF版，會比網頁上的更新的快一點。&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lexical-problems"&gt;
&lt;h2&gt;1      詞法問題(Lexical Problems)&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!139.entry"&gt;1.1 條件運算符(?:)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!140.entry"&gt;1.2 逗號運算符(,)、邏輯運算符(&amp;amp;&amp;amp;,||)與運算符重載的陷阱&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="x86"&gt;
&lt;h3&gt;2      X86體系結構&lt;/h3&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!146.entry"&gt;2.1 X86概述&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!147.entry"&gt;2.2 I386平臺的內存佈局&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!148.entry"&gt;2.3 I386平臺C函數內部的棧分配&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!149.entry"&gt;2.4 I386平臺C函數調用邊界的棧分配&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!150.entry"&gt;2.5 I386平臺的邊界對齊(Align)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!151.entry"&gt;2.6 I386平臺C函數的可變參數表(Variable Arguments)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!152.entry"&gt;2.7 I386平臺的其它函數調用模型&lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="id6"&gt;
&lt;h5&gt;3 過程式編程&lt;/h5&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!154.entry"&gt;3.1 左值右值與常量性(lvalue，rvalue &amp;amp; constant)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!155.entry"&gt;3.2 標號、goto，以及switch的實現&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.3 I386平臺C函數內部的棧分配</title><link href="//farseerfc.me/c-tricks-2-3-i386-stack-allocation-in-c-functions.html" rel="alternate"></link><published>2007-08-28T14:28:00+09:00</published><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks-2-3-i386-stack-allocation-in-c-functions.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.3 I386平臺C函數內部的棧分配&lt;/h2&gt;
&lt;p&gt;函數使用棧來保存局部變量，傳遞函數參數。進入函數時，函數在棧上爲函數中的變量統一預留棧空間，將esp減去相應字節數。當函數執行流程途徑變量聲明語句時，如有需要就調用相應構造函數將變量初始化。當執行流程即將離開聲明所在代碼塊時，以初始化的順序的相反順序逐一調用析構函數。當執行流程離開函數體時，將esp加上相應字節數，歸還棧空間。&lt;/p&gt;
&lt;p&gt;爲了訪問函數變量，必須有方法定位每一個變量。變量相對於棧頂esp的位置在進入函數體時就已確定，但是由於esp會在函數執行期變動，所以將esp的值保存在ebp中，並事先將ebp的值壓棧。隨後，在函數體中通過ebp減去偏移量來訪問變量。以一個最簡單的函數爲例：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int a=0; //a的地址被分配爲ebp-4&lt;/p&gt;
&lt;p&gt;char c=1; //c的地址被分配爲ebp-8&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;產生的彙編代碼爲：&lt;/p&gt;
&lt;p&gt;push ebp ;將ebp壓棧&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;ebp=esp 用棧底備份棧頂指針&lt;/p&gt;
&lt;p&gt;sub …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.3 I386平臺C函數內部的棧分配&lt;/h2&gt;
&lt;p&gt;函數使用棧來保存局部變量，傳遞函數參數。進入函數時，函數在棧上爲函數中的變量統一預留棧空間，將esp減去相應字節數。當函數執行流程途徑變量聲明語句時，如有需要就調用相應構造函數將變量初始化。當執行流程即將離開聲明所在代碼塊時，以初始化的順序的相反順序逐一調用析構函數。當執行流程離開函數體時，將esp加上相應字節數，歸還棧空間。&lt;/p&gt;
&lt;p&gt;爲了訪問函數變量，必須有方法定位每一個變量。變量相對於棧頂esp的位置在進入函數體時就已確定，但是由於esp會在函數執行期變動，所以將esp的值保存在ebp中，並事先將ebp的值壓棧。隨後，在函數體中通過ebp減去偏移量來訪問變量。以一個最簡單的函數爲例：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int a=0; //a的地址被分配爲ebp-4&lt;/p&gt;
&lt;p&gt;char c=1; //c的地址被分配爲ebp-8&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;產生的彙編代碼爲：&lt;/p&gt;
&lt;p&gt;push ebp ;將ebp壓棧&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;ebp=esp 用棧底備份棧頂指針&lt;/p&gt;
&lt;p&gt;sub esp,8 ;esp-=8，爲a和c預留空間，包括邊界對齊&lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],0 ;a=0&lt;/p&gt;
&lt;p&gt;mov byte ptr[ebp-8],1 ;c=1&lt;/p&gt;
&lt;p&gt;add esp,8 ;esp+=8，歸還a和c的空間&lt;/p&gt;
&lt;p&gt;mov esp,ebp ;esp=ebp 從棧底恢復棧頂指針&lt;/p&gt;
&lt;p&gt;pop ebp ;恢復ebp&lt;/p&gt;
&lt;p&gt;ret ;返回&lt;/p&gt;
&lt;p&gt;相應的內存佈局是這樣：&lt;/p&gt;
&lt;p&gt;09992:c=1 &amp;lt;-esp&lt;/p&gt;
&lt;p&gt;09996:a=0&lt;/p&gt;
&lt;p&gt;10000:舊ebp &amp;lt;-ebp&lt;/p&gt;
&lt;p&gt;10004:……&lt;/p&gt;
&lt;p&gt;注:彙編中的pop、push、call、ret語句是棧操作指令，其功能可以用普通指令替換&lt;/p&gt;
&lt;p&gt;push ebp相當於:&lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;mov dword ptr[esp],ebp&lt;/p&gt;
&lt;p&gt;pop ebp相當於：&lt;/p&gt;
&lt;p&gt;mov ebp,dword ptr[esp]&lt;/p&gt;
&lt;p&gt;sub esp,4&lt;/p&gt;
&lt;p&gt;call fun_address相當於：&lt;/p&gt;
&lt;p&gt;push eip&lt;/p&gt;
&lt;p&gt;jmp fun_address&lt;/p&gt;
&lt;p&gt;ret相當於&lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt;帶參數的ret&lt;/p&gt;
&lt;p&gt;ret 8相當於&lt;/p&gt;
&lt;p&gt;add esp,12&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt;所有局部變量都在棧中由函數統一分配，形成了類似逆序數組的結構，可以通過指針逐一訪問。這一特點具有很多有趣性質，比如，考慮如下函數，找出其中的錯誤及其造成的結果：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i,a[10];&lt;/p&gt;
&lt;p&gt;for(i=0;i&amp;lt;=10;++i)a[i]=0;/An error occurs here!&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;這個函數中包含的錯誤，即使是C++新手也很容易發現，這是老生常談的越界訪問問題。但是這個錯誤造成的結果，是很多人沒有想到的。這次的越界訪問，並不會像很多新手預料的那樣造成一個“非法操作”消息，也不會像很多老手估計的那樣會默不作聲，而是導致一個，呃，死循環！&lt;/p&gt;
&lt;p&gt;錯誤的本質顯而易見，我們訪問了a[10]，但是a[10]並不存在。C++標準對於越界訪問只是說“未定義操作”。我們知道，a[10]是數組a所在位置之後的一個位置，但問題是，是誰在這個位置上。是i!&lt;/p&gt;
&lt;p&gt;根據前面的討論，i在數組a之前被聲明，所以在a之前分配在棧上。但是，I386上棧是向下增長的，所以，a的地址低於i的地址。其結果是在循環的最後，a[i]引用到了i自己！接下來的事情就不難預見了，a[i]，也就是i，被重置爲0，然後繼續循環的條件仍然成立……這個循環會一直繼續下去，直到在你的帳單上產生高額電費，直到耗光地球電能，直到太陽停止燃燒……呵呵，或者直到聰明的你把程序Kill了……&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.4 I386平臺C函數調用邊界的棧分配</title><link href="//farseerfc.me/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html" rel="alternate"></link><published>2007-08-28T14:28:00+09:00</published><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.4 I386平臺C函數調用邊界的棧分配&lt;/h2&gt;
&lt;p&gt;當調用一個函數時，主調函數將參數以聲明中相反的順序壓棧，然後將當前的代碼執行指針(eip)壓棧，然後跳轉到被調函數的入口點。在被調函數中，通過將ebp加上一個偏移量來訪問函數參數，以聲明中的順序(即壓棧的相反順序)來確定參數偏移量。被調函數返回時，彈出主調函數壓在棧中的代碼執行指針，跳回主調函數。再由主調函數恢復到調用前的棧。&lt;/p&gt;
&lt;p&gt;函數的返回值不同於函數參數，通過寄存器傳遞。如果返回值類型可以放入32位變量，比如int、short、char、指針等類型，通過eax寄存器傳遞。如果返回值類型是64位變量，如_int64，同過edx+eax傳遞，edx存儲高32位，eax存儲低32位。如果返回值是浮點類型，如float和double，通過專用的浮點數寄存器棧的棧頂返回。如果返回值類型是用戶自定義結構，或C++類類型，通過修改函數簽名，以引用型參數的形式傳回。&lt;/p&gt;
&lt;p&gt;同樣以最簡單的函數爲例：&lt;/p&gt;
&lt;p&gt;void f(){&lt;/p&gt;
&lt;p&gt;int i …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.4 I386平臺C函數調用邊界的棧分配&lt;/h2&gt;
&lt;p&gt;當調用一個函數時，主調函數將參數以聲明中相反的順序壓棧，然後將當前的代碼執行指針(eip)壓棧，然後跳轉到被調函數的入口點。在被調函數中，通過將ebp加上一個偏移量來訪問函數參數，以聲明中的順序(即壓棧的相反順序)來確定參數偏移量。被調函數返回時，彈出主調函數壓在棧中的代碼執行指針，跳回主調函數。再由主調函數恢復到調用前的棧。&lt;/p&gt;
&lt;p&gt;函數的返回值不同於函數參數，通過寄存器傳遞。如果返回值類型可以放入32位變量，比如int、short、char、指針等類型，通過eax寄存器傳遞。如果返回值類型是64位變量，如_int64，同過edx+eax傳遞，edx存儲高32位，eax存儲低32位。如果返回值是浮點類型，如float和double，通過專用的浮點數寄存器棧的棧頂返回。如果返回值類型是用戶自定義結構，或C++類類型，通過修改函數簽名，以引用型參數的形式傳回。&lt;/p&gt;
&lt;p&gt;同樣以最簡單的函數爲例：&lt;/p&gt;
&lt;p&gt;void f(){&lt;/p&gt;
&lt;p&gt;int i=g(1,2);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int g(int a,int b){&lt;/p&gt;
&lt;p&gt;int c=a+b；&lt;/p&gt;
&lt;p&gt;return c;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;產生的彙編代碼如下：&lt;/p&gt;
&lt;p&gt;f:&lt;/p&gt;
&lt;p&gt;push ebp ;備份ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;建立棧底&lt;/p&gt;
&lt;p&gt;sub esp,4 ;爲i分配空間&lt;/p&gt;
&lt;p&gt;mov eax,2 ;準備參數b的值2&lt;/p&gt;
&lt;p&gt;push eax ;將b壓棧&lt;/p&gt;
&lt;p&gt;mov eax,1 ;準備參數a的值1&lt;/p&gt;
&lt;p&gt;push eax ;將a壓棧&lt;/p&gt;
&lt;p&gt;call g ;調用g&lt;/p&gt;
&lt;p&gt;add esp,8 ;將a和b一起彈出，恢復調用前的棧&lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ;將返回值保存進變量i&lt;/p&gt;
&lt;p&gt;mov esp,ebp ;恢復棧頂&lt;/p&gt;
&lt;p&gt;pop ebp ;恢復棧底&lt;/p&gt;
&lt;p&gt;g:&lt;/p&gt;
&lt;p&gt;push ebp ;備份ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;建立棧底&lt;/p&gt;
&lt;p&gt;sub esp,4 ;爲局部變量c在棧中分配內存&lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp+8] ;通過ebp間接讀取參數a的值&lt;/p&gt;
&lt;p&gt;mov ebx,dword ptr[ebp+12] ;通過ebp間接讀取參數b的值&lt;/p&gt;
&lt;p&gt;add eax,ebx ;將a和b的值相加，之和存在eax中&lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ;將和存入變量c&lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp-4] ;將c作爲返回值，代碼優化後會刪除此句&lt;/p&gt;
&lt;p&gt;add esp,4 ;銷燬c的內存&lt;/p&gt;
&lt;p&gt;mov esp,ebp ;恢復棧頂&lt;/p&gt;
&lt;p&gt;pop ebp ;恢復棧底&lt;/p&gt;
&lt;p&gt;ret ;返回函數f&lt;/p&gt;
&lt;p&gt;棧的內存佈局如下：&lt;/p&gt;
&lt;p&gt;100076:c &amp;lt;- g的esp&lt;/p&gt;
&lt;p&gt;100080:f的ebp=100100 &amp;lt;- g的ebp&lt;/p&gt;
&lt;p&gt;100084:f的eip&lt;/p&gt;
&lt;p&gt;100088:a=1&lt;/p&gt;
&lt;p&gt;100092:b=2&lt;/p&gt;
&lt;p&gt;100096:i&lt;/p&gt;
&lt;p&gt;100100:舊ebp &amp;lt;-f的ebp&lt;/p&gt;
&lt;p&gt;100104:……&lt;/p&gt;
&lt;p&gt;注意在函數g的彙編代碼中，訪問函數的局部變量和訪問函數參數的區別。局部變量總是通過將ebp減去偏移量來訪問，函數參數總是通過將ebp加上偏移量來訪問。對於32位變量而言，第一個局部變量位於ebp-4，第二個位於ebp-8，以此類推，32位局部變量在棧中形成一個逆序數組；第一個函數參數位於ebp+8，第二個位於ebp+12，以此類推，32位函數參數在棧中形成一個正序數組。&lt;/p&gt;
&lt;p&gt;由於函數返回值通過寄存器返回，不需要空間分配等操作，所以返回值的代價很低。基於這個原因，舊的C語法約定，不寫明返回值類型的函數，返回值類型爲int。這一規則與現行的C++語法相違背，因爲C++中，不寫明返回值類型的函數返回值類型爲void，表示不返回值。這種語法不兼容性是爲了加強C++的類型安全，但同時也帶來了一些問題。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.5 I386平臺的邊界對齊(Align)</title><link href="//farseerfc.me/c-tricks-2-5-address-alignment.html" rel="alternate"></link><published>2007-08-28T14:28:00+09:00</published><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks-2-5-address-alignment.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h2&gt;2.5 I386平臺的邊界對齊(Align)&lt;/h2&gt;
&lt;p&gt;首先提問，既然I386上sizeof(int)==4、sizeof(char)==1，那麼如下結構(struct)A的sizeof是多少？&lt;/p&gt;
&lt;p&gt;struct A{int i;char c;};&lt;/p&gt;
&lt;p&gt;答案是sizeof(A)==8……1+5=8？&lt;/p&gt;
&lt;p&gt;呵呵，這就是I386上的邊界對齊問題。我們知道，I386上有整整4GB的地址空間，不過並不是每一個字節上都可以放置任何東西的。由於內存總線帶寬等等的技術原因，很多體系結構都要求內存中的變量被放置於某一個邊界的地址上。如果違反這個要求，重則導致停機出錯，輕則減慢運行速度。對於I386平臺而言，類型爲T的變量必須放置在sizeof(T)的整數倍的地址上，char可以隨便放置，short必須放在2的整數倍的地址上，int必須放在4的整數倍的地址上，double必須放在8的整數倍的地址上。如果違反邊界對齊要求 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h2&gt;2.5 I386平臺的邊界對齊(Align)&lt;/h2&gt;
&lt;p&gt;首先提問，既然I386上sizeof(int)==4、sizeof(char)==1，那麼如下結構(struct)A的sizeof是多少？&lt;/p&gt;
&lt;p&gt;struct A{int i;char c;};&lt;/p&gt;
&lt;p&gt;答案是sizeof(A)==8……1+5=8？&lt;/p&gt;
&lt;p&gt;呵呵，這就是I386上的邊界對齊問題。我們知道，I386上有整整4GB的地址空間，不過並不是每一個字節上都可以放置任何東西的。由於內存總線帶寬等等的技術原因，很多體系結構都要求內存中的變量被放置於某一個邊界的地址上。如果違反這個要求，重則導致停機出錯，輕則減慢運行速度。對於I386平臺而言，類型爲T的變量必須放置在sizeof(T)的整數倍的地址上，char可以隨便放置，short必須放在2的整數倍的地址上，int必須放在4的整數倍的地址上，double必須放在8的整數倍的地址上。如果違反邊界對齊要求，從內存中讀取數據必須進行兩次，然後將獨到的兩半數據拼接起來，這會嚴重影響效率。&lt;/p&gt;
&lt;p&gt;由於邊界對齊問題的要求，在計算struct的sizeof的時候，編譯器必須算入額外的字節填充，以保證每一個變量都能自然對齊。比如如下聲明的struct:&lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;實際上相當於聲明瞭這樣一個結構：&lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;char _filling1 [3];//三個字節填充，保證下一個int的對齊&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2；&lt;/p&gt;
&lt;p&gt;char _filling2 [3];//又三個字節填充&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;值得注意的是尾部的3個字節填充，這是爲了可以在一個數組中聲明WASTE變量，並且每一個都自然對齊。因爲有了這些填充，所以sizeof(WASTE)==12。這是一種浪費，因爲只要我們重新安排變量的聲明，就可以減少sizeof：&lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c1,c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;像這樣的安排，sizeof就減少到8，只有2個字節的額外填充。爲了與彙編代碼相兼容，C語言語法規定，編譯器無權擅自安排結構體內變量的佈局順序，必須從左向右逐一排列。所以，妥當安排成員順序以避免內存空間的浪費，就成了我們程序員的責任之一。一般的，總是將結構體的成員按照其sizeof從大到小排列，double在最前，char在最後，這樣總可以將結構的字節填充降至最小。&lt;/p&gt;
&lt;p&gt;C++繼承了C語言關於結構體佈局的規定，所以以上的佈局準則也適用於C++的class的成員變量。C++進一步擴展了佈局規定，同一訪問區段(private、public、protected)中的變量，編譯器無權重新排列，不過編譯器有權排列訪問區段的前後順序。基於這個規則，C++中有的程序員建議給每一個成員變量放在單獨區段，在每一個成員聲明之前都加上private:、public:、protected:標誌，這可以最大限度的利用編譯器的決策優勢。&lt;/p&gt;
&lt;p&gt;在棧中按順序分配的變量，其邊界也受到對齊要求的限制。與在結構中不同的是，棧中的變量還必須保證其後續變量無論是何種類型都可以自由對齊，所以在棧中的變量通常都有平臺相關的對齊最小值。在MSVC編譯器上，這個最小值可以由宏_INTSIZEOF(T)查詢：&lt;/p&gt;
&lt;p&gt;#define _INTSIZEOF(T) ( (sizeof(T) + sizeof(int) - 1) &amp;amp; ~(sizeof(int) -
1) )&lt;/p&gt;
&lt;p&gt;_INTSIZEOF(T)會將sizeof(T)進位到sizeof(int)的整數倍。&lt;/p&gt;
&lt;p&gt;由於在棧中分配變量使用_INTSIZEOF而不是sizeof，在棧上連續分配多個小變量(sizeof小於int的變量)會造成內存浪費，不如使用結構(struct)或數組。也就是說：&lt;/p&gt;
&lt;p&gt;char c1,c2,c3,c4;//使用16字節&lt;/p&gt;
&lt;p&gt;char c[4];//使用4字節&lt;/p&gt;
&lt;p&gt;當然，使用數組的方法在訪問數組變量(比如c[1])時有一次額外的指針運算和提領(dereference)操作，這會有執行效率的損失。這又是一種空間(內存佔用)vs時間(執行效率)的折中，需要程序員自己根據情況權衡利弊。&lt;/p&gt;
&lt;p&gt;sizeof的大小可能比我們預期的大，也可能比我們預期的小。對於空類：&lt;/p&gt;
&lt;p&gt;class Empty {};&lt;/p&gt;
&lt;p&gt;在通常情況下，sizeof(Empty)至少爲1。這是因爲C++語法規定，對於任何實體類型的兩個變量，都必須具有不同的地址。爲了符合語法要求，編譯器會給Empty加入1字節的填充。所以sizeof()的值不可能出現0的情況。可是對於以下的類聲明：&lt;/p&gt;
&lt;p&gt;class A:public Empty{vitual ~A(){}};&lt;/p&gt;
&lt;p&gt;sizeof(A)有可能是6，也有可能是5，也有可能是4！必不可少的四個字節是一個指向虛函數表的指針。一個可能有的字節是Empty的大小，這是是因爲編譯器在特定情況下會將Empty視作一個“空基類”，從而實施“空基類優化”，省掉那毫無作用的一字節填充。另一個字節是A的一字節填充，因爲從語法上講，A沒有成員聲明，理應有1字節填充，而從語義上講，編譯器給A的聲明加入了一個指向虛函數表的指針，從而A就不再是一個“空類”，是否實施這個優化，要看編譯器作者對語法措詞的理解。也就是說，sizeof也會出現4+1+1=4的情況。具體要看編譯器有沒有實施“空基類優化”和“含虛函數表的空類優化”。&lt;/p&gt;
&lt;p&gt;結構和類的空間中可能有填充的字節，這意味着填充字節中可能有數值，雖然這數值並不影響結構的邏輯狀態，但是它也可能不知不覺中影響到你。比如說，你手頭正好有一組依賴於底層硬件(比如多處理器)的函數，他們在操縱連續字節時比手動編碼要快很多，而你想充分利用這種硬件優勢：&lt;/p&gt;
&lt;p&gt;bool BitCompare(void* begin,void* end,void* another);&lt;/p&gt;
&lt;p&gt;這個函數將區間[begin,end)之間的字節與another開始的字節相比較，如果有一位不同就返回false，否則返回true。&lt;/p&gt;
&lt;p&gt;比如你想將這個函數用於你自己的類的operator==中，這樣可以利用硬件加快速度。不過你在動手前要充分考慮，你的class是否真的要比較每一位。如果在類的成員中存在編譯器填充的字節數，那麼應用以上的函數就是不正確的，因爲填充的字節中可以有不同的值。爲了保證你可以用Bitwise
Compare，你必須確保填充的字節中的值也是相同的。這不僅要求你在類的構造函數中初始化類的每一bit而不是每一個成員，也要求你在複製初始化和複製賦值函數中也同時保證bitwise
copy語義，而不是編譯器默認產生的memberwise語義。當然，你可能通過與BitCompare一同提供的BitCopy來完成這個艱鉅的任務。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.6 I386平臺C函數的可變參數表(Variable Arguments)</title><link href="//farseerfc.me/c-tricks-2-6-i386-variable-arguments.html" rel="alternate"></link><published>2007-08-28T14:28:00+09:00</published><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks-2-6-i386-variable-arguments.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h2&gt;2.6 I386平臺C函數的可變參數表(Variable Arguments)&lt;/h2&gt;
&lt;p&gt;基於前文(2.4節)分析，我們可以不通過函數簽名，直接通過指針運算，來得到函數的參數。由於參數的壓棧和彈出操作都由主調函數進行，所以被調函數對於參數的真實數量不需要知曉。因此，函數簽名中的變量聲明不是必需的。爲了支持這種參數使用形式，C語言提供可變參數表。可變參數表的語法形式是在參數表末尾添加三個句點形成的省略號“...”：&lt;/p&gt;
&lt;p&gt;void g(int a,char* c,...);&lt;/p&gt;
&lt;p&gt;省略號之前的逗號是可選的，並不影響詞法語法分析。上面的函數g可以接受2個或2個以上的參數，前兩個參數的類型固定，其後的參數類型未知，參數的個數也未知。爲了知道參數個數，我們必須通過其他方法，比如通過第一個參數傳遞：&lt;/p&gt;
&lt;p&gt;g(3,”Hello”,2,4,5);//調用g並傳遞5個參數，其中後3個爲可變參數。&lt;/p&gt;
&lt;p&gt;在函數的實現代碼中，可以通過2.4節敘述的 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h2&gt;2.6 I386平臺C函數的可變參數表(Variable Arguments)&lt;/h2&gt;
&lt;p&gt;基於前文(2.4節)分析，我們可以不通過函數簽名，直接通過指針運算，來得到函數的參數。由於參數的壓棧和彈出操作都由主調函數進行，所以被調函數對於參數的真實數量不需要知曉。因此，函數簽名中的變量聲明不是必需的。爲了支持這種參數使用形式，C語言提供可變參數表。可變參數表的語法形式是在參數表末尾添加三個句點形成的省略號“...”：&lt;/p&gt;
&lt;p&gt;void g(int a,char* c,...);&lt;/p&gt;
&lt;p&gt;省略號之前的逗號是可選的，並不影響詞法語法分析。上面的函數g可以接受2個或2個以上的參數，前兩個參數的類型固定，其後的參數類型未知，參數的個數也未知。爲了知道參數個數，我們必須通過其他方法，比如通過第一個參數傳遞：&lt;/p&gt;
&lt;p&gt;g(3,”Hello”,2,4,5);//調用g並傳遞5個參數，其中後3個爲可變參數。&lt;/p&gt;
&lt;p&gt;在函數的實現代碼中，可以通過2.4節敘述的，參數在棧中的排列順序，來訪問位於可變參數表的參數。比如:&lt;/p&gt;
&lt;p&gt;void g(int a,char* c...){&lt;/p&gt;
&lt;p&gt;void *pc=&amp;amp;c;int* pi=static_cast&amp;lt;int*&amp;gt;(pc)+1;//將pi指向首個可變參數&lt;/p&gt;
&lt;p&gt;for(int i=0;i&amp;lt;a;i++)std::cout&amp;lt;&amp;lt;pi[i]&amp;lt;&amp;lt;” ”；&lt;/p&gt;
&lt;p&gt;std::cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;std::endl;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;我們甚至可以讓一個函數的所有參數都是可變參數，只要有辦法獲知參數的數量即可。比如，我們約定，在傳遞給addAll的參數都是int，並且最後一個以0結束：&lt;/p&gt;
&lt;p&gt;int addAll(...);&lt;/p&gt;
&lt;p&gt;int a=f(1,4,2,5,7,0);&lt;/p&gt;
&lt;p&gt;那麼addAll可以這樣實現：&lt;/p&gt;
&lt;p&gt;int addAll(...){&lt;/p&gt;
&lt;p&gt;int sum=0;int *p=&amp;amp;sum; //p指向第一個局部變量&lt;/p&gt;
&lt;p&gt;p+=3; //跳過sum，ebp，eip，現在p指向第一個參數&lt;/p&gt;
&lt;p&gt;for(;*p;++p) //如果p不指向0就繼續循環&lt;/p&gt;
&lt;p&gt;sum+=*p;&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;可變參數表的最廣泛應用是C的標準庫函數中的格式化輸入輸出：printf和scanf。&lt;/p&gt;
&lt;p&gt;void printf(char *c,...);&lt;/p&gt;
&lt;p&gt;void scanf(char *c,...);&lt;/p&gt;
&lt;p&gt;兩者都通過它的首個參數指出後續參數表中的參數類型和參數數量。&lt;/p&gt;
&lt;p&gt;如果可變參數表中的參數類型不一樣，那麼操縱可變參數表就需要複雜的指針運算，並且還要時刻注意邊界對齊(align)問題，非常令人頭痛。好在C標準庫提供了用於操縱可變參數表的宏(macro)和結構(struct)，他們被定義在庫文件stdarg.h中:&lt;/p&gt;
&lt;p&gt;typedef struct {char *p;int offset;} va_list;&lt;/p&gt;
&lt;p&gt;#define va_start(valist,arg)&lt;/p&gt;
&lt;p&gt;#define va_arg(valist,type)&lt;/p&gt;
&lt;p&gt;#define va_end(valist)&lt;/p&gt;
&lt;p&gt;其中結構va_list用於指示參數在棧中的位置，宏va_start接受一個va_list和函數的可變參數表之前的參數，通過第一個參數初始化va_list中的相應數據，因此要使用stdarg.h中的宏，你的可變參數表的函數必須至少有一個具名參數。va_arg返回下一個類型爲type的參數，va_end結束可變參數表的使用。還是以上文的addAll爲例，這次寫出它的使用標準宏的版本：&lt;/p&gt;
&lt;p&gt;int addAll(int i,...)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;va_list vl; //定義一個va_list結構&lt;/p&gt;
&lt;p&gt;va_start(vl,i); //用省略號之前的參數初始化vl&lt;/p&gt;
&lt;p&gt;if(i=0)return 0; //如果第一個參數就是0，返回&lt;/p&gt;
&lt;p&gt;int sum=i; //將第一個參數加入sum&lt;/p&gt;
&lt;p&gt;for(;;){&lt;/p&gt;
&lt;p&gt;i=va_arg(vl,int); //取得下一個參數，類型是sum&lt;/p&gt;
&lt;p&gt;if(i==0)break; //如果參數是0，跳出循環&lt;/p&gt;
&lt;p&gt;sum+=i;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;va_end(vl);&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;可以看出，如果參數類型一致，使用標準庫要多些幾行代碼。不過如果參數類型不一致或者未知(printf的情況)，使用標準庫就要方便很多，因爲我們很難猜出編譯器處置邊界對齊(align)等彙編代碼的細節。使用標準庫的代碼是可以移植的，而使用上文所述的其它方法操縱可變參數表都是不可移植的，僅限於在I386平臺上使用。&lt;/p&gt;
&lt;p&gt;縱使可變參數表有使用上的便利性，它的缺陷也有很多，不可移植性和平臺依賴性只是其一，最大的問題在於它的類型不安全性。使用可變參數表就意味着編譯器不對參數作任何類型檢查，這在C中算是一言難盡的歷史遺留問題，在C++中就意味着惡魔reinterpret_cast被你喚醒。C的可變參數表是C++代碼錯誤頻發的根源之一，以至於C++標準將可變參數表列爲即將被廢除的C語言遺留特性。C++語法中的許多新特性，比如重載函數、默認參數值、模板，都可以一定程度上替代可變參數表，並且比可變參數表更加安全。&lt;/p&gt;
&lt;p&gt;可變參數表在C++中惟一值得嘉獎的貢獻，是在模板元編程(TMP)的SFINAE技術中利用可變參數表製作最差匹配重載。根據C++標準中有關函數重載決議的規則，具有可變參數表的函數總是最差匹配，編譯器在被逼無奈走頭無路時纔會選擇可變參數表。利用這一點，我們可以精心製作重載函數來提取類型信息。比如，要判斷一個通過模板傳遞來的類型是不是int：&lt;/p&gt;
&lt;p&gt;long isIntImp(int);&lt;/p&gt;
&lt;p&gt;char isIntImp(...);&lt;/p&gt;
&lt;p&gt;template&amp;lt;typename T&amp;gt;&lt;/p&gt;
&lt;p&gt;struct isInt&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;enum{value=sizeof(isIntImp(T()))==sizeof(long);}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;然後，在一個具有模板參數T的函數中，我們就可以寫&lt;/p&gt;
&lt;p&gt;if(isInt&amp;lt;T&amp;gt;::value)//...&lt;/p&gt;
&lt;p&gt;在這個(不怎麼精緻的)例子中，如果T是int，那麼isIntImp的第一個重載版本就會被選中，返回值類型就是long，這樣value就爲1。否則，編譯器只能選中第二個具有可變參數表的重載版本，返回值類型成爲char，這樣value就爲0。把它說得再明白一些，上文的代碼所表達的意思是：如果類型T是int，那它就是int，否則它就不是int，呵呵簡單吧。這種通過重載決議規則來提取類型信息的技術，在模板元編程中被稱作SFINAE，它和其它模板元編程技術被廣泛運用於STL、Boost等模板庫的開發實現之中。&lt;/p&gt;
&lt;p&gt;值得注意的是，在上文SFINAE的運用中，isIntImp並沒有出現定義而只提供了聲明，因爲我們並沒有實際調用isIntImp函數，而只是讓它參與重載決議並用sizeof判斷其返回值類型。這是C++的一個設計準則的完美體現：不需要的東西可以不出現。由於這一準則，我們避免了在C++中調用具有可變參數表的函數這一危險舉動，而僅僅利用了可變參數表在語法分析過程中的特殊地位，這種對於危險語言特性的巧妙利用是善意而無害的。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.7 I386平臺的其它函數調用模型</title><link href="//farseerfc.me/c-tricks-2-7-i386-calling-conventions.html" rel="alternate"></link><published>2007-08-28T14:28:00+09:00</published><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-28:/c-tricks-2-7-i386-calling-conventions.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.7 I386平臺的其它函數調用模型&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;上文介紹的只是I386平臺上C函數調用的標準模型，被稱作__cdecl。事實上，Microsoft Visual C++編譯器還支持其它一些函數調用模型，所有調用模型名稱皆以雙下劃線開頭，下面列出所有函數調用模型的異同：&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="cdecl"&gt;
&lt;h3&gt;1 __cdecl&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：主調函數(caller)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__cdecl明確地指出函數使用C函數調用模型，這是默認的調用模型。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stdcall"&gt;
&lt;h3&gt;2 __stdcall&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__stdcall是微軟所謂的標準調用模型。可惜的是它與__cdecl不兼容。幾乎所有的Win32API函數使用這種函數調用模型，希望在DLL之間，或者在程序和WinNT操作系統之間傳遞函數指針的函數也應該使用這種模型。與__cdecl模型的不同之處在於，__stdcall模型下由被調函數恢復堆棧。主調函數在call語句之後，不需要再加上add語句。而被調函數的ret語句則被添加一個參數，代表函數參數堆棧的長度。因此，被調函數需要明確的知曉函數參數的數量和類型，所以在__stdcall模型下不支持可變參數表，所有參數必須寫明 …&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.7 I386平臺的其它函數調用模型&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;上文介紹的只是I386平臺上C函數調用的標準模型，被稱作__cdecl。事實上，Microsoft Visual C++編譯器還支持其它一些函數調用模型，所有調用模型名稱皆以雙下劃線開頭，下面列出所有函數調用模型的異同：&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="cdecl"&gt;
&lt;h3&gt;1 __cdecl&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：主調函數(caller)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__cdecl明確地指出函數使用C函數調用模型，這是默認的調用模型。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stdcall"&gt;
&lt;h3&gt;2 __stdcall&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__stdcall是微軟所謂的標準調用模型。可惜的是它與__cdecl不兼容。幾乎所有的Win32API函數使用這種函數調用模型，希望在DLL之間，或者在程序和WinNT操作系統之間傳遞函數指針的函數也應該使用這種模型。與__cdecl模型的不同之處在於，__stdcall模型下由被調函數恢復堆棧。主調函數在call語句之後，不需要再加上add語句。而被調函數的ret語句則被添加一個參數，代表函數參數堆棧的長度。因此，被調函數需要明確的知曉函數參數的數量和類型，所以在__stdcall模型下不支持可變參數表，所有參數必須寫明。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="thiscall"&gt;
&lt;h3&gt;3 __thiscall&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)，this用ecx傳遞。&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__thiscall是VC編譯器中類的非靜態成員函數(non-static member functon)的默認調用模型。但是如果此成員函數有可變參數表，VC編譯器會使用__cdecl。和__stdcall一樣，__thiscall由被調函數恢復堆棧。比較獨特的是__thiscall會通過ecx寄存器傳遞成員函數的this指針，而__cdecl下this指針是通過在參數表最前面增加一個函數參數來傳遞的。__thiscall是VC編譯器對this指針的使用的一種優化，大大提高了面向對象程序的效率。在VC2003及之前的編譯器上__thiscall不是一個關鍵字，不能被顯式指定。但可以給成員函數顯式指定__cdecl來避免使用__thiscall。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="fastcall"&gt;
&lt;h3&gt;4 __fastcall&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)，前兩個32位函數參數放入ecx和edx中&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;快速函數調用模型，將前兩個32位函數參數放入ecx和edx中，其餘參數再逆序壓棧。使用的是和__thiscall類似的優化技術，加快函數調用，適合運用在小型inline函數上。同樣使用__stdcall形式的被調函數恢復堆棧，所以不支持可變參數表。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pascal"&gt;
&lt;h3&gt;5 __pascal&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：正序(從左至右)&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;過程式編程語言Pascal所使用的函數調用模型，由此得名。也是16位版本的Windows使用的API模型，過時的模型，現在已經廢棄且禁止使用。你會看到有些書本仍會不時提到它，所以需要注意。__pascal是正序壓棧，這與大部分I386函數模型都不相同。與__stdcall一樣，由被調者恢復堆棧，不支持可變參數表。歷史上曾有過的別名PASCAL、pascal、_pascal(單下劃線)，現在都改成了__stdcall的別名，與__pascal(雙下劃線)不同。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;6 其它函數調用模型，以及模型別名。&lt;/h3&gt;
&lt;p&gt;__syscall：操作系統內部使用的函數調用模型，由用戶模式向核心模式跳轉時使用的模型。由於用戶模式和核心模式使用不同的棧，所以沒辦法使用棧來傳遞參數，所有參數通過寄存器傳遞，這限制了參數的數量。用戶模式編程中不允許使用。&lt;/p&gt;
&lt;p&gt;__fortran：數學運算語言fortran使用的函數模型，由此得名。在C中調用由fortran編譯的函數時使用。&lt;/p&gt;
&lt;p&gt;__clrcall：微軟.Net框架使用的函數模型，託管(Managed)C++默認使用，也可以從非託管代碼調用託管函數時使用。參數在託管棧上正序(從左至右)壓棧，不使用普通棧。&lt;/p&gt;
&lt;p&gt;CALLBACK、PASCAL、WINAPI、APIENTRY、APIPRIVATE：I386平臺上是__stdcall的別名&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;WINAPIV：I386平臺上是__cdecl的別名&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;7 函數調用模型的指定&lt;/h3&gt;
&lt;p&gt;函數調用模型的指定方式和inline關鍵字的指定方式相同，事實上，inline可以被看作是C++語言內建的一種函數調用模型。唯一不同的是，聲明函數指針時，也要指明函數調用模型，而inline的指針是不能指明的，根本不存在指向inline函數的指針。比如：&lt;/p&gt;
&lt;p&gt;int CALLBACK GetVersion();&lt;/p&gt;
&lt;p&gt;int (CALLBACK * pf)()=GetVersion;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 2.1 X86概述</title><link href="//farseerfc.me/c-tricks-2-1-x86-architecture.html" rel="alternate"></link><published>2007-08-27T16:33:00+09:00</published><updated>2007-08-27T16:33:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-27:/c-tricks-2-1-x86-architecture.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="x86"&gt;
&lt;h2&gt;2.1   X86概述&lt;/h2&gt;
&lt;p&gt;所謂X86體系結構，是指以Intel
8086芯片爲首的芯片所沿襲的CPU結構，一些文檔中又被稱作IA32體系結構。包括的芯片有但不限於:Intel
8086至
80486，奔騰(Pentium)系列處理器1至4，賽揚系列處理器，酷睿系列處理器，以及AMD的相應型號產品。X86體系結構在早期屬於16位處理器，自80386之後擴展爲32位處理器，所以一些文檔中又把80386之後的32位處理器體系稱作I386。自Pentium4後期，AMD的Athlon64開始，I386被進一步擴充爲64位處理器，含有64位尋址能力的X86體系結構被稱作X86-64或IA32-64。總之，市售的個人電腦用CPU，除蘋果的Macintosh之外，全部採用X86體系結構芯片。&lt;/p&gt;
&lt;p&gt;在X86早期，16位的尋址能力只支持64KB(2^16=64K)內存，這顯然是不夠的。Intel採用分段尋址的方法，用4位段位+16位偏移量，提供了總共1MB(2^20=1M)的尋址能力。所以在X86的16位編程中，有兩種指針類型 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="x86"&gt;
&lt;h2&gt;2.1   X86概述&lt;/h2&gt;
&lt;p&gt;所謂X86體系結構，是指以Intel
8086芯片爲首的芯片所沿襲的CPU結構，一些文檔中又被稱作IA32體系結構。包括的芯片有但不限於:Intel
8086至
80486，奔騰(Pentium)系列處理器1至4，賽揚系列處理器，酷睿系列處理器，以及AMD的相應型號產品。X86體系結構在早期屬於16位處理器，自80386之後擴展爲32位處理器，所以一些文檔中又把80386之後的32位處理器體系稱作I386。自Pentium4後期，AMD的Athlon64開始，I386被進一步擴充爲64位處理器，含有64位尋址能力的X86體系結構被稱作X86-64或IA32-64。總之，市售的個人電腦用CPU，除蘋果的Macintosh之外，全部採用X86體系結構芯片。&lt;/p&gt;
&lt;p&gt;在X86早期，16位的尋址能力只支持64KB(2^16=64K)內存，這顯然是不夠的。Intel採用分段尋址的方法，用4位段位+16位偏移量，提供了總共1MB(2^20=1M)的尋址能力。所以在X86的16位編程中，有兩種指針類型：長指針(lp,long
pointer)和短指針(sp,short
pointer)，長指針(20位)提供整個內存空間尋址能力，短指針(16位)僅支持同一段中的尋址。在“古代”DOS及Win3.x編程過程中，兩種類型的指針，以及總共1MB的內存大小，常常把程序員們折騰得焦頭爛額。&lt;/p&gt;
&lt;p&gt;自I386之後，CPU纔開始提供32位的尋址能力。有了整整4GB(2^32=4G)的尋址空間，所有指針統一爲長指針(32位)。時至今日，我們仍可以看到微軟文檔中指針變量的lp前綴。由於內存管理的需要，分段機制被保留下來，但這一次不是因爲地址空間太小，而是因爲地址空間遠大於實際內存容量，從而採用了虛擬內存機制。&lt;/p&gt;
&lt;p&gt;在從16位結構向32位結構轉變的過程中，由於向下兼容的歷史原因，曾一度長時間出現硬件32位(I386)、軟件16位(Win3.x)的情況。同樣也是爲了兼容16位軟件，Win9x操作系統(Win95、Win98、WinME)保留了16位代碼和32位代碼。混合代碼的設計使得Win9x及其混亂和不穩定。直到完全32位內核的操作系統WinNT(以及構建於其上的Win2000，WinXP，Win2003)的出現，X86平臺上內存佈局混亂的局面才得以改善。有了從16位至32位移植的經驗和準備，現今的從32位到64位的操作系統移植顯得平穩順利很多。WinXP和WinVista系統都同時發佈了32位版本和64位版本，並且其x86-64系統都實現了對32位軟件的無縫銜接支持。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 1.2 逗號運算符(,)、邏輯運算符(&amp;&amp;,||)與運算符重載的陷阱</title><link href="//farseerfc.me/c-tricks-1-2-trap-in-comma-logical-operator.html" rel="alternate"></link><published>2007-08-22T18:06:00+09:00</published><updated>2007-08-22T18:06:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-22:/c-tricks-1-2-trap-in-comma-logical-operator.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.2   逗號運算符(,)、邏輯運算符(&amp;amp;&amp;amp;,||)與運算符重載的陷阱&lt;/h2&gt;
&lt;p&gt;很多人甚至不知道逗號(,)也是個C++運算符。與語法上要求出現的逗號(比如分隔函數參數的逗號)不同的是，出現在表達式中的逗號運算符在語義上表示多個表達式操作的連續執行，類似於分隔多語句的分號。比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt;(&lt;strong&gt;int&lt;/strong&gt;i=0,j=9;i&amp;lt;10;++i&lt;strong&gt;,&lt;/strong&gt;--j)std::cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;”+”&amp;lt;&amp;lt;j&amp;lt;&amp;lt;”=9\n”;&lt;/p&gt;
&lt;p&gt;在這句語句中，出現了兩個逗號，其中前者是語法上用來分隔聲明的變量的，並非逗號運算符，而後者則是一個逗號運算符。根據C++標準，逗號運算符的執行順序爲從左到右依次執行，返回最後一個子表達式的結果。由於只有最後一個表達式返回結果，所以對於一個語義正常的逗號表達式而言，前幾個子表達式必須具有副作用。同時，從語言的定義中也可以看出，逗號表達式對求值的順序有嚴格要求 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.2   逗號運算符(,)、邏輯運算符(&amp;amp;&amp;amp;,||)與運算符重載的陷阱&lt;/h2&gt;
&lt;p&gt;很多人甚至不知道逗號(,)也是個C++運算符。與語法上要求出現的逗號(比如分隔函數參數的逗號)不同的是，出現在表達式中的逗號運算符在語義上表示多個表達式操作的連續執行，類似於分隔多語句的分號。比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt;(&lt;strong&gt;int&lt;/strong&gt;i=0,j=9;i&amp;lt;10;++i&lt;strong&gt;,&lt;/strong&gt;--j)std::cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;”+”&amp;lt;&amp;lt;j&amp;lt;&amp;lt;”=9\n”;&lt;/p&gt;
&lt;p&gt;在這句語句中，出現了兩個逗號，其中前者是語法上用來分隔聲明的變量的，並非逗號運算符，而後者則是一個逗號運算符。根據C++標準，逗號運算符的執行順序爲從左到右依次執行，返回最後一個子表達式的結果。由於只有最後一個表達式返回結果，所以對於一個語義正常的逗號表達式而言，前幾個子表達式必須具有副作用。同時，從語言的定義中也可以看出，逗號表達式對求值的順序有嚴格要求。&lt;/p&gt;
&lt;p&gt;對求值順序有要求的，除了逗號表達式和條件表達式(參見1.1)，在C++中還有邏輯運算符(&amp;amp;&amp;amp;和||)。邏輯運算相較於數學運算和位運算而言，有個顯著的不同點：邏輯運算在計算到一半時，就有可能已經得到結果，這樣繼續運算另一半就不是必需的。對於A&amp;amp;&amp;amp;B，如果A=false，那麼無論B爲何值，整個的結果都是false；同樣的A||B，如果A=true，那麼不考慮B，結果一定是true。&lt;/p&gt;
&lt;p&gt;C++標準規定，如果邏輯運算到一半(算出A)時，就已經可以確定運算的結果，那麼就不運算剩下的另一半(B)。這種執行語義被稱作“短路”。在其它一些編程語言中，短路語義是可以選擇的：在Ada裏非短路的邏輯運算符爲and和or，短路的邏輯運算符爲and_then和or_else。但是在C++中，邏輯運算符的短路語義是語法上強制的，我們沒有非短路版本的運算符。如果確實需要非短路語義，我們總是可以通過增加一個bool中間變量加以解決。有時，短路對於保證正確執行是必須的，比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char&lt;/strong&gt;*p=getString();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(p&lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;*p)std::cout&amp;lt;&amp;lt;p;&lt;/p&gt;
&lt;p&gt;這段代碼在得到了一個字符串後，在字符串不爲空時輸出它。在C++中判斷一個字符串不爲空需要兩個步驟：判斷指針是否爲0，以及指針不爲0時判斷指針指向的內容是否爲’’。就像條件表達式中討論到的(參見1.1)，在p爲空時提領p是個極其危險的操作。邏輯運算符的短路語義則避免了這種危險。&lt;/p&gt;
&lt;p&gt;以上對逗號運算符與邏輯運算符的討論，僅限於C++標準所定義的運算符語義。爲什麼這樣說呢？這是因爲在C++中，運算符的語義是可以由程序員自行定義的，這種機制叫做運算符重載(operator
overload)。運算符重載可以將人們熟悉的運算符表達式轉換成函數調用，使編程靈活而直觀，是個方便的語言特性。不過有時運算符重載也會使人困擾，那就是當運算符重載遇到求值順序問題時。&lt;/p&gt;
&lt;p&gt;C++中，並不是所有合法運算符都可以被合法地重載。條件運算符雖然對求值順序有要求，但它並不在可重載運算符之列，所以運算符重載機制對它沒有影響。問題在於，逗號運算符和邏輯運算符都可以被合法地重載：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class&lt;/strong&gt; BadThing{/* Some Bad and Stupid Thing*/};&lt;/p&gt;
&lt;p&gt;BadThing&amp;amp; &lt;strong&gt;operator&lt;/strong&gt;,(BadThing&amp;amp;, BadThing&amp;amp;);//重載了逗號運算符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bool&lt;/strong&gt; &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(BadThing&amp;amp;, BadThing&amp;amp;);//重載了&amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;BadThing b1,b2;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(b1&amp;amp;&amp;amp;b2)b1,b2;//被替換成如下形式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(b1,b2))&lt;strong&gt;operator&lt;/strong&gt;,(b1,b2);&lt;/p&gt;
&lt;p&gt;可以看到，重載了運算符之後，對運算符的使用被替換爲相應的函數調用形式。因此，舊有的運算符的執行順序不再適用，取而代之的是函數參數的壓棧順序。&lt;/p&gt;
&lt;p&gt;根據C++標準規定，任何參數必須在進入函數之前壓棧，所以在進入&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;之前，b1、b2就會被求值，這裏不再有短路規則，任何依賴於短路語義的不知不覺間操作BadThing的代碼(可能通過模板)都會混亂。&lt;/p&gt;
&lt;p&gt;短路語義只是一個方面，更重要的在於壓棧順序。鑑於執行效率和舊代碼兼容性等細節問題，C++標準在壓棧順序上給編譯器的開發者留有很大自主性。標準的說辭是，編譯器可能以任何它覺得方便的順序將參數壓棧，從左到右，從右到左，甚至從中間到兩邊，在這一點上我們不能安全地做任何假設。在上面的例子中，編譯器生成的代碼可能先計算b1再計算b2，也可能是相反的順序。再看看編譯器的實際情況，在我試過的所有基於X86體系結構的編譯器中，參數都是以逆向壓棧，即從右到左，有悖於大多數人的閱讀習慣和直覺(別說你是來自伊斯蘭的……)。&lt;/p&gt;
&lt;p&gt;在C時代使用函數調用時，壓棧順序並不是什麼大問題，畢竟大多數人會在函數調用的邊界稍稍小心一些。但是到了C++中，事情變得有些複雜，因爲簡單如a+b的使用，就有可能被運算符重載機制替換爲函數調用。更何況有模板參與之後，我們寫代碼時不能確定對象的真實類型，也就無法預知一個運算符是否真的被重載過，唯一穩妥的方法是，假定任何有可能被重載的運算符的使用都是函數調用。&lt;/p&gt;
&lt;blockquote&gt;
&amp;lt;p style="margin:0;"&amp;gt;&lt;/blockquote&gt;
&lt;p&gt;回到上文的示例中，由於,和&amp;amp;&amp;amp;都被替換爲函數調用，程序的執行順序將成爲壓棧順序，在X86上很有可能是從右到左，與標準定義的運算符的順序正好相反。逗號運算符原本就含有“先…後…”的語義，這種顛倒的執行順序勢必造成程序和程序員的混亂。以我的經驗而言，含有&lt;strong&gt;operator&lt;/strong&gt;,的類，完全沒有辦法和STL或者iostream相互協作，反而會導致巨量的錯誤報告(什麼叫巨量的錯誤報告有概念麼？如果沒有，那說明你還沒玩過範式編程(GP,
Generic
Programming)。去玩玩GP吧，看看你的編譯器對巨量的定義。在我手頭，針對3.5KB的代碼文件傾瀉出3.8&lt;strong&gt;MB&lt;/strong&gt;的錯誤信息的編譯器不在少數……)。有鑑於此，我的結論是，除非你有充足的依據支持你這麼做(比如你的粗暴上司的鍵盤上只剩下逗號能用)，並且你清楚的瞭解這麼做的後果的嚴重性(比如至少要看過此文)，否則我奉勸你，永遠不要碰&lt;strong&gt;operator&lt;/strong&gt;,、&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;以及&lt;strong&gt;operator&lt;/strong&gt;||！&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>C++ Tricks 1.1 條件運算符(?:)</title><link href="//farseerfc.me/c-tricks-1-1-conditional-operator.html" rel="alternate"></link><published>2007-08-22T18:05:00+09:00</published><updated>2007-08-22T18:05:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2007-08-22:/c-tricks-1-1-conditional-operator.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.1   條件運算符(?:)&lt;/h2&gt;
&lt;p&gt;條件運算符(?:)是C++中唯一的三目運算符(trinary
operator)，用於在表達式中作條件判斷，通常可以替換if語句，與Visual
Basic中的iif函數、Excel中的if函數有同樣的作用。語法形式如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;condition&lt;/em&gt; ? &lt;em&gt;true_value&lt;/em&gt; : &lt;em&gt;false_value&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;em&gt;condition
*條件是任何可以轉換爲bool類型的表達式，包括但不僅限於**bool*&lt;/em&gt;、&lt;strong&gt;int&lt;/strong&gt;、指針。與&lt;strong&gt;if&lt;/strong&gt;和&lt;strong&gt;while&lt;/strong&gt;的條件部分稍顯不同的是，這裏不能定義變量，否則會導致語法錯誤。&lt;/p&gt;
&lt;p&gt;另外，條件語句會切實地控制執行流程，而不僅僅是控制返回值。也就是說，兩個返回值表達式中永遠只有一個會被求值，在表達式的執行順序很重要時，這點尤爲值得注意。比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=pi …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.1   條件運算符(?:)&lt;/h2&gt;
&lt;p&gt;條件運算符(?:)是C++中唯一的三目運算符(trinary
operator)，用於在表達式中作條件判斷，通常可以替換if語句，與Visual
Basic中的iif函數、Excel中的if函數有同樣的作用。語法形式如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;condition&lt;/em&gt; ? &lt;em&gt;true_value&lt;/em&gt; : &lt;em&gt;false_value&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;em&gt;condition
*條件是任何可以轉換爲bool類型的表達式，包括但不僅限於**bool*&lt;/em&gt;、&lt;strong&gt;int&lt;/strong&gt;、指針。與&lt;strong&gt;if&lt;/strong&gt;和&lt;strong&gt;while&lt;/strong&gt;的條件部分稍顯不同的是，這裏不能定義變量，否則會導致語法錯誤。&lt;/p&gt;
&lt;p&gt;另外，條件語句會切實地控制執行流程，而不僅僅是控制返回值。也就是說，兩個返回值表達式中永遠只有一個會被求值，在表達式的執行順序很重要時，這點尤爲值得注意。比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=pi&lt;strong&gt;?&lt;/strong&gt;*pi&lt;strong&gt;:&lt;/strong&gt;0;&lt;/p&gt;
&lt;p&gt;這裏，只有當pi的值不爲0時，它纔會被提領(dereference)。這種語義保證了程序的正確性，因爲提領一個空指針將導致致命的運行期錯誤(通常是非法操作的警告)。同時，正因爲條件運算符控制運算流程的特點，使得它不能用類似iif的普通函數來模擬：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; iif(&lt;strong&gt;int&lt;/strong&gt; con,&lt;strong&gt;int&lt;/strong&gt; t,&lt;strong&gt;int&lt;/strong&gt;f){&lt;strong&gt;if&lt;/strong&gt;(c)&lt;strong&gt;return&lt;/strong&gt; t;&lt;strong&gt;return&lt;/strong&gt; f;}//試圖模擬?:&lt;/p&gt;
&lt;p&gt;…//in some function&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=iif(pi,*pi,0);//Error!&lt;/p&gt;
&lt;p&gt;這段代碼會導致上文提到的致命運行期錯誤。C/C++標準規定，參數在被傳遞給函數之前求值，因此無論pi爲何值，都會被提領。又因爲函數傳回一個空指針的情況比較少見，所以這樣的錯誤在調試時很難被發現，一旦發生又勢必造成重大災難。這樣的代碼在實踐中應儘量避免。&lt;/p&gt;
&lt;p&gt;有時，條件運算符控制流程的特點會不知不覺影響我們的代碼。在C時代，最大值MAX通常用宏實現：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#define&lt;/strong&gt;MAX(a,b) ((a)&amp;gt;(b)&lt;strong&gt;?&lt;/strong&gt;(a)&lt;strong&gt;:&lt;/strong&gt;(b))&lt;/p&gt;
&lt;p&gt;需要用額外的括號將宏參數和宏本體保護起來，以免運算符優先級擾亂邏輯，這是宏醜陋的特點之一，這裏暫且不提。矛盾在於，用具有副作用的表達式調用宏時，會出現問題：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=5,j=6;//…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=MAX(++i,++j);&lt;/p&gt;
&lt;p&gt;代碼的作者原意顯然是想先將i,j分別遞增，再將其中較大的一個賦給a。執行這段代碼，當i=5,j=6時，a=8，知道爲什麼嗎？通過宏展開，賦值語句成這樣：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=(++i)&amp;gt;(++j)&lt;strong&gt;?&lt;/strong&gt;(++i)&lt;strong&gt;:&lt;/strong&gt;(++j);//刪除了多餘括號&lt;/p&gt;
&lt;p&gt;在判斷之前，i、j被分別自增一次，然後捨棄:之前的部分，j又被自增一次。執行之後，i=6,j=8。&lt;/p&gt;
&lt;p&gt;MAX的更正確更安全的實現，是利用模板將類型參數化。STL標準算法中就有一個這樣的工具級模版函數std::max。&lt;/p&gt;
&lt;p&gt;條件運算符是表達式而不是語句，這使得它可以出現在任何需要表達式的地方，這擴大了它的適用範圍。在那些語法上只能出現表達式而不能出現語句的地方（比如變量初始化），條件運算符有着不可替代的作用。&lt;/p&gt;
&lt;p&gt;條件運算符優於&lt;strong&gt;if&lt;/strong&gt;語句的另一個場合是“模板元編程”(TMP, Template
MetaProgramming)。在TMP這個古怪奇異的編譯期運算編程技術中，一切舊有的技術和法則被全線擊破，我們所能仰仗的工具，只有模板特化(Specialization)、&lt;strong&gt;typedef&lt;/strong&gt;s、函數聲明(無法調用它們)、以及編譯期常量運算。已經有人很深入地論證過，僅有以上這些，就已經形成了一個“圖靈完善”的計算機語言。我們可以用模板特化技術，來模擬條件分支，循環迭代等一系列複雜的語言結構。由於可以參與編譯期常量運算，條件運算符在TMP世界中很自然地扮演起重要角色。&lt;/p&gt;
&lt;p&gt;比如，給與類型T的一個變量t，我們想聲明一個緩衝區存放t和一個int，緩衝區的大小不小於sizeof(T)也不小於sizeif(int)，我們可以這樣寫：&lt;/p&gt;
&lt;p&gt;char buffer[sizeof(T)&amp;gt;sizeof(int)? sizeof(T): sizeof(int)];&lt;/p&gt;
&lt;p&gt;我們不能用一個if語句替換這個運算：&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;if(sizeof(T)&amp;gt;sizeof(int))i=sizeof(T);&lt;/p&gt;
&lt;p&gt;else i=sizeof(int);&lt;/p&gt;
&lt;p&gt;char buffer[i];//語法錯誤!&lt;/p&gt;
&lt;p&gt;原因在於數組聲明中的下標必須是一個編譯期常量，而不是一個運行期的值，條件表達式的運算可以在編譯期進行，if語句就只能在執行期執行。&lt;/p&gt;
&lt;/div&gt;
</content><category term="import"></category><category term="C++"></category></entry><entry><title>填補信仰、喚醒良知</title><link href="//farseerfc.me/filling-believings-calling-conscience.html" rel="alternate"></link><published>2006-08-07T21:36:00+09:00</published><updated>2006-08-07T21:36:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.me,2006-08-07:/filling-believings-calling-conscience.html</id><summary type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;填補信仰、喚醒良知&lt;/p&gt;
&lt;p&gt;我們聽盡了呼籲與號召，對於良知，我不必譴責喪失它的國人，不必盛讚良知的美好。我只想討論，喪失了良知的原因——空缺的信仰。&lt;/p&gt;
&lt;p&gt;一、空缺信仰喪失良知&lt;/p&gt;
&lt;p&gt;現代的國人缺少信仰，以至於喪失良知。曾幾何時，中華民族由良好的信仰凝聚而成。三皇五帝時，族民們以炎黃爲信仰；春秋戰國時，士大夫之族以周制禮樂爲信仰；漢代以後，百姓延習孔孟之說、老聃之道，以儒家學說爲信仰；自大唐起，以佛教爲首的現代宗教紛紛傳入中原，人民開始以它們作爲信仰。&lt;/p&gt;
&lt;p&gt;直至鴉片戰爭、五四運動，西方文化入侵中華，國人開始拋棄國學，轉而去研究科學；文化大革命，十年文化浩劫，人們批判舊的信仰，卻沒有合適的新的信仰前來填補。從此，國人的信仰出現空缺，國人的良知也被一塊塊蠶食殆盡。&lt;/p&gt;
&lt;p&gt;二、信仰、科學、迷信&lt;/p&gt;
&lt;p&gt;在許多國人的心目中，信仰就等於迷信。從小到大的教育告訴我們 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;填補信仰、喚醒良知&lt;/p&gt;
&lt;p&gt;我們聽盡了呼籲與號召，對於良知，我不必譴責喪失它的國人，不必盛讚良知的美好。我只想討論，喪失了良知的原因——空缺的信仰。&lt;/p&gt;
&lt;p&gt;一、空缺信仰喪失良知&lt;/p&gt;
&lt;p&gt;現代的國人缺少信仰，以至於喪失良知。曾幾何時，中華民族由良好的信仰凝聚而成。三皇五帝時，族民們以炎黃爲信仰；春秋戰國時，士大夫之族以周制禮樂爲信仰；漢代以後，百姓延習孔孟之說、老聃之道，以儒家學說爲信仰；自大唐起，以佛教爲首的現代宗教紛紛傳入中原，人民開始以它們作爲信仰。&lt;/p&gt;
&lt;p&gt;直至鴉片戰爭、五四運動，西方文化入侵中華，國人開始拋棄國學，轉而去研究科學；文化大革命，十年文化浩劫，人們批判舊的信仰，卻沒有合適的新的信仰前來填補。從此，國人的信仰出現空缺，國人的良知也被一塊塊蠶食殆盡。&lt;/p&gt;
&lt;p&gt;二、信仰、科學、迷信&lt;/p&gt;
&lt;p&gt;在許多國人的心目中，信仰就等於迷信。從小到大的教育告訴我們，信奉宗教是愚昧而又無知的表現，科學與信仰是矛盾的。是麼？&lt;/p&gt;
&lt;p&gt;我們無法保證社會上的每一個人都接受過良好的教育，我們無法確信最前沿的科學素養能在民衆中普及。在科普與教育力不從心的社會死角，在科學技術尚不能及的文化盲區，我們依舊需要信仰的規範與限制，我們的良知需要信仰！&lt;/p&gt;
&lt;p&gt;信仰不等於迷信。信仰本身無所謂謎與不迷，迷信是持有信仰的人誤解了信仰，盲目遵從的結果。以爲燒過香就可以免遭禍患，以爲捐了錢就可以升入天堂，以爲引火自焚就可以功德圓滿，這便是迷信了。希特勒曾經的人類完善計劃，依照遺傳學的原理，將科學家與運動員強行結爲夫婦孕育生命，希望得到最優秀的人類種族，這便是對科學這種信仰的迷信！&lt;/p&gt;
&lt;p&gt;由此可見，科學與信仰並不是矛盾的硬幣的兩面，從某種意義而言科學本身也是信仰的一種。雖然歷史上宗教往往作爲科學發展的阻礙，可信奉真理的信念一直是推動科學發展的動力。牛頓就曾說過，對自然規律的探詢是爲了更接近上帝。由此可見，信仰與真理，與良知毫無矛盾。&lt;/p&gt;
&lt;p&gt;三、信仰喚醒良知&lt;/p&gt;
&lt;p&gt;很少有人仔細思考過，良知的缺失是由信仰的缺失造成的。信仰是人思想的寄託與依靠，是人行動處世的準則。沒有了信仰的人，思想行爲就缺少了約束的標準，人就更容易因爲一時不成熟的衝動，背叛良知、鑄成錯誤。&lt;/p&gt;
&lt;p&gt;泰國人以佛教爲信仰，泰國的寺廟每天都會有成千上萬人頂禮膜拜。寺廟有一個人盡皆知的不成文規定：不得穿鞋進入。於是在寺廟之外，遊客們可以看到千百雙各式的鞋子有序的擺放在門口。國人每每看到此景，總會詫異地問：沒有人會偷鞋麼？得到的答案極爲簡單：廟前偷鞋會遭報應。由於擁有信仰，泰國人作了壞事會受到良知的譴責，泰國商人售出假貨會徹夜難眠。二戰期間，無數猶太難民被天主教會收留藏匿從而僥倖逃生，這同樣是出於，天主教徒們被自己信奉的教義“衆生生來平等”，所喚醒的良知。&lt;/p&gt;
&lt;p&gt;天下無賊的世界，不能僅靠科普說教來營造。如果脫離了信仰，縱使是教育也無法培養良知。我問過許多修化學的同學，學習化學的意義，結論竟是爲了考試。如果沒有對科學的信仰，我們可以牢記公式定理，卻質疑它們是真理；如果沒有對社會公德的信仰，我們可以熟背交通規則，卻正大光明地闖紅燈；如果沒有對醫療道德的信仰，醫生可以放任傷口發炎，從而留住病人繼續治療……&lt;/p&gt;
&lt;p&gt;國人需要信仰的約束，需要填補信仰的空白，從而喚醒那深埋於每個國人內心深處的良知！&lt;/p&gt;
</content><category term="import"></category></entry></feed>