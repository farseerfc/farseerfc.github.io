<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Farseerfc's Blog</title><link href="//farseerfc.github.io/" rel="alternate"></link><link href="//farseerfc.github.io/feeds/tag-c.atom.xml" rel="self"></link><id>//farseerfc.github.io/</id><updated>2012-02-26T05:54:57+09:00</updated><entry><title>關於C++模板的類型轉換的討論</title><link href="//farseerfc.github.io/discuss-cpp-template-downcast.html" rel="alternate"></link><updated>2012-02-26T05:54:57+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2012-02-26:discuss-cpp-template-downcast.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;這兩天在飲水思源的C板，關於C++模板的類型轉換的一個討論，後面是我的解答。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;討論地址&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html"&gt;http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;原問題&lt;/h2&gt;
&lt;p&gt;今天在書上看到模板演繹的時候可以允許cast-down，於是我寫了個東西：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;_Test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BB&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DD&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//f(b);&lt;/span&gt;
    &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;奇怪的是重載決議的時候， &lt;/p&gt;&lt;pre&gt;
f&lt;/pre&gt;
 的情況下它就不讓我特化的 &lt;pre&gt;
f&amp;lt;A&amp;gt;&lt;/pre&gt;
 進來。
&lt;p&gt;但是在 &lt;/p&gt;&lt;pre&gt;
ff&lt;/pre&gt;
 的情況下， &lt;pre&gt;
ff&amp;lt;BB&amp;lt;long&amp;gt;&amp;gt;&lt;/pre&gt;
 卻進來了。
&lt;p&gt;在&lt;span class="caps"&gt;VC10&lt;/span&gt;和&lt;span class="caps"&gt;GCC3&lt;/span&gt;.4下測試&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;我的解答&lt;/h2&gt;
&lt;p&gt;我們來設身處地地作爲編譯器，看一遍到底發生了什麼。&lt;/p&gt;
&lt;p&gt;約定符號 &lt;/p&gt;&lt;pre&gt;
#&lt;/pre&gt;
 : &lt;pre&gt;
A#B&lt;/pre&gt;
 是把 &lt;pre&gt;
B&lt;/pre&gt;
 帶入 &lt;pre&gt;
A&amp;lt;T&amp;gt;&lt;/pre&gt;
 的參數 &lt;pre&gt;
T&lt;/pre&gt;
 之後實例化得到的結果。
&lt;div class="section" id="ff"&gt;
&lt;h3&gt;首先看ff的情況。&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;處理到這句的時候，編譯器看到了 &lt;/p&gt;&lt;pre&gt;
DD&amp;lt;long&amp;gt;&lt;/pre&gt;
 的實例化，於是去實例化 &lt;pre&gt;
DD#long&lt;/pre&gt;
 ，繼而實例
化了 &lt;pre&gt;
BB#long&lt;/pre&gt;
 。
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;這句，首先計算重載函數集合。&lt;/p&gt;
&lt;p&gt;第一步，需要從參數 &lt;/p&gt;&lt;pre&gt;
DD#long -&amp;gt; BB&amp;lt;T&amp;gt;&lt;/pre&gt;
 推斷 &lt;pre&gt;
ff&amp;lt;T&amp;gt;&lt;/pre&gt;
 的 &lt;pre&gt;
T&lt;/pre&gt;
 。根據函數模板參數推斷規則：
&lt;pre class="literal-block"&gt;
``class_template_name&amp;lt;T&amp;gt;`` 類型的參數，可以用於推斷 ``T`` 。
&lt;/pre&gt;
&lt;p&gt;於是編譯器推斷 &lt;/p&gt;&lt;pre&gt;
T&lt;/pre&gt;
 爲 &lt;pre&gt;
long&lt;/pre&gt;
 。這裏就算不是 &lt;pre&gt;
BB&lt;/pre&gt;
 而是完全無關的 &lt;pre&gt;
CC&lt;/pre&gt;
 都可以推斷成功，只要 &lt;pre&gt;
CC&lt;/pre&gt;
 也
是一個 &lt;pre&gt;
CC&amp;lt;T&amp;gt;&lt;/pre&gt;
 形式的模板。
&lt;p&gt;第二步，模板特化匹配。因爲只有一個模板，所以匹配了最泛化的 &lt;/p&gt;&lt;pre&gt;
ff&amp;lt;T&amp;gt;&lt;/pre&gt;
 。
&lt;p&gt;第三步，模板實例化。&lt;/p&gt;
&lt;p&gt;推斷了 &lt;/p&gt;&lt;pre&gt;
long -&amp;gt; T&lt;/pre&gt;
 之後，編譯器實例化 &lt;pre&gt;
ff#long&lt;/pre&gt;
 。
&lt;p&gt;重載函數集合： &lt;/p&gt;&lt;pre&gt;
{ff#long}&lt;/pre&gt;
&lt;p&gt;然後重載抉擇找到唯一的可匹配的實例 &lt;/p&gt;&lt;pre&gt;
ff#long&lt;/pre&gt;
 ，檢查實際參數 &lt;pre&gt;
DD#long&lt;/pre&gt;
 可以隱式轉換到
形式參數 &lt;pre&gt;
BB#long&lt;/pre&gt;
 ，從而生成了這次函數調用。
&lt;/div&gt;
&lt;div class="section" id="f"&gt;
&lt;h3&gt;再來看f的情況。&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;計算候選重載函數集合。&lt;/p&gt;
&lt;p&gt;第一步，對所有 &lt;/p&gt;&lt;pre&gt;
f&lt;/pre&gt;
 模板推斷實參。根據函數模板參數推斷規則：
&lt;pre class="literal-block"&gt;
帶有 ``T`` 類型的參數，可以用於推斷 ``T`` 。
&lt;/pre&gt;
&lt;p&gt;於是 &lt;/p&gt;&lt;pre&gt;
B -&amp;gt; T&lt;/pre&gt;
 被推斷出來了。
&lt;p&gt;第二步，模板特化匹配。&lt;/p&gt;
&lt;p&gt;這裏 &lt;/p&gt;&lt;pre&gt;
B&lt;/pre&gt;
 不是 &lt;pre&gt;
A&lt;/pre&gt;
 ，所以不能用 &lt;pre&gt;
f&amp;lt;A&amp;gt;&lt;/pre&gt;
 特化，只能用 &lt;pre&gt;
f&amp;lt;T&amp;gt;&lt;/pre&gt;
 模板。
&lt;p&gt;第三步，模板實例化。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;pre&gt;
B&lt;/pre&gt;
 帶入 &lt;pre&gt;
f&amp;lt;T&amp;gt;&lt;/pre&gt;
 實例化成 &lt;pre&gt;
f#B&lt;/pre&gt;
 的過程中，實例化 &lt;pre&gt;
traits#B&lt;/pre&gt;
 。
&lt;p&gt;由於沒有針對 &lt;/p&gt;&lt;pre&gt;
B&lt;/pre&gt;
 的特化，所以用 &lt;pre&gt;
traits&amp;lt;T&amp;gt;&lt;/pre&gt;
 模板， &lt;pre&gt;
traits#B::value=false&lt;/pre&gt;
 ，進而 &lt;pre&gt;
enable_if#false&lt;/pre&gt;
 沒有 &lt;pre&gt;
type&lt;/pre&gt;
 ，出錯。
&lt;p&gt;唯一的模板匹配出錯，重載函數集合爲空，&lt;span class="caps"&gt;SFINAE&lt;/span&gt;原則不能找到合適的匹配，於是報錯。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category><category term="template"></category><category term="C"></category></entry><entry><title>關於C++模板的類型轉換的討論</title><link href="//farseerfc.github.io/discuss-cpp-template-downcast.html" rel="alternate"></link><updated>2012-02-26T05:54:57+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2012-02-26:discuss-cpp-template-downcast.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;這兩天在飲水思源的C板，關於C++模板的類型轉換的一個討論，後面是我的解答。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;討論地址&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html"&gt;http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;原問題&lt;/h2&gt;
&lt;p&gt;今天在書上看到模板演繹的時候可以允許cast-down，於是我寫了個東西：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;_Test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BB&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DD&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//f(b);&lt;/span&gt;
    &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;奇怪的是重載決議的時候， &lt;/p&gt;&lt;pre&gt;
f&lt;/pre&gt;
 的情況下它就不讓我特化的 &lt;pre&gt;
f&amp;lt;A&amp;gt;&lt;/pre&gt;
 進來。
&lt;p&gt;但是在 &lt;/p&gt;&lt;pre&gt;
ff&lt;/pre&gt;
 的情況下， &lt;pre&gt;
ff&amp;lt;BB&amp;lt;long&amp;gt;&amp;gt;&lt;/pre&gt;
 卻進來了。
&lt;p&gt;在&lt;span class="caps"&gt;VC10&lt;/span&gt;和&lt;span class="caps"&gt;GCC3&lt;/span&gt;.4下測試&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;我的解答&lt;/h2&gt;
&lt;p&gt;我們來設身處地地作爲編譯器，看一遍到底發生了什麼。&lt;/p&gt;
&lt;p&gt;約定符號 &lt;/p&gt;&lt;pre&gt;
#&lt;/pre&gt;
 : &lt;pre&gt;
A#B&lt;/pre&gt;
 是把 &lt;pre&gt;
B&lt;/pre&gt;
 帶入 &lt;pre&gt;
A&amp;lt;T&amp;gt;&lt;/pre&gt;
 的參數 &lt;pre&gt;
T&lt;/pre&gt;
 之後實例化得到的結果。
&lt;div class="section" id="ff"&gt;
&lt;h3&gt;首先看ff的情況。&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;處理到這句的時候，編譯器看到了 &lt;/p&gt;&lt;pre&gt;
DD&amp;lt;long&amp;gt;&lt;/pre&gt;
 的實例化，於是去實例化 &lt;pre&gt;
DD#long&lt;/pre&gt;
 ，繼而實例
化了 &lt;pre&gt;
BB#long&lt;/pre&gt;
 。
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;這句，首先計算重載函數集合。&lt;/p&gt;
&lt;p&gt;第一步，需要從參數 &lt;/p&gt;&lt;pre&gt;
DD#long -&amp;gt; BB&amp;lt;T&amp;gt;&lt;/pre&gt;
 推斷 &lt;pre&gt;
ff&amp;lt;T&amp;gt;&lt;/pre&gt;
 的 &lt;pre&gt;
T&lt;/pre&gt;
 。根據函數模板參數推斷規則：
&lt;pre class="literal-block"&gt;
``class_template_name&amp;lt;T&amp;gt;`` 類型的參數，可以用於推斷 ``T`` 。
&lt;/pre&gt;
&lt;p&gt;於是編譯器推斷 &lt;/p&gt;&lt;pre&gt;
T&lt;/pre&gt;
 爲 &lt;pre&gt;
long&lt;/pre&gt;
 。這裏就算不是 &lt;pre&gt;
BB&lt;/pre&gt;
 而是完全無關的 &lt;pre&gt;
CC&lt;/pre&gt;
 都可以推斷成功，只要 &lt;pre&gt;
CC&lt;/pre&gt;
 也
是一個 &lt;pre&gt;
CC&amp;lt;T&amp;gt;&lt;/pre&gt;
 形式的模板。
&lt;p&gt;第二步，模板特化匹配。因爲只有一個模板，所以匹配了最泛化的 &lt;/p&gt;&lt;pre&gt;
ff&amp;lt;T&amp;gt;&lt;/pre&gt;
 。
&lt;p&gt;第三步，模板實例化。&lt;/p&gt;
&lt;p&gt;推斷了 &lt;/p&gt;&lt;pre&gt;
long -&amp;gt; T&lt;/pre&gt;
 之後，編譯器實例化 &lt;pre&gt;
ff#long&lt;/pre&gt;
 。
&lt;p&gt;重載函數集合： &lt;/p&gt;&lt;pre&gt;
{ff#long}&lt;/pre&gt;
&lt;p&gt;然後重載抉擇找到唯一的可匹配的實例 &lt;/p&gt;&lt;pre&gt;
ff#long&lt;/pre&gt;
 ，檢查實際參數 &lt;pre&gt;
DD#long&lt;/pre&gt;
 可以隱式轉換到
形式參數 &lt;pre&gt;
BB#long&lt;/pre&gt;
 ，從而生成了這次函數調用。
&lt;/div&gt;
&lt;div class="section" id="f"&gt;
&lt;h3&gt;再來看f的情況。&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;計算候選重載函數集合。&lt;/p&gt;
&lt;p&gt;第一步，對所有 &lt;/p&gt;&lt;pre&gt;
f&lt;/pre&gt;
 模板推斷實參。根據函數模板參數推斷規則：
&lt;pre class="literal-block"&gt;
帶有 ``T`` 類型的參數，可以用於推斷 ``T`` 。
&lt;/pre&gt;
&lt;p&gt;於是 &lt;/p&gt;&lt;pre&gt;
B -&amp;gt; T&lt;/pre&gt;
 被推斷出來了。
&lt;p&gt;第二步，模板特化匹配。&lt;/p&gt;
&lt;p&gt;這裏 &lt;/p&gt;&lt;pre&gt;
B&lt;/pre&gt;
 不是 &lt;pre&gt;
A&lt;/pre&gt;
 ，所以不能用 &lt;pre&gt;
f&amp;lt;A&amp;gt;&lt;/pre&gt;
 特化，只能用 &lt;pre&gt;
f&amp;lt;T&amp;gt;&lt;/pre&gt;
 模板。
&lt;p&gt;第三步，模板實例化。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;pre&gt;
B&lt;/pre&gt;
 帶入 &lt;pre&gt;
f&amp;lt;T&amp;gt;&lt;/pre&gt;
 實例化成 &lt;pre&gt;
f#B&lt;/pre&gt;
 的過程中，實例化 &lt;pre&gt;
traits#B&lt;/pre&gt;
 。
&lt;p&gt;由於沒有針對 &lt;/p&gt;&lt;pre&gt;
B&lt;/pre&gt;
 的特化，所以用 &lt;pre&gt;
traits&amp;lt;T&amp;gt;&lt;/pre&gt;
 模板， &lt;pre&gt;
traits#B::value=false&lt;/pre&gt;
 ，進而 &lt;pre&gt;
enable_if#false&lt;/pre&gt;
 沒有 &lt;pre&gt;
type&lt;/pre&gt;
 ，出錯。
&lt;p&gt;唯一的模板匹配出錯，重載函數集合爲空，&lt;span class="caps"&gt;SFINAE&lt;/span&gt;原則不能找到合適的匹配，於是報錯。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category><category term="template"></category><category term="C"></category></entry><entry><title>C++ Tricks 3.2 標號、goto，以及switch的實現</title><link href="//farseerfc.github.io/c-tricks-3-2-label-goto-and-implementation-of-switch.html" rel="alternate"></link><updated>2007-09-16T13:08:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-09-16:c-tricks-3-2-label-goto-and-implementation-of-switch.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h2&gt;3.2 標號、goto，以及switch的實現&lt;/h2&gt;
&lt;p&gt;goto語句及標號(label)是最古老的C語言特性，也是最早被人們拋棄的語言特性之一。像彙編語言中的jmp指令一樣，goto語句可以跳轉到同一函數體中任何標號位置：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{int i=0;&lt;/p&gt;
&lt;p&gt;Loop: //A label&lt;/p&gt;
&lt;p&gt;++i;&lt;/p&gt;
&lt;p&gt;if(i&amp;lt;10)goto Loop; //Jump to the label&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;在原始而和諧的早期Fortran和Basic時代，我們沒有if then else，沒有for和while，甚至沒有函數的概念，一切控制結構都靠goto(帶條件的或無條件的)構件。軟件工程師將這樣的代碼稱作“意大利麪條”代碼。實踐證明這樣的代碼極容易造成混亂。&lt;/p&gt;
&lt;p&gt;自從證明了結構化的程序可以做意大利麪條做到的任何事情，人們就開始不遺餘力地推廣結構化設計思想，將goto像猛獸一般囚禁在牢籠，標號也因此消失。&lt;/p&gt;
&lt;p&gt;標號唯一散發餘熱的地方，是在switch中控制分支流程。&lt;/p&gt;
&lt;p&gt;很多人不甚瞭解switch存在的意義，認爲它只是大型嵌套if then else結構的縮略形式，並且比if語句多了很多“不合理”的限制。如果你瞭解到switch在編譯器內部的實現機制，就不難理解強加在switch之上的諸多限制，比如case後只能跟一個編譯期整型常量，比如用break結束每一個case。首先看一個switch實例：&lt;/p&gt;
&lt;p&gt;switch (shape.getAngle())&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;case 3: cout&amp;lt;&amp;lt;”Triangle”;break;&lt;/p&gt;
&lt;p&gt;case 4: cout&amp;lt;&amp;lt;”Square”;break;&lt;/p&gt;
&lt;p&gt;case 0:case1: cout&amp;lt;&amp;lt;”Not a sharp!”;break;&lt;/p&gt;
&lt;p&gt;default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;任何程序員都可以寫出與之對應的if結構：&lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i==3) cout&amp;lt;&amp;lt;”Triangle”;&lt;/p&gt;
&lt;p&gt;else if(i==4) cout&amp;lt;&amp;lt;”Square”;&lt;/p&gt;
&lt;p&gt;else if(i==0||i==1) cout&amp;lt;&amp;lt;”Not a sharp!”;&lt;/p&gt;
&lt;p&gt;else cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;看起來這兩段代碼在語義上是完全一樣的，不是麼？&lt;/p&gt;
&lt;p&gt;不！或許代碼的執行結果完全一樣，但是就執行效率而言，switch版本的更快！&lt;/p&gt;
&lt;p&gt;要了解爲什麼switch的更快，我們需要知道編譯器是怎樣生成switch的實現代碼的：&lt;/p&gt;
&lt;p&gt;首先，保留switch之後由{}括起來的語具體，僅將其中case、default和break替換爲真正的標號：&lt;/p&gt;
&lt;p&gt;switch (getAngle(shape))&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;隨後，對於所有出現在case之後的常量，列出一張只有goto的跳轉表，其順序按case後的常量排列：&lt;/p&gt;
&lt;p&gt;goto _case_0;&lt;/p&gt;
&lt;p&gt;goto _case_1;&lt;/p&gt;
&lt;p&gt;goto _case_3;&lt;/p&gt;
&lt;p&gt;goto _case_4;&lt;/p&gt;
&lt;p&gt;然後，計算case之後的常量與跳轉表地址之間的關係，如有需要，在跳轉表中插入空缺的項目：&lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default; //因爲沒有case 2，所以插入此項以條轉到default&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt;假設一個goto語句佔用5個字節，那麼在本例中，goto的地址=case後的常量*5+100105&lt;/p&gt;
&lt;p&gt;之後，生成跳轉代碼，在其餘條件下跳轉至default，在已知範圍內按照公式跳轉，全部的實現如下：&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i&amp;lt;0||i&amp;gt;=5)goto _default;&lt;/p&gt;
&lt;p&gt;i=i*5+100105; //按照得出的公式算出跳轉地址&lt;/p&gt;
&lt;p&gt;goto i; //僞代碼，C中不允許跳轉到整數，但是彙編允許&lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default;&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;經過這樣處理整個switch結構，使得無論switch後的變量爲何值，都可以通過最多兩次跳轉到達目標代碼。相比之下if版本的代碼則採用線性的比較和跳轉，在case語句很多的情況下效率極低。&lt;/p&gt;
&lt;p&gt;由此,我們也可以知道,爲什麼case後跟的一定是編譯期整型常數，因爲編譯器需要根據這個值製作跳轉表。我們可以明白爲什麼case與case之間應該用break分隔，因爲編譯器不改變switch語句體的結構，case其本身只是一個具有語義的標號而已，要想跳出switch，就必須用break語句。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 3.1 左值右值與常量性(lvalue，rvalue &amp; constant)</title><link href="//farseerfc.github.io/c-tricks-3-1-lvalue-rvalue-constant.html" rel="alternate"></link><updated>2007-09-16T13:07:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-09-16:c-tricks-3-1-lvalue-rvalue-constant.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h2&gt;3.1 左值右值與常量性(lvalue，rvalue &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; constant)&lt;/h2&gt;
&lt;p&gt;首先要搞清楚的是，什麼是左值，什麼是右值。這裏給出左值右值的定義：&lt;/p&gt;
&lt;p&gt;1、左值是可以出現在等號(=)左邊的值，右值是隻能出現在等號右邊的值。&lt;/p&gt;
&lt;p&gt;2、左值是可讀可寫的值，右值是隻讀的值。&lt;/p&gt;
&lt;p&gt;3、左值有地址，右值沒有地址。&lt;/p&gt;
&lt;p&gt;根據左值右值的第二定義，值的左右性就是值的常量性——常量是右值，非常量是左值。比如：&lt;/p&gt;
&lt;p&gt;1=1;//Error&lt;/p&gt;
&lt;p&gt;這個複製操作在C++中是語法錯誤，&lt;span class="caps"&gt;MSVC&lt;/span&gt;給出的錯誤提示爲“error C2106: ‘=’ :
left operand must be l-value”，就是說’=’的左操作數必須是一個左值，而字面常數1是一個右值。可見，嚴格的區分左值右值可以從語法分析的角度找出程序的邏輯錯誤。&lt;/p&gt;
&lt;p&gt;根據第二定義，一個左值也是一個右值，因爲左值也可讀，而一個右值不是一個左值，因爲右值不可寫。&lt;/p&gt;
&lt;p&gt;通常情況下，聲明的變量是一個左值，除非你指定const將它變成一個右值：&lt;/p&gt;
&lt;p&gt;int lv=1;&lt;/p&gt;
&lt;p&gt;const int rv=lv;&lt;/p&gt;
&lt;p&gt;由於右值的值在程序執行期間不能改變，所以必須用另一個右值初始化它。&lt;/p&gt;
&lt;p&gt;一個普通變量只能用右值初始化，如果你想傳遞左值，必須聲明一個引用或一個指針：&lt;/p&gt;
&lt;p&gt;int &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; ref=lv;//用引用傳遞左值&lt;/p&gt;
&lt;p&gt;int * plv=&amp;amp;lv;//傳遞指針以間接傳遞左值&lt;/p&gt;
&lt;p&gt;必須用左值初始化引用，然而，可以用右值初始化常量引用：&lt;/p&gt;
&lt;p&gt;int &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; r1=1; //Error!&lt;/p&gt;
&lt;p&gt;const int &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; r2=1; //&lt;span class="caps"&gt;OK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;這實際上相當於：&lt;/p&gt;
&lt;p&gt;int _r2=1;&lt;/p&gt;
&lt;p&gt;const int &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; r2=_r2;&lt;/p&gt;
&lt;p&gt;這樣的寫法在函數體內沒什麼作用，但是在傳遞函數參數時，它可以避免潛在的(傳遞左值時的)複製操作，同時又可以接受右值。&lt;/p&gt;
&lt;p&gt;通常情況下，函數的參數和返回值都只傳回右值，除非你明確的通過引用傳遞左值。&lt;/p&gt;
&lt;p&gt;明確了左值與右值的區別，有助於我們寫函數時確定什麼時候應該有const，什麼時候不該有。比如，我們寫了一個代表數學中複數的類Complex：&lt;/p&gt;
&lt;p&gt;class Complex;&lt;/p&gt;
&lt;p&gt;然後，我們寫針對Complex的運算符重載：operator+和operator=。問題在於，參數和返回值應該是什麼類型，可選類型有四種：
Complex、const Complex、Complex&amp;amp;、const Complex&amp;amp;。&lt;/p&gt;
&lt;p&gt;對於operator+，我們不會改變參數的值，所以可以通過const
Complex&amp;amp;傳遞參數。至於返回值類型，由於int類型的加法返回右值，所以根據Do
as the ints do的原則，返回值類型爲const Complex：&lt;/p&gt;
&lt;p&gt;const Complex operator+(const Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt;對於operator=，同樣要思考這些問題。我們寫入第一個參數，所以第一個參數爲Complex&amp;amp;，我們只讀取第二個參數，所以第二個參數爲const
Complex&amp;amp;。至於返回值，還是Do as the ints do。int的賦值返回左值，不信你可以試一試：&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;(i=1)=2;&lt;/p&gt;
&lt;p&gt;雖然比較傻，先將i賦爲1，再將其改爲2，但是這是被C++語法支持的做法，我們就理應遵守。所以返回第一個參數的左值：&lt;/p&gt;
&lt;p&gt;Complex&amp;amp; operator=(Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt;const是C++引入的語言特性，也被&lt;span class="caps"&gt;ANSI&lt;/span&gt;
C99借鑑，在經典版本的C語言中是沒有的。關於const的歷史，有幾點值得玩味。最初Bjarne
Stroustrup引入const時，可寫性是和可讀性分開的。那時使用關鍵字readonly和writeonly。這個特點被首先提交到C的&lt;span class="caps"&gt;ANSI&lt;/span&gt;標準化委員會(當時還沒有C++標準化的計劃)，但是&lt;span class="caps"&gt;ANSI&lt;/span&gt; C標準只接受了readonly的概念，並將其命名爲const。隨後，有人發現在多線程同步的環境下，有些變量的值會在編譯器的預料之外改變，爲了防止過度優化破壞這些變量，C++又引入關鍵字violate。從語義特點來看，violate是const的反義詞，因爲const表示不會變的量，而violate表示會不按照預期自行變化的量。從語法特點而言，violate與const是極爲相似的，適用於const的一切語法規則同樣適用於violate。&lt;/p&gt;
&lt;p&gt;值的常量性可以被劃分爲兩種：編譯期常量和運行期常量。C++語法並沒有嚴格區分這兩種常量，導致了少許混亂：&lt;/p&gt;
&lt;p&gt;const int i=5;const int * pi=&amp;amp;i;&lt;/p&gt;
&lt;p&gt;const_cast&amp;lt;int&amp;amp;&amp;gt;i=1;//對於運行期常量，在需要時可以去除它的常量性&lt;/p&gt;
&lt;p&gt;int a[i];//對於編譯期常量，可以用它來指定數組大小&lt;/p&gt;
&lt;p&gt;cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;sizeof(a)/sizeof(a[0])&amp;lt;&amp;lt;*pi;&lt;/p&gt;
&lt;p&gt;這種將編譯期與運行期常量的特性混用的方法，勢必導致語義的混亂。數組a的大小最終是5，因爲採用了i的編譯期值，而不管i在運行期是否被改變了值。最後一句代碼將（有可能）輸出551，第一個i的值作爲一種優化在編譯期綁定，第二個值標明瞭a的大小，第三個值通過指針顯示地輸出i的運行期真實值。&lt;/p&gt;
&lt;p&gt;在C++的近親C#的語法中，這兩種常量被嚴格地區分開：編譯期常量由const指定，只能是內建類型變量；運行期常量由readonly指定，可以是任何類型。永遠不會改變的常量，如圓周率pi的值，應該用const聲明；而其它有可能改變的常量，皆由readonly聲明。&lt;/p&gt;
&lt;p&gt;C++中的const的特點更傾向於C#中的readonly，雖然語法上允許使用const的編譯期常量性，但正如上文所展示的，這容易造成混亂。爲了得到C#中const的語義，在C++中，我們不必迴歸惡魔#define的懷抱，可以使用所謂“匿名enum技巧”。當匿名聲明一個enum類型時，其中的枚舉值就是一個int類型的編譯期常量，比如：&lt;/p&gt;
&lt;p&gt;enum{Size=5;};&lt;/p&gt;
&lt;p&gt;int a[Size];&lt;/p&gt;
&lt;p&gt;這種使用匿名enum來聲明編譯期常量的做法，被廣泛應用於&lt;span class="caps"&gt;STL&lt;/span&gt;、boost等模板庫的實現代碼中。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.2 I386平臺的內存佈局</title><link href="//farseerfc.github.io/c-tricks-2-2-i386-memory-layout.html" rel="alternate"></link><updated>2007-08-28T14:30:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-2-i386-memory-layout.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.2 I386平臺的內存佈局&lt;/h2&gt;
&lt;p&gt;衆所周知，I386是32位體系結構。因此對於絕大多數I386平臺的C++編譯器而言，sizeof(int)=sizeof(long)=sizeof(void*)=4。當然C++標準對此沒有任何保證，我們也不應該試圖編寫依賴於此的代碼。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;32位指針的可尋址空間爲&lt;span class="caps"&gt;4GB&lt;/span&gt;。爲充分利用這麼大的尋址空間，也是爲了支持其它更先進的技術比如多任務技術或者動態鏈接庫技術，WinNT使用虛擬內存技術，給與每個應用程序全部&lt;span class="caps"&gt;4GB&lt;/span&gt;的內存空間。&lt;span class="caps"&gt;4GB&lt;/span&gt;的地址被一分爲二，前&lt;span class="caps"&gt;2GB&lt;/span&gt;供應用程序自己使用，後&lt;span class="caps"&gt;2GB&lt;/span&gt;由系統內核分配和管理。這&lt;span class="caps"&gt;2GB&lt;/span&gt;的內存地址，通常被劃分成3種內存區使用：&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;1 代碼及靜態數據區&lt;/h3&gt;
&lt;p&gt;由代碼加載器從動態鏈接庫鏡像(通常是exe或dll文件)加載，通常定位到鏡像文件中指定的基址開始的內存區。如果基址所在內存已被佔用，動態連接器會將代碼或數據重定向到其它可用地址。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;在C++中，靜態數據包括：名字空間(namespace)和全局(global)對象、函數的static對象、類的static數據成員。這些靜態數據由編譯器分配地址(但可能被重定向)，由靜態連接器寫入代碼文件(通常是exe或dll)的靜態數據區段。所以標準說，這些靜態數據在編譯期就已經具有地址。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stack"&gt;
&lt;h3&gt;2 棧(Stack)&lt;/h3&gt;
&lt;p&gt;棧是最常用的動態數據存儲區，所有函數的non-static對象和函數參數都在程序運行期在棧上分配內存。在數據結構中，術語“棧(Stack)”意指先進後出(&lt;span class="caps"&gt;FILO&lt;/span&gt;，First
In Last
Out)，與“隊列(Queue)”所指的&lt;span class="caps"&gt;FIFO&lt;/span&gt;相對。相對於基於堆的對象分配技術，默認使用棧的對象分配有兩點優勢：&lt;/p&gt;
&lt;p&gt;一、棧的&lt;span class="caps"&gt;FILO&lt;/span&gt;與人的思維方式相同&lt;/p&gt;
&lt;p&gt;現實生活中有許多事例都使用&lt;span class="caps"&gt;FILO&lt;/span&gt;的方式，比如人們必須先提起話筒再撥打號碼，而後掛斷電話之後再放下話筒。使用&lt;span class="caps"&gt;FILO&lt;/span&gt;的棧，可以保證事物的銷燬順序以其誕生順序相反的順序進行，不會產生在掛斷電話之前就放下話筒的尷尬。&lt;/p&gt;
&lt;p&gt;二、棧的分配管理僅需要兩個額外指針：棧頂(esp)和棧底(ebp)指針&lt;/p&gt;
&lt;p&gt;從實現的技術層面而言，棧的管理比其它動態分配技術要簡單很多。I386平臺上的動態棧管理，僅需要棧頂和棧底兩個指針。這兩個指針的存儲顯然不能放置於棧中，置於靜態數據區又有損效率。I386平臺爲管理動態棧專門預留了兩個通用寄存器變量esp與ebp，分別代表棧頂(esp,Extended
Stack Pointer)與棧底(Extended Bottom Pointer)指針。其中的extended代表它們是32位指針，以區分16位的sp和bp寄存器。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;棧是動態存儲區的特點，表明它的內存佔用將隨着程序的運行而變化。I386平臺上WinNT將應用程序的棧置於程序空間，向下增長。程序初始化時，由操作系統將esp指向系統分配的棧空間的頂部。當程序需要在棧上分配變量時，就將esp減去變量所需字節數，這被稱作“壓棧(Push)”；隨後又要銷燬變量時，就將esp加上變量所需字節數，這被稱作“彈出(Pop)”。esp與ebp兩者之間所夾的空間，就是當前函數正在使用的棧空間。由於棧向下增長，esp(棧頂)的值總是小於ebp(棧底)的值，新分配的變量地址總是小於舊變量的地址。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="heap"&gt;
&lt;h3&gt;3 堆(Heap)和自由存儲區&lt;/h3&gt;
&lt;p&gt;棧中的變量對於分配與釋放的順序有特定要求，這在一定程度上限制了棧的適用範圍。面向對象(&lt;span class="caps"&gt;OO&lt;/span&gt;，Object Oriented)的程序設計思想也要求能自由地控制變量的分配與銷燬。由此，現代操作系統都提供了被稱作“堆(Heap)”的自由存儲區，以允許由程序員控制的對象創建和銷燬過程。C標準庫函數malloc和free則是對操作系統提供的堆操作的封裝。C++提供的自由存儲區運算符new和delete則通常是malloc和free的又一層封裝。&lt;/p&gt;
&lt;p&gt;操作系統經由malloc和free控制對堆的訪問。堆的存儲管理技術各不相同，簡單的使用雙鏈表管理，複雜的可以比擬一個完整的文件系統。&lt;/p&gt;
&lt;p&gt;由於額外的管理需求，使用系統提供的通用分配器在堆上分配和銷燬變量的代價，無論從空間角度還是效率角度而言，都比在棧上分配對象要高昂很多。對於sizeof上百的大型對象，這樣的高昂代價還是可以接受的，但是對於sizeof只有個位數的小對象，這樣的代價通常是一個數量級的差距。正因爲這個原因，&lt;span class="caps"&gt;STL&lt;/span&gt;不使用new和delete，轉而使用分配子(alllocor)分配對象。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks</title><link href="//farseerfc.github.io/c-tricks.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ Tricks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;By  FarseerFc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;從今天起，我再將在&lt;a class="reference external" href="http://firechildren.spaces.live.com/"&gt;Live
Space&lt;/a&gt;和&lt;a class="reference external" href="http://76635424.qzone.qq.com/"&gt;QQZone&lt;/a&gt;同時發表一系列文章，暫定名爲“C++Tricks”。&lt;/p&gt;
&lt;p&gt;本文旨在記錄和闡述一些本人學習C++時所得的心得、技巧。總體來看，本文涉及的內容是每一個C++程序員都應該知道的，但是很少見諸C++教材。希望對各位同仁學習C++有所幫助。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;也可以通過&lt;span class="caps"&gt;QQ&lt;/span&gt;或&lt;span class="caps"&gt;MSN&lt;/span&gt;向我索要此文的&lt;span class="caps"&gt;DOC&lt;/span&gt;版或&lt;span class="caps"&gt;PDF&lt;/span&gt;版，會比網頁上的更新的快一點。&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lexical-problems"&gt;
&lt;h2&gt;1      詞法問題(Lexical Problems)&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!139.entry"&gt;1.1 條件運算符(?:)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!140.entry"&gt;1.2 逗號運算符(,)、邏輯運算符(&amp;amp;&amp;amp;,||)與運算符重載的陷阱&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="x86"&gt;
&lt;h3&gt;2      X86體系結構&lt;/h3&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!146.entry"&gt;2.1 X86概述&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!147.entry"&gt;2.2 I386平臺的內存佈局&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!148.entry"&gt;2.3 I386平臺C函數內部的棧分配&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!149.entry"&gt;2.4 I386平臺C函數調用邊界的棧分配&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!150.entry"&gt;2.5 I386平臺的邊界對齊(Align)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!151.entry"&gt;2.6 I386平臺C函數的可變參數表(Variable Arguments)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!152.entry"&gt;2.7 I386平臺的其它函數調用模型&lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="id6"&gt;
&lt;h5&gt;3 過程式編程&lt;/h5&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!154.entry"&gt;3.1 左值右值與常量性(lvalue，rvalue &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; constant)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!155.entry"&gt;3.2 標號、goto，以及switch的實現&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.3 I386平臺C函數內部的棧分配</title><link href="//farseerfc.github.io/c-tricks-2-3-i386-stack-allocation-in-c-functions.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-3-i386-stack-allocation-in-c-functions.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.3 I386平臺C函數內部的棧分配&lt;/h2&gt;
&lt;p&gt;函數使用棧來保存局部變量，傳遞函數參數。進入函數時，函數在棧上爲函數中的變量統一預留棧空間，將esp減去相應字節數。當函數執行流程途徑變量聲明語句時，如有需要就調用相應構造函數將變量初始化。當執行流程即將離開聲明所在代碼塊時，以初始化的順序的相反順序逐一調用析構函數。當執行流程離開函數體時，將esp加上相應字節數，歸還棧空間。&lt;/p&gt;
&lt;p&gt;爲了訪問函數變量，必須有方法定位每一個變量。變量相對於棧頂esp的位置在進入函數體時就已確定，但是由於esp會在函數執行期變動，所以將esp的值保存在ebp中，並事先將ebp的值壓棧。隨後，在函數體中通過ebp減去偏移量來訪問變量。以一個最簡單的函數爲例：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int a=0; //a的地址被分配爲ebp-4&lt;/p&gt;
&lt;p&gt;char c=1; //c的地址被分配爲ebp-8&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;產生的彙編代碼爲：&lt;/p&gt;
&lt;p&gt;push ebp ;將ebp壓棧&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;ebp=esp 用棧底備份棧頂指針&lt;/p&gt;
&lt;p&gt;sub esp,8 ;esp-=8，爲a和c預留空間，包括邊界對齊&lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],0 ;a=0&lt;/p&gt;
&lt;p&gt;mov byte ptr[ebp-8],1 ;c=1&lt;/p&gt;
&lt;p&gt;add esp,8 ;esp+=8，歸還a和c的空間&lt;/p&gt;
&lt;p&gt;mov esp,ebp ;esp=ebp 從棧底恢復棧頂指針&lt;/p&gt;
&lt;p&gt;pop ebp ;恢復ebp&lt;/p&gt;
&lt;p&gt;ret ;返回&lt;/p&gt;
&lt;p&gt;相應的內存佈局是這樣：&lt;/p&gt;
&lt;p&gt;09992:c=1 &amp;lt;-esp&lt;/p&gt;
&lt;p&gt;09996:a=0&lt;/p&gt;
&lt;p&gt;10000:舊ebp &amp;lt;-ebp&lt;/p&gt;
&lt;p&gt;10004:……&lt;/p&gt;
&lt;p&gt;注:彙編中的pop、push、call、ret語句是棧操作指令，其功能可以用普通指令替換&lt;/p&gt;
&lt;p&gt;push ebp相當於:&lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;mov dword ptr[esp],ebp&lt;/p&gt;
&lt;p&gt;pop ebp相當於：&lt;/p&gt;
&lt;p&gt;mov ebp,dword ptr[esp]&lt;/p&gt;
&lt;p&gt;sub esp,4&lt;/p&gt;
&lt;p&gt;call fun_address相當於：&lt;/p&gt;
&lt;p&gt;push eip&lt;/p&gt;
&lt;p&gt;jmp fun_address&lt;/p&gt;
&lt;p&gt;ret相當於&lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt;帶參數的ret&lt;/p&gt;
&lt;p&gt;ret 8相當於&lt;/p&gt;
&lt;p&gt;add esp,12&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt;所有局部變量都在棧中由函數統一分配，形成了類似逆序數組的結構，可以通過指針逐一訪問。這一特點具有很多有趣性質，比如，考慮如下函數，找出其中的錯誤及其造成的結果：&lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i,a[10];&lt;/p&gt;
&lt;p&gt;for(i=0;i&amp;lt;=10;++i)a[i]=0;/An error occurs here!&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;這個函數中包含的錯誤，即使是C++新手也很容易發現，這是老生常談的越界訪問問題。但是這個錯誤造成的結果，是很多人沒有想到的。這次的越界訪問，並不會像很多新手預料的那樣造成一個“非法操作”消息，也不會像很多老手估計的那樣會默不作聲，而是導致一個，呃，死循環！&lt;/p&gt;
&lt;p&gt;錯誤的本質顯而易見，我們訪問了a[10]，但是a[10]並不存在。C++標準對於越界訪問只是說“未定義操作”。我們知道，a[10]是數組a所在位置之後的一個位置，但問題是，是誰在這個位置上。是i!&lt;/p&gt;
&lt;p&gt;根據前面的討論，i在數組a之前被聲明，所以在a之前分配在棧上。但是，I386上棧是向下增長的，所以，a的地址低於i的地址。其結果是在循環的最後，a[i]引用到了i自己！接下來的事情就不難預見了，a[i]，也就是i，被重置爲0，然後繼續循環的條件仍然成立……這個循環會一直繼續下去，直到在你的帳單上產生高額電費，直到耗光地球電能，直到太陽停止燃燒……呵呵，或者直到聰明的你把程序Kill了……&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.4 I386平臺C函數調用邊界的棧分配</title><link href="//farseerfc.github.io/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.4 I386平臺C函數調用邊界的棧分配&lt;/h2&gt;
&lt;p&gt;當調用一個函數時，主調函數將參數以聲明中相反的順序壓棧，然後將當前的代碼執行指針(eip)壓棧，然後跳轉到被調函數的入口點。在被調函數中，通過將ebp加上一個偏移量來訪問函數參數，以聲明中的順序(即壓棧的相反順序)來確定參數偏移量。被調函數返回時，彈出主調函數壓在棧中的代碼執行指針，跳回主調函數。再由主調函數恢復到調用前的棧。&lt;/p&gt;
&lt;p&gt;函數的返回值不同於函數參數，通過寄存器傳遞。如果返回值類型可以放入32位變量，比如int、short、char、指針等類型，通過eax寄存器傳遞。如果返回值類型是64位變量，如_int64，同過edx+eax傳遞，edx存儲高32位，eax存儲低32位。如果返回值是浮點類型，如float和double，通過專用的浮點數寄存器棧的棧頂返回。如果返回值類型是用戶自定義結構，或C++類類型，通過修改函數簽名，以引用型參數的形式傳回。&lt;/p&gt;
&lt;p&gt;同樣以最簡單的函數爲例：&lt;/p&gt;
&lt;p&gt;void f(){&lt;/p&gt;
&lt;p&gt;int i=g(1,2);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int g(int a,int b){&lt;/p&gt;
&lt;p&gt;int c=a+b；&lt;/p&gt;
&lt;p&gt;return c;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;產生的彙編代碼如下：&lt;/p&gt;
&lt;p&gt;f:&lt;/p&gt;
&lt;p&gt;push ebp ;備份ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;建立棧底&lt;/p&gt;
&lt;p&gt;sub esp,4 ;爲i分配空間&lt;/p&gt;
&lt;p&gt;mov eax,2 ;準備參數b的值2&lt;/p&gt;
&lt;p&gt;push eax ;將b壓棧&lt;/p&gt;
&lt;p&gt;mov eax,1 ;準備參數a的值1&lt;/p&gt;
&lt;p&gt;push eax ;將a壓棧&lt;/p&gt;
&lt;p&gt;call g ;調用g&lt;/p&gt;
&lt;p&gt;add esp,8 ;將a和b一起彈出，恢復調用前的棧&lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ;將返回值保存進變量i&lt;/p&gt;
&lt;p&gt;mov esp,ebp ;恢復棧頂&lt;/p&gt;
&lt;p&gt;pop ebp ;恢復棧底&lt;/p&gt;
&lt;p&gt;g:&lt;/p&gt;
&lt;p&gt;push ebp ;備份ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ;建立棧底&lt;/p&gt;
&lt;p&gt;sub esp,4 ;爲局部變量c在棧中分配內存&lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp+8] ;通過ebp間接讀取參數a的值&lt;/p&gt;
&lt;p&gt;mov ebx,dword ptr[ebp+12] ;通過ebp間接讀取參數b的值&lt;/p&gt;
&lt;p&gt;add eax,ebx ;將a和b的值相加，之和存在eax中&lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ;將和存入變量c&lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp-4] ;將c作爲返回值，代碼優化後會刪除此句&lt;/p&gt;
&lt;p&gt;add esp,4 ;銷燬c的內存&lt;/p&gt;
&lt;p&gt;mov esp,ebp ;恢復棧頂&lt;/p&gt;
&lt;p&gt;pop ebp ;恢復棧底&lt;/p&gt;
&lt;p&gt;ret ;返回函數f&lt;/p&gt;
&lt;p&gt;棧的內存佈局如下：&lt;/p&gt;
&lt;p&gt;100076:c &amp;lt;- g的esp&lt;/p&gt;
&lt;p&gt;100080:f的ebp=100100 &amp;lt;- g的ebp&lt;/p&gt;
&lt;p&gt;100084:f的eip&lt;/p&gt;
&lt;p&gt;100088:a=1&lt;/p&gt;
&lt;p&gt;100092:b=2&lt;/p&gt;
&lt;p&gt;100096:i&lt;/p&gt;
&lt;p&gt;100100:舊ebp &amp;lt;-f的ebp&lt;/p&gt;
&lt;p&gt;100104:……&lt;/p&gt;
&lt;p&gt;注意在函數g的彙編代碼中，訪問函數的局部變量和訪問函數參數的區別。局部變量總是通過將ebp減去偏移量來訪問，函數參數總是通過將ebp加上偏移量來訪問。對於32位變量而言，第一個局部變量位於ebp-4，第二個位於ebp-8，以此類推，32位局部變量在棧中形成一個逆序數組；第一個函數參數位於ebp+8，第二個位於ebp+12，以此類推，32位函數參數在棧中形成一個正序數組。&lt;/p&gt;
&lt;p&gt;由於函數返回值通過寄存器返回，不需要空間分配等操作，所以返回值的代價很低。基於這個原因，舊的C語法約定，不寫明返回值類型的函數，返回值類型爲int。這一規則與現行的C++語法相違背，因爲C++中，不寫明返回值類型的函數返回值類型爲void，表示不返回值。這種語法不兼容性是爲了加強C++的類型安全，但同時也帶來了一些問題。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.5 I386平臺的邊界對齊(Align)</title><link href="//farseerfc.github.io/c-tricks-2-5-address-alignment.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-5-address-alignment.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h2&gt;2.5 I386平臺的邊界對齊(Align)&lt;/h2&gt;
&lt;p&gt;首先提問，既然I386上sizeof(int)==4、sizeof(char)==1，那麼如下結構(struct)A的sizeof是多少？&lt;/p&gt;
&lt;p&gt;struct A{int i;char c;};&lt;/p&gt;
&lt;p&gt;答案是sizeof(A)==8……1+5=8？&lt;/p&gt;
&lt;p&gt;呵呵，這就是I386上的邊界對齊問題。我們知道，I386上有整整&lt;span class="caps"&gt;4GB&lt;/span&gt;的地址空間，不過並不是每一個字節上都可以放置任何東西的。由於內存總線帶寬等等的技術原因，很多體系結構都要求內存中的變量被放置於某一個邊界的地址上。如果違反這個要求，重則導致停機出錯，輕則減慢運行速度。對於I386平臺而言，類型爲T的變量必須放置在sizeof(T)的整數倍的地址上，char可以隨便放置，short必須放在2的整數倍的地址上，int必須放在4的整數倍的地址上，double必須放在8的整數倍的地址上。如果違反邊界對齊要求，從內存中讀取數據必須進行兩次，然後將獨到的兩半數據拼接起來，這會嚴重影響效率。&lt;/p&gt;
&lt;p&gt;由於邊界對齊問題的要求，在計算struct的sizeof的時候，編譯器必須算入額外的字節填充，以保證每一個變量都能自然對齊。比如如下聲明的struct:&lt;/p&gt;
&lt;p&gt;struct &lt;span class="caps"&gt;WASTE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;實際上相當於聲明瞭這樣一個結構：&lt;/p&gt;
&lt;p&gt;struct &lt;span class="caps"&gt;WASTE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;char _filling1 [3];//三個字節填充，保證下一個int的對齊&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2；&lt;/p&gt;
&lt;p&gt;char _filling2 [3];//又三個字節填充&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;值得注意的是尾部的3個字節填充，這是爲了可以在一個數組中聲明&lt;span class="caps"&gt;WASTE&lt;/span&gt;變量，並且每一個都自然對齊。因爲有了這些填充，所以sizeof(&lt;span class="caps"&gt;WASTE&lt;/span&gt;)==12。這是一種浪費，因爲只要我們重新安排變量的聲明，就可以減少sizeof：&lt;/p&gt;
&lt;p&gt;struct &lt;span class="caps"&gt;WASTE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c1,c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;像這樣的安排，sizeof就減少到8，只有2個字節的額外填充。爲了與彙編代碼相兼容，C語言語法規定，編譯器無權擅自安排結構體內變量的佈局順序，必須從左向右逐一排列。所以，妥當安排成員順序以避免內存空間的浪費，就成了我們程序員的責任之一。一般的，總是將結構體的成員按照其sizeof從大到小排列，double在最前，char在最後，這樣總可以將結構的字節填充降至最小。&lt;/p&gt;
&lt;p&gt;C++繼承了C語言關於結構體佈局的規定，所以以上的佈局準則也適用於C++的class的成員變量。C++進一步擴展了佈局規定，同一訪問區段(private、public、protected)中的變量，編譯器無權重新排列，不過編譯器有權排列訪問區段的前後順序。基於這個規則，C++中有的程序員建議給每一個成員變量放在單獨區段，在每一個成員聲明之前都加上private:、public:、protected:標誌，這可以最大限度的利用編譯器的決策優勢。&lt;/p&gt;
&lt;p&gt;在棧中按順序分配的變量，其邊界也受到對齊要求的限制。與在結構中不同的是，棧中的變量還必須保證其後續變量無論是何種類型都可以自由對齊，所以在棧中的變量通常都有平臺相關的對齊最小值。在&lt;span class="caps"&gt;MSVC&lt;/span&gt;編譯器上，這個最小值可以由宏_INTSIZEOF(T)查詢：&lt;/p&gt;
&lt;p&gt;#define _INTSIZEOF(T) ( (sizeof(T) + sizeof(int) - 1) &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; ~(sizeof(int) -
1) )&lt;/p&gt;
&lt;p&gt;_INTSIZEOF(T)會將sizeof(T)進位到sizeof(int)的整數倍。&lt;/p&gt;
&lt;p&gt;由於在棧中分配變量使用_INTSIZEOF而不是sizeof，在棧上連續分配多個小變量(sizeof小於int的變量)會造成內存浪費，不如使用結構(struct)或數組。也就是說：&lt;/p&gt;
&lt;p&gt;char c1,c2,c3,c4;//使用16字節&lt;/p&gt;
&lt;p&gt;char c[4];//使用4字節&lt;/p&gt;
&lt;p&gt;當然，使用數組的方法在訪問數組變量(比如c[1])時有一次額外的指針運算和提領(dereference)操作，這會有執行效率的損失。這又是一種空間(內存佔用)vs時間(執行效率)的折中，需要程序員自己根據情況權衡利弊。&lt;/p&gt;
&lt;p&gt;sizeof的大小可能比我們預期的大，也可能比我們預期的小。對於空類：&lt;/p&gt;
&lt;p&gt;class Empty {};&lt;/p&gt;
&lt;p&gt;在通常情況下，sizeof(Empty)至少爲1。這是因爲C++語法規定，對於任何實體類型的兩個變量，都必須具有不同的地址。爲了符合語法要求，編譯器會給Empty加入1字節的填充。所以sizeof()的值不可能出現0的情況。可是對於以下的類聲明：&lt;/p&gt;
&lt;p&gt;class A:public Empty{vitual ~A(){}};&lt;/p&gt;
&lt;p&gt;sizeof(A)有可能是6，也有可能是5，也有可能是4！必不可少的四個字節是一個指向虛函數表的指針。一個可能有的字節是Empty的大小，這是是因爲編譯器在特定情況下會將Empty視作一個“空基類”，從而實施“空基類優化”，省掉那毫無作用的一字節填充。另一個字節是A的一字節填充，因爲從語法上講，A沒有成員聲明，理應有1字節填充，而從語義上講，編譯器給A的聲明加入了一個指向虛函數表的指針，從而A就不再是一個“空類”，是否實施這個優化，要看編譯器作者對語法措詞的理解。也就是說，sizeof也會出現4+1+1=4的情況。具體要看編譯器有沒有實施“空基類優化”和“含虛函數表的空類優化”。&lt;/p&gt;
&lt;p&gt;結構和類的空間中可能有填充的字節，這意味着填充字節中可能有數值，雖然這數值並不影響結構的邏輯狀態，但是它也可能不知不覺中影響到你。比如說，你手頭正好有一組依賴於底層硬件(比如多處理器)的函數，他們在操縱連續字節時比手動編碼要快很多，而你想充分利用這種硬件優勢：&lt;/p&gt;
&lt;p&gt;bool BitCompare(void* begin,void* end,void* another);&lt;/p&gt;
&lt;p&gt;這個函數將區間[begin,end)之間的字節與another開始的字節相比較，如果有一位不同就返回false，否則返回true。&lt;/p&gt;
&lt;p&gt;比如你想將這個函數用於你自己的類的operator==中，這樣可以利用硬件加快速度。不過你在動手前要充分考慮，你的class是否真的要比較每一位。如果在類的成員中存在編譯器填充的字節數，那麼應用以上的函數就是不正確的，因爲填充的字節中可以有不同的值。爲了保證你可以用Bitwise
Compare，你必須確保填充的字節中的值也是相同的。這不僅要求你在類的構造函數中初始化類的每一bit而不是每一個成員，也要求你在複製初始化和複製賦值函數中也同時保證bitwise copy語義，而不是編譯器默認產生的memberwise語義。當然，你可能通過與BitCompare一同提供的BitCopy來完成這個艱鉅的任務。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.6 I386平臺C函數的可變參數表(Variable Arguments)</title><link href="//farseerfc.github.io/c-tricks-2-6-i386-variable-arguments.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-6-i386-variable-arguments.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h2&gt;2.6 I386平臺C函數的可變參數表(Variable Arguments)&lt;/h2&gt;
&lt;p&gt;基於前文(2.4節)分析，我們可以不通過函數簽名，直接通過指針運算，來得到函數的參數。由於參數的壓棧和彈出操作都由主調函數進行，所以被調函數對於參數的真實數量不需要知曉。因此，函數簽名中的變量聲明不是必需的。爲了支持這種參數使用形式，C語言提供可變參數表。可變參數表的語法形式是在參數表末尾添加三個句點形成的省略號“…”：&lt;/p&gt;
&lt;p&gt;void g(int a,char* c,…);&lt;/p&gt;
&lt;p&gt;省略號之前的逗號是可選的，並不影響詞法語法分析。上面的函數g可以接受2個或2個以上的參數，前兩個參數的類型固定，其後的參數類型未知，參數的個數也未知。爲了知道參數個數，我們必須通過其他方法，比如通過第一個參數傳遞：&lt;/p&gt;
&lt;p&gt;g(3,”Hello”,2,4,5);//調用g並傳遞5個參數，其中後3個爲可變參數。&lt;/p&gt;
&lt;p&gt;在函數的實現代碼中，可以通過2.4節敘述的，參數在棧中的排列順序，來訪問位於可變參數表的參數。比如:&lt;/p&gt;
&lt;p&gt;void g(int a,char* c…){&lt;/p&gt;
&lt;p&gt;void *pc=&amp;amp;c;int* pi=static_cast&amp;lt;int*&amp;gt;(pc)+1;//將pi指向首個可變參數&lt;/p&gt;
&lt;p&gt;for(int i=0;i&amp;lt;a;i++)std::cout&amp;lt;&amp;lt;pi[i]&amp;lt;&amp;lt;” ”；&lt;/p&gt;
&lt;p&gt;std::cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;std::endl;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;我們甚至可以讓一個函數的所有參數都是可變參數，只要有辦法獲知參數的數量即可。比如，我們約定，在傳遞給addAll的參數都是int，並且最後一個以0結束：&lt;/p&gt;
&lt;p&gt;int addAll(…);&lt;/p&gt;
&lt;p&gt;int a=f(1,4,2,5,7,0);&lt;/p&gt;
&lt;p&gt;那麼addAll可以這樣實現：&lt;/p&gt;
&lt;p&gt;int addAll(…){&lt;/p&gt;
&lt;p&gt;int sum=0;int *p=&amp;amp;sum; //p指向第一個局部變量&lt;/p&gt;
&lt;p&gt;p+=3; //跳過sum，ebp，eip，現在p指向第一個參數&lt;/p&gt;
&lt;p&gt;for(;*p;++p) //如果p不指向0就繼續循環&lt;/p&gt;
&lt;p&gt;sum+=*p;&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;可變參數表的最廣泛應用是C的標準庫函數中的格式化輸入輸出：printf和scanf。&lt;/p&gt;
&lt;p&gt;void printf(char *c,…);&lt;/p&gt;
&lt;p&gt;void scanf(char *c,…);&lt;/p&gt;
&lt;p&gt;兩者都通過它的首個參數指出後續參數表中的參數類型和參數數量。&lt;/p&gt;
&lt;p&gt;如果可變參數表中的參數類型不一樣，那麼操縱可變參數表就需要複雜的指針運算，並且還要時刻注意邊界對齊(align)問題，非常令人頭痛。好在C標準庫提供了用於操縱可變參數表的宏(macro)和結構(struct)，他們被定義在庫文件stdarg.h中:&lt;/p&gt;
&lt;p&gt;typedef struct {char *p;int offset;} va_list;&lt;/p&gt;
&lt;p&gt;#define va_start(valist,arg)&lt;/p&gt;
&lt;p&gt;#define va_arg(valist,type)&lt;/p&gt;
&lt;p&gt;#define va_end(valist)&lt;/p&gt;
&lt;p&gt;其中結構va_list用於指示參數在棧中的位置，宏va_start接受一個va_list和函數的可變參數表之前的參數，通過第一個參數初始化va_list中的相應數據，因此要使用stdarg.h中的宏，你的可變參數表的函數必須至少有一個具名參數。va_arg返回下一個類型爲type的參數，va_end結束可變參數表的使用。還是以上文的addAll爲例，這次寫出它的使用標準宏的版本：&lt;/p&gt;
&lt;p&gt;int addAll(int i,…)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;va_list vl; //定義一個va_list結構&lt;/p&gt;
&lt;p&gt;va_start(vl,i); //用省略號之前的參數初始化vl&lt;/p&gt;
&lt;p&gt;if(i=0)return 0; //如果第一個參數就是0，返回&lt;/p&gt;
&lt;p&gt;int sum=i; //將第一個參數加入sum&lt;/p&gt;
&lt;p&gt;for(;;){&lt;/p&gt;
&lt;p&gt;i=va_arg(vl,int); //取得下一個參數，類型是sum&lt;/p&gt;
&lt;p&gt;if(i==0)break; //如果參數是0，跳出循環&lt;/p&gt;
&lt;p&gt;sum+=i;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;va_end(vl);&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;可以看出，如果參數類型一致，使用標準庫要多些幾行代碼。不過如果參數類型不一致或者未知(printf的情況)，使用標準庫就要方便很多，因爲我們很難猜出編譯器處置邊界對齊(align)等彙編代碼的細節。使用標準庫的代碼是可以移植的，而使用上文所述的其它方法操縱可變參數表都是不可移植的，僅限於在I386平臺上使用。&lt;/p&gt;
&lt;p&gt;縱使可變參數表有使用上的便利性，它的缺陷也有很多，不可移植性和平臺依賴性只是其一，最大的問題在於它的類型不安全性。使用可變參數表就意味着編譯器不對參數作任何類型檢查，這在C中算是一言難盡的歷史遺留問題，在C++中就意味着惡魔reinterpret_cast被你喚醒。C的可變參數表是C++代碼錯誤頻發的根源之一，以至於C++標準將可變參數表列爲即將被廢除的C語言遺留特性。C++語法中的許多新特性，比如重載函數、默認參數值、模板，都可以一定程度上替代可變參數表，並且比可變參數表更加安全。&lt;/p&gt;
&lt;p&gt;可變參數表在C++中惟一值得嘉獎的貢獻，是在模板元編程(&lt;span class="caps"&gt;TMP&lt;/span&gt;)的&lt;span class="caps"&gt;SFINAE&lt;/span&gt;技術中利用可變參數表製作最差匹配重載。根據C++標準中有關函數重載決議的規則，具有可變參數表的函數總是最差匹配，編譯器在被逼無奈走頭無路時纔會選擇可變參數表。利用這一點，我們可以精心製作重載函數來提取類型信息。比如，要判斷一個通過模板傳遞來的類型是不是int：&lt;/p&gt;
&lt;p&gt;long isIntImp(int);&lt;/p&gt;
&lt;p&gt;char isIntImp(…);&lt;/p&gt;
&lt;p&gt;template&amp;lt;typename T&amp;gt;&lt;/p&gt;
&lt;p&gt;struct isInt&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;enum{value=sizeof(isIntImp(T()))==sizeof(long);}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;然後，在一個具有模板參數T的函數中，我們就可以寫&lt;/p&gt;
&lt;p&gt;if(isInt&amp;lt;T&amp;gt;::value)//…&lt;/p&gt;
&lt;p&gt;在這個(不怎麼精緻的)例子中，如果T是int，那麼isIntImp的第一個重載版本就會被選中，返回值類型就是long，這樣value就爲1。否則，編譯器只能選中第二個具有可變參數表的重載版本，返回值類型成爲char，這樣value就爲0。把它說得再明白一些，上文的代碼所表達的意思是：如果類型T是int，那它就是int，否則它就不是int，呵呵簡單吧。這種通過重載決議規則來提取類型信息的技術，在模板元編程中被稱作&lt;span class="caps"&gt;SFINAE&lt;/span&gt;，它和其它模板元編程技術被廣泛運用於&lt;span class="caps"&gt;STL&lt;/span&gt;、Boost等模板庫的開發實現之中。&lt;/p&gt;
&lt;p&gt;值得注意的是，在上文&lt;span class="caps"&gt;SFINAE&lt;/span&gt;的運用中，isIntImp並沒有出現定義而只提供了聲明，因爲我們並沒有實際調用isIntImp函數，而只是讓它參與重載決議並用sizeof判斷其返回值類型。這是C++的一個設計準則的完美體現：不需要的東西可以不出現。由於這一準則，我們避免了在C++中調用具有可變參數表的函數這一危險舉動，而僅僅利用了可變參數表在語法分析過程中的特殊地位，這種對於危險語言特性的巧妙利用是善意而無害的。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.7 I386平臺的其它函數調用模型</title><link href="//farseerfc.github.io/c-tricks-2-7-i386-calling-conventions.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-7-i386-calling-conventions.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.7 I386平臺的其它函數調用模型&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;上文介紹的只是I386平臺上C函數調用的標準模型，被稱作__cdecl。事實上，Microsoft Visual C++編譯器還支持其它一些函數調用模型，所有調用模型名稱皆以雙下劃線開頭，下面列出所有函數調用模型的異同：&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="cdecl"&gt;
&lt;h3&gt;1 __cdecl&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：主調函數(caller)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__cdecl明確地指出函數使用C函數調用模型，這是默認的調用模型。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stdcall"&gt;
&lt;h3&gt;2 __stdcall&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__stdcall是微軟所謂的標準調用模型。可惜的是它與__cdecl不兼容。幾乎所有的Win32API函數使用這種函數調用模型，希望在&lt;span class="caps"&gt;DLL&lt;/span&gt;之間，或者在程序和WinNT操作系統之間傳遞函數指針的函數也應該使用這種模型。與__cdecl模型的不同之處在於，__stdcall模型下由被調函數恢復堆棧。主調函數在call語句之後，不需要再加上add語句。而被調函數的ret語句則被添加一個參數，代表函數參數堆棧的長度。因此，被調函數需要明確的知曉函數參數的數量和類型，所以在__stdcall模型下不支持可變參數表，所有參數必須寫明。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="thiscall"&gt;
&lt;h3&gt;3 __thiscall&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)，this用ecx傳遞。&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__thiscall是&lt;span class="caps"&gt;VC&lt;/span&gt;編譯器中類的非靜態成員函數(non-static member functon)的默認調用模型。但是如果此成員函數有可變參數表，&lt;span class="caps"&gt;VC&lt;/span&gt;編譯器會使用__cdecl。和__stdcall一樣，__thiscall由被調函數恢復堆棧。比較獨特的是__thiscall會通過ecx寄存器傳遞成員函數的this指針，而__cdecl下this指針是通過在參數表最前面增加一個函數參數來傳遞的。__thiscall是&lt;span class="caps"&gt;VC&lt;/span&gt;編譯器對this指針的使用的一種優化，大大提高了面向對象程序的效率。在&lt;span class="caps"&gt;VC2003&lt;/span&gt;及之前的編譯器上__thiscall不是一個關鍵字，不能被顯式指定。但可以給成員函數顯式指定__cdecl來避免使用__thiscall。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="fastcall"&gt;
&lt;h3&gt;4 __fastcall&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：逆序(從右至左)，前兩個32位函數參數放入ecx和edx中&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;快速函數調用模型，將前兩個32位函數參數放入ecx和edx中，其餘參數再逆序壓棧。使用的是和__thiscall類似的優化技術，加快函數調用，適合運用在小型inline函數上。同樣使用__stdcall形式的被調函數恢復堆棧，所以不支持可變參數表。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pascal"&gt;
&lt;h3&gt;5 __pascal&lt;/h3&gt;
&lt;p&gt;參數壓棧順序：正序(從左至右)&lt;/p&gt;
&lt;p&gt;參數堆棧恢復者：被調函數(callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;過程式編程語言Pascal所使用的函數調用模型，由此得名。也是16位版本的Windows使用的&lt;span class="caps"&gt;API&lt;/span&gt;模型，過時的模型，現在已經廢棄且禁止使用。你會看到有些書本仍會不時提到它，所以需要注意。__pascal是正序壓棧，這與大部分I386函數模型都不相同。與__stdcall一樣，由被調者恢復堆棧，不支持可變參數表。歷史上曾有過的別名&lt;span class="caps"&gt;PASCAL&lt;/span&gt;、pascal、_pascal(單下劃線)，現在都改成了__stdcall的別名，與__pascal(雙下劃線)不同。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;6 其它函數調用模型，以及模型別名。&lt;/h3&gt;
&lt;p&gt;__syscall：操作系統內部使用的函數調用模型，由用戶模式向核心模式跳轉時使用的模型。由於用戶模式和核心模式使用不同的棧，所以沒辦法使用棧來傳遞參數，所有參數通過寄存器傳遞，這限制了參數的數量。用戶模式編程中不允許使用。&lt;/p&gt;
&lt;p&gt;__fortran：數學運算語言fortran使用的函數模型，由此得名。在C中調用由fortran編譯的函數時使用。&lt;/p&gt;
&lt;p&gt;__clrcall：微軟.Net框架使用的函數模型，託管(Managed)C++默認使用，也可以從非託管代碼調用託管函數時使用。參數在託管棧上正序(從左至右)壓棧，不使用普通棧。&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;CALLBACK&lt;/span&gt;、&lt;span class="caps"&gt;PASCAL&lt;/span&gt;、&lt;span class="caps"&gt;WINAPI&lt;/span&gt;、&lt;span class="caps"&gt;APIENTRY&lt;/span&gt;、&lt;span class="caps"&gt;APIPRIVATE&lt;/span&gt;：I386平臺上是__stdcall的別名&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;span class="caps"&gt;WINAPIV&lt;/span&gt;：I386平臺上是__cdecl的別名&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;7 函數調用模型的指定&lt;/h3&gt;
&lt;p&gt;函數調用模型的指定方式和inline關鍵字的指定方式相同，事實上，inline可以被看作是C++語言內建的一種函數調用模型。唯一不同的是，聲明函數指針時，也要指明函數調用模型，而inline的指針是不能指明的，根本不存在指向inline函數的指針。比如：&lt;/p&gt;
&lt;p&gt;int &lt;span class="caps"&gt;CALLBACK&lt;/span&gt; GetVersion();&lt;/p&gt;
&lt;p&gt;int (&lt;span class="caps"&gt;CALLBACK&lt;/span&gt; * pf)()=GetVersion;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.1 X86概述</title><link href="//farseerfc.github.io/c-tricks-2-1-x86-architecture.html" rel="alternate"></link><updated>2007-08-27T16:33:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-27:c-tricks-2-1-x86-architecture.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="x86"&gt;
&lt;h2&gt;2.1   X86概述&lt;/h2&gt;
&lt;p&gt;所謂X86體系結構，是指以Intel
8086芯片爲首的芯片所沿襲的&lt;span class="caps"&gt;CPU&lt;/span&gt;結構，一些文檔中又被稱作&lt;span class="caps"&gt;IA32&lt;/span&gt;體系結構。包括的芯片有但不限於:Intel
8086至
80486，奔騰(Pentium)系列處理器1至4，賽揚系列處理器，酷睿系列處理器，以及&lt;span class="caps"&gt;AMD&lt;/span&gt;的相應型號產品。X86體系結構在早期屬於16位處理器，自80386之後擴展爲32位處理器，所以一些文檔中又把80386之後的32位處理器體系稱作I386。自Pentium4後期，&lt;span class="caps"&gt;AMD&lt;/span&gt;的Athlon64開始，I386被進一步擴充爲64位處理器，含有64位尋址能力的X86體系結構被稱作X86-64或&lt;span class="caps"&gt;IA32&lt;/span&gt;-64。總之，市售的個人電腦用&lt;span class="caps"&gt;CPU&lt;/span&gt;，除蘋果的Macintosh之外，全部採用X86體系結構芯片。&lt;/p&gt;
&lt;p&gt;在X86早期，16位的尋址能力只支持&lt;span class="caps"&gt;64KB&lt;/span&gt;(2^16=64K)內存，這顯然是不夠的。Intel採用分段尋址的方法，用4位段位+16位偏移量，提供了總共&lt;span class="caps"&gt;1MB&lt;/span&gt;(2^20=1M)的尋址能力。所以在X86的16位編程中，有兩種指針類型：長指針(lp,long
pointer)和短指針(sp,short
pointer)，長指針(20位)提供整個內存空間尋址能力，短指針(16位)僅支持同一段中的尋址。在“古代”&lt;span class="caps"&gt;DOS&lt;/span&gt;及Win3.x編程過程中，兩種類型的指針，以及總共&lt;span class="caps"&gt;1MB&lt;/span&gt;的內存大小，常常把程序員們折騰得焦頭爛額。&lt;/p&gt;
&lt;p&gt;自I386之後，&lt;span class="caps"&gt;CPU&lt;/span&gt;纔開始提供32位的尋址能力。有了整整&lt;span class="caps"&gt;4GB&lt;/span&gt;(2^32=4G)的尋址空間，所有指針統一爲長指針(32位)。時至今日，我們仍可以看到微軟文檔中指針變量的lp前綴。由於內存管理的需要，分段機制被保留下來，但這一次不是因爲地址空間太小，而是因爲地址空間遠大於實際內存容量，從而採用了虛擬內存機制。&lt;/p&gt;
&lt;p&gt;在從16位結構向32位結構轉變的過程中，由於向下兼容的歷史原因，曾一度長時間出現硬件32位(I386)、軟件16位(Win3.x)的情況。同樣也是爲了兼容16位軟件，Win9x操作系統(Win95、Win98、WinME)保留了16位代碼和32位代碼。混合代碼的設計使得Win9x及其混亂和不穩定。直到完全32位內核的操作系統WinNT(以及構建於其上的Win2000，WinXP，Win2003)的出現，X86平臺上內存佈局混亂的局面才得以改善。有了從16位至32位移植的經驗和準備，現今的從32位到64位的操作系統移植顯得平穩順利很多。WinXP和WinVista系統都同時發佈了32位版本和64位版本，並且其x86-64系統都實現了對32位軟件的無縫銜接支持。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 1.2 逗號運算符(,)、邏輯運算符(&amp;&amp;,||)與運算符重載的陷阱</title><link href="//farseerfc.github.io/c-tricks-1-2-trap-in-comma-logical-operator.html" rel="alternate"></link><updated>2007-08-22T18:06:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-22:c-tricks-1-2-trap-in-comma-logical-operator.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.2   逗號運算符(,)、邏輯運算符(&amp;amp;&amp;amp;,||)與運算符重載的陷阱&lt;/h2&gt;
&lt;p&gt;很多人甚至不知道逗號(,)也是個C++運算符。與語法上要求出現的逗號(比如分隔函數參數的逗號)不同的是，出現在表達式中的逗號運算符在語義上表示多個表達式操作的連續執行，類似於分隔多語句的分號。比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt;(&lt;strong&gt;int&lt;/strong&gt;i=0,j=9;i&amp;lt;10;++i&lt;strong&gt;,&lt;/strong&gt;—j)std::cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;”+”&amp;lt;&amp;lt;j&amp;lt;&amp;lt;”=9\n”;&lt;/p&gt;
&lt;p&gt;在這句語句中，出現了兩個逗號，其中前者是語法上用來分隔聲明的變量的，並非逗號運算符，而後者則是一個逗號運算符。根據C++標準，逗號運算符的執行順序爲從左到右依次執行，返回最後一個子表達式的結果。由於只有最後一個表達式返回結果，所以對於一個語義正常的逗號表達式而言，前幾個子表達式必須具有副作用。同時，從語言的定義中也可以看出，逗號表達式對求值的順序有嚴格要求。&lt;/p&gt;
&lt;p&gt;對求值順序有要求的，除了逗號表達式和條件表達式(參見1.1)，在C++中還有邏輯運算符(&amp;amp;&amp;amp;和||)。邏輯運算相較於數學運算和位運算而言，有個顯著的不同點：邏輯運算在計算到一半時，就有可能已經得到結果，這樣繼續運算另一半就不是必需的。對於A&amp;amp;&amp;amp;B，如果A=false，那麼無論B爲何值，整個的結果都是false；同樣的A||B，如果A=true，那麼不考慮B，結果一定是true。&lt;/p&gt;
&lt;p&gt;C++標準規定，如果邏輯運算到一半(算出A)時，就已經可以確定運算的結果，那麼就不運算剩下的另一半(B)。這種執行語義被稱作“短路”。在其它一些編程語言中，短路語義是可以選擇的：在Ada裏非短路的邏輯運算符爲and和or，短路的邏輯運算符爲and_then和or_else。但是在C++中，邏輯運算符的短路語義是語法上強制的，我們沒有非短路版本的運算符。如果確實需要非短路語義，我們總是可以通過增加一個bool中間變量加以解決。有時，短路對於保證正確執行是必須的，比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char&lt;/strong&gt;*p=getString();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(p&lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;*p)std::cout&amp;lt;&amp;lt;p;&lt;/p&gt;
&lt;p&gt;這段代碼在得到了一個字符串後，在字符串不爲空時輸出它。在C++中判斷一個字符串不爲空需要兩個步驟：判斷指針是否爲0，以及指針不爲0時判斷指針指向的內容是否爲’’。就像條件表達式中討論到的(參見1.1)，在p爲空時提領p是個極其危險的操作。邏輯運算符的短路語義則避免了這種危險。&lt;/p&gt;
&lt;p&gt;以上對逗號運算符與邏輯運算符的討論，僅限於C++標準所定義的運算符語義。爲什麼這樣說呢？這是因爲在C++中，運算符的語義是可以由程序員自行定義的，這種機制叫做運算符重載(operator overload)。運算符重載可以將人們熟悉的運算符表達式轉換成函數調用，使編程靈活而直觀，是個方便的語言特性。不過有時運算符重載也會使人困擾，那就是當運算符重載遇到求值順序問題時。&lt;/p&gt;
&lt;p&gt;C++中，並不是所有合法運算符都可以被合法地重載。條件運算符雖然對求值順序有要求，但它並不在可重載運算符之列，所以運算符重載機制對它沒有影響。問題在於，逗號運算符和邏輯運算符都可以被合法地重載：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class&lt;/strong&gt; BadThing{/* Some Bad and Stupid Thing*/};&lt;/p&gt;
&lt;p&gt;BadThing&amp;amp; &lt;strong&gt;operator&lt;/strong&gt;,(BadThing&amp;amp;, BadThing&amp;amp;);//重載了逗號運算符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bool&lt;/strong&gt; &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(BadThing&amp;amp;, BadThing&amp;amp;);//重載了&amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;BadThing b1,b2;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(b1&amp;amp;&amp;amp;b2)b1,b2;//被替換成如下形式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(b1,b2))&lt;strong&gt;operator&lt;/strong&gt;,(b1,b2);&lt;/p&gt;
&lt;p&gt;可以看到，重載了運算符之後，對運算符的使用被替換爲相應的函數調用形式。因此，舊有的運算符的執行順序不再適用，取而代之的是函數參數的壓棧順序。&lt;/p&gt;
&lt;p&gt;根據C++標準規定，任何參數必須在進入函數之前壓棧，所以在進入&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;之前，b1、b2就會被求值，這裏不再有短路規則，任何依賴於短路語義的不知不覺間操作BadThing的代碼(可能通過模板)都會混亂。&lt;/p&gt;
&lt;p&gt;短路語義只是一個方面，更重要的在於壓棧順序。鑑於執行效率和舊代碼兼容性等細節問題，C++標準在壓棧順序上給編譯器的開發者留有很大自主性。標準的說辭是，編譯器可能以任何它覺得方便的順序將參數壓棧，從左到右，從右到左，甚至從中間到兩邊，在這一點上我們不能安全地做任何假設。在上面的例子中，編譯器生成的代碼可能先計算b1再計算b2，也可能是相反的順序。再看看編譯器的實際情況，在我試過的所有基於X86體系結構的編譯器中，參數都是以逆向壓棧，即從右到左，有悖於大多數人的閱讀習慣和直覺(別說你是來自伊斯蘭的……)。&lt;/p&gt;
&lt;p&gt;在C時代使用函數調用時，壓棧順序並不是什麼大問題，畢竟大多數人會在函數調用的邊界稍稍小心一些。但是到了C++中，事情變得有些複雜，因爲簡單如a+b的使用，就有可能被運算符重載機制替換爲函數調用。更何況有模板參與之後，我們寫代碼時不能確定對象的真實類型，也就無法預知一個運算符是否真的被重載過，唯一穩妥的方法是，假定任何有可能被重載的運算符的使用都是函數調用。&lt;/p&gt;
&lt;blockquote&gt;
&amp;lt;p style="margin:0;"&amp;gt;&lt;/blockquote&gt;
&lt;p&gt;回到上文的示例中，由於,和&amp;amp;&amp;amp;都被替換爲函數調用，程序的執行順序將成爲壓棧順序，在X86上很有可能是從右到左，與標準定義的運算符的順序正好相反。逗號運算符原本就含有“先…後…”的語義，這種顛倒的執行順序勢必造成程序和程序員的混亂。以我的經驗而言，含有&lt;strong&gt;operator&lt;/strong&gt;,的類，完全沒有辦法和&lt;span class="caps"&gt;STL&lt;/span&gt;或者iostream相互協作，反而會導致巨量的錯誤報告(什麼叫巨量的錯誤報告有概念麼？如果沒有，那說明你還沒玩過範式編程(&lt;span class="caps"&gt;GP&lt;/span&gt;,
Generic
Programming)。去玩玩&lt;span class="caps"&gt;GP&lt;/span&gt;吧，看看你的編譯器對巨量的定義。在我手頭，針對3.&lt;span class="caps"&gt;5KB&lt;/span&gt;的代碼文件傾瀉出3.8&lt;strong&gt;&lt;span class="caps"&gt;MB&lt;/span&gt;&lt;/strong&gt;的錯誤信息的編譯器不在少數……)。有鑑於此，我的結論是，除非你有充足的依據支持你這麼做(比如你的粗暴上司的鍵盤上只剩下逗號能用)，並且你清楚的瞭解這麼做的後果的嚴重性(比如至少要看過此文)，否則我奉勸你，永遠不要碰&lt;strong&gt;operator&lt;/strong&gt;,、&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;以及&lt;strong&gt;operator&lt;/strong&gt;||！&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 1.1 條件運算符(?:)</title><link href="//farseerfc.github.io/c-tricks-1-1-conditional-operator.html" rel="alternate"></link><updated>2007-08-22T18:05:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-22:c-tricks-1-1-conditional-operator.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt; 導入&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.1   條件運算符(?:)&lt;/h2&gt;
&lt;p&gt;條件運算符(?:)是C++中唯一的三目運算符(trinary
operator)，用於在表達式中作條件判斷，通常可以替換if語句，與Visual Basic中的iif函數、Excel中的if函數有同樣的作用。語法形式如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;condition&lt;/em&gt; ? &lt;em&gt;true_value&lt;/em&gt; : &lt;em&gt;false_value&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;em&gt;condition
*條件是任何可以轉換爲bool類型的表達式，包括但不僅限於**bool*&lt;/em&gt;、&lt;strong&gt;int&lt;/strong&gt;、指針。與&lt;strong&gt;if&lt;/strong&gt;和&lt;strong&gt;while&lt;/strong&gt;的條件部分稍顯不同的是，這裏不能定義變量，否則會導致語法錯誤。&lt;/p&gt;
&lt;p&gt;另外，條件語句會切實地控制執行流程，而不僅僅是控制返回值。也就是說，兩個返回值表達式中永遠只有一個會被求值，在表達式的執行順序很重要時，這點尤爲值得注意。比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=pi&lt;strong&gt;?&lt;/strong&gt;*pi&lt;strong&gt;:&lt;/strong&gt;0;&lt;/p&gt;
&lt;p&gt;這裏，只有當pi的值不爲0時，它纔會被提領(dereference)。這種語義保證了程序的正確性，因爲提領一個空指針將導致致命的運行期錯誤(通常是非法操作的警告)。同時，正因爲條件運算符控制運算流程的特點，使得它不能用類似iif的普通函數來模擬：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; iif(&lt;strong&gt;int&lt;/strong&gt; con,&lt;strong&gt;int&lt;/strong&gt; t,&lt;strong&gt;int&lt;/strong&gt;f){&lt;strong&gt;if&lt;/strong&gt;(c)&lt;strong&gt;return&lt;/strong&gt; t;&lt;strong&gt;return&lt;/strong&gt; f;}//試圖模擬?:&lt;/p&gt;
&lt;p&gt;…//in some function&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=iif(pi,*pi,0);//Error!&lt;/p&gt;
&lt;p&gt;這段代碼會導致上文提到的致命運行期錯誤。C/C++標準規定，參數在被傳遞給函數之前求值，因此無論pi爲何值，都會被提領。又因爲函數傳回一個空指針的情況比較少見，所以這樣的錯誤在調試時很難被發現，一旦發生又勢必造成重大災難。這樣的代碼在實踐中應儘量避免。&lt;/p&gt;
&lt;p&gt;有時，條件運算符控制流程的特點會不知不覺影響我們的代碼。在C時代，最大值&lt;span class="caps"&gt;MAX&lt;/span&gt;通常用宏實現：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#define&lt;/strong&gt;&lt;span class="caps"&gt;MAX&lt;/span&gt;(a,b) ((a)&amp;gt;(b)&lt;strong&gt;?&lt;/strong&gt;(a)&lt;strong&gt;:&lt;/strong&gt;(b))&lt;/p&gt;
&lt;p&gt;需要用額外的括號將宏參數和宏本體保護起來，以免運算符優先級擾亂邏輯，這是宏醜陋的特點之一，這裏暫且不提。矛盾在於，用具有副作用的表達式調用宏時，會出現問題：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=5,j=6;//…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=&lt;span class="caps"&gt;MAX&lt;/span&gt;(++i,++j);&lt;/p&gt;
&lt;p&gt;代碼的作者原意顯然是想先將i,j分別遞增，再將其中較大的一個賦給a。執行這段代碼，當i=5,j=6時，a=8，知道爲什麼嗎？通過宏展開，賦值語句成這樣：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=(++i)&amp;gt;(++j)&lt;strong&gt;?&lt;/strong&gt;(++i)&lt;strong&gt;:&lt;/strong&gt;(++j);//刪除了多餘括號&lt;/p&gt;
&lt;p&gt;在判斷之前，i、j被分別自增一次，然後捨棄:之前的部分，j又被自增一次。執行之後，i=6,j=8。&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;MAX&lt;/span&gt;的更正確更安全的實現，是利用模板將類型參數化。&lt;span class="caps"&gt;STL&lt;/span&gt;標準算法中就有一個這樣的工具級模版函數std::max。&lt;/p&gt;
&lt;p&gt;條件運算符是表達式而不是語句，這使得它可以出現在任何需要表達式的地方，這擴大了它的適用範圍。在那些語法上只能出現表達式而不能出現語句的地方（比如變量初始化），條件運算符有着不可替代的作用。&lt;/p&gt;
&lt;p&gt;條件運算符優於&lt;strong&gt;if&lt;/strong&gt;語句的另一個場合是“模板元編程”(&lt;span class="caps"&gt;TMP&lt;/span&gt;, Template
MetaProgramming)。在&lt;span class="caps"&gt;TMP&lt;/span&gt;這個古怪奇異的編譯期運算編程技術中，一切舊有的技術和法則被全線擊破，我們所能仰仗的工具，只有模板特化(Specialization)、&lt;strong&gt;typedef&lt;/strong&gt;s、函數聲明(無法調用它們)、以及編譯期常量運算。已經有人很深入地論證過，僅有以上這些，就已經形成了一個“圖靈完善”的計算機語言。我們可以用模板特化技術，來模擬條件分支，循環迭代等一系列複雜的語言結構。由於可以參與編譯期常量運算，條件運算符在&lt;span class="caps"&gt;TMP&lt;/span&gt;世界中很自然地扮演起重要角色。&lt;/p&gt;
&lt;p&gt;比如，給與類型T的一個變量t，我們想聲明一個緩衝區存放t和一個int，緩衝區的大小不小於sizeof(T)也不小於sizeif(int)，我們可以這樣寫：&lt;/p&gt;
&lt;p&gt;char buffer[sizeof(T)&amp;gt;sizeof(int)? sizeof(T): sizeof(int)];&lt;/p&gt;
&lt;p&gt;我們不能用一個if語句替換這個運算：&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;if(sizeof(T)&amp;gt;sizeof(int))i=sizeof(T);&lt;/p&gt;
&lt;p&gt;else i=sizeof(int);&lt;/p&gt;
&lt;p&gt;char buffer[i];//語法錯誤!&lt;/p&gt;
&lt;p&gt;原因在於數組聲明中的下標必須是一個編譯期常量，而不是一個運行期的值，條件表達式的運算可以在編譯期進行，if語句就只能在執行期執行。&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry></feed>