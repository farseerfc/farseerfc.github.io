<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Farseerfc的小窩</title><link href="//farseerfc.github.io/" rel="alternate"></link><link href="//farseerfc.github.io/feeds/tag-c.atom.xml" rel="self"></link><id>//farseerfc.github.io/</id><updated>2014-12-12T17:06:00+09:00</updated><entry><title>從非緩衝輸入流到 Linux 控制檯的歷史</title><link href="//farseerfc.github.io/from-unbuffered-stdin-to-history-of-linux-tty.html" rel="alternate"></link><updated>2014-12-12T17:06:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2014-12-12:from-unbuffered-stdin-to-history-of-linux-tty.html</id><summary type="html">&lt;html&gt;&lt;body&gt;
&lt;p&gt; 這篇也是源自於水源 C 板上板友的一個問題，涉及 Linux 上的控制檯的實現方式和歷史原因。因爲內容比較長，所以在這裏再排版一下發出來。 &lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1418138991,file,M.1418138991.A.html"&gt; 原帖在這裏 &lt;/a&gt;  。 &lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt; 可以設置不帶緩衝的標準輸入流嗎？ &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;WaterElement(UnChanged)  於 2014 年 12 月 09 日 23:29:51  星期二問到： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 請問對於標準輸入流可以設置不帶緩衝嗎？比如以下程序 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 似乎還是需要在命令行輸入後按回車纔會讓 &lt;code class="code"&gt;
fgets&lt;/code&gt;
  返回，不帶緩衝究竟體現在哪裏？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt; 這和緩存無關，是控制檯的實現方式的問題。 &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 再講細節一點，這裏有很多個程序和設備。以下按 linux  的情況講： &lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 終端模擬器窗口（比如 xterm ）收到鍵盤事件 &lt;/li&gt;
&lt;li&gt; 終端模擬器 (xterm) 把鍵盤事件發給虛擬終端 pty1&lt;/li&gt;
&lt;li&gt;pty1  檢查目前的輸入狀態，把鍵盤事件轉換成 stdin  的輸入，發給你的程序 &lt;/li&gt;
&lt;li&gt; 你的程序的 c  庫從 stdin  讀入一個輸入，處理 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 標準庫說的輸入緩存是在 4  的這一步進行的。而行輸入是在 3  的這一步被緩存起來的。 &lt;/p&gt;
&lt;p&gt; 終端 pty 有多種狀態，一般控制檯程序所在的狀態叫「回顯行緩存」狀態，這個狀態的意思是 :&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 所有普通字符的按鍵，會回顯到屏幕上，同時記錄在行緩存區裏。 &lt;/li&gt;
&lt;li&gt; 處理退格 ( &lt;kbd class="kbd"&gt;
BackSpace&lt;/kbd&gt;
 ) ，刪除 ( &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;
 ) 按鍵爲刪掉字符，左右按鍵移動光標。 &lt;/li&gt;
&lt;li&gt; 收到回車的時候把整個一行的內容發給 stdin 。 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 參考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Cooked_mode"&gt;http://en.wikipedia.org/wiki/Cooked_mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 同時在 Linux/Unix 下可以發特殊控制符號給 pty 讓它進入「 raw 」狀態，這種狀態下按鍵不會被回顯，顯示什麼內容都靠你程序自己控制。如果你想得到每一個按鍵事件需要用 raw 狀態，這需要自己控制回顯自己處理緩衝，簡單點的方法是用 readline  這樣的庫（基本就是「回顯行緩存」的高級擴展，支持了 Home/End ，支持歷史）或者 ncurses  這樣的庫（在 raw 狀態下實現了一個簡單的窗口 /
 事件處理框架）。 &lt;/p&gt;
&lt;p&gt; 參考： &lt;a class="reference external" href="http://en.wikipedia.org/wiki/POSIX_terminal_interface#History"&gt;http://en.wikipedia.org/wiki/POSIX_terminal_interface#History&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 除此之外， &lt;kbd class="kbd"&gt;
Ctrl-C&lt;/kbd&gt;
  轉換到 SIGINT  ， &lt;kbd class="kbd"&gt;
Ctrl-D&lt;/kbd&gt;
  轉換到 EOF  這種也是在 3  這一步做的。 &lt;/p&gt;
&lt;p&gt; 以及，有些終端模擬器提供的 &lt;kbd class="kbd"&gt;
Ctrl-Shift-C&lt;/kbd&gt;
  表示複製這種是在 2  這一步做的。 &lt;/p&gt;
&lt;p&gt; 以上是 Linux/unix  的方式。 Windows 的情況大體類似，只是細節上有很多地方不一樣： &lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 窗口事件的接收者是創建 cmd  窗口的 Win32  子系統。 &lt;/li&gt;
&lt;li&gt;Win32 子系統接收到事件之後，傳遞給位於命令行子系統的 cmd  程序 &lt;/li&gt;
&lt;li&gt;cmd  程序再傳遞給你的程序。 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Windows 上同樣有類似行緩存模式和 raw 模式的區別，只不過實現細節不太一樣。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="strace"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;strace 查看了下 &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WaterElement(UnChanged)  於 2014 年 12 月 10 日 21:53:54  星期三回復： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 感謝 FC 的詳盡解答。 &lt;/p&gt;
&lt;p&gt; 用 strace 查看了下，設置標準輸入沒有緩存的話讀每個字符都會調用一次 &lt;code class="code"&gt;
read&lt;/code&gt;
  系統調用，比如輸入 abc ： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;read(0, abc
"a", 1)                         = 1
read(0, "b", 1)                         = 1
read(0, "c", 1)                         = 1
read(0, "\n", 1)                        = 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果有緩存的話就只調用一次了 &lt;code class="code"&gt;
read&lt;/code&gt;
  系統調用了： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;read(0, abc
"abc\n", 1024)                  = 4
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="raw-mode"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt; 如果想感受一下 raw mode&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 沒錯，這個是你的進程內 C 庫做的緩存， tty 屬於字符設備所以是一個一個字符塞給你的程序的。 &lt;/p&gt;
&lt;p&gt; 如果想感受一下 raw mode  可以試試下面這段程序（沒有檢測錯誤返回值） &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;termios.h&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ttyfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/* reset tty - useful also for restoring the terminal when this process&lt;/span&gt;
&lt;span class="cm"&gt;   wishes to temporarily relinquish the tty&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="cm"&gt;/* flush and reset */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="cm"&gt;/* put terminal in raw mode - see termio(7I) for modes */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;raw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;orig_termios&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* copy original and then modify below */&lt;/span&gt;

    &lt;span class="cm"&gt;/* input modes - clear indicated ones giving: no break, no CR to NL,&lt;/span&gt;
&lt;span class="cm"&gt;       no parity check, no strip char, no start/stop output (sic) control */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_iflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BRKINT&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICRNL&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;INPCK&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISTRIP&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IXON&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* output modes - clear giving: no post processing such as NL to CR+NL */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_oflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OPOST&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* control modes - set 8 bit chars */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cflag&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CS8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* local modes - clear giving: echoing off, canonical off (no erase with&lt;/span&gt;
&lt;span class="cm"&gt;       backspace, ^U,...),  no extended functions, no signal chars (^Z,^C) */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_lflag&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ECHO&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ICANON&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;IEXTEN&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ISIG&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* control chars - set return condition: min number of bytes and timer */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after 5 bytes or .8 seconds&lt;/span&gt;
&lt;span class="cm"&gt;                                                after first byte seen      */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* immediate - anything       */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after two bytes, no timer  */&lt;/span&gt;
    &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VMIN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_cc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VTIME&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* after a byte or .8 seconds */&lt;/span&gt;

    &lt;span class="cm"&gt;/* put terminal in raw mode after flushing */&lt;/span&gt;
    &lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TCSAFLUSH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;atexit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tty_reset&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;tty_raw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttyfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;setvbuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_IONBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"buffer is:%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt; 終端上的字符編程 &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;vander( 大青蛙 )  於 2014 年 12 月 12 日 08:52:20  星期五問到： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 學習了！ &lt;/p&gt;
&lt;p&gt; 進一步想請教一下 fc 大神。如果我在 Linux 上做終端上的字符編程，是否除了用 ncurses 庫之外，也可以不用該庫而直接與終端打交道，就是你所說的直接在 raw 模式？另外，終端類型 vt100 和 linux 的差別在哪裏？爲什麼 Kevin Boone 的 KBox 配置手冊裏面說必須把終端類型設成 linux ，而且要加上 terminfo 文件，才能讓終端上的 vim 正常工作？ term
info 文件又是幹什麼的？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;Linux 控制檯的歷史 &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt; 嗯理論上可以不用 ncurses  庫直接在 raw  模式操縱終端。 &lt;/p&gt;
&lt;p&gt; 這裏稍微聊一下 terminfo/termcap 的歷史，詳細的歷史和吐槽參考 &lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater's Handbook&lt;/a&gt;
 第 6 章 Terminal Insanity 。 &lt;/p&gt;
&lt;p&gt; 首先一個真正意義上的終端就是一個輸入設備（通常是鍵盤）加上一個輸出設備（打印機或者顯示器）。很顯然不同的終端的能力不同，比如如果輸出設備是打印機的話，顯示出來的字符就不能刪掉了（但是能覆蓋），而且輸出了一行之後就不能回到那一行了。再比如顯示器終端有的支持粗體和下劃線，有的支持顏色，而有的什麼都不支持。早期 Unix 工作在電傳打字機（ TeleTYpe ）終端上，後來 Unix 被 port 到越來越多的機器上，然後越來越多類型的終端會被連到 Unix 上，很可能同一臺 Unix 主機連了多個不同類型的終端。由於是不同廠商提供的不同的終端，能力各有不同，自然控制他們工作的方式也是不一樣的。所有終端都支持回顯行編輯模式，所以一般的面向行的程序還比較好寫，但是那時候要撰寫支持所有終端的「全屏」程序就非常痛苦，這種情況就像現在瀏覽器沒有統一標準下寫 HTML 要測試各種瀏覽器兼容性一樣。通常的做法是 &lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt; 使用最小功能子集 &lt;/li&gt;
&lt;li&gt; 假設終端是某個特殊設備，不管別的設備。 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 水源的代碼源頭 Firebird2000  就是那樣的一個程序，只支持固定大小的 vt102 終端。 &lt;/p&gt;
&lt;p&gt; 這時有一個劃時代意義的程序出現了，就是 vi ，試圖要做到「全屏可視化編輯」。這在現在看起來很簡單，但是在當時基本是天方夜譚。 vi  的做法是提出一層抽象，記錄它所需要的所有終端操作，然後有一個終端類型數據庫，把那些操作映射到終端類型的具體指令上。當然並不是所有操作在所有終端類型上都支持，所以會有一堆 fallback ，比如要「強調」某段文字，在彩色終端上可能 fallback  到紅色，在黑白終端上可能 fallback  到粗體。 &lt;/p&gt;
&lt;p&gt;vi  一出現大家都覺得好頂讚，然後想要寫更多類似 vi  這樣的全屏程序。然後 vi  的作者就把終端抽象的這部分數據庫放出來形成一個單獨的項目，叫 termcap  （ Terminal
Capibility ），對應的描述終端的數據庫就是 termcap  格式。然後 termcap  只是一個數據庫（所以無狀態）還不夠方便易用，所以後來又有人用 termcap  實現了 curses  。 &lt;/p&gt;
&lt;p&gt; 再後來大家用 curses/termcap  的時候漸漸發現這個數據庫有一點不足：它是爲 vi  設計的，所以只實現了 vi  需要的那部分終端能力。然後對它改進的努力就形成了新的 terminfo  數據庫和 pcurses  和後來的 ncurses  。然後 VIM  出現了自然也用 terminfo  實現這部分終端操作。 &lt;/p&gt;
&lt;p&gt; 然後麼就是 X  出現了， xterm  出現了，大家都用顯示器了，然後 xterm  爲了兼容各種老程序加入了各種老終端的模擬模式。不過因爲最普及的終端是 vt100  所以 xterm  默認是工作在兼容 vt100  的模式下。然後接下來各種新程序（偷懶不用 *curses 的那些）都以 xterm/vt100  的方式寫。 &lt;/p&gt;
&lt;p&gt; 嗯到此爲止是 Unix  世界的黑歷史。 &lt;/p&gt;
&lt;p&gt; 知道這段歷史的話就可以明白爲什麼需要 TERM  變量配合 terminfo  數據庫纔能用一些 Unix  下的全屏程序了。類比一下的話這就是現代瀏覽器的 user-agent 。 &lt;/p&gt;
&lt;p&gt; 然後話題回到 Linux  。大家知道 Linux  早期代碼不是一個 OS ，而是 Linus  大神想在他的嶄新蹭亮的 386-PC  上遠程登錄他學校的 Unix  主機，接收郵件和逛水源（咳咳）。於是 Linux  最早的那部分代碼並不是一個通用 OS  而只是一個 bootloader  加一個終端模擬器。所以現在 Linux  內核裏還留有他當年實現的終端模擬器的部分代碼，而這個終端模擬器的終端類型就是 linux  啦。然後他當時是爲了逛水源嘛所以 linux  終端基本上是 vt102  的一個接近完整子集。 &lt;/p&gt;
&lt;p&gt; 說到這裏脈絡大概應該清晰了， xterm 終端類型基本模擬 vt100 ， linux 終端類型基本模擬 vt102 。這兩個的區別其實很細微，都是同一個廠商的兩代產品嘛。有差別的地方差不多就是 &lt;kbd class="kbd"&gt;
Home&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
End&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageUp&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
PageDown&lt;/kbd&gt;
 / &lt;kbd class="kbd"&gt;
Delete&lt;/kbd&gt;

 這些不在 ASCII  控制字符表裏的按鍵的映射關係不同。 &lt;/p&gt;
&lt;p&gt; 嗯這也就解釋了爲什麼在 linux 環境的圖形界面的終端裏 telnet  上水源的話，上面這些按鍵會錯亂 ……  如果設置終端類型是 linux/vt102  的話就不會亂了。在 linux  的 TTY  裏 telnet  也不會亂的樣子。 &lt;/p&gt;
&lt;p&gt; 寫到這裏纔發現貌似有點長 ……  總之可以參考 &lt;a class="reference external" href="http://web.mit.edu/~simsong/www/ugh.pdf"&gt;Unix hater's Handbook&lt;/a&gt;
 裏的相關歷史評論和吐槽，那一段非常有意思。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="c"></category><category term="linux"></category><category term="stdio"></category><category term="tty"></category><category term="unix"></category><category term="ugh"></category><category term="ncurses"></category><category term="termcap"></category><category term="terminfo"></category></entry><entry><title>關於C++模板的類型轉換的討論</title><link href="//farseerfc.github.io/discuss-cpp-template-downcast.html" rel="alternate"></link><updated>2012-02-26T05:54:57+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2012-02-26:discuss-cpp-template-downcast.html</id><summary type="html">&lt;html&gt;&lt;body&gt;
&lt;p&gt; 這兩天在飲水思源的 C 板，關於 C++ 模板的類型轉換的一個討論，後面是我的解答。 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt; 討論地址 &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html"&gt;http://bbs.sjtu.edu.cn/bbstcon,board,C,reid,1330078933,file,M.1330078933.A.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt; 原問題 &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt; 今天在書上看到模板演繹的時候可以允許 cast-down ，於是我寫了個東西： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;_Test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;_Type&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BB&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DD&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BB&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//f(b);&lt;/span&gt;
    &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 奇怪的是重載決議的時候， &lt;code class="code"&gt;
f&lt;/code&gt;
  的情況下它就不讓我特化的 &lt;code class="code"&gt;
f&amp;lt;A&amp;gt;&lt;/code&gt;
  進來。 &lt;/p&gt;
&lt;p&gt; 但是在 &lt;code class="code"&gt;
ff&lt;/code&gt;
  的情況下， &lt;code class="code"&gt;
ff&amp;lt;BB&amp;lt;long&amp;gt;&amp;gt;&lt;/code&gt;
  卻進來了。 &lt;/p&gt;
&lt;p&gt; 在 VC10 和 GCC3.4 下測試 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt; 我的解答 &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt; 我們來設身處地地作爲編譯器，看一遍到底發生了什麼。 &lt;/p&gt;
&lt;p&gt; 約定符號 &lt;code class="code"&gt;
#&lt;/code&gt;
 : &lt;code class="code"&gt;
A#B&lt;/code&gt;
  是把 &lt;code class="code"&gt;
B&lt;/code&gt;
  帶入 &lt;code class="code"&gt;
A&amp;lt;T&amp;gt;&lt;/code&gt;
  的參數 &lt;code class="code"&gt;
T&lt;/code&gt;
  之後實例化得到的結果。 &lt;/p&gt;
&lt;div class="section" id="ff"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt; 首先看 ff 的情況。 &lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DD&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 處理到這句的時候，編譯器看到了 &lt;code class="code"&gt;
DD&amp;lt;long&amp;gt;&lt;/code&gt;
  的實例化，於是去實例化 &lt;code class="code"&gt;
DD#long&lt;/code&gt;
  ，繼而實例化了 &lt;code class="code"&gt;
BB#long&lt;/code&gt;
  。 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 這句，首先計算重載函數集合。 &lt;/p&gt;
&lt;p&gt; 第一步，需要從參數 &lt;code class="code"&gt;
DD#long -&amp;gt; BB&amp;lt;T&amp;gt;&lt;/code&gt;
  推斷 &lt;code class="code"&gt;
ff&amp;lt;T&amp;gt;&lt;/code&gt;
  的 &lt;code class="code"&gt;
T&lt;/code&gt;
  。根據函數模板參數推斷規則： &lt;/p&gt;
&lt;pre class="literal-block"&gt;
:code:`class_template_name&amp;lt;T&amp;gt;`  類型的參數，可以用於推斷 :code:`T`  。 &lt;/pre&gt;
&lt;p&gt; 於是編譯器推斷 &lt;code class="code"&gt;
T&lt;/code&gt;
  爲 &lt;code class="code"&gt;
long&lt;/code&gt;
  。這裏就算不是 &lt;code class="code"&gt;
BB&lt;/code&gt;
  而是完全無關的 &lt;code class="code"&gt;
CC&lt;/code&gt;
  都可以推斷成功，只要 &lt;code class="code"&gt;
CC&lt;/code&gt;
  也是一個 &lt;code class="code"&gt;
CC&amp;lt;T&amp;gt;&lt;/code&gt;
  形式的模板。 &lt;/p&gt;
&lt;p&gt; 第二步，模板特化匹配。因爲只有一個模板，所以匹配了最泛化的 &lt;code class="code"&gt;
ff&amp;lt;T&amp;gt;&lt;/code&gt;
  。 &lt;/p&gt;
&lt;p&gt; 第三步，模板實例化。 &lt;/p&gt;
&lt;p&gt; 推斷了 &lt;code class="code"&gt;
long -&amp;gt; T&lt;/code&gt;
  之後，編譯器實例化 &lt;code class="code"&gt;
ff#long&lt;/code&gt;
  。 &lt;/p&gt;
&lt;p&gt; 重載函數集合： &lt;code class="code"&gt;
{ff#long}&lt;/code&gt;
&lt;/p&gt;
&lt;p&gt; 然後重載抉擇找到唯一的可匹配的實例 &lt;code class="code"&gt;
ff#long&lt;/code&gt;
  ，檢查實際參數 &lt;code class="code"&gt;
DD#long&lt;/code&gt;
  可以隱式轉換到形式參數 &lt;code class="code"&gt;
BB#long&lt;/code&gt;
  ，從而生成了這次函數調用。 &lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="f"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt; 再來看 f 的情況。 &lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 計算候選重載函數集合。 &lt;/p&gt;
&lt;p&gt; 第一步，對所有 &lt;code class="code"&gt;
f&lt;/code&gt;
  模板推斷實參。根據函數模板參數推斷規則： &lt;/p&gt;
&lt;pre class="literal-block"&gt;
 帶有 :code:`T`  類型的參數，可以用於推斷 :code:`T`  。 &lt;/pre&gt;
&lt;p&gt; 於是 &lt;code class="code"&gt;
B -&amp;gt; T&lt;/code&gt;
  被推斷出來了。 &lt;/p&gt;
&lt;p&gt; 第二步，模板特化匹配。 &lt;/p&gt;
&lt;p&gt; 這裏 &lt;code class="code"&gt;
B&lt;/code&gt;
  不是 &lt;code class="code"&gt;
A&lt;/code&gt;
  ，所以不能用 &lt;code class="code"&gt;
f&amp;lt;A&amp;gt;&lt;/code&gt;
  特化，只能用 &lt;code class="code"&gt;
f&amp;lt;T&amp;gt;&lt;/code&gt;
  模板。 &lt;/p&gt;
&lt;p&gt; 第三步，模板實例化。 &lt;/p&gt;
&lt;p&gt;&lt;code class="code"&gt;
B&lt;/code&gt;
  帶入 &lt;code class="code"&gt;
f&amp;lt;T&amp;gt;&lt;/code&gt;
  實例化成 &lt;code class="code"&gt;
f#B&lt;/code&gt;
  的過程中，實例化 &lt;code class="code"&gt;
traits#B&lt;/code&gt;
  。 &lt;/p&gt;
&lt;p&gt; 由於沒有針對 &lt;code class="code"&gt;
B&lt;/code&gt;
  的特化，所以用 &lt;code class="code"&gt;
traits&amp;lt;T&amp;gt;&lt;/code&gt;
  模板， &lt;code class="code"&gt;
traits#B::value=false&lt;/code&gt;
  ，進而 &lt;code class="code"&gt;
enable_if#false&lt;/code&gt;
  沒有 &lt;code class="code"&gt;
type&lt;/code&gt;
  ，出錯。 &lt;/p&gt;
&lt;p&gt; 唯一的模板匹配出錯，重載函數集合爲空， SFINAE 原則不能找到合適的匹配，於是報錯。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="template"></category><category term="C"></category></entry><entry><title>C++ Tricks 3.2 標號、goto，以及switch的實現</title><link href="//farseerfc.github.io/c-tricks-3-2-label-goto-and-implementation-of-switch.html" rel="alternate"></link><updated>2007-09-16T13:08:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-09-16:c-tricks-3-2-label-goto-and-implementation-of-switch.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h2&gt;3.2  標號、 goto ，以及 switch 的實現 &lt;/h2&gt;
&lt;p&gt;goto 語句及標號 (label) 是最古老的 C 語言特性，也是最早被人們拋棄的語言特性之一。像彙編語言中的 jmp 指令一樣， goto 語句可以跳轉到同一函數體中任何標號位置： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{int i=0;&lt;/p&gt;
&lt;p&gt;Loop: //A label&lt;/p&gt;
&lt;p&gt;++i;&lt;/p&gt;
&lt;p&gt;if(i&amp;lt;10)goto Loop; //Jump to the label&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 在原始而和諧的早期 Fortran 和 Basic 時代，我們沒有 if then
else ，沒有 for 和 while ，甚至沒有函數的概念，一切控制結構都靠 goto( 帶條件的或無條件的 ) 構件。軟件工程師將這樣的代碼稱作 “ 意大利麪條 ” 代碼。實踐證明這樣的代碼極容易造成混亂。 &lt;/p&gt;
&lt;p&gt; 自從證明了結構化的程序可以做意大利麪條做到的任何事情，人們就開始不遺餘力地推廣結構化設計思想，將 goto 像猛獸一般囚禁在牢籠，標號也因此消失。 &lt;/p&gt;
&lt;p&gt; 標號唯一散發餘熱的地方，是在 switch 中控制分支流程。 &lt;/p&gt;
&lt;p&gt; 很多人不甚瞭解 switch 存在的意義，認爲它只是大型嵌套 if then
else 結構的縮略形式，並且比 if 語句多了很多 “ 不合理 ” 的限制。如果你瞭解到 switch 在編譯器內部的實現機制，就不難理解強加在 switch 之上的諸多限制，比如 case 後只能跟一個編譯期整型常量，比如用 break 結束每一個 case 。首先看一個 switch 實例： &lt;/p&gt;
&lt;p&gt;switch (shape.getAngle())&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;case 3: cout&amp;lt;&amp;lt;”Triangle”;break;&lt;/p&gt;
&lt;p&gt;case 4: cout&amp;lt;&amp;lt;”Square”;break;&lt;/p&gt;
&lt;p&gt;case 0:case1: cout&amp;lt;&amp;lt;”Not a sharp!”;break;&lt;/p&gt;
&lt;p&gt;default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 任何程序員都可以寫出與之對應的 if 結構： &lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i==3) cout&amp;lt;&amp;lt;”Triangle”;&lt;/p&gt;
&lt;p&gt;else if(i==4) cout&amp;lt;&amp;lt;”Square”;&lt;/p&gt;
&lt;p&gt;else if(i==0||i==1) cout&amp;lt;&amp;lt;”Not a sharp!”;&lt;/p&gt;
&lt;p&gt;else cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt; 看起來這兩段代碼在語義上是完全一樣的，不是麼？ &lt;/p&gt;
&lt;p&gt; 不！或許代碼的執行結果完全一樣，但是就執行效率而言， switch 版本的更快！ &lt;/p&gt;
&lt;p&gt; 要了解爲什麼 switch 的更快，我們需要知道編譯器是怎樣生成 switch 的實現代碼的： &lt;/p&gt;
&lt;p&gt; 首先，保留 switch 之後由 {} 括起來的語具體，僅將其中 case 、 default 和 break 替換爲真正的標號： &lt;/p&gt;
&lt;p&gt;switch (getAngle(shape))&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 隨後，對於所有出現在 case 之後的常量，列出一張只有 goto 的跳轉表，其順序按 case 後的常量排列： &lt;/p&gt;
&lt;p&gt;goto _case_0;&lt;/p&gt;
&lt;p&gt;goto _case_1;&lt;/p&gt;
&lt;p&gt;goto _case_3;&lt;/p&gt;
&lt;p&gt;goto _case_4;&lt;/p&gt;
&lt;p&gt; 然後，計算 case 之後的常量與跳轉表地址之間的關係，如有需要，在跳轉表中插入空缺的項目： &lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default; // 因爲沒有 case 2 ，所以插入此項以條轉到 default&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt; 假設一個 goto 語句佔用 5 個字節，那麼在本例中， goto 的地址 =case 後的常量 *5+100105&lt;/p&gt;
&lt;p&gt; 之後，生成跳轉代碼，在其餘條件下跳轉至 default ，在已知範圍內按照公式跳轉，全部的實現如下： &lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i= getAngle(shape);&lt;/p&gt;
&lt;p&gt;if (i&amp;lt;0||i&amp;gt;=5)goto _default;&lt;/p&gt;
&lt;p&gt;i=i*5+100105; // 按照得出的公式算出跳轉地址 &lt;/p&gt;
&lt;p&gt;goto i; // 僞代碼， C 中不允許跳轉到整數，但是彙編允許 &lt;/p&gt;
&lt;p&gt;100105: goto _case_0;&lt;/p&gt;
&lt;p&gt;100110: goto _case_1;&lt;/p&gt;
&lt;p&gt;100115: goto _default;&lt;/p&gt;
&lt;p&gt;100120: goto _case_3;&lt;/p&gt;
&lt;p&gt;100125: goto _case_4;&lt;/p&gt;
&lt;p&gt;_case_3: cout&amp;lt;&amp;lt;”Triangle”;goto _break;&lt;/p&gt;
&lt;p&gt;_case_4: cout&amp;lt;&amp;lt;”Square”; goto _break;&lt;/p&gt;
&lt;p&gt;_case_0:_case_1: cout&amp;lt;&amp;lt;”Not a sharp!”; goto _break;&lt;/p&gt;
&lt;p&gt;_default: cout&amp;lt;&amp;lt;”Polygon”;&lt;/p&gt;
&lt;p&gt;_break:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 經過這樣處理整個 switch 結構，使得無論 switch 後的變量爲何值，都可以通過最多兩次跳轉到達目標代碼。相比之下 if 版本的代碼則採用線性的比較和跳轉，在 case 語句很多的情況下效率極低。 &lt;/p&gt;
&lt;p&gt; 由此 , 我們也可以知道 , 爲什麼 case 後跟的一定是編譯期整型常數，因爲編譯器需要根據這個值製作跳轉表。我們可以明白爲什麼 case 與 case 之間應該用 break 分隔，因爲編譯器不改變 switch 語句體的結構， case 其本身只是一個具有語義的標號而已，要想跳出 switch ，就必須用 break 語句。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 3.1 左值右值與常量性(lvalue，rvalue &amp; constant)</title><link href="//farseerfc.github.io/c-tricks-3-1-lvalue-rvalue-constant.html" rel="alternate"></link><updated>2007-09-16T13:07:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-09-16:c-tricks-3-1-lvalue-rvalue-constant.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h2&gt;3.1  左值右值與常量性 (lvalue ， rvalue &amp;amp; constant)&lt;/h2&gt;
&lt;p&gt; 首先要搞清楚的是，什麼是左值，什麼是右值。這裏給出左值右值的定義： &lt;/p&gt;
&lt;p&gt;1 、左值是可以出現在等號 (=) 左邊的值，右值是隻能出現在等號右邊的值。 &lt;/p&gt;
&lt;p&gt;2 、左值是可讀可寫的值，右值是隻讀的值。 &lt;/p&gt;
&lt;p&gt;3 、左值有地址，右值沒有地址。 &lt;/p&gt;
&lt;p&gt; 根據左值右值的第二定義，值的左右性就是值的常量性 —— 常量是右值，非常量是左值。比如： &lt;/p&gt;
&lt;p&gt;1=1;//Error&lt;/p&gt;
&lt;p&gt; 這個複製操作在 C++ 中是語法錯誤， MSVC 給出的錯誤提示爲 “error C2106: '=' :
left operand must be
l-value” ，就是說 ’=’ 的左操作數必須是一個左值，而字面常數 1 是一個右值。可見，嚴格的區分左值右值可以從語法分析的角度找出程序的邏輯錯誤。 &lt;/p&gt;
&lt;p&gt; 根據第二定義，一個左值也是一個右值，因爲左值也可讀，而一個右值不是一個左值，因爲右值不可寫。 &lt;/p&gt;
&lt;p&gt; 通常情況下，聲明的變量是一個左值，除非你指定 const 將它變成一個右值： &lt;/p&gt;
&lt;p&gt;int lv=1;&lt;/p&gt;
&lt;p&gt;const int rv=lv;&lt;/p&gt;
&lt;p&gt; 由於右值的值在程序執行期間不能改變，所以必須用另一個右值初始化它。 &lt;/p&gt;
&lt;p&gt; 一個普通變量只能用右值初始化，如果你想傳遞左值，必須聲明一個引用或一個指針： &lt;/p&gt;
&lt;p&gt;int &amp;amp; ref=lv;// 用引用傳遞左值 &lt;/p&gt;
&lt;p&gt;int * plv=&amp;amp;lv;// 傳遞指針以間接傳遞左值 &lt;/p&gt;
&lt;p&gt; 必須用左值初始化引用，然而，可以用右值初始化常量引用： &lt;/p&gt;
&lt;p&gt;int &amp;amp; r1=1; //Error!&lt;/p&gt;
&lt;p&gt;const int &amp;amp; r2=1; //OK&lt;/p&gt;
&lt;p&gt; 這實際上相當於： &lt;/p&gt;
&lt;p&gt;int _r2=1;&lt;/p&gt;
&lt;p&gt;const int &amp;amp; r2=_r2;&lt;/p&gt;
&lt;p&gt; 這樣的寫法在函數體內沒什麼作用，但是在傳遞函數參數時，它可以避免潛在的 ( 傳遞左值時的 ) 複製操作，同時又可以接受右值。 &lt;/p&gt;
&lt;p&gt; 通常情況下，函數的參數和返回值都只傳回右值，除非你明確的通過引用傳遞左值。 &lt;/p&gt;
&lt;p&gt; 明確了左值與右值的區別，有助於我們寫函數時確定什麼時候應該有 const ，什麼時候不該有。比如，我們寫了一個代表數學中複數的類 Complex ： &lt;/p&gt;
&lt;p&gt;class Complex;&lt;/p&gt;
&lt;p&gt; 然後，我們寫針對 Complex 的運算符重載： operator+ 和 operator= 。問題在於，參數和返回值應該是什麼類型，可選類型有四種： Complex 、 const Complex 、 Complex&amp;amp; 、 const Complex&amp;amp; 。 &lt;/p&gt;
&lt;p&gt; 對於 operator+ ，我們不會改變參數的值，所以可以通過 const
Complex&amp;amp; 傳遞參數。至於返回值類型，由於 int 類型的加法返回右值，所以根據 Do
as the ints do 的原則，返回值類型爲 const Complex ： &lt;/p&gt;
&lt;p&gt;const Complex operator+(const Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt; 對於 operator= ，同樣要思考這些問題。我們寫入第一個參數，所以第一個參數爲 Complex&amp;amp; ，我們只讀取第二個參數，所以第二個參數爲 const
Complex&amp;amp; 。至於返回值，還是 Do as the ints
do 。 int 的賦值返回左值，不信你可以試一試： &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;(i=1)=2;&lt;/p&gt;
&lt;p&gt; 雖然比較傻，先將 i 賦爲 1 ，再將其改爲 2 ，但是這是被 C++ 語法支持的做法，我們就理應遵守。所以返回第一個參數的左值： &lt;/p&gt;
&lt;p&gt;Complex&amp;amp; operator=(Complex&amp;amp;,const Complex&amp;amp;);&lt;/p&gt;
&lt;p&gt;const 是 C++ 引入的語言特性，也被 ANSI
C99 借鑑，在經典版本的 C 語言中是沒有的。關於 const 的歷史，有幾點值得玩味。最初 Bjarne
Stroustrup 引入 const 時，可寫性是和可讀性分開的。那時使用關鍵字 readonly 和 writeonly 。這個特點被首先提交到 C 的 ANSI 標準化委員會 ( 當時還沒有 C++ 標準化的計劃 ) ，但是 ANSI
C 標準只接受了 readonly 的概念，並將其命名爲 const 。隨後，有人發現在多線程同步的環境下，有些變量的值會在編譯器的預料之外改變，爲了防止過度優化破壞這些變量， C++ 又引入關鍵字 violate 。從語義特點來看， violate 是 const 的反義詞，因爲 const 表示不會變的量，而 violate 表示會不按照預期自行變化的量。從語法特點而言， violate 與 const 是極爲相似的，適用於 const 的一切語法規則同樣適用於 violate 。 &lt;/p&gt;
&lt;p&gt; 值的常量性可以被劃分爲兩種：編譯期常量和運行期常量。 C++ 語法並沒有嚴格區分這兩種常量，導致了少許混亂： &lt;/p&gt;
&lt;p&gt;const int i=5;const int * pi=&amp;amp;i;&lt;/p&gt;
&lt;p&gt;const_cast&amp;lt;int&amp;amp;&amp;gt;i=1;// 對於運行期常量，在需要時可以去除它的常量性 &lt;/p&gt;
&lt;p&gt;int a[i];// 對於編譯期常量，可以用它來指定數組大小 &lt;/p&gt;
&lt;p&gt;cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;sizeof(a)/sizeof(a[0])&amp;lt;&amp;lt;*pi;&lt;/p&gt;
&lt;p&gt; 這種將編譯期與運行期常量的特性混用的方法，勢必導致語義的混亂。數組 a 的大小最終是 5 ，因爲採用了 i 的編譯期值，而不管 i 在運行期是否被改變了值。最後一句代碼將（有可能）輸出 551 ，第一個 i 的值作爲一種優化在編譯期綁定，第二個值標明瞭 a 的大小，第三個值通過指針顯示地輸出 i 的運行期真實值。 &lt;/p&gt;
&lt;p&gt; 在 C++ 的近親 C# 的語法中，這兩種常量被嚴格地區分開：編譯期常量由 const 指定，只能是內建類型變量；運行期常量由 readonly 指定，可以是任何類型。永遠不會改變的常量，如圓周率 pi 的值，應該用 const 聲明；而其它有可能改變的常量，皆由 readonly 聲明。 &lt;/p&gt;
&lt;p&gt;C++ 中的 const 的特點更傾向於 C# 中的 readonly ，雖然語法上允許使用 const 的編譯期常量性，但正如上文所展示的，這容易造成混亂。爲了得到 C# 中 const 的語義，在 C++ 中，我們不必迴歸惡魔 #define 的懷抱，可以使用所謂 “ 匿名 enum 技巧 ” 。當匿名聲明一個 enum 類型時，其中的枚舉值就是一個 int 類型的編譯期常量，比如： &lt;/p&gt;
&lt;p&gt;enum{Size=5;};&lt;/p&gt;
&lt;p&gt;int a[Size];&lt;/p&gt;
&lt;p&gt; 這種使用匿名 enum 來聲明編譯期常量的做法，被廣泛應用於 STL 、 boost 等模板庫的實現代碼中。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.2 I386平臺的內存佈局</title><link href="//farseerfc.github.io/c-tricks-2-2-i386-memory-layout.html" rel="alternate"></link><updated>2007-08-28T14:30:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-2-i386-memory-layout.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.2 I386 平臺的內存佈局 &lt;/h2&gt;
&lt;p&gt; 衆所周知， I386 是 32 位體系結構。因此對於絕大多數 I386 平臺的 C++ 編譯器而言， sizeof(int)=sizeof(long)=sizeof(void*)=4 。當然 C++ 標準對此沒有任何保證，我們也不應該試圖編寫依賴於此的代碼。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;32 位指針的可尋址空間爲 4GB 。爲充分利用這麼大的尋址空間，也是爲了支持其它更先進的技術比如多任務技術或者動態鏈接庫技術， WinNT 使用虛擬內存技術，給與每個應用程序全部 4GB 的內存空間。 4GB 的地址被一分爲二，前 2GB 供應用程序自己使用，後 2GB 由系統內核分配和管理。這 2GB 的內存地址，通常被劃分成 3 種內存區使用： &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;1  代碼及靜態數據區 &lt;/h3&gt;
&lt;p&gt; 由代碼加載器從動態鏈接庫鏡像 ( 通常是 exe 或 dll 文件 ) 加載，通常定位到鏡像文件中指定的基址開始的內存區。如果基址所在內存已被佔用，動態連接器會將代碼或數據重定向到其它可用地址。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 在 C++ 中，靜態數據包括：名字空間 (namespace) 和全局 (global) 對象、函數的 static 對象、類的 static 數據成員。這些靜態數據由編譯器分配地址 ( 但可能被重定向 ) ，由靜態連接器寫入代碼文件 ( 通常是 exe 或 dll) 的靜態數據區段。所以標準說，這些靜態數據在編譯期就已經具有地址。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stack"&gt;
&lt;h3&gt;2  棧 (Stack)&lt;/h3&gt;
&lt;p&gt; 棧是最常用的動態數據存儲區，所有函數的 non-static 對象和函數參數都在程序運行期在棧上分配內存。在數據結構中，術語 “ 棧 (Stack)” 意指先進後出 (FILO ， First
In Last
Out) ，與 “ 隊列 (Queue)” 所指的 FIFO 相對。相對於基於堆的對象分配技術，默認使用棧的對象分配有兩點優勢： &lt;/p&gt;
&lt;p&gt; 一、棧的 FILO 與人的思維方式相同 &lt;/p&gt;
&lt;p&gt; 現實生活中有許多事例都使用 FILO 的方式，比如人們必須先提起話筒再撥打號碼，而後掛斷電話之後再放下話筒。使用 FILO 的棧，可以保證事物的銷燬順序以其誕生順序相反的順序進行，不會產生在掛斷電話之前就放下話筒的尷尬。 &lt;/p&gt;
&lt;p&gt; 二、棧的分配管理僅需要兩個額外指針：棧頂 (esp) 和棧底 (ebp) 指針 &lt;/p&gt;
&lt;p&gt; 從實現的技術層面而言，棧的管理比其它動態分配技術要簡單很多。 I386 平臺上的動態棧管理，僅需要棧頂和棧底兩個指針。這兩個指針的存儲顯然不能放置於棧中，置於靜態數據區又有損效率。 I386 平臺爲管理動態棧專門預留了兩個通用寄存器變量 esp 與 ebp ，分別代表棧頂 (esp,Extended
Stack Pointer) 與棧底 (Extended Bottom
Pointer) 指針。其中的 extended 代表它們是 32 位指針，以區分 16 位的 sp 和 bp 寄存器。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 棧是動態存儲區的特點，表明它的內存佔用將隨着程序的運行而變化。 I386 平臺上 WinNT 將應用程序的棧置於程序空間，向下增長。程序初始化時，由操作系統將 esp 指向系統分配的棧空間的頂部。當程序需要在棧上分配變量時，就將 esp 減去變量所需字節數，這被稱作 “ 壓棧 (Push)” ；隨後又要銷燬變量時，就將 esp 加上變量所需字節數，這被稱作 “ 彈出 (Pop)” 。 esp 與 ebp 兩者之間所夾的空間，就是當前函數正在使用的棧空間。由於棧向下增長， esp( 棧頂 ) 的值總是小於 ebp( 棧底 ) 的值，新分配的變量地址總是小於舊變量的地址。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="heap"&gt;
&lt;h3&gt;3  堆 (Heap) 和自由存儲區 &lt;/h3&gt;
&lt;p&gt; 棧中的變量對於分配與釋放的順序有特定要求，這在一定程度上限制了棧的適用範圍。面向對象 (OO ， Object
Oriented) 的程序設計思想也要求能自由地控制變量的分配與銷燬。由此，現代操作系統都提供了被稱作 “ 堆 (Heap)” 的自由存儲區，以允許由程序員控制的對象創建和銷燬過程。 C 標準庫函數 malloc 和 free 則是對操作系統提供的堆操作的封裝。 C++ 提供的自由存儲區運算符 new 和 delete 則通常是 malloc 和 free 的又一層封裝。 &lt;/p&gt;
&lt;p&gt; 操作系統經由 malloc 和 free 控制對堆的訪問。堆的存儲管理技術各不相同，簡單的使用雙鏈表管理，複雜的可以比擬一個完整的文件系統。 &lt;/p&gt;
&lt;p&gt; 由於額外的管理需求，使用系統提供的通用分配器在堆上分配和銷燬變量的代價，無論從空間角度還是效率角度而言，都比在棧上分配對象要高昂很多。對於 sizeof 上百的大型對象，這樣的高昂代價還是可以接受的，但是對於 sizeof 只有個位數的小對象，這樣的代價通常是一個數量級的差距。正因爲這個原因， STL 不使用 new 和 delete ，轉而使用分配子 (alllocor) 分配對象。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks</title><link href="//farseerfc.github.io/c-tricks.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ Tricks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;By  FarseerFc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 從今天起，我再將在 &lt;a class="reference external" href="http://firechildren.spaces.live.com/"&gt;Live
Space&lt;/a&gt; 和 &lt;a class="reference external" href="http://76635424.qzone.qq.com/"&gt;QQZone&lt;/a&gt; 同時發表一系列文章，暫定名爲 “C++Tricks” 。 &lt;/p&gt;
&lt;p&gt; 本文旨在記錄和闡述一些本人學習 C++ 時所得的心得、技巧。總體來看，本文涉及的內容是每一個 C++ 程序員都應該知道的，但是很少見諸 C++ 教材。希望對各位同仁學習 C++ 有所幫助。 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 也可以通過 QQ 或 MSN 向我索要此文的 DOC 版或 PDF 版，會比網頁上的更新的快一點。 &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lexical-problems"&gt;
&lt;h2&gt;1       詞法問題 (Lexical Problems)&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!139.entry"&gt;1.1  條件運算符 (?:)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!140.entry"&gt;1.2  逗號運算符 (,) 、邏輯運算符 (&amp;amp;&amp;amp;,||) 與運算符重載的陷阱 &lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="x86"&gt;
&lt;h3&gt;2      X86 體系結構 &lt;/h3&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!146.entry"&gt;2.1 X86 概述 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!147.entry"&gt;2.2 I386 平臺的內存佈局 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!148.entry"&gt;2.3 I386 平臺 C 函數內部的棧分配 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!149.entry"&gt;2.4 I386 平臺 C 函數調用邊界的棧分配 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!150.entry"&gt;2.5 I386 平臺的邊界對齊 (Align)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!151.entry"&gt;2.6 I386 平臺 C 函數的可變參數表 (Variable Arguments)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;     &lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!152.entry"&gt;2.7 I386 平臺的其它函數調用模型 &lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="id6"&gt;
&lt;h5&gt;3  過程式編程 &lt;/h5&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lvalue-rvalue-constant"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!154.entry"&gt;3.1  左值右值與常量性 (lvalue ， rvalue &amp;amp; constant)&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="goto-switch"&gt;
&lt;h4&gt;&lt;a class="reference external" href="http://firechildren.spaces.live.com/blog/cns!1D8C01E7131A5AD4!155.entry"&gt;3.2  標號、 goto ，以及 switch 的實現 &lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.3 I386平臺C函數內部的棧分配</title><link href="//farseerfc.github.io/c-tricks-2-3-i386-stack-allocation-in-c-functions.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-3-i386-stack-allocation-in-c-functions.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.3 I386 平臺 C 函數內部的棧分配 &lt;/h2&gt;
&lt;p&gt; 函數使用棧來保存局部變量，傳遞函數參數。進入函數時，函數在棧上爲函數中的變量統一預留棧空間，將 esp 減去相應字節數。當函數執行流程途徑變量聲明語句時，如有需要就調用相應構造函數將變量初始化。當執行流程即將離開聲明所在代碼塊時，以初始化的順序的相反順序逐一調用析構函數。當執行流程離開函數體時，將 esp 加上相應字節數，歸還棧空間。 &lt;/p&gt;
&lt;p&gt; 爲了訪問函數變量，必須有方法定位每一個變量。變量相對於棧頂 esp 的位置在進入函數體時就已確定，但是由於 esp 會在函數執行期變動，所以將 esp 的值保存在 ebp 中，並事先將 ebp 的值壓棧。隨後，在函數體中通過 ebp 減去偏移量來訪問變量。以一個最簡單的函數爲例： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int a=0; //a 的地址被分配爲 ebp-4&lt;/p&gt;
&lt;p&gt;char c=1; //c 的地址被分配爲 ebp-8&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 產生的彙編代碼爲： &lt;/p&gt;
&lt;p&gt;push ebp ; 將 ebp 壓棧 &lt;/p&gt;
&lt;p&gt;mov ebp,esp ;ebp=esp  用棧底備份棧頂指針 &lt;/p&gt;
&lt;p&gt;sub esp,8 ;esp-=8 ，爲 a 和 c 預留空間，包括邊界對齊 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],0 ;a=0&lt;/p&gt;
&lt;p&gt;mov byte ptr[ebp-8],1 ;c=1&lt;/p&gt;
&lt;p&gt;add esp,8 ;esp+=8 ，歸還 a 和 c 的空間 &lt;/p&gt;
&lt;p&gt;mov esp,ebp ;esp=ebp  從棧底恢復棧頂指針 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢復 ebp&lt;/p&gt;
&lt;p&gt;ret ; 返回 &lt;/p&gt;
&lt;p&gt; 相應的內存佈局是這樣： &lt;/p&gt;
&lt;p&gt;09992:c=1 &amp;lt;-esp&lt;/p&gt;
&lt;p&gt;09996:a=0&lt;/p&gt;
&lt;p&gt;10000: 舊 ebp &amp;lt;-ebp&lt;/p&gt;
&lt;p&gt;10004:……&lt;/p&gt;
&lt;p&gt; 注 : 彙編中的 pop 、 push 、 call 、 ret 語句是棧操作指令，其功能可以用普通指令替換 &lt;/p&gt;
&lt;p&gt;push ebp 相當於 :&lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;mov dword ptr[esp],ebp&lt;/p&gt;
&lt;p&gt;pop ebp 相當於： &lt;/p&gt;
&lt;p&gt;mov ebp,dword ptr[esp]&lt;/p&gt;
&lt;p&gt;sub esp,4&lt;/p&gt;
&lt;p&gt;call fun_address 相當於： &lt;/p&gt;
&lt;p&gt;push eip&lt;/p&gt;
&lt;p&gt;jmp fun_address&lt;/p&gt;
&lt;p&gt;ret 相當於 &lt;/p&gt;
&lt;p&gt;add esp,4&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt; 帶參數的 ret&lt;/p&gt;
&lt;p&gt;ret 8 相當於 &lt;/p&gt;
&lt;p&gt;add esp,12&lt;/p&gt;
&lt;p&gt;jmp dword ptr[esp-4]&lt;/p&gt;
&lt;p&gt; 所有局部變量都在棧中由函數統一分配，形成了類似逆序數組的結構，可以通過指針逐一訪問。這一特點具有很多有趣性質，比如，考慮如下函數，找出其中的錯誤及其造成的結果： &lt;/p&gt;
&lt;p&gt;void f()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i,a[10];&lt;/p&gt;
&lt;p&gt;for(i=0;i&amp;lt;=10;++i)a[i]=0;/An error occurs here!&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 這個函數中包含的錯誤，即使是 C++ 新手也很容易發現，這是老生常談的越界訪問問題。但是這個錯誤造成的結果，是很多人沒有想到的。這次的越界訪問，並不會像很多新手預料的那樣造成一個 “ 非法操作 ” 消息，也不會像很多老手估計的那樣會默不作聲，而是導致一個，呃，死循環！ &lt;/p&gt;
&lt;p&gt; 錯誤的本質顯而易見，我們訪問了 a[10] ，但是 a[10] 並不存在。 C++ 標準對於越界訪問只是說 “ 未定義操作 ” 。我們知道， a[10] 是數組 a 所在位置之後的一個位置，但問題是，是誰在這個位置上。是 i!&lt;/p&gt;
&lt;p&gt; 根據前面的討論， i 在數組 a 之前被聲明，所以在 a 之前分配在棧上。但是， I386 上棧是向下增長的，所以， a 的地址低於 i 的地址。其結果是在循環的最後， a[i] 引用到了 i 自己！接下來的事情就不難預見了， a[i] ，也就是 i ，被重置爲 0 ，然後繼續循環的條件仍然成立 …… 這個循環會一直繼續下去，直到在你的帳單上產生高額電費，直到耗光地球電能，直到太陽停止燃燒 …… 呵呵，或者直到聰明的你把程序 Kill 了 ……&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.4 I386平臺C函數調用邊界的棧分配</title><link href="//farseerfc.github.io/c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-4-i386-stack-allocation-accross-function-invocation.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386c"&gt;
&lt;h2&gt;2.4 I386 平臺 C 函數調用邊界的棧分配 &lt;/h2&gt;
&lt;p&gt; 當調用一個函數時，主調函數將參數以聲明中相反的順序壓棧，然後將當前的代碼執行指針 (eip) 壓棧，然後跳轉到被調函數的入口點。在被調函數中，通過將 ebp 加上一個偏移量來訪問函數參數，以聲明中的順序 ( 即壓棧的相反順序 ) 來確定參數偏移量。被調函數返回時，彈出主調函數壓在棧中的代碼執行指針，跳回主調函數。再由主調函數恢復到調用前的棧。 &lt;/p&gt;
&lt;p&gt; 函數的返回值不同於函數參數，通過寄存器傳遞。如果返回值類型可以放入 32 位變量，比如 int 、 short 、 char 、指針等類型，通過 eax 寄存器傳遞。如果返回值類型是 64 位變量，如 _int64 ，同過 edx+eax 傳遞， edx 存儲高 32 位， eax 存儲低 32 位。如果返回值是浮點類型，如 float 和 double ，通過專用的浮點數寄存器棧的棧頂返回。如果返回值類型是用戶自定義結構，或 C++ 類類型，通過修改函數簽名，以引用型參數的形式傳回。 &lt;/p&gt;
&lt;p&gt; 同樣以最簡單的函數爲例： &lt;/p&gt;
&lt;p&gt;void f(){&lt;/p&gt;
&lt;p&gt;int i=g(1,2);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int g(int a,int b){&lt;/p&gt;
&lt;p&gt;int c=a+b ； &lt;/p&gt;
&lt;p&gt;return c;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 產生的彙編代碼如下： &lt;/p&gt;
&lt;p&gt;f:&lt;/p&gt;
&lt;p&gt;push ebp ; 備份 ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ; 建立棧底 &lt;/p&gt;
&lt;p&gt;sub esp,4 ; 爲 i 分配空間 &lt;/p&gt;
&lt;p&gt;mov eax,2 ; 準備參數 b 的值 2&lt;/p&gt;
&lt;p&gt;push eax ; 將 b 壓棧 &lt;/p&gt;
&lt;p&gt;mov eax,1 ; 準備參數 a 的值 1&lt;/p&gt;
&lt;p&gt;push eax ; 將 a 壓棧 &lt;/p&gt;
&lt;p&gt;call g ; 調用 g&lt;/p&gt;
&lt;p&gt;add esp,8 ; 將 a 和 b 一起彈出，恢復調用前的棧 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ; 將返回值保存進變量 i&lt;/p&gt;
&lt;p&gt;mov esp,ebp ; 恢復棧頂 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢復棧底 &lt;/p&gt;
&lt;p&gt;g:&lt;/p&gt;
&lt;p&gt;push ebp ; 備份 ebp&lt;/p&gt;
&lt;p&gt;mov ebp,esp ; 建立棧底 &lt;/p&gt;
&lt;p&gt;sub esp,4 ; 爲局部變量 c 在棧中分配內存 &lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp+8] ; 通過 ebp 間接讀取參數 a 的值 &lt;/p&gt;
&lt;p&gt;mov ebx,dword ptr[ebp+12] ; 通過 ebp 間接讀取參數 b 的值 &lt;/p&gt;
&lt;p&gt;add eax,ebx ; 將 a 和 b 的值相加，之和存在 eax 中 &lt;/p&gt;
&lt;p&gt;mov dword ptr[ebp-4],eax ; 將和存入變量 c&lt;/p&gt;
&lt;p&gt;mov eax,dword ptr[ebp-4] ; 將 c 作爲返回值，代碼優化後會刪除此句 &lt;/p&gt;
&lt;p&gt;add esp,4 ; 銷燬 c 的內存 &lt;/p&gt;
&lt;p&gt;mov esp,ebp ; 恢復棧頂 &lt;/p&gt;
&lt;p&gt;pop ebp ; 恢復棧底 &lt;/p&gt;
&lt;p&gt;ret ; 返回函數 f&lt;/p&gt;
&lt;p&gt; 棧的內存佈局如下： &lt;/p&gt;
&lt;p&gt;100076:c &amp;lt;- g 的 esp&lt;/p&gt;
&lt;p&gt;100080:f 的 ebp=100100 &amp;lt;- g 的 ebp&lt;/p&gt;
&lt;p&gt;100084:f 的 eip&lt;/p&gt;
&lt;p&gt;100088:a=1&lt;/p&gt;
&lt;p&gt;100092:b=2&lt;/p&gt;
&lt;p&gt;100096:i&lt;/p&gt;
&lt;p&gt;100100: 舊 ebp &amp;lt;-f 的 ebp&lt;/p&gt;
&lt;p&gt;100104:……&lt;/p&gt;
&lt;p&gt; 注意在函數 g 的彙編代碼中，訪問函數的局部變量和訪問函數參數的區別。局部變量總是通過將 ebp 減去偏移量來訪問，函數參數總是通過將 ebp 加上偏移量來訪問。對於 32 位變量而言，第一個局部變量位於 ebp-4 ，第二個位於 ebp-8 ，以此類推， 32 位局部變量在棧中形成一個逆序數組；第一個函數參數位於 ebp+8 ，第二個位於 ebp+12 ，以此類推， 32 位函數參數在棧中形成一個正序數組。 &lt;/p&gt;
&lt;p&gt; 由於函數返回值通過寄存器返回，不需要空間分配等操作，所以返回值的代價很低。基於這個原因，舊的 C 語法約定，不寫明返回值類型的函數，返回值類型爲 int 。這一規則與現行的 C++ 語法相違背，因爲 C++ 中，不寫明返回值類型的函數返回值類型爲 void ，表示不返回值。這種語法不兼容性是爲了加強 C++ 的類型安全，但同時也帶來了一些問題。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.5 I386平臺的邊界對齊(Align)</title><link href="//farseerfc.github.io/c-tricks-2-5-address-alignment.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-5-address-alignment.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386-align"&gt;
&lt;h2&gt;2.5 I386 平臺的邊界對齊 (Align)&lt;/h2&gt;
&lt;p&gt; 首先提問，既然 I386 上 sizeof(int)==4 、 sizeof(char)==1 ，那麼如下結構 (struct)A 的 sizeof 是多少？ &lt;/p&gt;
&lt;p&gt;struct A{int i;char c;};&lt;/p&gt;
&lt;p&gt; 答案是 sizeof(A)==8……1+5=8 ？ &lt;/p&gt;
&lt;p&gt; 呵呵，這就是 I386 上的邊界對齊問題。我們知道， I386 上有整整 4GB 的地址空間，不過並不是每一個字節上都可以放置任何東西的。由於內存總線帶寬等等的技術原因，很多體系結構都要求內存中的變量被放置於某一個邊界的地址上。如果違反這個要求，重則導致停機出錯，輕則減慢運行速度。對於 I386 平臺而言，類型爲 T 的變量必須放置在 sizeof(T) 的整數倍的地址上， char 可以隨便放置， short 必須放在 2 的整數倍的地址上， int 必須放在 4 的整數倍的地址上， double 必須放在 8 的整數倍的地址上。如果違反邊界對齊要求，從內存中讀取數據必須進行兩次，然後將獨到的兩半數據拼接起來，這會嚴重影響效率。 &lt;/p&gt;
&lt;p&gt; 由於邊界對齊問題的要求，在計算 struct 的 sizeof 的時候，編譯器必須算入額外的字節填充，以保證每一個變量都能自然對齊。比如如下聲明的 struct:&lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 實際上相當於聲明瞭這樣一個結構： &lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;char c1;&lt;/p&gt;
&lt;p&gt;char _filling1 [3];// 三個字節填充，保證下一個 int 的對齊 &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c2 ； &lt;/p&gt;
&lt;p&gt;char _filling2 [3];// 又三個字節填充 &lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 值得注意的是尾部的 3 個字節填充，這是爲了可以在一個數組中聲明 WASTE 變量，並且每一個都自然對齊。因爲有了這些填充，所以 sizeof(WASTE)==12 。這是一種浪費，因爲只要我們重新安排變量的聲明，就可以減少 sizeof ： &lt;/p&gt;
&lt;p&gt;struct WASTE&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;char c1,c2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 像這樣的安排， sizeof 就減少到 8 ，只有 2 個字節的額外填充。爲了與彙編代碼相兼容， C 語言語法規定，編譯器無權擅自安排結構體內變量的佈局順序，必須從左向右逐一排列。所以，妥當安排成員順序以避免內存空間的浪費，就成了我們程序員的責任之一。一般的，總是將結構體的成員按照其 sizeof 從大到小排列， double 在最前， char 在最後，這樣總可以將結構的字節填充降至最小。 &lt;/p&gt;
&lt;p&gt;C++ 繼承了 C 語言關於結構體佈局的規定，所以以上的佈局準則也適用於 C++ 的 class 的成員變量。 C++ 進一步擴展了佈局規定，同一訪問區段 (private 、 public 、 protected) 中的變量，編譯器無權重新排列，不過編譯器有權排列訪問區段的前後順序。基於這個規則， C++ 中有的程序員建議給每一個成員變量放在單獨區段，在每一個成員聲明之前都加上 private: 、 public: 、 protected: 標誌，這可以最大限度的利用編譯器的決策優勢。 &lt;/p&gt;
&lt;p&gt; 在棧中按順序分配的變量，其邊界也受到對齊要求的限制。與在結構中不同的是，棧中的變量還必須保證其後續變量無論是何種類型都可以自由對齊，所以在棧中的變量通常都有平臺相關的對齊最小值。在 MSVC 編譯器上，這個最小值可以由宏 _INTSIZEOF(T) 查詢： &lt;/p&gt;
&lt;p&gt;#define _INTSIZEOF(T) ( (sizeof(T) + sizeof(int) - 1) &amp;amp; ~(sizeof(int) -
1) )&lt;/p&gt;
&lt;p&gt;_INTSIZEOF(T) 會將 sizeof(T) 進位到 sizeof(int) 的整數倍。 &lt;/p&gt;
&lt;p&gt; 由於在棧中分配變量使用 _INTSIZEOF 而不是 sizeof ，在棧上連續分配多個小變量 (sizeof 小於 int 的變量 ) 會造成內存浪費，不如使用結構 (struct) 或數組。也就是說： &lt;/p&gt;
&lt;p&gt;char c1,c2,c3,c4;// 使用 16 字節 &lt;/p&gt;
&lt;p&gt;char c[4];// 使用 4 字節 &lt;/p&gt;
&lt;p&gt; 當然，使用數組的方法在訪問數組變量 ( 比如 c[1]) 時有一次額外的指針運算和提領 (dereference) 操作，這會有執行效率的損失。這又是一種空間 ( 內存佔用 )vs 時間 ( 執行效率 ) 的折中，需要程序員自己根據情況權衡利弊。 &lt;/p&gt;
&lt;p&gt;sizeof 的大小可能比我們預期的大，也可能比我們預期的小。對於空類： &lt;/p&gt;
&lt;p&gt;class Empty {};&lt;/p&gt;
&lt;p&gt; 在通常情況下， sizeof(Empty) 至少爲 1 。這是因爲 C++ 語法規定，對於任何實體類型的兩個變量，都必須具有不同的地址。爲了符合語法要求，編譯器會給 Empty 加入 1 字節的填充。所以 sizeof() 的值不可能出現 0 的情況。可是對於以下的類聲明： &lt;/p&gt;
&lt;p&gt;class A:public Empty{vitual ~A(){}};&lt;/p&gt;
&lt;p&gt;sizeof(A) 有可能是 6 ，也有可能是 5 ，也有可能是 4 ！必不可少的四個字節是一個指向虛函數表的指針。一個可能有的字節是 Empty 的大小，這是是因爲編譯器在特定情況下會將 Empty 視作一個 “ 空基類 ” ，從而實施 “ 空基類優化 ” ，省掉那毫無作用的一字節填充。另一個字節是 A 的一字節填充，因爲從語法上講， A 沒有成員聲明，理應有 1 字節填充，而從語義上講，編譯器給 A 的聲明加入了一個指向虛函數表的指針，從而 A 就不再是一個 “ 空類 ” ，是否實施這個優化，要看編譯器作者對語法措詞的理解。也就是說， sizeof 也會出現 4+1+1=4 的情況。具體要看編譯器有沒有實施 “ 空基類優化 ” 和 “ 含虛函數表的空類優化 ” 。 &lt;/p&gt;
&lt;p&gt; 結構和類的空間中可能有填充的字節，這意味着填充字節中可能有數值，雖然這數值並不影響結構的邏輯狀態，但是它也可能不知不覺中影響到你。比如說，你手頭正好有一組依賴於底層硬件 ( 比如多處理器 ) 的函數，他們在操縱連續字節時比手動編碼要快很多，而你想充分利用這種硬件優勢： &lt;/p&gt;
&lt;p&gt;bool BitCompare(void* begin,void* end,void* another);&lt;/p&gt;
&lt;p&gt; 這個函數將區間 [begin,end) 之間的字節與 another 開始的字節相比較，如果有一位不同就返回 false ，否則返回 true 。 &lt;/p&gt;
&lt;p&gt; 比如你想將這個函數用於你自己的類的 operator== 中，這樣可以利用硬件加快速度。不過你在動手前要充分考慮，你的 class 是否真的要比較每一位。如果在類的成員中存在編譯器填充的字節數，那麼應用以上的函數就是不正確的，因爲填充的字節中可以有不同的值。爲了保證你可以用 Bitwise
Compare ，你必須確保填充的字節中的值也是相同的。這不僅要求你在類的構造函數中初始化類的每一 bit 而不是每一個成員，也要求你在複製初始化和複製賦值函數中也同時保證 bitwise
copy 語義，而不是編譯器默認產生的 memberwise 語義。當然，你可能通過與 BitCompare 一同提供的 BitCopy 來完成這個艱鉅的任務。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.6 I386平臺C函數的可變參數表(Variable Arguments)</title><link href="//farseerfc.github.io/c-tricks-2-6-i386-variable-arguments.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-6-i386-variable-arguments.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386c-variable-arguments"&gt;
&lt;h2&gt;2.6 I386 平臺 C 函數的可變參數表 (Variable Arguments)&lt;/h2&gt;
&lt;p&gt; 基於前文 (2.4 節 ) 分析，我們可以不通過函數簽名，直接通過指針運算，來得到函數的參數。由於參數的壓棧和彈出操作都由主調函數進行，所以被調函數對於參數的真實數量不需要知曉。因此，函數簽名中的變量聲明不是必需的。爲了支持這種參數使用形式， C 語言提供可變參數表。可變參數表的語法形式是在參數表末尾添加三個句點形成的省略號 “...” ： &lt;/p&gt;
&lt;p&gt;void g(int a,char* c,...);&lt;/p&gt;
&lt;p&gt; 省略號之前的逗號是可選的，並不影響詞法語法分析。上面的函數 g 可以接受 2 個或 2 個以上的參數，前兩個參數的類型固定，其後的參數類型未知，參數的個數也未知。爲了知道參數個數，我們必須通過其他方法，比如通過第一個參數傳遞： &lt;/p&gt;
&lt;p&gt;g(3,”Hello”,2,4,5);// 調用 g 並傳遞 5 個參數，其中後 3 個爲可變參數。 &lt;/p&gt;
&lt;p&gt; 在函數的實現代碼中，可以通過 2.4 節敘述的，參數在棧中的排列順序，來訪問位於可變參數表的參數。比如 :&lt;/p&gt;
&lt;p&gt;void g(int a,char* c...){&lt;/p&gt;
&lt;p&gt;void *pc=&amp;amp;c;int* pi=static_cast&amp;lt;int*&amp;gt;(pc)+1;// 將 pi 指向首個可變參數 &lt;/p&gt;
&lt;p&gt;for(int i=0;i&amp;lt;a;i++)std::cout&amp;lt;&amp;lt;pi[i]&amp;lt;&amp;lt;” ” ； &lt;/p&gt;
&lt;p&gt;std::cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;std::endl;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 我們甚至可以讓一個函數的所有參數都是可變參數，只要有辦法獲知參數的數量即可。比如，我們約定，在傳遞給 addAll 的參數都是 int ，並且最後一個以 0 結束： &lt;/p&gt;
&lt;p&gt;int addAll(...);&lt;/p&gt;
&lt;p&gt;int a=f(1,4,2,5,7,0);&lt;/p&gt;
&lt;p&gt; 那麼 addAll 可以這樣實現： &lt;/p&gt;
&lt;p&gt;int addAll(...){&lt;/p&gt;
&lt;p&gt;int sum=0;int *p=&amp;amp;sum; //p 指向第一個局部變量 &lt;/p&gt;
&lt;p&gt;p+=3; // 跳過 sum ， ebp ， eip ，現在 p 指向第一個參數 &lt;/p&gt;
&lt;p&gt;for(;*p;++p) // 如果 p 不指向 0 就繼續循環 &lt;/p&gt;
&lt;p&gt;sum+=*p;&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 可變參數表的最廣泛應用是 C 的標準庫函數中的格式化輸入輸出： printf 和 scanf 。 &lt;/p&gt;
&lt;p&gt;void printf(char *c,...);&lt;/p&gt;
&lt;p&gt;void scanf(char *c,...);&lt;/p&gt;
&lt;p&gt; 兩者都通過它的首個參數指出後續參數表中的參數類型和參數數量。 &lt;/p&gt;
&lt;p&gt; 如果可變參數表中的參數類型不一樣，那麼操縱可變參數表就需要複雜的指針運算，並且還要時刻注意邊界對齊 (align) 問題，非常令人頭痛。好在 C 標準庫提供了用於操縱可變參數表的宏 (macro) 和結構 (struct) ，他們被定義在庫文件 stdarg.h 中 :&lt;/p&gt;
&lt;p&gt;typedef struct {char *p;int offset;} va_list;&lt;/p&gt;
&lt;p&gt;#define va_start(valist,arg)&lt;/p&gt;
&lt;p&gt;#define va_arg(valist,type)&lt;/p&gt;
&lt;p&gt;#define va_end(valist)&lt;/p&gt;
&lt;p&gt; 其中結構 va_list 用於指示參數在棧中的位置，宏 va_start 接受一個 va_list 和函數的可變參數表之前的參數，通過第一個參數初始化 va_list 中的相應數據，因此要使用 stdarg.h 中的宏，你的可變參數表的函數必須至少有一個具名參數。 va_arg 返回下一個類型爲 type 的參數， va_end 結束可變參數表的使用。還是以上文的 addAll 爲例，這次寫出它的使用標準宏的版本： &lt;/p&gt;
&lt;p&gt;int addAll(int i,...)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;va_list vl; // 定義一個 va_list 結構 &lt;/p&gt;
&lt;p&gt;va_start(vl,i); // 用省略號之前的參數初始化 vl&lt;/p&gt;
&lt;p&gt;if(i=0)return 0; // 如果第一個參數就是 0 ，返回 &lt;/p&gt;
&lt;p&gt;int sum=i; // 將第一個參數加入 sum&lt;/p&gt;
&lt;p&gt;for(;;){&lt;/p&gt;
&lt;p&gt;i=va_arg(vl,int); // 取得下一個參數，類型是 sum&lt;/p&gt;
&lt;p&gt;if(i==0)break; // 如果參數是 0 ，跳出循環 &lt;/p&gt;
&lt;p&gt;sum+=i;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;va_end(vl);&lt;/p&gt;
&lt;p&gt;return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 可以看出，如果參數類型一致，使用標準庫要多些幾行代碼。不過如果參數類型不一致或者未知 (printf 的情況 ) ，使用標準庫就要方便很多，因爲我們很難猜出編譯器處置邊界對齊 (align) 等彙編代碼的細節。使用標準庫的代碼是可以移植的，而使用上文所述的其它方法操縱可變參數表都是不可移植的，僅限於在 I386 平臺上使用。 &lt;/p&gt;
&lt;p&gt; 縱使可變參數表有使用上的便利性，它的缺陷也有很多，不可移植性和平臺依賴性只是其一，最大的問題在於它的類型不安全性。使用可變參數表就意味着編譯器不對參數作任何類型檢查，這在 C 中算是一言難盡的歷史遺留問題，在 C++ 中就意味着惡魔 reinterpret_cast 被你喚醒。 C 的可變參數表是 C++ 代碼錯誤頻發的根源之一，以至於 C++ 標準將可變參數表列爲即將被廢除的 C 語言遺留特性。 C++ 語法中的許多新特性，比如重載函數、默認參數值、模板，都可以一定程度上替代可變參數表，並且比可變參數表更加安全。 &lt;/p&gt;
&lt;p&gt; 可變參數表在 C++ 中惟一值得嘉獎的貢獻，是在模板元編程 (TMP) 的 SFINAE 技術中利用可變參數表製作最差匹配重載。根據 C++ 標準中有關函數重載決議的規則，具有可變參數表的函數總是最差匹配，編譯器在被逼無奈走頭無路時纔會選擇可變參數表。利用這一點，我們可以精心製作重載函數來提取類型信息。比如，要判斷一個通過模板傳遞來的類型是不是 int ： &lt;/p&gt;
&lt;p&gt;long isIntImp(int);&lt;/p&gt;
&lt;p&gt;char isIntImp(...);&lt;/p&gt;
&lt;p&gt;template&amp;lt;typename T&amp;gt;&lt;/p&gt;
&lt;p&gt;struct isInt&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;enum{value=sizeof(isIntImp(T()))==sizeof(long);}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; 然後，在一個具有模板參數 T 的函數中，我們就可以寫 &lt;/p&gt;
&lt;p&gt;if(isInt&amp;lt;T&amp;gt;::value)//...&lt;/p&gt;
&lt;p&gt; 在這個 ( 不怎麼精緻的 ) 例子中，如果 T 是 int ，那麼 isIntImp 的第一個重載版本就會被選中，返回值類型就是 long ，這樣 value 就爲 1 。否則，編譯器只能選中第二個具有可變參數表的重載版本，返回值類型成爲 char ，這樣 value 就爲 0 。把它說得再明白一些，上文的代碼所表達的意思是：如果類型 T 是 int ，那它就是 int ，否則它就不是 int ，呵呵簡單吧。這種通過重載決議規則來提取類型信息的技術，在模板元編程中被稱作 SFINAE ，它和其它模板元編程技術被廣泛運用於 STL 、 Boost 等模板庫的開發實現之中。 &lt;/p&gt;
&lt;p&gt; 值得注意的是，在上文 SFINAE 的運用中， isIntImp 並沒有出現定義而只提供了聲明，因爲我們並沒有實際調用 isIntImp 函數，而只是讓它參與重載決議並用 sizeof 判斷其返回值類型。這是 C++ 的一個設計準則的完美體現：不需要的東西可以不出現。由於這一準則，我們避免了在 C++ 中調用具有可變參數表的函數這一危險舉動，而僅僅利用了可變參數表在語法分析過程中的特殊地位，這種對於危險語言特性的巧妙利用是善意而無害的。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.7 I386平臺的其它函數調用模型</title><link href="//farseerfc.github.io/c-tricks-2-7-i386-calling-conventions.html" rel="alternate"></link><updated>2007-08-28T14:28:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-28:c-tricks-2-7-i386-calling-conventions.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="i386"&gt;
&lt;h2&gt;2.7 I386 平臺的其它函數調用模型 &lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 上文介紹的只是 I386 平臺上 C 函數調用的標準模型，被稱作 __cdecl 。事實上， Microsoft Visual C++ 編譯器還支持其它一些函數調用模型，所有調用模型名稱皆以雙下劃線開頭，下面列出所有函數調用模型的異同： &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="cdecl"&gt;
&lt;h3&gt;1 __cdecl&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：逆序 ( 從右至左 )&lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：主調函數 (caller)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__cdecl 明確地指出函數使用 C 函數調用模型，這是默認的調用模型。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stdcall"&gt;
&lt;h3&gt;2 __stdcall&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：逆序 ( 從右至左 )&lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：被調函數 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__stdcall 是微軟所謂的標準調用模型。可惜的是它與 __cdecl 不兼容。幾乎所有的 Win32API 函數使用這種函數調用模型，希望在 DLL 之間，或者在程序和 WinNT 操作系統之間傳遞函數指針的函數也應該使用這種模型。與 __cdecl 模型的不同之處在於， __stdcall 模型下由被調函數恢復堆棧。主調函數在 call 語句之後，不需要再加上 add 語句。而被調函數的 ret 語句則被添加一個參數，代表函數參數堆棧的長度。因此，被調函數需要明確的知曉函數參數的數量和類型，所以在 __stdcall 模型下不支持可變參數表，所有參數必須寫明。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="thiscall"&gt;
&lt;h3&gt;3 __thiscall&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：逆序 ( 從右至左 ) ， this 用 ecx 傳遞。 &lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：被調函數 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;__thiscall 是 VC 編譯器中類的非靜態成員函數 (non-static member functon) 的默認調用模型。但是如果此成員函數有可變參數表， VC 編譯器會使用 __cdecl 。和 __stdcall 一樣， __thiscall 由被調函數恢復堆棧。比較獨特的是 __thiscall 會通過 ecx 寄存器傳遞成員函數的 this 指針，而 __cdecl 下 this 指針是通過在參數表最前面增加一個函數參數來傳遞的。 __thiscall 是 VC 編譯器對 this 指針的使用的一種優化，大大提高了面向對象程序的效率。在 VC2003 及之前的編譯器上 __thiscall 不是一個關鍵字，不能被顯式指定。但可以給成員函數顯式指定 __cdecl 來避免使用 __thiscall 。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="fastcall"&gt;
&lt;h3&gt;4 __fastcall&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：逆序 ( 從右至左 ) ，前兩個 32 位函數參數放入 ecx 和 edx 中 &lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：被調函數 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 快速函數調用模型，將前兩個 32 位函數參數放入 ecx 和 edx 中，其餘參數再逆序壓棧。使用的是和 __thiscall 類似的優化技術，加快函數調用，適合運用在小型 inline 函數上。同樣使用 __stdcall 形式的被調函數恢復堆棧，所以不支持可變參數表。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pascal"&gt;
&lt;h3&gt;5 __pascal&lt;/h3&gt;
&lt;p&gt; 參數壓棧順序：正序 ( 從左至右 )&lt;/p&gt;
&lt;p&gt; 參數堆棧恢復者：被調函數 (callee)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt; 過程式編程語言 Pascal 所使用的函數調用模型，由此得名。也是 16 位版本的 Windows 使用的 API 模型，過時的模型，現在已經廢棄且禁止使用。你會看到有些書本仍會不時提到它，所以需要注意。 __pascal 是正序壓棧，這與大部分 I386 函數模型都不相同。與 __stdcall 一樣，由被調者恢復堆棧，不支持可變參數表。歷史上曾有過的別名 PASCAL 、 pascal 、 _pascal( 單下劃線 ) ，現在都改成了 __stdcall 的別名，與 __pascal( 雙下劃線 ) 不同。 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;6  其它函數調用模型，以及模型別名。 &lt;/h3&gt;
&lt;p&gt;__syscall ：操作系統內部使用的函數調用模型，由用戶模式向核心模式跳轉時使用的模型。由於用戶模式和核心模式使用不同的棧，所以沒辦法使用棧來傳遞參數，所有參數通過寄存器傳遞，這限制了參數的數量。用戶模式編程中不允許使用。 &lt;/p&gt;
&lt;p&gt;__fortran ：數學運算語言 fortran 使用的函數模型，由此得名。在 C 中調用由 fortran 編譯的函數時使用。 &lt;/p&gt;
&lt;p&gt;__clrcall ：微軟 .Net 框架使用的函數模型，託管 (Managed)C++ 默認使用，也可以從非託管代碼調用託管函數時使用。參數在託管棧上正序 ( 從左至右 ) 壓棧，不使用普通棧。 &lt;/p&gt;
&lt;p&gt;CALLBACK 、 PASCAL 、 WINAPI 、 APIENTRY 、 APIPRIVATE ： I386 平臺上是 __stdcall 的別名 &lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;WINAPIV ： I386 平臺上是 __cdecl 的別名 &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;7  函數調用模型的指定 &lt;/h3&gt;
&lt;p&gt; 函數調用模型的指定方式和 inline 關鍵字的指定方式相同，事實上， inline 可以被看作是 C++ 語言內建的一種函數調用模型。唯一不同的是，聲明函數指針時，也要指明函數調用模型，而 inline 的指針是不能指明的，根本不存在指向 inline 函數的指針。比如： &lt;/p&gt;
&lt;p&gt;int CALLBACK GetVersion();&lt;/p&gt;
&lt;p&gt;int (CALLBACK * pf)()=GetVersion;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 2.1 X86概述</title><link href="//farseerfc.github.io/c-tricks-2-1-x86-architecture.html" rel="alternate"></link><updated>2007-08-27T16:33:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-27:c-tricks-2-1-x86-architecture.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="x86"&gt;
&lt;h2&gt;2.1   X86 概述 &lt;/h2&gt;
&lt;p&gt; 所謂 X86 體系結構，是指以 Intel
8086 芯片爲首的芯片所沿襲的 CPU 結構，一些文檔中又被稱作 IA32 體系結構。包括的芯片有但不限於 :Intel
8086 至 80486 ，奔騰 (Pentium) 系列處理器 1 至 4 ，賽揚系列處理器，酷睿系列處理器，以及 AMD 的相應型號產品。 X86 體系結構在早期屬於 16 位處理器，自 80386 之後擴展爲 32 位處理器，所以一些文檔中又把 80386 之後的 32 位處理器體系稱作 I386 。自 Pentium4 後期， AMD 的 Athlon64 開始， I386 被進一步擴充爲 64 位處理器，含有 64 位尋址能力的 X86 體系結構被稱作 X86-64 或 IA32-64 。總之，市售的個人電腦用 CPU ，除蘋果的 Macintosh 之外，全部採用 X86 體系結構芯片。 &lt;/p&gt;
&lt;p&gt; 在 X86 早期， 16 位的尋址能力只支持 64KB(2^16=64K) 內存，這顯然是不夠的。 Intel 採用分段尋址的方法，用 4 位段位 +16 位偏移量，提供了總共 1MB(2^20=1M) 的尋址能力。所以在 X86 的 16 位編程中，有兩種指針類型：長指針 (lp,long
pointer) 和短指針 (sp,short
pointer) ，長指針 (20 位 ) 提供整個內存空間尋址能力，短指針 (16 位 ) 僅支持同一段中的尋址。在 “ 古代 ”DOS 及 Win3.x 編程過程中，兩種類型的指針，以及總共 1MB 的內存大小，常常把程序員們折騰得焦頭爛額。 &lt;/p&gt;
&lt;p&gt; 自 I386 之後， CPU 纔開始提供 32 位的尋址能力。有了整整 4GB(2^32=4G) 的尋址空間，所有指針統一爲長指針 (32 位 ) 。時至今日，我們仍可以看到微軟文檔中指針變量的 lp 前綴。由於內存管理的需要，分段機制被保留下來，但這一次不是因爲地址空間太小，而是因爲地址空間遠大於實際內存容量，從而採用了虛擬內存機制。 &lt;/p&gt;
&lt;p&gt; 在從 16 位結構向 32 位結構轉變的過程中，由於向下兼容的歷史原因，曾一度長時間出現硬件 32 位 (I386) 、軟件 16 位 (Win3.x) 的情況。同樣也是爲了兼容 16 位軟件， Win9x 操作系統 (Win95 、 Win98 、 WinME) 保留了 16 位代碼和 32 位代碼。混合代碼的設計使得 Win9x 及其混亂和不穩定。直到完全 32 位內核的操作系統 WinNT( 以及構建於其上的 Win2000 ， WinXP ， Win2003) 的出現， X86 平臺上內存佈局混亂的局面才得以改善。有了從 16 位至 32 位移植的經驗和準備，現今的從 32 位到 64 位的操作系統移植顯得平穩順利很多。 WinXP 和 WinVista 系統都同時發佈了 32 位版本和 64 位版本，並且其 x86-64 系統都實現了對 32 位軟件的無縫銜接支持。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 1.2 逗號運算符(,)、邏輯運算符(&amp;&amp;,||)與運算符重載的陷阱</title><link href="//farseerfc.github.io/c-tricks-1-2-trap-in-comma-logical-operator.html" rel="alternate"></link><updated>2007-08-22T18:06:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-22:c-tricks-1-2-trap-in-comma-logical-operator.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.2    逗號運算符 (,) 、邏輯運算符 (&amp;amp;&amp;amp;,||) 與運算符重載的陷阱 &lt;/h2&gt;
&lt;p&gt; 很多人甚至不知道逗號 (,) 也是個 C++ 運算符。與語法上要求出現的逗號 ( 比如分隔函數參數的逗號 ) 不同的是，出現在表達式中的逗號運算符在語義上表示多個表達式操作的連續執行，類似於分隔多語句的分號。比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt;(&lt;strong&gt;int&lt;/strong&gt;i=0,j=9;i&amp;lt;10;++i&lt;strong&gt;,&lt;/strong&gt;--j)std::cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;”+”&amp;lt;&amp;lt;j&amp;lt;&amp;lt;”=9\n”;&lt;/p&gt;
&lt;p&gt; 在這句語句中，出現了兩個逗號，其中前者是語法上用來分隔聲明的變量的，並非逗號運算符，而後者則是一個逗號運算符。根據 C++ 標準，逗號運算符的執行順序爲從左到右依次執行，返回最後一個子表達式的結果。由於只有最後一個表達式返回結果，所以對於一個語義正常的逗號表達式而言，前幾個子表達式必須具有副作用。同時，從語言的定義中也可以看出，逗號表達式對求值的順序有嚴格要求。 &lt;/p&gt;
&lt;p&gt; 對求值順序有要求的，除了逗號表達式和條件表達式 ( 參見 1.1) ，在 C++ 中還有邏輯運算符 (&amp;amp;&amp;amp; 和 ||) 。邏輯運算相較於數學運算和位運算而言，有個顯著的不同點：邏輯運算在計算到一半時，就有可能已經得到結果，這樣繼續運算另一半就不是必需的。對於 A&amp;amp;&amp;amp;B ，如果 A=false ，那麼無論 B 爲何值，整個的結果都是 false ；同樣的 A||B ，如果 A=true ，那麼不考慮 B ，結果一定是 true 。 &lt;/p&gt;
&lt;p&gt;C++ 標準規定，如果邏輯運算到一半 ( 算出 A) 時，就已經可以確定運算的結果，那麼就不運算剩下的另一半 (B) 。這種執行語義被稱作 “ 短路 ” 。在其它一些編程語言中，短路語義是可以選擇的：在 Ada 裏非短路的邏輯運算符爲 and 和 or ，短路的邏輯運算符爲 and_then 和 or_else 。但是在 C++ 中，邏輯運算符的短路語義是語法上強制的，我們沒有非短路版本的運算符。如果確實需要非短路語義，我們總是可以通過增加一個 bool 中間變量加以解決。有時，短路對於保證正確執行是必須的，比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char&lt;/strong&gt;*p=getString();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(p&lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;*p)std::cout&amp;lt;&amp;lt;p;&lt;/p&gt;
&lt;p&gt; 這段代碼在得到了一個字符串後，在字符串不爲空時輸出它。在 C++ 中判斷一個字符串不爲空需要兩個步驟：判斷指針是否爲 0 ，以及指針不爲 0 時判斷指針指向的內容是否爲 ’’ 。就像條件表達式中討論到的 ( 參見 1.1) ，在 p 爲空時提領 p 是個極其危險的操作。邏輯運算符的短路語義則避免了這種危險。 &lt;/p&gt;
&lt;p&gt; 以上對逗號運算符與邏輯運算符的討論，僅限於 C++ 標準所定義的運算符語義。爲什麼這樣說呢？這是因爲在 C++ 中，運算符的語義是可以由程序員自行定義的，這種機制叫做運算符重載 (operator
overload) 。運算符重載可以將人們熟悉的運算符表達式轉換成函數調用，使編程靈活而直觀，是個方便的語言特性。不過有時運算符重載也會使人困擾，那就是當運算符重載遇到求值順序問題時。 &lt;/p&gt;
&lt;p&gt;C++ 中，並不是所有合法運算符都可以被合法地重載。條件運算符雖然對求值順序有要求，但它並不在可重載運算符之列，所以運算符重載機制對它沒有影響。問題在於，逗號運算符和邏輯運算符都可以被合法地重載： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class&lt;/strong&gt; BadThing{/* Some Bad and Stupid Thing*/};&lt;/p&gt;
&lt;p&gt;BadThing&amp;amp; &lt;strong&gt;operator&lt;/strong&gt;,(BadThing&amp;amp;, BadThing&amp;amp;);// 重載了逗號運算符 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bool&lt;/strong&gt; &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(BadThing&amp;amp;, BadThing&amp;amp;);// 重載了 &amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;BadThing b1,b2;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(b1&amp;amp;&amp;amp;b2)b1,b2;// 被替換成如下形式： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;(&lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp;(b1,b2))&lt;strong&gt;operator&lt;/strong&gt;,(b1,b2);&lt;/p&gt;
&lt;p&gt; 可以看到，重載了運算符之後，對運算符的使用被替換爲相應的函數調用形式。因此，舊有的運算符的執行順序不再適用，取而代之的是函數參數的壓棧順序。 &lt;/p&gt;
&lt;p&gt; 根據 C++ 標準規定，任何參數必須在進入函數之前壓棧，所以在進入 &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp; 之前， b1 、 b2 就會被求值，這裏不再有短路規則，任何依賴於短路語義的不知不覺間操作 BadThing 的代碼 ( 可能通過模板 ) 都會混亂。 &lt;/p&gt;
&lt;p&gt; 短路語義只是一個方面，更重要的在於壓棧順序。鑑於執行效率和舊代碼兼容性等細節問題， C++ 標準在壓棧順序上給編譯器的開發者留有很大自主性。標準的說辭是，編譯器可能以任何它覺得方便的順序將參數壓棧，從左到右，從右到左，甚至從中間到兩邊，在這一點上我們不能安全地做任何假設。在上面的例子中，編譯器生成的代碼可能先計算 b1 再計算 b2 ，也可能是相反的順序。再看看編譯器的實際情況，在我試過的所有基於 X86 體系結構的編譯器中，參數都是以逆向壓棧，即從右到左，有悖於大多數人的閱讀習慣和直覺 ( 別說你是來自伊斯蘭的 ……) 。 &lt;/p&gt;
&lt;p&gt; 在 C 時代使用函數調用時，壓棧順序並不是什麼大問題，畢竟大多數人會在函數調用的邊界稍稍小心一些。但是到了 C++ 中，事情變得有些複雜，因爲簡單如 a+b 的使用，就有可能被運算符重載機制替換爲函數調用。更何況有模板參與之後，我們寫代碼時不能確定對象的真實類型，也就無法預知一個運算符是否真的被重載過，唯一穩妥的方法是，假定任何有可能被重載的運算符的使用都是函數調用。 &lt;/p&gt;
&lt;blockquote&gt;
&amp;lt;p style="margin:0;"&amp;gt;&lt;/blockquote&gt;
&lt;p&gt; 回到上文的示例中，由於 , 和 &amp;amp;&amp;amp; 都被替換爲函數調用，程序的執行順序將成爲壓棧順序，在 X86 上很有可能是從右到左，與標準定義的運算符的順序正好相反。逗號運算符原本就含有 “ 先 … 後 …” 的語義，這種顛倒的執行順序勢必造成程序和程序員的混亂。以我的經驗而言，含有 &lt;strong&gt;operator&lt;/strong&gt;, 的類，完全沒有辦法和 STL 或者 iostream 相互協作，反而會導致巨量的錯誤報告 ( 什麼叫巨量的錯誤報告有概念麼？如果沒有，那說明你還沒玩過範式編程 (GP,
Generic
Programming) 。去玩玩 GP 吧，看看你的編譯器對巨量的定義。在我手頭，針對 3.5KB 的代碼文件傾瀉出 3.8&lt;strong&gt;MB&lt;/strong&gt; 的錯誤信息的編譯器不在少數 ……) 。有鑑於此，我的結論是，除非你有充足的依據支持你這麼做 ( 比如你的粗暴上司的鍵盤上只剩下逗號能用 ) ，並且你清楚的瞭解這麼做的後果的嚴重性 ( 比如至少要看過此文 ) ，否則我奉勸你，永遠不要碰 &lt;strong&gt;operator&lt;/strong&gt;, 、 &lt;strong&gt;operator&lt;/strong&gt;&amp;amp;&amp;amp; 以及 &lt;strong&gt;operator&lt;/strong&gt;|| ！ &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry><entry><title>C++ Tricks 1.1 條件運算符(?:)</title><link href="//farseerfc.github.io/c-tricks-1-1-conditional-operator.html" rel="alternate"></link><updated>2007-08-22T18:05:00+09:00</updated><author><name>farseerfc</name></author><id>tag:farseerfc.github.io,2007-08-22:c-tricks-1-1-conditional-operator.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt; 從 &lt;a class="reference external" href="http://farseerfc.wordpress.com/"&gt;farseerfc.wordpress.com&lt;/a&gt;  導入 &lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1.1    條件運算符 (?:)&lt;/h2&gt;
&lt;p&gt; 條件運算符 (?:) 是 C++ 中唯一的三目運算符 (trinary
operator) ，用於在表達式中作條件判斷，通常可以替換 if 語句，與 Visual
Basic 中的 iif 函數、 Excel 中的 if 函數有同樣的作用。語法形式如下： &lt;/p&gt;
&lt;p&gt;&lt;em&gt;condition&lt;/em&gt; ? &lt;em&gt;true_value&lt;/em&gt; : &lt;em&gt;false_value&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 其中 &lt;em&gt;condition
* 條件是任何可以轉換爲 bool 類型的表達式，包括但不僅限於 **bool*&lt;/em&gt; 、 &lt;strong&gt;int&lt;/strong&gt; 、指針。與 &lt;strong&gt;if&lt;/strong&gt; 和 &lt;strong&gt;while&lt;/strong&gt; 的條件部分稍顯不同的是，這裏不能定義變量，否則會導致語法錯誤。 &lt;/p&gt;
&lt;p&gt; 另外，條件語句會切實地控制執行流程，而不僅僅是控制返回值。也就是說，兩個返回值表達式中永遠只有一個會被求值，在表達式的執行順序很重要時，這點尤爲值得注意。比如： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=pi&lt;strong&gt;?&lt;/strong&gt;*pi&lt;strong&gt;:&lt;/strong&gt;0;&lt;/p&gt;
&lt;p&gt; 這裏，只有當 pi 的值不爲 0 時，它纔會被提領 (dereference) 。這種語義保證了程序的正確性，因爲提領一個空指針將導致致命的運行期錯誤 ( 通常是非法操作的警告 ) 。同時，正因爲條件運算符控制運算流程的特點，使得它不能用類似 iif 的普通函數來模擬： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; iif(&lt;strong&gt;int&lt;/strong&gt; con,&lt;strong&gt;int&lt;/strong&gt; t,&lt;strong&gt;int&lt;/strong&gt;f){&lt;strong&gt;if&lt;/strong&gt;(c)&lt;strong&gt;return&lt;/strong&gt; t;&lt;strong&gt;return&lt;/strong&gt; f;}// 試圖模擬 ?:&lt;/p&gt;
&lt;p&gt;…//in some function&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; *pi=getInt();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=iif(pi,*pi,0);//Error!&lt;/p&gt;
&lt;p&gt; 這段代碼會導致上文提到的致命運行期錯誤。 C/C++ 標準規定，參數在被傳遞給函數之前求值，因此無論 pi 爲何值，都會被提領。又因爲函數傳回一個空指針的情況比較少見，所以這樣的錯誤在調試時很難被發現，一旦發生又勢必造成重大災難。這樣的代碼在實踐中應儘量避免。 &lt;/p&gt;
&lt;p&gt; 有時，條件運算符控制流程的特點會不知不覺影響我們的代碼。在 C 時代，最大值 MAX 通常用宏實現： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#define&lt;/strong&gt;MAX(a,b) ((a)&amp;gt;(b)&lt;strong&gt;?&lt;/strong&gt;(a)&lt;strong&gt;:&lt;/strong&gt;(b))&lt;/p&gt;
&lt;p&gt; 需要用額外的括號將宏參數和宏本體保護起來，以免運算符優先級擾亂邏輯，這是宏醜陋的特點之一，這裏暫且不提。矛盾在於，用具有副作用的表達式調用宏時，會出現問題： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; i=5,j=6;//…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=MAX(++i,++j);&lt;/p&gt;
&lt;p&gt; 代碼的作者原意顯然是想先將 i,j 分別遞增，再將其中較大的一個賦給 a 。執行這段代碼，當 i=5,j=6 時， a=8 ，知道爲什麼嗎？通過宏展開，賦值語句成這樣： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; a=(++i)&amp;gt;(++j)&lt;strong&gt;?&lt;/strong&gt;(++i)&lt;strong&gt;:&lt;/strong&gt;(++j);// 刪除了多餘括號 &lt;/p&gt;
&lt;p&gt; 在判斷之前， i 、 j 被分別自增一次，然後捨棄 : 之前的部分， j 又被自增一次。執行之後， i=6,j=8 。 &lt;/p&gt;
&lt;p&gt;MAX 的更正確更安全的實現，是利用模板將類型參數化。 STL 標準算法中就有一個這樣的工具級模版函數 std::max 。 &lt;/p&gt;
&lt;p&gt; 條件運算符是表達式而不是語句，這使得它可以出現在任何需要表達式的地方，這擴大了它的適用範圍。在那些語法上只能出現表達式而不能出現語句的地方（比如變量初始化），條件運算符有着不可替代的作用。 &lt;/p&gt;
&lt;p&gt; 條件運算符優於 &lt;strong&gt;if&lt;/strong&gt; 語句的另一個場合是 “ 模板元編程 ”(TMP, Template
MetaProgramming) 。在 TMP 這個古怪奇異的編譯期運算編程技術中，一切舊有的技術和法則被全線擊破，我們所能仰仗的工具，只有模板特化 (Specialization) 、 &lt;strong&gt;typedef&lt;/strong&gt;s 、函數聲明 ( 無法調用它們 ) 、以及編譯期常量運算。已經有人很深入地論證過，僅有以上這些，就已經形成了一個 “ 圖靈完善 ” 的計算機語言。我們可以用模板特化技術，來模擬條件分支，循環迭代等一系列複雜的語言結構。由於可以參與編譯期常量運算，條件運算符在 TMP 世界中很自然地扮演起重要角色。 &lt;/p&gt;
&lt;p&gt; 比如，給與類型 T 的一個變量 t ，我們想聲明一個緩衝區存放 t 和一個 int ，緩衝區的大小不小於 sizeof(T) 也不小於 sizeif(int) ，我們可以這樣寫： &lt;/p&gt;
&lt;p&gt;char buffer[sizeof(T)&amp;gt;sizeof(int)? sizeof(T): sizeof(int)];&lt;/p&gt;
&lt;p&gt; 我們不能用一個 if 語句替換這個運算： &lt;/p&gt;
&lt;p&gt;int i;&lt;/p&gt;
&lt;p&gt;if(sizeof(T)&amp;gt;sizeof(int))i=sizeof(T);&lt;/p&gt;
&lt;p&gt;else i=sizeof(int);&lt;/p&gt;
&lt;p&gt;char buffer[i];// 語法錯誤 !&lt;/p&gt;
&lt;p&gt; 原因在於數組聲明中的下標必須是一個編譯期常量，而不是一個運行期的值，條件表達式的運算可以在編譯期進行， if 語句就只能在執行期執行。 &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;</summary><category term="C++"></category></entry></feed>